! Vector norms
module stdlib_linalg_norms
     use stdlib_linalg_constants
     use stdlib_linalg_blas,only:nrm2
     use stdlib_linalg_lapack,only:lange
     use stdlib_linalg_state
     use iso_fortran_env,only:real32,real64,real128,int8,int16,int32,int64,stderr => error_unit
     implicit none(type,external)
     private
     
     public :: norm,get_norm

     character(*),parameter :: this = 'norm'
     
     !> List of internal norm flags
     integer(ilp),parameter :: NORM_ONE = 1_ilp
     integer(ilp),parameter :: NORM_TWO = 2_ilp
     integer(ilp),parameter :: NORM_POW_FIRST = 3_ilp
     integer(ilp),parameter :: NORM_INF = +huge(0_ilp) ! infinity norm
     integer(ilp),parameter :: NORM_POW_LAST = NORM_INF - 1_ilp
     integer(ilp),parameter :: NORM_MINUSINF = -huge(0_ilp)
     
     !> Vector norm: function interface
     interface norm
        !> Scalar norms: real(sp)
        module procedure stdlib_linalg_norm_1D_order_char_s
        module procedure stdlib_linalg_norm_1D_order_err_char_s
        module procedure stdlib_linalg_norm_2D_order_char_s
        module procedure stdlib_linalg_norm_2D_order_err_char_s
        module procedure stdlib_linalg_norm_3D_order_char_s
        module procedure stdlib_linalg_norm_3D_order_err_char_s
        module procedure stdlib_linalg_norm_4D_order_char_s
        module procedure stdlib_linalg_norm_4D_order_err_char_s
        module procedure stdlib_linalg_norm_5D_order_char_s
        module procedure stdlib_linalg_norm_5D_order_err_char_s
        module procedure stdlib_linalg_norm_6D_order_char_s
        module procedure stdlib_linalg_norm_6D_order_err_char_s
        module procedure stdlib_linalg_norm_7D_order_char_s
        module procedure stdlib_linalg_norm_7D_order_err_char_s
        module procedure stdlib_linalg_norm_8D_order_char_s
        module procedure stdlib_linalg_norm_8D_order_err_char_s
        module procedure stdlib_linalg_norm_9D_order_char_s
        module procedure stdlib_linalg_norm_9D_order_err_char_s
        module procedure stdlib_linalg_norm_10D_order_char_s
        module procedure stdlib_linalg_norm_10D_order_err_char_s
        module procedure stdlib_linalg_norm_11D_order_char_s
        module procedure stdlib_linalg_norm_11D_order_err_char_s
        module procedure stdlib_linalg_norm_12D_order_char_s
        module procedure stdlib_linalg_norm_12D_order_err_char_s
        module procedure stdlib_linalg_norm_13D_order_char_s
        module procedure stdlib_linalg_norm_13D_order_err_char_s
        module procedure stdlib_linalg_norm_14D_order_char_s
        module procedure stdlib_linalg_norm_14D_order_err_char_s
        module procedure stdlib_linalg_norm_15D_order_char_s
        module procedure stdlib_linalg_norm_15D_order_err_char_s
        !> Array norms: real(sp)
        module procedure stdlib_linalg_norm_2D_to_1D_char_s
        module procedure stdlib_linalg_norm_2D_to_1D_err_char_s
        module procedure stdlib_linalg_norm_3D_to_2D_char_s
        module procedure stdlib_linalg_norm_3D_to_2D_err_char_s
        module procedure stdlib_linalg_norm_4D_to_3D_char_s
        module procedure stdlib_linalg_norm_4D_to_3D_err_char_s
        module procedure stdlib_linalg_norm_5D_to_4D_char_s
        module procedure stdlib_linalg_norm_5D_to_4D_err_char_s
        module procedure stdlib_linalg_norm_6D_to_5D_char_s
        module procedure stdlib_linalg_norm_6D_to_5D_err_char_s
        module procedure stdlib_linalg_norm_7D_to_6D_char_s
        module procedure stdlib_linalg_norm_7D_to_6D_err_char_s
        module procedure stdlib_linalg_norm_8D_to_7D_char_s
        module procedure stdlib_linalg_norm_8D_to_7D_err_char_s
        module procedure stdlib_linalg_norm_9D_to_8D_char_s
        module procedure stdlib_linalg_norm_9D_to_8D_err_char_s
        module procedure stdlib_linalg_norm_10D_to_9D_char_s
        module procedure stdlib_linalg_norm_10D_to_9D_err_char_s
        module procedure stdlib_linalg_norm_11D_to_10D_char_s
        module procedure stdlib_linalg_norm_11D_to_10D_err_char_s
        module procedure stdlib_linalg_norm_12D_to_11D_char_s
        module procedure stdlib_linalg_norm_12D_to_11D_err_char_s
        module procedure stdlib_linalg_norm_13D_to_12D_char_s
        module procedure stdlib_linalg_norm_13D_to_12D_err_char_s
        module procedure stdlib_linalg_norm_14D_to_13D_char_s
        module procedure stdlib_linalg_norm_14D_to_13D_err_char_s
        module procedure stdlib_linalg_norm_15D_to_14D_char_s
        module procedure stdlib_linalg_norm_15D_to_14D_err_char_s
        !> Scalar norms: real(sp)
        module procedure stdlib_linalg_norm_1D_order_int_s
        module procedure stdlib_linalg_norm_1D_order_err_int_s
        module procedure stdlib_linalg_norm_2D_order_int_s
        module procedure stdlib_linalg_norm_2D_order_err_int_s
        module procedure stdlib_linalg_norm_3D_order_int_s
        module procedure stdlib_linalg_norm_3D_order_err_int_s
        module procedure stdlib_linalg_norm_4D_order_int_s
        module procedure stdlib_linalg_norm_4D_order_err_int_s
        module procedure stdlib_linalg_norm_5D_order_int_s
        module procedure stdlib_linalg_norm_5D_order_err_int_s
        module procedure stdlib_linalg_norm_6D_order_int_s
        module procedure stdlib_linalg_norm_6D_order_err_int_s
        module procedure stdlib_linalg_norm_7D_order_int_s
        module procedure stdlib_linalg_norm_7D_order_err_int_s
        module procedure stdlib_linalg_norm_8D_order_int_s
        module procedure stdlib_linalg_norm_8D_order_err_int_s
        module procedure stdlib_linalg_norm_9D_order_int_s
        module procedure stdlib_linalg_norm_9D_order_err_int_s
        module procedure stdlib_linalg_norm_10D_order_int_s
        module procedure stdlib_linalg_norm_10D_order_err_int_s
        module procedure stdlib_linalg_norm_11D_order_int_s
        module procedure stdlib_linalg_norm_11D_order_err_int_s
        module procedure stdlib_linalg_norm_12D_order_int_s
        module procedure stdlib_linalg_norm_12D_order_err_int_s
        module procedure stdlib_linalg_norm_13D_order_int_s
        module procedure stdlib_linalg_norm_13D_order_err_int_s
        module procedure stdlib_linalg_norm_14D_order_int_s
        module procedure stdlib_linalg_norm_14D_order_err_int_s
        module procedure stdlib_linalg_norm_15D_order_int_s
        module procedure stdlib_linalg_norm_15D_order_err_int_s
        !> Array norms: real(sp)
        module procedure stdlib_linalg_norm_2D_to_1D_int_s
        module procedure stdlib_linalg_norm_2D_to_1D_err_int_s
        module procedure stdlib_linalg_norm_3D_to_2D_int_s
        module procedure stdlib_linalg_norm_3D_to_2D_err_int_s
        module procedure stdlib_linalg_norm_4D_to_3D_int_s
        module procedure stdlib_linalg_norm_4D_to_3D_err_int_s
        module procedure stdlib_linalg_norm_5D_to_4D_int_s
        module procedure stdlib_linalg_norm_5D_to_4D_err_int_s
        module procedure stdlib_linalg_norm_6D_to_5D_int_s
        module procedure stdlib_linalg_norm_6D_to_5D_err_int_s
        module procedure stdlib_linalg_norm_7D_to_6D_int_s
        module procedure stdlib_linalg_norm_7D_to_6D_err_int_s
        module procedure stdlib_linalg_norm_8D_to_7D_int_s
        module procedure stdlib_linalg_norm_8D_to_7D_err_int_s
        module procedure stdlib_linalg_norm_9D_to_8D_int_s
        module procedure stdlib_linalg_norm_9D_to_8D_err_int_s
        module procedure stdlib_linalg_norm_10D_to_9D_int_s
        module procedure stdlib_linalg_norm_10D_to_9D_err_int_s
        module procedure stdlib_linalg_norm_11D_to_10D_int_s
        module procedure stdlib_linalg_norm_11D_to_10D_err_int_s
        module procedure stdlib_linalg_norm_12D_to_11D_int_s
        module procedure stdlib_linalg_norm_12D_to_11D_err_int_s
        module procedure stdlib_linalg_norm_13D_to_12D_int_s
        module procedure stdlib_linalg_norm_13D_to_12D_err_int_s
        module procedure stdlib_linalg_norm_14D_to_13D_int_s
        module procedure stdlib_linalg_norm_14D_to_13D_err_int_s
        module procedure stdlib_linalg_norm_15D_to_14D_int_s
        module procedure stdlib_linalg_norm_15D_to_14D_err_int_s
        !> Scalar norms: real(dp)
        module procedure stdlib_linalg_norm_1D_order_char_d
        module procedure stdlib_linalg_norm_1D_order_err_char_d
        module procedure stdlib_linalg_norm_2D_order_char_d
        module procedure stdlib_linalg_norm_2D_order_err_char_d
        module procedure stdlib_linalg_norm_3D_order_char_d
        module procedure stdlib_linalg_norm_3D_order_err_char_d
        module procedure stdlib_linalg_norm_4D_order_char_d
        module procedure stdlib_linalg_norm_4D_order_err_char_d
        module procedure stdlib_linalg_norm_5D_order_char_d
        module procedure stdlib_linalg_norm_5D_order_err_char_d
        module procedure stdlib_linalg_norm_6D_order_char_d
        module procedure stdlib_linalg_norm_6D_order_err_char_d
        module procedure stdlib_linalg_norm_7D_order_char_d
        module procedure stdlib_linalg_norm_7D_order_err_char_d
        module procedure stdlib_linalg_norm_8D_order_char_d
        module procedure stdlib_linalg_norm_8D_order_err_char_d
        module procedure stdlib_linalg_norm_9D_order_char_d
        module procedure stdlib_linalg_norm_9D_order_err_char_d
        module procedure stdlib_linalg_norm_10D_order_char_d
        module procedure stdlib_linalg_norm_10D_order_err_char_d
        module procedure stdlib_linalg_norm_11D_order_char_d
        module procedure stdlib_linalg_norm_11D_order_err_char_d
        module procedure stdlib_linalg_norm_12D_order_char_d
        module procedure stdlib_linalg_norm_12D_order_err_char_d
        module procedure stdlib_linalg_norm_13D_order_char_d
        module procedure stdlib_linalg_norm_13D_order_err_char_d
        module procedure stdlib_linalg_norm_14D_order_char_d
        module procedure stdlib_linalg_norm_14D_order_err_char_d
        module procedure stdlib_linalg_norm_15D_order_char_d
        module procedure stdlib_linalg_norm_15D_order_err_char_d
        !> Array norms: real(dp)
        module procedure stdlib_linalg_norm_2D_to_1D_char_d
        module procedure stdlib_linalg_norm_2D_to_1D_err_char_d
        module procedure stdlib_linalg_norm_3D_to_2D_char_d
        module procedure stdlib_linalg_norm_3D_to_2D_err_char_d
        module procedure stdlib_linalg_norm_4D_to_3D_char_d
        module procedure stdlib_linalg_norm_4D_to_3D_err_char_d
        module procedure stdlib_linalg_norm_5D_to_4D_char_d
        module procedure stdlib_linalg_norm_5D_to_4D_err_char_d
        module procedure stdlib_linalg_norm_6D_to_5D_char_d
        module procedure stdlib_linalg_norm_6D_to_5D_err_char_d
        module procedure stdlib_linalg_norm_7D_to_6D_char_d
        module procedure stdlib_linalg_norm_7D_to_6D_err_char_d
        module procedure stdlib_linalg_norm_8D_to_7D_char_d
        module procedure stdlib_linalg_norm_8D_to_7D_err_char_d
        module procedure stdlib_linalg_norm_9D_to_8D_char_d
        module procedure stdlib_linalg_norm_9D_to_8D_err_char_d
        module procedure stdlib_linalg_norm_10D_to_9D_char_d
        module procedure stdlib_linalg_norm_10D_to_9D_err_char_d
        module procedure stdlib_linalg_norm_11D_to_10D_char_d
        module procedure stdlib_linalg_norm_11D_to_10D_err_char_d
        module procedure stdlib_linalg_norm_12D_to_11D_char_d
        module procedure stdlib_linalg_norm_12D_to_11D_err_char_d
        module procedure stdlib_linalg_norm_13D_to_12D_char_d
        module procedure stdlib_linalg_norm_13D_to_12D_err_char_d
        module procedure stdlib_linalg_norm_14D_to_13D_char_d
        module procedure stdlib_linalg_norm_14D_to_13D_err_char_d
        module procedure stdlib_linalg_norm_15D_to_14D_char_d
        module procedure stdlib_linalg_norm_15D_to_14D_err_char_d
        !> Scalar norms: real(dp)
        module procedure stdlib_linalg_norm_1D_order_int_d
        module procedure stdlib_linalg_norm_1D_order_err_int_d
        module procedure stdlib_linalg_norm_2D_order_int_d
        module procedure stdlib_linalg_norm_2D_order_err_int_d
        module procedure stdlib_linalg_norm_3D_order_int_d
        module procedure stdlib_linalg_norm_3D_order_err_int_d
        module procedure stdlib_linalg_norm_4D_order_int_d
        module procedure stdlib_linalg_norm_4D_order_err_int_d
        module procedure stdlib_linalg_norm_5D_order_int_d
        module procedure stdlib_linalg_norm_5D_order_err_int_d
        module procedure stdlib_linalg_norm_6D_order_int_d
        module procedure stdlib_linalg_norm_6D_order_err_int_d
        module procedure stdlib_linalg_norm_7D_order_int_d
        module procedure stdlib_linalg_norm_7D_order_err_int_d
        module procedure stdlib_linalg_norm_8D_order_int_d
        module procedure stdlib_linalg_norm_8D_order_err_int_d
        module procedure stdlib_linalg_norm_9D_order_int_d
        module procedure stdlib_linalg_norm_9D_order_err_int_d
        module procedure stdlib_linalg_norm_10D_order_int_d
        module procedure stdlib_linalg_norm_10D_order_err_int_d
        module procedure stdlib_linalg_norm_11D_order_int_d
        module procedure stdlib_linalg_norm_11D_order_err_int_d
        module procedure stdlib_linalg_norm_12D_order_int_d
        module procedure stdlib_linalg_norm_12D_order_err_int_d
        module procedure stdlib_linalg_norm_13D_order_int_d
        module procedure stdlib_linalg_norm_13D_order_err_int_d
        module procedure stdlib_linalg_norm_14D_order_int_d
        module procedure stdlib_linalg_norm_14D_order_err_int_d
        module procedure stdlib_linalg_norm_15D_order_int_d
        module procedure stdlib_linalg_norm_15D_order_err_int_d
        !> Array norms: real(dp)
        module procedure stdlib_linalg_norm_2D_to_1D_int_d
        module procedure stdlib_linalg_norm_2D_to_1D_err_int_d
        module procedure stdlib_linalg_norm_3D_to_2D_int_d
        module procedure stdlib_linalg_norm_3D_to_2D_err_int_d
        module procedure stdlib_linalg_norm_4D_to_3D_int_d
        module procedure stdlib_linalg_norm_4D_to_3D_err_int_d
        module procedure stdlib_linalg_norm_5D_to_4D_int_d
        module procedure stdlib_linalg_norm_5D_to_4D_err_int_d
        module procedure stdlib_linalg_norm_6D_to_5D_int_d
        module procedure stdlib_linalg_norm_6D_to_5D_err_int_d
        module procedure stdlib_linalg_norm_7D_to_6D_int_d
        module procedure stdlib_linalg_norm_7D_to_6D_err_int_d
        module procedure stdlib_linalg_norm_8D_to_7D_int_d
        module procedure stdlib_linalg_norm_8D_to_7D_err_int_d
        module procedure stdlib_linalg_norm_9D_to_8D_int_d
        module procedure stdlib_linalg_norm_9D_to_8D_err_int_d
        module procedure stdlib_linalg_norm_10D_to_9D_int_d
        module procedure stdlib_linalg_norm_10D_to_9D_err_int_d
        module procedure stdlib_linalg_norm_11D_to_10D_int_d
        module procedure stdlib_linalg_norm_11D_to_10D_err_int_d
        module procedure stdlib_linalg_norm_12D_to_11D_int_d
        module procedure stdlib_linalg_norm_12D_to_11D_err_int_d
        module procedure stdlib_linalg_norm_13D_to_12D_int_d
        module procedure stdlib_linalg_norm_13D_to_12D_err_int_d
        module procedure stdlib_linalg_norm_14D_to_13D_int_d
        module procedure stdlib_linalg_norm_14D_to_13D_err_int_d
        module procedure stdlib_linalg_norm_15D_to_14D_int_d
        module procedure stdlib_linalg_norm_15D_to_14D_err_int_d
        !> Scalar norms: real(qp)
        module procedure stdlib_linalg_norm_1D_order_char_q
        module procedure stdlib_linalg_norm_1D_order_err_char_q
        module procedure stdlib_linalg_norm_2D_order_char_q
        module procedure stdlib_linalg_norm_2D_order_err_char_q
        module procedure stdlib_linalg_norm_3D_order_char_q
        module procedure stdlib_linalg_norm_3D_order_err_char_q
        module procedure stdlib_linalg_norm_4D_order_char_q
        module procedure stdlib_linalg_norm_4D_order_err_char_q
        module procedure stdlib_linalg_norm_5D_order_char_q
        module procedure stdlib_linalg_norm_5D_order_err_char_q
        module procedure stdlib_linalg_norm_6D_order_char_q
        module procedure stdlib_linalg_norm_6D_order_err_char_q
        module procedure stdlib_linalg_norm_7D_order_char_q
        module procedure stdlib_linalg_norm_7D_order_err_char_q
        module procedure stdlib_linalg_norm_8D_order_char_q
        module procedure stdlib_linalg_norm_8D_order_err_char_q
        module procedure stdlib_linalg_norm_9D_order_char_q
        module procedure stdlib_linalg_norm_9D_order_err_char_q
        module procedure stdlib_linalg_norm_10D_order_char_q
        module procedure stdlib_linalg_norm_10D_order_err_char_q
        module procedure stdlib_linalg_norm_11D_order_char_q
        module procedure stdlib_linalg_norm_11D_order_err_char_q
        module procedure stdlib_linalg_norm_12D_order_char_q
        module procedure stdlib_linalg_norm_12D_order_err_char_q
        module procedure stdlib_linalg_norm_13D_order_char_q
        module procedure stdlib_linalg_norm_13D_order_err_char_q
        module procedure stdlib_linalg_norm_14D_order_char_q
        module procedure stdlib_linalg_norm_14D_order_err_char_q
        module procedure stdlib_linalg_norm_15D_order_char_q
        module procedure stdlib_linalg_norm_15D_order_err_char_q
        !> Array norms: real(qp)
        module procedure stdlib_linalg_norm_2D_to_1D_char_q
        module procedure stdlib_linalg_norm_2D_to_1D_err_char_q
        module procedure stdlib_linalg_norm_3D_to_2D_char_q
        module procedure stdlib_linalg_norm_3D_to_2D_err_char_q
        module procedure stdlib_linalg_norm_4D_to_3D_char_q
        module procedure stdlib_linalg_norm_4D_to_3D_err_char_q
        module procedure stdlib_linalg_norm_5D_to_4D_char_q
        module procedure stdlib_linalg_norm_5D_to_4D_err_char_q
        module procedure stdlib_linalg_norm_6D_to_5D_char_q
        module procedure stdlib_linalg_norm_6D_to_5D_err_char_q
        module procedure stdlib_linalg_norm_7D_to_6D_char_q
        module procedure stdlib_linalg_norm_7D_to_6D_err_char_q
        module procedure stdlib_linalg_norm_8D_to_7D_char_q
        module procedure stdlib_linalg_norm_8D_to_7D_err_char_q
        module procedure stdlib_linalg_norm_9D_to_8D_char_q
        module procedure stdlib_linalg_norm_9D_to_8D_err_char_q
        module procedure stdlib_linalg_norm_10D_to_9D_char_q
        module procedure stdlib_linalg_norm_10D_to_9D_err_char_q
        module procedure stdlib_linalg_norm_11D_to_10D_char_q
        module procedure stdlib_linalg_norm_11D_to_10D_err_char_q
        module procedure stdlib_linalg_norm_12D_to_11D_char_q
        module procedure stdlib_linalg_norm_12D_to_11D_err_char_q
        module procedure stdlib_linalg_norm_13D_to_12D_char_q
        module procedure stdlib_linalg_norm_13D_to_12D_err_char_q
        module procedure stdlib_linalg_norm_14D_to_13D_char_q
        module procedure stdlib_linalg_norm_14D_to_13D_err_char_q
        module procedure stdlib_linalg_norm_15D_to_14D_char_q
        module procedure stdlib_linalg_norm_15D_to_14D_err_char_q
        !> Scalar norms: real(qp)
        module procedure stdlib_linalg_norm_1D_order_int_q
        module procedure stdlib_linalg_norm_1D_order_err_int_q
        module procedure stdlib_linalg_norm_2D_order_int_q
        module procedure stdlib_linalg_norm_2D_order_err_int_q
        module procedure stdlib_linalg_norm_3D_order_int_q
        module procedure stdlib_linalg_norm_3D_order_err_int_q
        module procedure stdlib_linalg_norm_4D_order_int_q
        module procedure stdlib_linalg_norm_4D_order_err_int_q
        module procedure stdlib_linalg_norm_5D_order_int_q
        module procedure stdlib_linalg_norm_5D_order_err_int_q
        module procedure stdlib_linalg_norm_6D_order_int_q
        module procedure stdlib_linalg_norm_6D_order_err_int_q
        module procedure stdlib_linalg_norm_7D_order_int_q
        module procedure stdlib_linalg_norm_7D_order_err_int_q
        module procedure stdlib_linalg_norm_8D_order_int_q
        module procedure stdlib_linalg_norm_8D_order_err_int_q
        module procedure stdlib_linalg_norm_9D_order_int_q
        module procedure stdlib_linalg_norm_9D_order_err_int_q
        module procedure stdlib_linalg_norm_10D_order_int_q
        module procedure stdlib_linalg_norm_10D_order_err_int_q
        module procedure stdlib_linalg_norm_11D_order_int_q
        module procedure stdlib_linalg_norm_11D_order_err_int_q
        module procedure stdlib_linalg_norm_12D_order_int_q
        module procedure stdlib_linalg_norm_12D_order_err_int_q
        module procedure stdlib_linalg_norm_13D_order_int_q
        module procedure stdlib_linalg_norm_13D_order_err_int_q
        module procedure stdlib_linalg_norm_14D_order_int_q
        module procedure stdlib_linalg_norm_14D_order_err_int_q
        module procedure stdlib_linalg_norm_15D_order_int_q
        module procedure stdlib_linalg_norm_15D_order_err_int_q
        !> Array norms: real(qp)
        module procedure stdlib_linalg_norm_2D_to_1D_int_q
        module procedure stdlib_linalg_norm_2D_to_1D_err_int_q
        module procedure stdlib_linalg_norm_3D_to_2D_int_q
        module procedure stdlib_linalg_norm_3D_to_2D_err_int_q
        module procedure stdlib_linalg_norm_4D_to_3D_int_q
        module procedure stdlib_linalg_norm_4D_to_3D_err_int_q
        module procedure stdlib_linalg_norm_5D_to_4D_int_q
        module procedure stdlib_linalg_norm_5D_to_4D_err_int_q
        module procedure stdlib_linalg_norm_6D_to_5D_int_q
        module procedure stdlib_linalg_norm_6D_to_5D_err_int_q
        module procedure stdlib_linalg_norm_7D_to_6D_int_q
        module procedure stdlib_linalg_norm_7D_to_6D_err_int_q
        module procedure stdlib_linalg_norm_8D_to_7D_int_q
        module procedure stdlib_linalg_norm_8D_to_7D_err_int_q
        module procedure stdlib_linalg_norm_9D_to_8D_int_q
        module procedure stdlib_linalg_norm_9D_to_8D_err_int_q
        module procedure stdlib_linalg_norm_10D_to_9D_int_q
        module procedure stdlib_linalg_norm_10D_to_9D_err_int_q
        module procedure stdlib_linalg_norm_11D_to_10D_int_q
        module procedure stdlib_linalg_norm_11D_to_10D_err_int_q
        module procedure stdlib_linalg_norm_12D_to_11D_int_q
        module procedure stdlib_linalg_norm_12D_to_11D_err_int_q
        module procedure stdlib_linalg_norm_13D_to_12D_int_q
        module procedure stdlib_linalg_norm_13D_to_12D_err_int_q
        module procedure stdlib_linalg_norm_14D_to_13D_int_q
        module procedure stdlib_linalg_norm_14D_to_13D_err_int_q
        module procedure stdlib_linalg_norm_15D_to_14D_int_q
        module procedure stdlib_linalg_norm_15D_to_14D_err_int_q
        !> Scalar norms: complex(sp)
        module procedure stdlib_linalg_norm_1D_order_char_c
        module procedure stdlib_linalg_norm_1D_order_err_char_c
        module procedure stdlib_linalg_norm_2D_order_char_c
        module procedure stdlib_linalg_norm_2D_order_err_char_c
        module procedure stdlib_linalg_norm_3D_order_char_c
        module procedure stdlib_linalg_norm_3D_order_err_char_c
        module procedure stdlib_linalg_norm_4D_order_char_c
        module procedure stdlib_linalg_norm_4D_order_err_char_c
        module procedure stdlib_linalg_norm_5D_order_char_c
        module procedure stdlib_linalg_norm_5D_order_err_char_c
        module procedure stdlib_linalg_norm_6D_order_char_c
        module procedure stdlib_linalg_norm_6D_order_err_char_c
        module procedure stdlib_linalg_norm_7D_order_char_c
        module procedure stdlib_linalg_norm_7D_order_err_char_c
        module procedure stdlib_linalg_norm_8D_order_char_c
        module procedure stdlib_linalg_norm_8D_order_err_char_c
        module procedure stdlib_linalg_norm_9D_order_char_c
        module procedure stdlib_linalg_norm_9D_order_err_char_c
        module procedure stdlib_linalg_norm_10D_order_char_c
        module procedure stdlib_linalg_norm_10D_order_err_char_c
        module procedure stdlib_linalg_norm_11D_order_char_c
        module procedure stdlib_linalg_norm_11D_order_err_char_c
        module procedure stdlib_linalg_norm_12D_order_char_c
        module procedure stdlib_linalg_norm_12D_order_err_char_c
        module procedure stdlib_linalg_norm_13D_order_char_c
        module procedure stdlib_linalg_norm_13D_order_err_char_c
        module procedure stdlib_linalg_norm_14D_order_char_c
        module procedure stdlib_linalg_norm_14D_order_err_char_c
        module procedure stdlib_linalg_norm_15D_order_char_c
        module procedure stdlib_linalg_norm_15D_order_err_char_c
        !> Array norms: complex(sp)
        module procedure stdlib_linalg_norm_2D_to_1D_char_c
        module procedure stdlib_linalg_norm_2D_to_1D_err_char_c
        module procedure stdlib_linalg_norm_3D_to_2D_char_c
        module procedure stdlib_linalg_norm_3D_to_2D_err_char_c
        module procedure stdlib_linalg_norm_4D_to_3D_char_c
        module procedure stdlib_linalg_norm_4D_to_3D_err_char_c
        module procedure stdlib_linalg_norm_5D_to_4D_char_c
        module procedure stdlib_linalg_norm_5D_to_4D_err_char_c
        module procedure stdlib_linalg_norm_6D_to_5D_char_c
        module procedure stdlib_linalg_norm_6D_to_5D_err_char_c
        module procedure stdlib_linalg_norm_7D_to_6D_char_c
        module procedure stdlib_linalg_norm_7D_to_6D_err_char_c
        module procedure stdlib_linalg_norm_8D_to_7D_char_c
        module procedure stdlib_linalg_norm_8D_to_7D_err_char_c
        module procedure stdlib_linalg_norm_9D_to_8D_char_c
        module procedure stdlib_linalg_norm_9D_to_8D_err_char_c
        module procedure stdlib_linalg_norm_10D_to_9D_char_c
        module procedure stdlib_linalg_norm_10D_to_9D_err_char_c
        module procedure stdlib_linalg_norm_11D_to_10D_char_c
        module procedure stdlib_linalg_norm_11D_to_10D_err_char_c
        module procedure stdlib_linalg_norm_12D_to_11D_char_c
        module procedure stdlib_linalg_norm_12D_to_11D_err_char_c
        module procedure stdlib_linalg_norm_13D_to_12D_char_c
        module procedure stdlib_linalg_norm_13D_to_12D_err_char_c
        module procedure stdlib_linalg_norm_14D_to_13D_char_c
        module procedure stdlib_linalg_norm_14D_to_13D_err_char_c
        module procedure stdlib_linalg_norm_15D_to_14D_char_c
        module procedure stdlib_linalg_norm_15D_to_14D_err_char_c
        !> Scalar norms: complex(sp)
        module procedure stdlib_linalg_norm_1D_order_int_c
        module procedure stdlib_linalg_norm_1D_order_err_int_c
        module procedure stdlib_linalg_norm_2D_order_int_c
        module procedure stdlib_linalg_norm_2D_order_err_int_c
        module procedure stdlib_linalg_norm_3D_order_int_c
        module procedure stdlib_linalg_norm_3D_order_err_int_c
        module procedure stdlib_linalg_norm_4D_order_int_c
        module procedure stdlib_linalg_norm_4D_order_err_int_c
        module procedure stdlib_linalg_norm_5D_order_int_c
        module procedure stdlib_linalg_norm_5D_order_err_int_c
        module procedure stdlib_linalg_norm_6D_order_int_c
        module procedure stdlib_linalg_norm_6D_order_err_int_c
        module procedure stdlib_linalg_norm_7D_order_int_c
        module procedure stdlib_linalg_norm_7D_order_err_int_c
        module procedure stdlib_linalg_norm_8D_order_int_c
        module procedure stdlib_linalg_norm_8D_order_err_int_c
        module procedure stdlib_linalg_norm_9D_order_int_c
        module procedure stdlib_linalg_norm_9D_order_err_int_c
        module procedure stdlib_linalg_norm_10D_order_int_c
        module procedure stdlib_linalg_norm_10D_order_err_int_c
        module procedure stdlib_linalg_norm_11D_order_int_c
        module procedure stdlib_linalg_norm_11D_order_err_int_c
        module procedure stdlib_linalg_norm_12D_order_int_c
        module procedure stdlib_linalg_norm_12D_order_err_int_c
        module procedure stdlib_linalg_norm_13D_order_int_c
        module procedure stdlib_linalg_norm_13D_order_err_int_c
        module procedure stdlib_linalg_norm_14D_order_int_c
        module procedure stdlib_linalg_norm_14D_order_err_int_c
        module procedure stdlib_linalg_norm_15D_order_int_c
        module procedure stdlib_linalg_norm_15D_order_err_int_c
        !> Array norms: complex(sp)
        module procedure stdlib_linalg_norm_2D_to_1D_int_c
        module procedure stdlib_linalg_norm_2D_to_1D_err_int_c
        module procedure stdlib_linalg_norm_3D_to_2D_int_c
        module procedure stdlib_linalg_norm_3D_to_2D_err_int_c
        module procedure stdlib_linalg_norm_4D_to_3D_int_c
        module procedure stdlib_linalg_norm_4D_to_3D_err_int_c
        module procedure stdlib_linalg_norm_5D_to_4D_int_c
        module procedure stdlib_linalg_norm_5D_to_4D_err_int_c
        module procedure stdlib_linalg_norm_6D_to_5D_int_c
        module procedure stdlib_linalg_norm_6D_to_5D_err_int_c
        module procedure stdlib_linalg_norm_7D_to_6D_int_c
        module procedure stdlib_linalg_norm_7D_to_6D_err_int_c
        module procedure stdlib_linalg_norm_8D_to_7D_int_c
        module procedure stdlib_linalg_norm_8D_to_7D_err_int_c
        module procedure stdlib_linalg_norm_9D_to_8D_int_c
        module procedure stdlib_linalg_norm_9D_to_8D_err_int_c
        module procedure stdlib_linalg_norm_10D_to_9D_int_c
        module procedure stdlib_linalg_norm_10D_to_9D_err_int_c
        module procedure stdlib_linalg_norm_11D_to_10D_int_c
        module procedure stdlib_linalg_norm_11D_to_10D_err_int_c
        module procedure stdlib_linalg_norm_12D_to_11D_int_c
        module procedure stdlib_linalg_norm_12D_to_11D_err_int_c
        module procedure stdlib_linalg_norm_13D_to_12D_int_c
        module procedure stdlib_linalg_norm_13D_to_12D_err_int_c
        module procedure stdlib_linalg_norm_14D_to_13D_int_c
        module procedure stdlib_linalg_norm_14D_to_13D_err_int_c
        module procedure stdlib_linalg_norm_15D_to_14D_int_c
        module procedure stdlib_linalg_norm_15D_to_14D_err_int_c
        !> Scalar norms: complex(dp)
        module procedure stdlib_linalg_norm_1D_order_char_z
        module procedure stdlib_linalg_norm_1D_order_err_char_z
        module procedure stdlib_linalg_norm_2D_order_char_z
        module procedure stdlib_linalg_norm_2D_order_err_char_z
        module procedure stdlib_linalg_norm_3D_order_char_z
        module procedure stdlib_linalg_norm_3D_order_err_char_z
        module procedure stdlib_linalg_norm_4D_order_char_z
        module procedure stdlib_linalg_norm_4D_order_err_char_z
        module procedure stdlib_linalg_norm_5D_order_char_z
        module procedure stdlib_linalg_norm_5D_order_err_char_z
        module procedure stdlib_linalg_norm_6D_order_char_z
        module procedure stdlib_linalg_norm_6D_order_err_char_z
        module procedure stdlib_linalg_norm_7D_order_char_z
        module procedure stdlib_linalg_norm_7D_order_err_char_z
        module procedure stdlib_linalg_norm_8D_order_char_z
        module procedure stdlib_linalg_norm_8D_order_err_char_z
        module procedure stdlib_linalg_norm_9D_order_char_z
        module procedure stdlib_linalg_norm_9D_order_err_char_z
        module procedure stdlib_linalg_norm_10D_order_char_z
        module procedure stdlib_linalg_norm_10D_order_err_char_z
        module procedure stdlib_linalg_norm_11D_order_char_z
        module procedure stdlib_linalg_norm_11D_order_err_char_z
        module procedure stdlib_linalg_norm_12D_order_char_z
        module procedure stdlib_linalg_norm_12D_order_err_char_z
        module procedure stdlib_linalg_norm_13D_order_char_z
        module procedure stdlib_linalg_norm_13D_order_err_char_z
        module procedure stdlib_linalg_norm_14D_order_char_z
        module procedure stdlib_linalg_norm_14D_order_err_char_z
        module procedure stdlib_linalg_norm_15D_order_char_z
        module procedure stdlib_linalg_norm_15D_order_err_char_z
        !> Array norms: complex(dp)
        module procedure stdlib_linalg_norm_2D_to_1D_char_z
        module procedure stdlib_linalg_norm_2D_to_1D_err_char_z
        module procedure stdlib_linalg_norm_3D_to_2D_char_z
        module procedure stdlib_linalg_norm_3D_to_2D_err_char_z
        module procedure stdlib_linalg_norm_4D_to_3D_char_z
        module procedure stdlib_linalg_norm_4D_to_3D_err_char_z
        module procedure stdlib_linalg_norm_5D_to_4D_char_z
        module procedure stdlib_linalg_norm_5D_to_4D_err_char_z
        module procedure stdlib_linalg_norm_6D_to_5D_char_z
        module procedure stdlib_linalg_norm_6D_to_5D_err_char_z
        module procedure stdlib_linalg_norm_7D_to_6D_char_z
        module procedure stdlib_linalg_norm_7D_to_6D_err_char_z
        module procedure stdlib_linalg_norm_8D_to_7D_char_z
        module procedure stdlib_linalg_norm_8D_to_7D_err_char_z
        module procedure stdlib_linalg_norm_9D_to_8D_char_z
        module procedure stdlib_linalg_norm_9D_to_8D_err_char_z
        module procedure stdlib_linalg_norm_10D_to_9D_char_z
        module procedure stdlib_linalg_norm_10D_to_9D_err_char_z
        module procedure stdlib_linalg_norm_11D_to_10D_char_z
        module procedure stdlib_linalg_norm_11D_to_10D_err_char_z
        module procedure stdlib_linalg_norm_12D_to_11D_char_z
        module procedure stdlib_linalg_norm_12D_to_11D_err_char_z
        module procedure stdlib_linalg_norm_13D_to_12D_char_z
        module procedure stdlib_linalg_norm_13D_to_12D_err_char_z
        module procedure stdlib_linalg_norm_14D_to_13D_char_z
        module procedure stdlib_linalg_norm_14D_to_13D_err_char_z
        module procedure stdlib_linalg_norm_15D_to_14D_char_z
        module procedure stdlib_linalg_norm_15D_to_14D_err_char_z
        !> Scalar norms: complex(dp)
        module procedure stdlib_linalg_norm_1D_order_int_z
        module procedure stdlib_linalg_norm_1D_order_err_int_z
        module procedure stdlib_linalg_norm_2D_order_int_z
        module procedure stdlib_linalg_norm_2D_order_err_int_z
        module procedure stdlib_linalg_norm_3D_order_int_z
        module procedure stdlib_linalg_norm_3D_order_err_int_z
        module procedure stdlib_linalg_norm_4D_order_int_z
        module procedure stdlib_linalg_norm_4D_order_err_int_z
        module procedure stdlib_linalg_norm_5D_order_int_z
        module procedure stdlib_linalg_norm_5D_order_err_int_z
        module procedure stdlib_linalg_norm_6D_order_int_z
        module procedure stdlib_linalg_norm_6D_order_err_int_z
        module procedure stdlib_linalg_norm_7D_order_int_z
        module procedure stdlib_linalg_norm_7D_order_err_int_z
        module procedure stdlib_linalg_norm_8D_order_int_z
        module procedure stdlib_linalg_norm_8D_order_err_int_z
        module procedure stdlib_linalg_norm_9D_order_int_z
        module procedure stdlib_linalg_norm_9D_order_err_int_z
        module procedure stdlib_linalg_norm_10D_order_int_z
        module procedure stdlib_linalg_norm_10D_order_err_int_z
        module procedure stdlib_linalg_norm_11D_order_int_z
        module procedure stdlib_linalg_norm_11D_order_err_int_z
        module procedure stdlib_linalg_norm_12D_order_int_z
        module procedure stdlib_linalg_norm_12D_order_err_int_z
        module procedure stdlib_linalg_norm_13D_order_int_z
        module procedure stdlib_linalg_norm_13D_order_err_int_z
        module procedure stdlib_linalg_norm_14D_order_int_z
        module procedure stdlib_linalg_norm_14D_order_err_int_z
        module procedure stdlib_linalg_norm_15D_order_int_z
        module procedure stdlib_linalg_norm_15D_order_err_int_z
        !> Array norms: complex(dp)
        module procedure stdlib_linalg_norm_2D_to_1D_int_z
        module procedure stdlib_linalg_norm_2D_to_1D_err_int_z
        module procedure stdlib_linalg_norm_3D_to_2D_int_z
        module procedure stdlib_linalg_norm_3D_to_2D_err_int_z
        module procedure stdlib_linalg_norm_4D_to_3D_int_z
        module procedure stdlib_linalg_norm_4D_to_3D_err_int_z
        module procedure stdlib_linalg_norm_5D_to_4D_int_z
        module procedure stdlib_linalg_norm_5D_to_4D_err_int_z
        module procedure stdlib_linalg_norm_6D_to_5D_int_z
        module procedure stdlib_linalg_norm_6D_to_5D_err_int_z
        module procedure stdlib_linalg_norm_7D_to_6D_int_z
        module procedure stdlib_linalg_norm_7D_to_6D_err_int_z
        module procedure stdlib_linalg_norm_8D_to_7D_int_z
        module procedure stdlib_linalg_norm_8D_to_7D_err_int_z
        module procedure stdlib_linalg_norm_9D_to_8D_int_z
        module procedure stdlib_linalg_norm_9D_to_8D_err_int_z
        module procedure stdlib_linalg_norm_10D_to_9D_int_z
        module procedure stdlib_linalg_norm_10D_to_9D_err_int_z
        module procedure stdlib_linalg_norm_11D_to_10D_int_z
        module procedure stdlib_linalg_norm_11D_to_10D_err_int_z
        module procedure stdlib_linalg_norm_12D_to_11D_int_z
        module procedure stdlib_linalg_norm_12D_to_11D_err_int_z
        module procedure stdlib_linalg_norm_13D_to_12D_int_z
        module procedure stdlib_linalg_norm_13D_to_12D_err_int_z
        module procedure stdlib_linalg_norm_14D_to_13D_int_z
        module procedure stdlib_linalg_norm_14D_to_13D_err_int_z
        module procedure stdlib_linalg_norm_15D_to_14D_int_z
        module procedure stdlib_linalg_norm_15D_to_14D_err_int_z
        !> Scalar norms: complex(qp)
        module procedure stdlib_linalg_norm_1D_order_char_w
        module procedure stdlib_linalg_norm_1D_order_err_char_w
        module procedure stdlib_linalg_norm_2D_order_char_w
        module procedure stdlib_linalg_norm_2D_order_err_char_w
        module procedure stdlib_linalg_norm_3D_order_char_w
        module procedure stdlib_linalg_norm_3D_order_err_char_w
        module procedure stdlib_linalg_norm_4D_order_char_w
        module procedure stdlib_linalg_norm_4D_order_err_char_w
        module procedure stdlib_linalg_norm_5D_order_char_w
        module procedure stdlib_linalg_norm_5D_order_err_char_w
        module procedure stdlib_linalg_norm_6D_order_char_w
        module procedure stdlib_linalg_norm_6D_order_err_char_w
        module procedure stdlib_linalg_norm_7D_order_char_w
        module procedure stdlib_linalg_norm_7D_order_err_char_w
        module procedure stdlib_linalg_norm_8D_order_char_w
        module procedure stdlib_linalg_norm_8D_order_err_char_w
        module procedure stdlib_linalg_norm_9D_order_char_w
        module procedure stdlib_linalg_norm_9D_order_err_char_w
        module procedure stdlib_linalg_norm_10D_order_char_w
        module procedure stdlib_linalg_norm_10D_order_err_char_w
        module procedure stdlib_linalg_norm_11D_order_char_w
        module procedure stdlib_linalg_norm_11D_order_err_char_w
        module procedure stdlib_linalg_norm_12D_order_char_w
        module procedure stdlib_linalg_norm_12D_order_err_char_w
        module procedure stdlib_linalg_norm_13D_order_char_w
        module procedure stdlib_linalg_norm_13D_order_err_char_w
        module procedure stdlib_linalg_norm_14D_order_char_w
        module procedure stdlib_linalg_norm_14D_order_err_char_w
        module procedure stdlib_linalg_norm_15D_order_char_w
        module procedure stdlib_linalg_norm_15D_order_err_char_w
        !> Array norms: complex(qp)
        module procedure stdlib_linalg_norm_2D_to_1D_char_w
        module procedure stdlib_linalg_norm_2D_to_1D_err_char_w
        module procedure stdlib_linalg_norm_3D_to_2D_char_w
        module procedure stdlib_linalg_norm_3D_to_2D_err_char_w
        module procedure stdlib_linalg_norm_4D_to_3D_char_w
        module procedure stdlib_linalg_norm_4D_to_3D_err_char_w
        module procedure stdlib_linalg_norm_5D_to_4D_char_w
        module procedure stdlib_linalg_norm_5D_to_4D_err_char_w
        module procedure stdlib_linalg_norm_6D_to_5D_char_w
        module procedure stdlib_linalg_norm_6D_to_5D_err_char_w
        module procedure stdlib_linalg_norm_7D_to_6D_char_w
        module procedure stdlib_linalg_norm_7D_to_6D_err_char_w
        module procedure stdlib_linalg_norm_8D_to_7D_char_w
        module procedure stdlib_linalg_norm_8D_to_7D_err_char_w
        module procedure stdlib_linalg_norm_9D_to_8D_char_w
        module procedure stdlib_linalg_norm_9D_to_8D_err_char_w
        module procedure stdlib_linalg_norm_10D_to_9D_char_w
        module procedure stdlib_linalg_norm_10D_to_9D_err_char_w
        module procedure stdlib_linalg_norm_11D_to_10D_char_w
        module procedure stdlib_linalg_norm_11D_to_10D_err_char_w
        module procedure stdlib_linalg_norm_12D_to_11D_char_w
        module procedure stdlib_linalg_norm_12D_to_11D_err_char_w
        module procedure stdlib_linalg_norm_13D_to_12D_char_w
        module procedure stdlib_linalg_norm_13D_to_12D_err_char_w
        module procedure stdlib_linalg_norm_14D_to_13D_char_w
        module procedure stdlib_linalg_norm_14D_to_13D_err_char_w
        module procedure stdlib_linalg_norm_15D_to_14D_char_w
        module procedure stdlib_linalg_norm_15D_to_14D_err_char_w
        !> Scalar norms: complex(qp)
        module procedure stdlib_linalg_norm_1D_order_int_w
        module procedure stdlib_linalg_norm_1D_order_err_int_w
        module procedure stdlib_linalg_norm_2D_order_int_w
        module procedure stdlib_linalg_norm_2D_order_err_int_w
        module procedure stdlib_linalg_norm_3D_order_int_w
        module procedure stdlib_linalg_norm_3D_order_err_int_w
        module procedure stdlib_linalg_norm_4D_order_int_w
        module procedure stdlib_linalg_norm_4D_order_err_int_w
        module procedure stdlib_linalg_norm_5D_order_int_w
        module procedure stdlib_linalg_norm_5D_order_err_int_w
        module procedure stdlib_linalg_norm_6D_order_int_w
        module procedure stdlib_linalg_norm_6D_order_err_int_w
        module procedure stdlib_linalg_norm_7D_order_int_w
        module procedure stdlib_linalg_norm_7D_order_err_int_w
        module procedure stdlib_linalg_norm_8D_order_int_w
        module procedure stdlib_linalg_norm_8D_order_err_int_w
        module procedure stdlib_linalg_norm_9D_order_int_w
        module procedure stdlib_linalg_norm_9D_order_err_int_w
        module procedure stdlib_linalg_norm_10D_order_int_w
        module procedure stdlib_linalg_norm_10D_order_err_int_w
        module procedure stdlib_linalg_norm_11D_order_int_w
        module procedure stdlib_linalg_norm_11D_order_err_int_w
        module procedure stdlib_linalg_norm_12D_order_int_w
        module procedure stdlib_linalg_norm_12D_order_err_int_w
        module procedure stdlib_linalg_norm_13D_order_int_w
        module procedure stdlib_linalg_norm_13D_order_err_int_w
        module procedure stdlib_linalg_norm_14D_order_int_w
        module procedure stdlib_linalg_norm_14D_order_err_int_w
        module procedure stdlib_linalg_norm_15D_order_int_w
        module procedure stdlib_linalg_norm_15D_order_err_int_w
        !> Array norms: complex(qp)
        module procedure stdlib_linalg_norm_2D_to_1D_int_w
        module procedure stdlib_linalg_norm_2D_to_1D_err_int_w
        module procedure stdlib_linalg_norm_3D_to_2D_int_w
        module procedure stdlib_linalg_norm_3D_to_2D_err_int_w
        module procedure stdlib_linalg_norm_4D_to_3D_int_w
        module procedure stdlib_linalg_norm_4D_to_3D_err_int_w
        module procedure stdlib_linalg_norm_5D_to_4D_int_w
        module procedure stdlib_linalg_norm_5D_to_4D_err_int_w
        module procedure stdlib_linalg_norm_6D_to_5D_int_w
        module procedure stdlib_linalg_norm_6D_to_5D_err_int_w
        module procedure stdlib_linalg_norm_7D_to_6D_int_w
        module procedure stdlib_linalg_norm_7D_to_6D_err_int_w
        module procedure stdlib_linalg_norm_8D_to_7D_int_w
        module procedure stdlib_linalg_norm_8D_to_7D_err_int_w
        module procedure stdlib_linalg_norm_9D_to_8D_int_w
        module procedure stdlib_linalg_norm_9D_to_8D_err_int_w
        module procedure stdlib_linalg_norm_10D_to_9D_int_w
        module procedure stdlib_linalg_norm_10D_to_9D_err_int_w
        module procedure stdlib_linalg_norm_11D_to_10D_int_w
        module procedure stdlib_linalg_norm_11D_to_10D_err_int_w
        module procedure stdlib_linalg_norm_12D_to_11D_int_w
        module procedure stdlib_linalg_norm_12D_to_11D_err_int_w
        module procedure stdlib_linalg_norm_13D_to_12D_int_w
        module procedure stdlib_linalg_norm_13D_to_12D_err_int_w
        module procedure stdlib_linalg_norm_14D_to_13D_int_w
        module procedure stdlib_linalg_norm_14D_to_13D_err_int_w
        module procedure stdlib_linalg_norm_15D_to_14D_int_w
        module procedure stdlib_linalg_norm_15D_to_14D_err_int_w
     end interface norm
     
     !> Vector norm: subroutine interface
     interface get_norm
            !> Scalar norms: real(sp)
            module procedure norm_1D_char_s
            module procedure norm_2D_char_s
            module procedure norm_3D_char_s
            module procedure norm_4D_char_s
            module procedure norm_5D_char_s
            module procedure norm_6D_char_s
            module procedure norm_7D_char_s
            module procedure norm_8D_char_s
            module procedure norm_9D_char_s
            module procedure norm_10D_char_s
            module procedure norm_11D_char_s
            module procedure norm_12D_char_s
            module procedure norm_13D_char_s
            module procedure norm_14D_char_s
            module procedure norm_15D_char_s
            !> Array norms: real(sp)
            module procedure norm_2D_to_1D_char_s
            module procedure norm_3D_to_2D_char_s
            module procedure norm_4D_to_3D_char_s
            module procedure norm_5D_to_4D_char_s
            module procedure norm_6D_to_5D_char_s
            module procedure norm_7D_to_6D_char_s
            module procedure norm_8D_to_7D_char_s
            module procedure norm_9D_to_8D_char_s
            module procedure norm_10D_to_9D_char_s
            module procedure norm_11D_to_10D_char_s
            module procedure norm_12D_to_11D_char_s
            module procedure norm_13D_to_12D_char_s
            module procedure norm_14D_to_13D_char_s
            module procedure norm_15D_to_14D_char_s
            !> Scalar norms: real(sp)
            module procedure norm_1D_int_s
            module procedure norm_2D_int_s
            module procedure norm_3D_int_s
            module procedure norm_4D_int_s
            module procedure norm_5D_int_s
            module procedure norm_6D_int_s
            module procedure norm_7D_int_s
            module procedure norm_8D_int_s
            module procedure norm_9D_int_s
            module procedure norm_10D_int_s
            module procedure norm_11D_int_s
            module procedure norm_12D_int_s
            module procedure norm_13D_int_s
            module procedure norm_14D_int_s
            module procedure norm_15D_int_s
            !> Array norms: real(sp)
            module procedure norm_2D_to_1D_int_s
            module procedure norm_3D_to_2D_int_s
            module procedure norm_4D_to_3D_int_s
            module procedure norm_5D_to_4D_int_s
            module procedure norm_6D_to_5D_int_s
            module procedure norm_7D_to_6D_int_s
            module procedure norm_8D_to_7D_int_s
            module procedure norm_9D_to_8D_int_s
            module procedure norm_10D_to_9D_int_s
            module procedure norm_11D_to_10D_int_s
            module procedure norm_12D_to_11D_int_s
            module procedure norm_13D_to_12D_int_s
            module procedure norm_14D_to_13D_int_s
            module procedure norm_15D_to_14D_int_s
            !> Scalar norms: real(dp)
            module procedure norm_1D_char_d
            module procedure norm_2D_char_d
            module procedure norm_3D_char_d
            module procedure norm_4D_char_d
            module procedure norm_5D_char_d
            module procedure norm_6D_char_d
            module procedure norm_7D_char_d
            module procedure norm_8D_char_d
            module procedure norm_9D_char_d
            module procedure norm_10D_char_d
            module procedure norm_11D_char_d
            module procedure norm_12D_char_d
            module procedure norm_13D_char_d
            module procedure norm_14D_char_d
            module procedure norm_15D_char_d
            !> Array norms: real(dp)
            module procedure norm_2D_to_1D_char_d
            module procedure norm_3D_to_2D_char_d
            module procedure norm_4D_to_3D_char_d
            module procedure norm_5D_to_4D_char_d
            module procedure norm_6D_to_5D_char_d
            module procedure norm_7D_to_6D_char_d
            module procedure norm_8D_to_7D_char_d
            module procedure norm_9D_to_8D_char_d
            module procedure norm_10D_to_9D_char_d
            module procedure norm_11D_to_10D_char_d
            module procedure norm_12D_to_11D_char_d
            module procedure norm_13D_to_12D_char_d
            module procedure norm_14D_to_13D_char_d
            module procedure norm_15D_to_14D_char_d
            !> Scalar norms: real(dp)
            module procedure norm_1D_int_d
            module procedure norm_2D_int_d
            module procedure norm_3D_int_d
            module procedure norm_4D_int_d
            module procedure norm_5D_int_d
            module procedure norm_6D_int_d
            module procedure norm_7D_int_d
            module procedure norm_8D_int_d
            module procedure norm_9D_int_d
            module procedure norm_10D_int_d
            module procedure norm_11D_int_d
            module procedure norm_12D_int_d
            module procedure norm_13D_int_d
            module procedure norm_14D_int_d
            module procedure norm_15D_int_d
            !> Array norms: real(dp)
            module procedure norm_2D_to_1D_int_d
            module procedure norm_3D_to_2D_int_d
            module procedure norm_4D_to_3D_int_d
            module procedure norm_5D_to_4D_int_d
            module procedure norm_6D_to_5D_int_d
            module procedure norm_7D_to_6D_int_d
            module procedure norm_8D_to_7D_int_d
            module procedure norm_9D_to_8D_int_d
            module procedure norm_10D_to_9D_int_d
            module procedure norm_11D_to_10D_int_d
            module procedure norm_12D_to_11D_int_d
            module procedure norm_13D_to_12D_int_d
            module procedure norm_14D_to_13D_int_d
            module procedure norm_15D_to_14D_int_d
            !> Scalar norms: real(qp)
            module procedure norm_1D_char_q
            module procedure norm_2D_char_q
            module procedure norm_3D_char_q
            module procedure norm_4D_char_q
            module procedure norm_5D_char_q
            module procedure norm_6D_char_q
            module procedure norm_7D_char_q
            module procedure norm_8D_char_q
            module procedure norm_9D_char_q
            module procedure norm_10D_char_q
            module procedure norm_11D_char_q
            module procedure norm_12D_char_q
            module procedure norm_13D_char_q
            module procedure norm_14D_char_q
            module procedure norm_15D_char_q
            !> Array norms: real(qp)
            module procedure norm_2D_to_1D_char_q
            module procedure norm_3D_to_2D_char_q
            module procedure norm_4D_to_3D_char_q
            module procedure norm_5D_to_4D_char_q
            module procedure norm_6D_to_5D_char_q
            module procedure norm_7D_to_6D_char_q
            module procedure norm_8D_to_7D_char_q
            module procedure norm_9D_to_8D_char_q
            module procedure norm_10D_to_9D_char_q
            module procedure norm_11D_to_10D_char_q
            module procedure norm_12D_to_11D_char_q
            module procedure norm_13D_to_12D_char_q
            module procedure norm_14D_to_13D_char_q
            module procedure norm_15D_to_14D_char_q
            !> Scalar norms: real(qp)
            module procedure norm_1D_int_q
            module procedure norm_2D_int_q
            module procedure norm_3D_int_q
            module procedure norm_4D_int_q
            module procedure norm_5D_int_q
            module procedure norm_6D_int_q
            module procedure norm_7D_int_q
            module procedure norm_8D_int_q
            module procedure norm_9D_int_q
            module procedure norm_10D_int_q
            module procedure norm_11D_int_q
            module procedure norm_12D_int_q
            module procedure norm_13D_int_q
            module procedure norm_14D_int_q
            module procedure norm_15D_int_q
            !> Array norms: real(qp)
            module procedure norm_2D_to_1D_int_q
            module procedure norm_3D_to_2D_int_q
            module procedure norm_4D_to_3D_int_q
            module procedure norm_5D_to_4D_int_q
            module procedure norm_6D_to_5D_int_q
            module procedure norm_7D_to_6D_int_q
            module procedure norm_8D_to_7D_int_q
            module procedure norm_9D_to_8D_int_q
            module procedure norm_10D_to_9D_int_q
            module procedure norm_11D_to_10D_int_q
            module procedure norm_12D_to_11D_int_q
            module procedure norm_13D_to_12D_int_q
            module procedure norm_14D_to_13D_int_q
            module procedure norm_15D_to_14D_int_q
            !> Scalar norms: complex(sp)
            module procedure norm_1D_char_c
            module procedure norm_2D_char_c
            module procedure norm_3D_char_c
            module procedure norm_4D_char_c
            module procedure norm_5D_char_c
            module procedure norm_6D_char_c
            module procedure norm_7D_char_c
            module procedure norm_8D_char_c
            module procedure norm_9D_char_c
            module procedure norm_10D_char_c
            module procedure norm_11D_char_c
            module procedure norm_12D_char_c
            module procedure norm_13D_char_c
            module procedure norm_14D_char_c
            module procedure norm_15D_char_c
            !> Array norms: complex(sp)
            module procedure norm_2D_to_1D_char_c
            module procedure norm_3D_to_2D_char_c
            module procedure norm_4D_to_3D_char_c
            module procedure norm_5D_to_4D_char_c
            module procedure norm_6D_to_5D_char_c
            module procedure norm_7D_to_6D_char_c
            module procedure norm_8D_to_7D_char_c
            module procedure norm_9D_to_8D_char_c
            module procedure norm_10D_to_9D_char_c
            module procedure norm_11D_to_10D_char_c
            module procedure norm_12D_to_11D_char_c
            module procedure norm_13D_to_12D_char_c
            module procedure norm_14D_to_13D_char_c
            module procedure norm_15D_to_14D_char_c
            !> Scalar norms: complex(sp)
            module procedure norm_1D_int_c
            module procedure norm_2D_int_c
            module procedure norm_3D_int_c
            module procedure norm_4D_int_c
            module procedure norm_5D_int_c
            module procedure norm_6D_int_c
            module procedure norm_7D_int_c
            module procedure norm_8D_int_c
            module procedure norm_9D_int_c
            module procedure norm_10D_int_c
            module procedure norm_11D_int_c
            module procedure norm_12D_int_c
            module procedure norm_13D_int_c
            module procedure norm_14D_int_c
            module procedure norm_15D_int_c
            !> Array norms: complex(sp)
            module procedure norm_2D_to_1D_int_c
            module procedure norm_3D_to_2D_int_c
            module procedure norm_4D_to_3D_int_c
            module procedure norm_5D_to_4D_int_c
            module procedure norm_6D_to_5D_int_c
            module procedure norm_7D_to_6D_int_c
            module procedure norm_8D_to_7D_int_c
            module procedure norm_9D_to_8D_int_c
            module procedure norm_10D_to_9D_int_c
            module procedure norm_11D_to_10D_int_c
            module procedure norm_12D_to_11D_int_c
            module procedure norm_13D_to_12D_int_c
            module procedure norm_14D_to_13D_int_c
            module procedure norm_15D_to_14D_int_c
            !> Scalar norms: complex(dp)
            module procedure norm_1D_char_z
            module procedure norm_2D_char_z
            module procedure norm_3D_char_z
            module procedure norm_4D_char_z
            module procedure norm_5D_char_z
            module procedure norm_6D_char_z
            module procedure norm_7D_char_z
            module procedure norm_8D_char_z
            module procedure norm_9D_char_z
            module procedure norm_10D_char_z
            module procedure norm_11D_char_z
            module procedure norm_12D_char_z
            module procedure norm_13D_char_z
            module procedure norm_14D_char_z
            module procedure norm_15D_char_z
            !> Array norms: complex(dp)
            module procedure norm_2D_to_1D_char_z
            module procedure norm_3D_to_2D_char_z
            module procedure norm_4D_to_3D_char_z
            module procedure norm_5D_to_4D_char_z
            module procedure norm_6D_to_5D_char_z
            module procedure norm_7D_to_6D_char_z
            module procedure norm_8D_to_7D_char_z
            module procedure norm_9D_to_8D_char_z
            module procedure norm_10D_to_9D_char_z
            module procedure norm_11D_to_10D_char_z
            module procedure norm_12D_to_11D_char_z
            module procedure norm_13D_to_12D_char_z
            module procedure norm_14D_to_13D_char_z
            module procedure norm_15D_to_14D_char_z
            !> Scalar norms: complex(dp)
            module procedure norm_1D_int_z
            module procedure norm_2D_int_z
            module procedure norm_3D_int_z
            module procedure norm_4D_int_z
            module procedure norm_5D_int_z
            module procedure norm_6D_int_z
            module procedure norm_7D_int_z
            module procedure norm_8D_int_z
            module procedure norm_9D_int_z
            module procedure norm_10D_int_z
            module procedure norm_11D_int_z
            module procedure norm_12D_int_z
            module procedure norm_13D_int_z
            module procedure norm_14D_int_z
            module procedure norm_15D_int_z
            !> Array norms: complex(dp)
            module procedure norm_2D_to_1D_int_z
            module procedure norm_3D_to_2D_int_z
            module procedure norm_4D_to_3D_int_z
            module procedure norm_5D_to_4D_int_z
            module procedure norm_6D_to_5D_int_z
            module procedure norm_7D_to_6D_int_z
            module procedure norm_8D_to_7D_int_z
            module procedure norm_9D_to_8D_int_z
            module procedure norm_10D_to_9D_int_z
            module procedure norm_11D_to_10D_int_z
            module procedure norm_12D_to_11D_int_z
            module procedure norm_13D_to_12D_int_z
            module procedure norm_14D_to_13D_int_z
            module procedure norm_15D_to_14D_int_z
            !> Scalar norms: complex(qp)
            module procedure norm_1D_char_w
            module procedure norm_2D_char_w
            module procedure norm_3D_char_w
            module procedure norm_4D_char_w
            module procedure norm_5D_char_w
            module procedure norm_6D_char_w
            module procedure norm_7D_char_w
            module procedure norm_8D_char_w
            module procedure norm_9D_char_w
            module procedure norm_10D_char_w
            module procedure norm_11D_char_w
            module procedure norm_12D_char_w
            module procedure norm_13D_char_w
            module procedure norm_14D_char_w
            module procedure norm_15D_char_w
            !> Array norms: complex(qp)
            module procedure norm_2D_to_1D_char_w
            module procedure norm_3D_to_2D_char_w
            module procedure norm_4D_to_3D_char_w
            module procedure norm_5D_to_4D_char_w
            module procedure norm_6D_to_5D_char_w
            module procedure norm_7D_to_6D_char_w
            module procedure norm_8D_to_7D_char_w
            module procedure norm_9D_to_8D_char_w
            module procedure norm_10D_to_9D_char_w
            module procedure norm_11D_to_10D_char_w
            module procedure norm_12D_to_11D_char_w
            module procedure norm_13D_to_12D_char_w
            module procedure norm_14D_to_13D_char_w
            module procedure norm_15D_to_14D_char_w
            !> Scalar norms: complex(qp)
            module procedure norm_1D_int_w
            module procedure norm_2D_int_w
            module procedure norm_3D_int_w
            module procedure norm_4D_int_w
            module procedure norm_5D_int_w
            module procedure norm_6D_int_w
            module procedure norm_7D_int_w
            module procedure norm_8D_int_w
            module procedure norm_9D_int_w
            module procedure norm_10D_int_w
            module procedure norm_11D_int_w
            module procedure norm_12D_int_w
            module procedure norm_13D_int_w
            module procedure norm_14D_int_w
            module procedure norm_15D_int_w
            !> Array norms: complex(qp)
            module procedure norm_2D_to_1D_int_w
            module procedure norm_3D_to_2D_int_w
            module procedure norm_4D_to_3D_int_w
            module procedure norm_5D_to_4D_int_w
            module procedure norm_6D_to_5D_int_w
            module procedure norm_7D_to_6D_int_w
            module procedure norm_8D_to_7D_int_w
            module procedure norm_9D_to_8D_int_w
            module procedure norm_10D_to_9D_int_w
            module procedure norm_11D_to_10D_int_w
            module procedure norm_12D_to_11D_int_w
            module procedure norm_13D_to_12D_int_w
            module procedure norm_14D_to_13D_int_w
            module procedure norm_15D_to_14D_int_w
     end interface get_norm
     
     interface parse_norm_type
        module procedure parse_norm_type_integer
        module procedure parse_norm_type_character
     end interface parse_norm_type
     
     contains
     
     !> Parse norm type from an integer user input
     pure subroutine parse_norm_type_integer(order,norm_type,err)
        !> User input value
        integer(ilp),intent(in) :: order
        !> Return value: norm type
        integer(ilp),intent(out) :: norm_type
        !> State return flag
        type(linalg_state),intent(out) :: err
        
        select case (order)
           case (1_ilp)
               norm_type = NORM_ONE
           case (2_ilp)
               norm_type = NORM_TWO
           case (3_ilp:huge(0_ilp) - 1_ilp)
               norm_type = order
           case (huge(0_ilp):)
               norm_type = NORM_INF
           case (:-huge(0_ilp))
               norm_type = NORM_MINUSINF
           
           case default
               norm_type = NORM_ONE
               err = linalg_state(this,LINALG_ERROR,'Input norm type ',order,' is not recognized.')
        end select
        
     end subroutine parse_norm_type_integer

     pure subroutine parse_norm_type_character(order,norm_type,err)
        !> User input value
        character(len=*),intent(in) :: order
        !> Return value: norm type
        integer(ilp),intent(out) :: norm_type
        !> State return flag
        type(linalg_state),intent(out) :: err
        
        integer(ilp) :: int_order,read_err
        
        select case (order)
           case ('inf','Inf','INF')
              norm_type = NORM_INF
           case ('-inf','-Inf','-INF')
              norm_type = NORM_MINUSINF
           case ('Euclidean','euclidean','EUCLIDEAN')
              norm_type = NORM_TWO
           case default
            
              ! Check if this input can be read as an integer
              read (order,*,iostat=read_err) int_order
              if (read_err /= 0) then
                 ! Cannot read as an integer
                 norm_type = NORM_ONE
                 err = linalg_state(this,LINALG_ERROR,'Input norm type ',order,' is not recognized.')
              else
                 call parse_norm_type_integer(int_order,norm_type,err)
              end if

        end select
        
     end subroutine parse_norm_type_character

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_char_s(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        real(sp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_1D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_char_s(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        real(sp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_1D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_1D_char_s(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        real(sp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_char_s(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(sp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_2D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_char_s(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(sp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_2D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_2D_char_s(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        real(sp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_char_s(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(sp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_3D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_char_s(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(sp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_3D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_3D_char_s(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        real(sp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_char_s(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_4D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_char_s(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_4D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_4D_char_s(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_char_s(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_5D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_char_s(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_5D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_5D_char_s(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_char_s(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_6D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_char_s(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_6D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_6D_char_s(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_char_s(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_7D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_char_s(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_7D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_7D_char_s(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_char_s(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_8D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_char_s(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_8D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_8D_char_s(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_char_s(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_9D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_char_s(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_9D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_9D_char_s(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_char_s(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_10D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_char_s(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_10D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_10D_char_s(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_char_s(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_11D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_char_s(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_11D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_11D_char_s(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_char_s(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_12D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_char_s(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_12D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_12D_char_s(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_char_s(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_13D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_char_s(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_13D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_13D_char_s(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_char_s(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_14D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_char_s(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_14D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_14D_char_s(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_char_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_char_s(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_15D_char_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_char_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_char_s(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_15D_char_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_char_s
    
    ! Internal implementation
    pure subroutine norm_15D_char_s(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_char_s

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and char input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        character(len=*),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_char_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_char_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_char_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_char_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_char_s
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_char_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_char_s

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_int_s(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        real(sp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_1D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_int_s(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        real(sp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_1D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_1D_int_s(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        real(sp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_int_s(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(sp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_2D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_int_s(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(sp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_2D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_2D_int_s(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        real(sp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_int_s(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(sp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_3D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_int_s(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(sp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_3D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_3D_int_s(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        real(sp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_int_s(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_4D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_int_s(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_4D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_4D_int_s(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_int_s(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_5D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_int_s(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_5D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_5D_int_s(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_int_s(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_6D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_int_s(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_6D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_6D_int_s(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_int_s(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_7D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_int_s(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_7D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_7D_int_s(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_int_s(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_8D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_int_s(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_8D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_8D_int_s(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_int_s(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_9D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_int_s(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_9D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_9D_int_s(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_int_s(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_10D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_int_s(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_10D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_10D_int_s(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_int_s(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_11D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_int_s(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_11D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_11D_int_s(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_int_s(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_12D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_int_s(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_12D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_12D_int_s(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_int_s(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_13D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_int_s(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_13D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_13D_int_s(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_int_s(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_14D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_int_s(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_14D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_14D_int_s(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_int_s

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_int_s(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_15D_int_s(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_int_s
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_int_s(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_15D_int_s(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_int_s
    
    ! Internal implementation
    pure subroutine norm_15D_int_s(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_int_s

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and int input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        integer(ilp),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_int_s

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_int_s(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_s(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_int_s

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_int_s(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_s(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_int_s
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_int_s(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_int_s

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_char_d(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        real(dp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_1D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_char_d(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        real(dp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_1D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_1D_char_d(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        real(dp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_char_d(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(dp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_2D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_char_d(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(dp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_2D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_2D_char_d(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        real(dp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_char_d(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(dp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_3D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_char_d(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(dp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_3D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_3D_char_d(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        real(dp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_char_d(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_4D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_char_d(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_4D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_4D_char_d(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_char_d(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_5D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_char_d(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_5D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_5D_char_d(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_char_d(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_6D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_char_d(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_6D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_6D_char_d(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_char_d(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_7D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_char_d(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_7D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_7D_char_d(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_char_d(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_8D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_char_d(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_8D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_8D_char_d(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_char_d(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_9D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_char_d(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_9D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_9D_char_d(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_char_d(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_10D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_char_d(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_10D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_10D_char_d(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_char_d(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_11D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_char_d(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_11D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_11D_char_d(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_char_d(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_12D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_char_d(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_12D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_12D_char_d(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_char_d(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_13D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_char_d(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_13D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_13D_char_d(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_char_d(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_14D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_char_d(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_14D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_14D_char_d(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_char_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_char_d(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_15D_char_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_char_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_char_d(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_15D_char_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_char_d
    
    ! Internal implementation
    pure subroutine norm_15D_char_d(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_char_d

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and char input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        character(len=*),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_char_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_char_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_char_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_char_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_char_d
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_char_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_char_d

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_int_d(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        real(dp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_1D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_int_d(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        real(dp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_1D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_1D_int_d(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        real(dp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_int_d(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(dp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_2D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_int_d(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(dp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_2D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_2D_int_d(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        real(dp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_int_d(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(dp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_3D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_int_d(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(dp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_3D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_3D_int_d(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        real(dp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_int_d(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_4D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_int_d(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_4D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_4D_int_d(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_int_d(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_5D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_int_d(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_5D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_5D_int_d(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_int_d(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_6D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_int_d(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_6D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_6D_int_d(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_int_d(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_7D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_int_d(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_7D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_7D_int_d(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_int_d(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_8D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_int_d(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_8D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_8D_int_d(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_int_d(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_9D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_int_d(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_9D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_9D_int_d(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_int_d(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_10D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_int_d(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_10D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_10D_int_d(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_int_d(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_11D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_int_d(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_11D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_11D_int_d(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_int_d(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_12D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_int_d(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_12D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_12D_int_d(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_int_d(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_13D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_int_d(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_13D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_13D_int_d(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_int_d(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_14D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_int_d(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_14D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_14D_int_d(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_int_d

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_int_d(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_15D_int_d(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_int_d
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_int_d(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_15D_int_d(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_int_d
    
    ! Internal implementation
    pure subroutine norm_15D_int_d(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_int_d

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and int input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        integer(ilp),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_int_d

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_int_d(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_d(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_int_d

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_int_d(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_d(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_int_d
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_int_d(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_int_d

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_char_q(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        real(qp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_1D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_char_q(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        real(qp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_1D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_1D_char_q(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        real(qp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_char_q(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(qp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_2D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_char_q(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(qp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_2D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_2D_char_q(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        real(qp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_char_q(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(qp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_3D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_char_q(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(qp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_3D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_3D_char_q(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        real(qp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_char_q(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_4D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_char_q(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_4D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_4D_char_q(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_char_q(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_5D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_char_q(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_5D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_5D_char_q(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_char_q(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_6D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_char_q(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_6D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_6D_char_q(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_char_q(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_7D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_char_q(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_7D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_7D_char_q(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_char_q(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_8D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_char_q(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_8D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_8D_char_q(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_char_q(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_9D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_char_q(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_9D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_9D_char_q(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_char_q(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_10D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_char_q(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_10D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_10D_char_q(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_char_q(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_11D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_char_q(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_11D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_11D_char_q(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_char_q(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_12D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_char_q(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_12D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_12D_char_q(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_char_q(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_13D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_char_q(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_13D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_13D_char_q(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_char_q(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_14D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_char_q(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_14D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_14D_char_q(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_char_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_char_q(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_15D_char_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_char_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_char_q(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_15D_char_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_char_q
    
    ! Internal implementation
    pure subroutine norm_15D_char_q(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_char_q

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and char input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        character(len=*),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_char_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_char_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_char_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_char_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_char_q
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_char_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_char_q

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_int_q(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        real(qp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_1D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_int_q(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        real(qp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_1D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_1D_int_q(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        real(qp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_int_q(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(qp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_2D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_int_q(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        real(qp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_2D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_2D_int_q(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        real(qp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_int_q(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(qp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_3D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_int_q(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        real(qp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_3D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_3D_int_q(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        real(qp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_int_q(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_4D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_int_q(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_4D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_4D_int_q(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_int_q(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_5D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_int_q(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_5D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_5D_int_q(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_int_q(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_6D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_int_q(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_6D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_6D_int_q(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_int_q(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_7D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_int_q(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_7D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_7D_int_q(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_int_q(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_8D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_int_q(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_8D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_8D_int_q(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_int_q(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_9D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_int_q(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_9D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_9D_int_q(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_int_q(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_10D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_int_q(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_10D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_10D_int_q(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_int_q(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_11D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_int_q(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_11D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_11D_int_q(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_int_q(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_12D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_int_q(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_12D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_12D_int_q(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_int_q(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_13D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_int_q(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_13D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_13D_int_q(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_int_q(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_14D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_int_q(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_14D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_14D_int_q(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_int_q

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_int_q(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_15D_int_q(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_int_q
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_int_q(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_15D_int_q(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_int_q
    
    ! Internal implementation
    pure subroutine norm_15D_int_q(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        real(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(sum(a**2))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_int_q

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and int input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        integer(ilp),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_int_q

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_int_q(a,order,dim) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_q(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_int_q

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_int_q(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_q(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_int_q
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_int_q(a,nrm,order,dim,err)
        !> Input matrix a[..]
        real(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(sum(a**2,dim=dim))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_int_q

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_char_c(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        complex(sp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_1D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_char_c(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        complex(sp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_1D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_1D_char_c(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        complex(sp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_char_c(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(sp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_2D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_char_c(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(sp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_2D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_2D_char_c(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        complex(sp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_char_c(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(sp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_3D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_char_c(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(sp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_3D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_3D_char_c(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        complex(sp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_char_c(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_4D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_char_c(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_4D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_4D_char_c(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_char_c(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_5D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_char_c(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_5D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_5D_char_c(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_char_c(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_6D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_char_c(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_6D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_6D_char_c(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_char_c(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_7D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_char_c(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_7D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_7D_char_c(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_char_c(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_8D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_char_c(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_8D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_8D_char_c(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_char_c(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_9D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_char_c(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_9D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_9D_char_c(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_char_c(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_10D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_char_c(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_10D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_10D_char_c(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_char_c(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_11D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_char_c(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_11D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_11D_char_c(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_char_c(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_12D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_char_c(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_12D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_12D_char_c(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_char_c(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_13D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_char_c(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_13D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_13D_char_c(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_char_c(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_14D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_char_c(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_14D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_14D_char_c(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_char_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_char_c(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_15D_char_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_char_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_char_c(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_15D_char_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_char_c
    
    ! Internal implementation
    pure subroutine norm_15D_char_c(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_char_c

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and char input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        character(len=*),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_char_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_char_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_char_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_char_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_char_c
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_char_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_char_c

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_int_c(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        complex(sp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_1D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_int_c(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        complex(sp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_1D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_1D_int_c(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        complex(sp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_int_c(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(sp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_2D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_int_c(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(sp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_2D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_2D_int_c(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        complex(sp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_int_c(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(sp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_3D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_int_c(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(sp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_3D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_3D_int_c(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        complex(sp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_int_c(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_4D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_int_c(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_4D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_4D_int_c(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_int_c(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_5D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_int_c(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_5D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_5D_int_c(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_int_c(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_6D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_int_c(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_6D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_6D_int_c(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_int_c(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_7D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_int_c(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_7D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_7D_int_c(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_int_c(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_8D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_int_c(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_8D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_8D_int_c(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_int_c(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_9D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_int_c(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_9D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_9D_int_c(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_int_c(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_10D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_int_c(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_10D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_10D_int_c(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_int_c(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_11D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_int_c(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_11D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_11D_int_c(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_int_c(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_12D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_int_c(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_12D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_12D_int_c(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_int_c(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_13D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_int_c(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_13D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_13D_int_c(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_int_c(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_14D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_int_c(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_14D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_14D_int_c(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_int_c

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_int_c(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(sp) :: nrm
                                    
        call norm_15D_int_c(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_int_c
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_int_c(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm
                
        call norm_15D_int_c(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_int_c
    
    ! Internal implementation
    pure subroutine norm_15D_int_c(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(sp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),sp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_int_c

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and int input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        integer(ilp),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_int_c

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_int_c(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_c(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_int_c

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_int_c(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(sp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_c(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_int_c
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_int_c(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(sp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(sp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(sp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_sp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),sp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_sp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_int_c

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_char_z(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        complex(dp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_1D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_char_z(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        complex(dp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_1D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_1D_char_z(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        complex(dp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_char_z(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(dp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_2D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_char_z(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(dp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_2D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_2D_char_z(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        complex(dp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_char_z(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(dp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_3D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_char_z(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(dp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_3D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_3D_char_z(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        complex(dp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_char_z(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_4D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_char_z(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_4D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_4D_char_z(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_char_z(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_5D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_char_z(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_5D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_5D_char_z(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_char_z(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_6D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_char_z(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_6D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_6D_char_z(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_char_z(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_7D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_char_z(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_7D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_7D_char_z(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_char_z(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_8D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_char_z(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_8D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_8D_char_z(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_char_z(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_9D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_char_z(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_9D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_9D_char_z(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_char_z(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_10D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_char_z(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_10D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_10D_char_z(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_char_z(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_11D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_char_z(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_11D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_11D_char_z(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_char_z(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_12D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_char_z(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_12D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_12D_char_z(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_char_z(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_13D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_char_z(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_13D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_13D_char_z(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_char_z(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_14D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_char_z(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_14D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_14D_char_z(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_char_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_char_z(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_15D_char_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_char_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_char_z(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_15D_char_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_char_z
    
    ! Internal implementation
    pure subroutine norm_15D_char_z(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_char_z

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and char input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        character(len=*),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_char_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_char_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_char_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_char_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_char_z
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_char_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_char_z

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_int_z(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        complex(dp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_1D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_int_z(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        complex(dp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_1D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_1D_int_z(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        complex(dp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_int_z(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(dp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_2D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_int_z(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(dp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_2D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_2D_int_z(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        complex(dp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_int_z(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(dp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_3D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_int_z(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(dp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_3D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_3D_int_z(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        complex(dp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_int_z(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_4D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_int_z(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_4D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_4D_int_z(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_int_z(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_5D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_int_z(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_5D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_5D_int_z(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_int_z(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_6D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_int_z(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_6D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_6D_int_z(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_int_z(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_7D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_int_z(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_7D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_7D_int_z(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_int_z(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_8D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_int_z(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_8D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_8D_int_z(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_int_z(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_9D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_int_z(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_9D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_9D_int_z(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_int_z(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_10D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_int_z(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_10D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_10D_int_z(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_int_z(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_11D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_int_z(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_11D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_11D_int_z(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_int_z(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_12D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_int_z(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_12D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_12D_int_z(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_int_z(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_13D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_int_z(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_13D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_13D_int_z(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_int_z(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_14D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_int_z(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_14D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_14D_int_z(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_int_z

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_int_z(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(dp) :: nrm
                                    
        call norm_15D_int_z(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_int_z
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_int_z(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm
                
        call norm_15D_int_z(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_int_z
    
    ! Internal implementation
    pure subroutine norm_15D_int_z(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(dp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),dp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_int_z

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and int input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        integer(ilp),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_int_z

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_int_z(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_z(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_int_z

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_int_z(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(dp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_z(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_int_z
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_int_z(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(dp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(dp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(dp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_dp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),dp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_dp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_int_z

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_char_w(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        complex(qp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_1D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_char_w(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        complex(qp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_1D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_1D_char_w(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        complex(qp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_char_w(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(qp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_2D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_char_w(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(qp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_2D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_2D_char_w(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        complex(qp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_char_w(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(qp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_3D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_char_w(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(qp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_3D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_3D_char_w(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        complex(qp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_char_w(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_4D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_char_w(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_4D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_4D_char_w(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_char_w(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_5D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_char_w(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_5D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_5D_char_w(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_char_w(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_6D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_char_w(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_6D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_6D_char_w(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_char_w(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_7D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_char_w(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_7D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_7D_char_w(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_char_w(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_8D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_char_w(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_8D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_8D_char_w(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_char_w(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_9D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_char_w(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_9D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_9D_char_w(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_char_w(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_10D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_char_w(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_10D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_10D_char_w(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_char_w(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_11D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_char_w(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_11D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_11D_char_w(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_char_w(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_12D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_char_w(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_12D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_12D_char_w(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_char_w(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_13D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_char_w(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_13D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_13D_char_w(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_char_w(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_14D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_char_w(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_14D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_14D_char_w(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_char_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_char_w(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_15D_char_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_char_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_char_w(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_15D_char_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_char_w
    
    ! Internal implementation
    pure subroutine norm_15D_char_w(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_char_w

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and char input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        character(len=*),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_char_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_char_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_char_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_char_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_char_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_char_w
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_char_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        character(len=*),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_char_w

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_1D_order_int_w(a,order) result(nrm)
        !> Input 1-d matrix a(:)
        complex(qp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_1D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_1D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_1D_order_err_int_w(a,order,err) result(nrm)
        !> Input 1-d matrix a(:)
        complex(qp),intent(in) :: a(:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_1D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_1D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_1D_int_w(a,nrm,order,err)
        !> Input 1-d matrix a(:)
        complex(qp),intent(in) :: a(:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_1D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_2D_order_int_w(a,order) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(qp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_2D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_2D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_2D_order_err_int_w(a,order,err) result(nrm)
        !> Input 2-d matrix a(:,:)
        complex(qp),intent(in) :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_2D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_2D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_2D_int_w(a,nrm,order,err)
        !> Input 2-d matrix a(:,:)
        complex(qp),intent(in) :: a(:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_3D_order_int_w(a,order) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(qp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_3D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_3D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_3D_order_err_int_w(a,order,err) result(nrm)
        !> Input 3-d matrix a(:,:,:)
        complex(qp),intent(in) :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_3D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_3D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_3D_int_w(a,nrm,order,err)
        !> Input 3-d matrix a(:,:,:)
        complex(qp),intent(in) :: a(:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_4D_order_int_w(a,order) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_4D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_4D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_4D_order_err_int_w(a,order,err) result(nrm)
        !> Input 4-d matrix a(:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_4D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_4D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_4D_int_w(a,nrm,order,err)
        !> Input 4-d matrix a(:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_5D_order_int_w(a,order) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_5D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_5D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_5D_order_err_int_w(a,order,err) result(nrm)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_5D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_5D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_5D_int_w(a,nrm,order,err)
        !> Input 5-d matrix a(:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_6D_order_int_w(a,order) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_6D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_6D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_6D_order_err_int_w(a,order,err) result(nrm)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_6D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_6D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_6D_int_w(a,nrm,order,err)
        !> Input 6-d matrix a(:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_7D_order_int_w(a,order) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_7D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_7D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_7D_order_err_int_w(a,order,err) result(nrm)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_7D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_7D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_7D_int_w(a,nrm,order,err)
        !> Input 7-d matrix a(:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_8D_order_int_w(a,order) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_8D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_8D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_8D_order_err_int_w(a,order,err) result(nrm)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_8D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_8D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_8D_int_w(a,nrm,order,err)
        !> Input 8-d matrix a(:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_9D_order_int_w(a,order) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_9D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_9D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_9D_order_err_int_w(a,order,err) result(nrm)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_9D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_9D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_9D_int_w(a,nrm,order,err)
        !> Input 9-d matrix a(:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_10D_order_int_w(a,order) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_10D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_10D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_10D_order_err_int_w(a,order,err) result(nrm)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_10D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_10D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_10D_int_w(a,nrm,order,err)
        !> Input 10-d matrix a(:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_11D_order_int_w(a,order) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_11D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_11D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_11D_order_err_int_w(a,order,err) result(nrm)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_11D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_11D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_11D_int_w(a,nrm,order,err)
        !> Input 11-d matrix a(:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_12D_order_int_w(a,order) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_12D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_12D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_12D_order_err_int_w(a,order,err) result(nrm)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_12D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_12D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_12D_int_w(a,nrm,order,err)
        !> Input 12-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_13D_order_int_w(a,order) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_13D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_13D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_13D_order_err_int_w(a,order,err) result(nrm)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_13D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_13D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_13D_int_w(a,nrm,order,err)
        !> Input 13-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_14D_order_int_w(a,order) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_14D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_14D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_14D_order_err_int_w(a,order,err) result(nrm)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_14D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_14D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_14D_int_w(a,nrm,order,err)
        !> Input 14-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_int_w

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_15D_order_int_w(a,order) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Norm of the matrix.
        real(qp) :: nrm
                                    
        call norm_15D_int_w(a,nrm=nrm,order=order)
        
    end function stdlib_linalg_norm_15D_order_int_w
    
    ! Function interface with output error
    function stdlib_linalg_norm_15D_order_err_int_w(a,order,err) result(nrm)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm
                
        call norm_15D_int_w(a,nrm=nrm,order=order,err=err)
        
    end function stdlib_linalg_norm_15D_order_err_int_w
    
    ! Internal implementation
    pure subroutine norm_15D_int_w(a,nrm,order,err)
        !> Input 15-d matrix a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        complex(qp),intent(in) :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        ! Check matrix size
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a))
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a)),qp))
            case (NORM_INF)
                nrm = maxval(abs(a))
            case (-NORM_INF)
                nrm = minval(abs(a))
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_int_w

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and int input
    !====================================================================

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_2D_to_1D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_2D_to_1D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_2D_to_1D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        
        call norm_2D_to_1D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_2D_to_1D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_2D_to_1D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 2) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_2D_to_1D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_3D_to_2D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_3D_to_2D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_3D_to_2D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        
        call norm_3D_to_2D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_3D_to_2D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_3D_to_2D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 3) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_3D_to_2D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_4D_to_3D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_4D_to_3D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_4D_to_3D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim))
        
        call norm_4D_to_3D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_4D_to_3D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_4D_to_3D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 4) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_4D_to_3D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_5D_to_4D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_5D_to_4D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_5D_to_4D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        
        call norm_5D_to_4D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_5D_to_4D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_5D_to_4D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 5) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_5D_to_4D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_6D_to_5D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_6D_to_5D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_6D_to_5D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim))
        
        call norm_6D_to_5D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_6D_to_5D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_6D_to_5D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 6) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_6D_to_5D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_7D_to_6D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_7D_to_6D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_7D_to_6D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim))
        
        call norm_7D_to_6D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_7D_to_6D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_7D_to_6D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 7) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_7D_to_6D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_8D_to_7D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_8D_to_7D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_8D_to_7D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        
        call norm_8D_to_7D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_8D_to_7D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_8D_to_7D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 8) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_8D_to_7D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_9D_to_8D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_9D_to_8D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_9D_to_8D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim))
        
        call norm_9D_to_8D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_9D_to_8D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_9D_to_8D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 9) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_9D_to_8D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_10D_to_9D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_10D_to_9D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_10D_to_9D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        
        call norm_10D_to_9D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_10D_to_9D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_10D_to_9D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 10) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_10D_to_9D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_11D_to_10D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_11D_to_10D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_11D_to_10D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))
        
        call norm_11D_to_10D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_11D_to_10D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_11D_to_10D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim))  &
            &
        integer(ilp),intent(in) :: order
!> Order of the matrix norm being computed.
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 11) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_11D_to_10D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_12D_to_11D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_12D_to_11D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_12D_to_11D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim))
        
        call norm_12D_to_11D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_12D_to_11D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_12D_to_11D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 12) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_12D_to_11D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_13D_to_12D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_13D_to_12D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_13D_to_12D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        
        call norm_13D_to_12D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_13D_to_12D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_13D_to_12D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 13) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_13D_to_12D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_14D_to_13D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_14D_to_13D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_14D_to_13D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim))
        
        call norm_14D_to_13D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_14D_to_13D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_14D_to_13D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 14) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_14D_to_13D_int_w

    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_15D_to_14D_int_w(a,order,dim) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_w(a,nrm,order,dim)
            
    end function stdlib_linalg_norm_15D_to_14D_int_w

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_15D_to_14D_err_int_w(a,order,dim,err) result(nrm)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp),intent(in) :: dim
        !> Output state return flag.
        type(linalg_state),intent(out) :: err
        !> Norm of the matrix.
        real(qp) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),merge(size(a,3),&
            & size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),mask=5 < dim),&
            & merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),size(a,9),&
            & mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),merge(size(a,&
            & 11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),size(a,14),&
            & mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        
        call norm_15D_to_14D_int_w(a,nrm,order,dim,err)
            
    end function stdlib_linalg_norm_15D_to_14D_err_int_w
    
    ! Internal implementation
    pure subroutine norm_15D_to_14D_int_w(a,nrm,order,dim,err)
        !> Input matrix a[..]
        complex(qp),intent(in),target :: a(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:)
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp),intent(in) :: dim
        !> Norm of the matrix.
        real(qp),intent(out) :: nrm(merge(size(a,1),size(a,2),mask=1 < dim),merge(size(a,2),size(a,3),mask=2 < dim),&
            & merge(size(a,3),size(a,4),mask=3 < dim),merge(size(a,4),size(a,5),mask=4 < dim),merge(size(a,5),size(a,6),&
            & mask=5 < dim),merge(size(a,6),size(a,7),mask=6 < dim),merge(size(a,7),size(a,8),mask=7 < dim),merge(size(a,8),&
            & size(a,9),mask=8 < dim),merge(size(a,9),size(a,10),mask=9 < dim),merge(size(a,10),size(a,11),mask=10 < dim),&
            & merge(size(a,11),size(a,12),mask=11 < dim),merge(size(a,12),size(a,13),mask=12 < dim),merge(size(a,13),&
            & size(a,14),mask=13 < dim),merge(size(a,14),size(a,15),mask=14 < dim))
        !> Order of the matrix norm being computed.
        integer(ilp),intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state),intent(out),optional :: err
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(qp) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_qp
        
        if (sze <= 0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim < 1 .or. dim > 15) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then
            call linalg_error_handling(err_,err)
            return
        end if
        
        select case (norm_request)
            case (NORM_ONE)
                nrm = sum(abs(a),dim=dim)
            case (NORM_TWO)
                nrm = sqrt(real(sum(a*conjg(a),dim=dim),qp))
            case (NORM_INF)
                nrm = maxval(abs(a),dim=dim)
            case (-NORM_INF)
                nrm = minval(abs(a),dim=dim)
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_qp/norm_request
                nrm = sum(abs(a)**norm_request,dim=dim)**rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_15D_to_14D_int_w

end module stdlib_linalg_norms
