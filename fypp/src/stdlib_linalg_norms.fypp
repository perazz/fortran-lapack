#:include "common.fypp"
#:set RANKS = range(1, MAXRANK + 1)
#:set INPUT_TYPE    = ["character(len=*)","integer(ilp)"]
#:set INPUT_SHORT   = ["char","int"]
#:set INPUT_OPTIONS = list(zip(INPUT_TYPE,INPUT_SHORT))
! Vector norms
module stdlib_linalg_norms
     use stdlib_linalg_constants
     use stdlib_linalg_blas, only: nrm2
     use stdlib_linalg_lapack, only: lange
     use stdlib_linalg_state
     use iso_fortran_env,only:real32,real64,real128,int8,int16,int32,int64,stderr => error_unit
     implicit none(type,external)
     private
     
     public :: norm, measure

     character(*), parameter :: this = 'norm'
     
     !> List of internal norm flags
     integer(ilp), parameter :: NORM_ONE       = 1_ilp 
     integer(ilp), parameter :: NORM_TWO       = 2_ilp
     integer(ilp), parameter :: NORM_POW_FIRST = 3_ilp       
     integer(ilp), parameter :: NORM_INF      = +huge(0_ilp) ! infinity norm 
     integer(ilp), parameter :: NORM_POW_LAST  = NORM_INF - 1_ilp
     integer(ilp), parameter :: NORM_MINUSINF = -huge(0_ilp)
     
     !> Vector norm: function interface
     interface norm
        #:for rk,rt,ri in ALL_KINDS_TYPES
        #:for it,ii in INPUT_OPTIONS
        !> Scalar norms: ${rt}$
        #:for rank in RANKS        
        module procedure stdlib_linalg_norm_${rank}$D_order_${ii}$_${ri}$         
        module procedure stdlib_linalg_norm_${rank}$D_order_err_${ii}$_${ri}$         
        #:endfor
        !> Array norms: ${rt}$
        #:for rank in range(2, MAXRANK + 1)
        module procedure stdlib_linalg_norm_${rank}$D_to_${rank-1}$D_${ii}$_${ri}$
        module procedure stdlib_linalg_norm_${rank}$D_to_${rank-1}$D_err_${ii}$_${ri}$
        #:endfor
        #:endfor        
        #:endfor
     end interface norm
     
     !> Vector norm: subroutine interface
     interface measure
        #:for rk,rt,ri in ALL_KINDS_TYPES
        #:for it,ii in INPUT_OPTIONS
            !> Scalar norms: ${rt}$
            #:for rank in RANKS                    
            module procedure norm_${rank}$D_${ii}$_${ri}$
            #:endfor
            !> Array norms: ${rt}$
            #:for rank in range(2, MAXRANK + 1)
            module procedure norm_${rank}$D_to_${rank-1}$D_${ii}$_${ri}$
            #:endfor
        #:endfor
        #:endfor
     end interface measure
     
     interface parse_norm_type
        module procedure parse_norm_type_integer
        module procedure parse_norm_type_character
     end interface parse_norm_type
     
     contains
     
     !> Parse norm type from an integer user input
     pure subroutine parse_norm_type_integer(order,norm_type,err)
        !> User input value
        integer(ilp), intent(in) :: order
        !> Return value: norm type
        integer(ilp), intent(out) :: norm_type
        !> State return flag
        type(linalg_state), intent(out) :: err
        
        select case (order)
           case (1_ilp)
               norm_type = NORM_ONE
           case (2_ilp)
               norm_type = NORM_TWO
           case (3_ilp:huge(0_ilp)-1_ilp)
               norm_type = order
           case (huge(0_ilp):)
               norm_type = NORM_INF
           case (:-huge(0_ilp))
               norm_type = NORM_MINUSINF
           
           case default
               norm_type = NORM_ONE
               err = linalg_state(this,LINALG_ERROR,'Input norm type ',order,' is not recognized.')
        end select    
        
     end subroutine parse_norm_type_integer

     pure subroutine parse_norm_type_character(order,norm_type,err)
        !> User input value
        character(len=*), intent(in) :: order
        !> Return value: norm type
        integer(ilp), intent(out) :: norm_type
        !> State return flag
        type(linalg_state), intent(out) :: err
        
        integer(ilp) :: int_order,read_err
        
        select case (order)
           case ('inf','Inf','INF')
              norm_type = NORM_INF
           case ('-inf','-Inf','-INF')
              norm_type = NORM_MINUSINF
           case ('Euclidean','euclidean','EUCLIDEAN')
              norm_type = NORM_TWO
           case default
            
              ! Check if this input can be read as an integer
              read(order,*,iostat=read_err) int_order
              if (read_err/=0) then 
                 ! Cannot read as an integer
                 norm_type = NORM_ONE
                 err = linalg_state(this,LINALG_ERROR,'Input norm type ',order,' is not recognized.')                 
              else
                 call parse_norm_type_integer(int_order,norm_type,err)
              endif  

        end select    
        
     end subroutine parse_norm_type_character

    #:for rk,rt,ri in ALL_KINDS_TYPES
    #:for it,ii in INPUT_OPTIONS

    !==============================================
    ! Norms : any rank to scalar
    !==============================================

    #:for rank in RANKS

    ! Pure function interface, with order specification. On error, the code will stop
    pure function stdlib_linalg_norm_${rank}$D_order_${ii}$_${ri}$(a, order) result(nrm)
        !> Input ${rank}$-d matrix a${ranksuffix(rank)}$
        ${rt}$, intent(in) :: a${ranksuffix(rank)}$
        !> Order of the matrix norm being computed.
        ${it}$, intent(in) :: order
        !> Norm of the matrix.
        ${rt}$ :: nrm
                                    
        call norm_${rank}$D_${ii}$_${ri}$(a, nrm=nrm, order=order)
        
    end function stdlib_linalg_norm_${rank}$D_order_${ii}$_${ri}$
    
    ! Function interface with output error
    function stdlib_linalg_norm_${rank}$D_order_err_${ii}$_${ri}$(a, order, err) result(nrm)
        !> Input ${rank}$-d matrix a${ranksuffix(rank)}$
        ${rt}$, intent(in) :: a${ranksuffix(rank)}$
        !> Order of the matrix norm being computed.
        ${it}$, intent(in) :: order
        !> Output state return flag. 
        type(linalg_state), intent(out) :: err                         
        !> Norm of the matrix.
        ${rt}$ :: nrm                 
                
        call norm_${rank}$D_${ii}$_${ri}$(a, nrm=nrm, order=order, err=err)
        
    end function stdlib_linalg_norm_${rank}$D_order_err_${ii}$_${ri}$
    
    ! Internal implementation
    pure subroutine norm_${rank}$D_${ii}$_${ri}$(a, nrm, order, err)
        !> Input ${rank}$-d matrix a${ranksuffix(rank)}$
        ${rt}$, intent(in) :: a${ranksuffix(rank)}$
        !> Norm of the matrix.
        ${rt}$, intent(out) :: nrm
        !> Order of the matrix norm being computed.
        ${it}$, intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state), intent(out), optional :: err         
        
        type(linalg_state) :: err_
        
        integer(ilp) :: sze,norm_request
        real(${rk}$) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_${rk}$
        
        ! Check matrix size
        if (sze<=0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then 
            call linalg_error_handling(err_,err)
            return
        endif          
        
        select case(norm_request)
            case(NORM_ONE)
                nrm = sum( abs(a) )
            case(NORM_TWO)            
                #:if rt.startswith('complex')
                nrm = sqrt( sum( a * conjg(a) ) )
                #:else
                nrm = sqrt( sum( a ** 2 ) )
                #:endif             
            case(NORM_INF)
                nrm = maxval( abs(a) )
            case(-NORM_INF)
                nrm = minval( abs(a) )
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_${rk}$ / norm_request
                nrm = sum( abs(a) ** norm_request ) ** rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)
        end select
        
    end subroutine norm_${rank}$D_${ii}$_${ri}$

    #:endfor

    !====================================================================
    ! Norms : any rank to rank-1, with DIM specifier and ${ii}$ input
    !====================================================================

    #:for rank in range(2, MAXRANK + 1)
    
    ! Pure function interface with DIM specifier. On error, the code will stop
    pure function stdlib_linalg_norm_${rank}$D_to_${rank-1}$D_${ii}$_${ri}$(a, order, dim) result(nrm)
        !> Input matrix a[..]
        ${rt}$, intent(in), target :: a${ranksuffix(rank)}$
        !> Order of the matrix norm being computed.
        ${it}$, intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp), intent(in) :: dim
        !> Norm of the matrix.
        ${rt}$ :: nrm${reduced_shape('a', rank, 'dim')}$     
        
        call norm_${rank}$D_to_${rank-1}$D_${ii}$_${ri}$(a, nrm, order, dim)
            
    end function stdlib_linalg_norm_${rank}$D_to_${rank-1}$D_${ii}$_${ri}$

    ! Function interface with DIM specifier and output error state.
    function stdlib_linalg_norm_${rank}$D_to_${rank-1}$D_err_${ii}$_${ri}$(a, order, dim, err) result(nrm)
        !> Input matrix a[..]
        ${rt}$, intent(in), target :: a${ranksuffix(rank)}$
        !> Order of the matrix norm being computed.
        ${it}$, intent(in) :: order
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        integer(ilp), intent(in) :: dim
        !> Output state return flag. 
        type(linalg_state), intent(out) :: err                                 
        !> Norm of the matrix.
        ${rt}$ :: nrm${reduced_shape('a', rank, 'dim')}$     
        
        call norm_${rank}$D_to_${rank-1}$D_${ii}$_${ri}$(a, nrm, order, dim, err)
            
    end function stdlib_linalg_norm_${rank}$D_to_${rank-1}$D_err_${ii}$_${ri}$
    
    ! Internal implementation 
    pure subroutine norm_${rank}$D_to_${rank-1}$D_${ii}$_${ri}$(a, nrm, order, dim, err)
        !> Input matrix a[..]
        ${rt}$, intent(in), target :: a${ranksuffix(rank)}$
        !> Dimension to collapse by computing the norm w.r.t other dimensions
        !  (dim must be defined before it is used for `nrm`)
        integer(ilp), intent(in) :: dim        
        !> Norm of the matrix.        
        ${rt}$, intent(out) :: nrm${reduced_shape('a', rank, 'dim')}$     
        !> Order of the matrix norm being computed.
        ${it}$, intent(in) :: order
        !> [optional] state return flag. On error if not requested, the code will stop
        type(linalg_state), intent(out), optional :: err           
        
        type(linalg_state) :: err_
        integer(ilp) :: sze,norm_request
        real(${rk}$) :: rorder
        
        sze = size(a,kind=ilp)
        
        ! Initialize norm to zero
        nrm = 0.0_${rk}$
        
        if (sze<=0) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix shape: a=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if

        ! Check dimension choice
        if (dim<1 .or. dim>${rank}$) then
            err_ = linalg_state(this,LINALG_VALUE_ERROR,'dimension ',dim, &
                                'is out of rank for shape(a)=',shape(a,kind=ilp))
            call linalg_error_handling(err_,err)
            return
        end if
        
        ! Check norm request
        call parse_norm_type(order,norm_request,err_)
        if (err_%error()) then 
            call linalg_error_handling(err_,err)
            return
        endif                   
        
        select case(norm_request)            
            case(NORM_ONE)
                nrm = sum( abs(a) , dim = dim )                
            case(NORM_TWO)                
                #:if rt.startswith('complex')
                nrm = sqrt( sum( a * conjg(a) , dim = dim ) )
                #:else
                nrm = sqrt( sum( a ** 2 , dim = dim ) )
                #:endif
            case(NORM_INF)
                nrm = maxval( abs(a) , dim = dim )
            case(-NORM_INF)
                nrm = minval( abs(a) , dim = dim )
            case (NORM_POW_FIRST:NORM_POW_LAST)
                rorder = 1.0_${rk}$ / norm_request
                nrm = sum( abs(a) ** norm_request , dim = dim ) ** rorder
            case default
                err_ = linalg_state(this,LINALG_INTERNAL_ERROR,'invalid norm type after checking')
                call linalg_error_handling(err_,err)            
        end select
        
    end subroutine norm_${rank}$D_to_${rank-1}$D_${ii}$_${ri}$

    #:endfor
    #:endfor
    #:endfor

end module stdlib_linalg_norms
