module la_lapack
     use la_constants
     use la_blas
     use la_lapack_aux
     use la_lapack_s
     use la_lapack_d
     use la_lapack_q
     use la_lapack_c
     use la_lapack_z
     use la_lapack_w
     implicit none(type,external)
     public

          !> BBCSD: computes the CS decomposition of a unitary matrix in
          !> bidiagonal-block form,
          !>     [ B11 | B12 0  0 ]
          !>     [  0  |  0 -I  0 ]
          !> X = [----------------]
          !>     [ B21 | B22 0  0 ]
          !>     [  0  |  0  0  I ]
          !>     [  C  | -S  0  0 ]
          !>   [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**H
          !> = [---------] [---------------] [---------]   .
          !>   [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
          !>   [  0 |  0  0  I ]
          !> X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
          !> than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
          !> transposed and/or permuted. This can be done in constant time using
          !> the TRANS and SIGNS options. See CUNCSD for details.)
          !> The bidiagonal matrices B11, B12, B21, and B22 are represented
          !> implicitly by angles THETA(1:Q) and PHI(1:Q-1).
          !> The unitary matrices U1, U2, V1T, and V2T are input/output.
          !> The input matrices are pre- or post-multiplied by the appropriate
          !> singular vector matrices.
          interface bbcsd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cbbcsd(jobu1,jobu2,jobv1t,jobv2t,trans,m,p,q,theta,phi, &
               u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,b11d,b11e,b12d,b12e,b21d,b21e,b22d, &
                          b22e,rwork,lrwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(sp),intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),b22d( &
                              *),b22e(*),rwork(*)
                    real(sp),intent(inout) :: phi(*),theta(*)
                    complex(sp),intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)
                              
               end subroutine cbbcsd
#else
               module procedure la_cbbcsd
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dbbcsd(jobu1,jobu2,jobv1t,jobv2t,trans,m,p,q,theta,phi, &
               u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,b11d,b11e,b12d,b12e,b21d,b21e,b22d, &
                          b22e,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lwork,m,p,q
                    real(dp),intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),b22d( &
                              *),b22e(*),work(*)
                    real(dp),intent(inout) :: phi(*),theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*), &
                              v2t(ldv2t,*)
               end subroutine dbbcsd
#else
               module procedure la_dbbcsd
#endif
               module procedure la_qbbcsd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sbbcsd(jobu1,jobu2,jobv1t,jobv2t,trans,m,p,q,theta,phi, &
               u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,b11d,b11e,b12d,b12e,b21d,b21e,b22d, &
                          b22e,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lwork,m,p,q
                    real(sp),intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),b22d( &
                              *),b22e(*),work(*)
                    real(sp),intent(inout) :: phi(*),theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*), &
                              v2t(ldv2t,*)
               end subroutine sbbcsd
#else
               module procedure la_sbbcsd
#endif
               module procedure la_wbbcsd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zbbcsd(jobu1,jobu2,jobv1t,jobv2t,trans,m,p,q,theta,phi, &
               u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,b11d,b11e,b12d,b12e,b21d,b21e,b22d, &
                          b22e,rwork,lrwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(dp),intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),b22d( &
                              *),b22e(*),rwork(*)
                    real(dp),intent(inout) :: phi(*),theta(*)
                    complex(dp),intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)
                              
               end subroutine zbbcsd
#else
               module procedure la_zbbcsd
#endif
          end interface bbcsd

          !> BDSDC: computes the singular value decomposition (SVD) of a real
          !> N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
          !> using a divide and conquer method, where S is a diagonal matrix
          !> with non-negative diagonal elements (the singular values of B), and
          !> U and VT are orthogonal matrices of left and right singular vectors,
          !> respectively. BDSDC can be used to compute all singular values,
          !> and optionally, singular vectors or singular vectors in compact form.
          !> This code makes very mild assumptions about floating point
          !> arithmetic. It will work on machines with a guard digit in
          !> add/subtract, or on those binary machines without guard digits
          !> which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
          !> It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.  See DLASD3 for details.
          !> The code currently calls DLASDQ if singular values only are desired.
          !> However, it can be slightly modified to compute singular values
          !> using the divide and conquer method.
          interface bdsdc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dbdsdc(uplo,compq,n,d,e,u,ldu,vt,ldvt,q,iq,work,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,uplo
                    integer(ilp),intent(out) :: info,iq(*),iwork(*)
                    integer(ilp),intent(in) :: ldu,ldvt,n
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: q(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dbdsdc
#else
               module procedure la_dbdsdc
#endif
               module procedure la_qbdsdc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sbdsdc(uplo,compq,n,d,e,u,ldu,vt,ldvt,q,iq,work,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,uplo
                    integer(ilp),intent(out) :: info,iq(*),iwork(*)
                    integer(ilp),intent(in) :: ldu,ldvt,n
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: q(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sbdsdc
#else
               module procedure la_sbdsdc
#endif
          end interface bdsdc

          !> BDSQR: computes the singular values and, optionally, the right and/or
          !> left singular vectors from the singular value decomposition (SVD) of
          !> a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
          !> zero-shift QR algorithm.  The SVD of B has the form
          !> B = Q * S * P**H
          !> where S is the diagonal matrix of singular values, Q is an orthogonal
          !> matrix of left singular vectors, and P is an orthogonal matrix of
          !> right singular vectors.  If left singular vectors are requested, this
          !> subroutine actually returns U*Q instead of Q, and, if right singular
          !> vectors are requested, this subroutine returns P**H*VT instead of
          !> P**H, for given complex input matrices U and VT.  When U and VT are
          !> the unitary matrices that reduce a general matrix A to bidiagonal
          !> form: A = U*B*VT, as computed by CGEBRD, then
          !> A = (U*Q) * S * (P**H*VT)
          !> is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
          !> for a given complex input matrix C.
          !> See "Computing  Small Singular Values of Bidiagonal Matrices With
          !> Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
          !> LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
          !> no. 5, pp. 873-912, Sept 1990) and
          !> "Accurate singular values and differential qd algorithms," by
          !> B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
          !> Department, University of California at Berkeley, July 1992
          !> for a detailed description of the algorithm.
          interface bdsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cbdsqr(uplo,n,ncvt,nru,ncc,d,e,vt,ldvt,u,ldu,c,ldc, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: c(ldc,*),u(ldu,*),vt(ldvt,*)
               end subroutine cbdsqr
#else
               module procedure la_cbdsqr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dbdsqr(uplo,n,ncvt,nru,ncc,d,e,vt,ldvt,u,ldu,c,ldc, &
                         work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(dp),intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dbdsqr
#else
               module procedure la_dbdsqr
#endif
               module procedure la_qbdsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sbdsqr(uplo,n,ncvt,nru,ncc,d,e,vt,ldvt,u,ldu,c,ldc, &
                         work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(sp),intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sbdsqr
#else
               module procedure la_sbdsqr
#endif
               module procedure la_wbdsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zbdsqr(uplo,n,ncvt,nru,ncc,d,e,vt,ldvt,u,ldu,c,ldc, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: c(ldc,*),u(ldu,*),vt(ldvt,*)
               end subroutine zbdsqr
#else
               module procedure la_zbdsqr
#endif
          end interface bdsqr

          !> DISNA: computes the reciprocal condition numbers for the eigenvectors
          !> of a real symmetric or complex Hermitian matrix or for the left or
          !> right singular vectors of a general m-by-n matrix. The reciprocal
          !> condition number is the 'gap' between the corresponding eigenvalue or
          !> singular value and the nearest other one.
          !> The bound on the error, measured by angle in radians, in the I-th
          !> computed vector is given by
          !> DLAMCH( 'E' ) * ( ANORM / SEP( I ) )
          !> where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
          !> to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
          !> the error bound.
          !> DISNA may also be used to compute error bounds for eigenvectors of
          !> the generalized symmetric definite eigenproblem.
          interface disna
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ddisna(job,m,n,d,sep,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: m,n
                    real(dp),intent(in) :: d(*)
                    real(dp),intent(out) :: sep(*)
               end subroutine ddisna
#else
               module procedure la_ddisna
#endif
               module procedure la_qdisna
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sdisna(job,m,n,d,sep,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: m,n
                    real(sp),intent(in) :: d(*)
                    real(sp),intent(out) :: sep(*)
               end subroutine sdisna
#else
               module procedure la_sdisna
#endif
          end interface disna

          !> GBBRD: reduces a complex general m-by-n band matrix A to real upper
          !> bidiagonal form B by a unitary transformation: Q**H * A * P = B.
          !> The routine computes B, and optionally forms Q or P**H, or computes
          !> Q**H*C for a given matrix C.
          interface gbbrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgbbrd(vect,m,n,ncc,kl,ku,ab,ldab,d,e,q,ldq,pt,ldpt, &
                         c,ldc,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(sp),intent(out) :: d(*),e(*),rwork(*)
                    complex(sp),intent(inout) :: ab(ldab,*),c(ldc,*)
                    complex(sp),intent(out) :: pt(ldpt,*),q(ldq,*),work(*)
               end subroutine cgbbrd
#else
               module procedure la_cgbbrd
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgbbrd(vect,m,n,ncc,kl,ku,ab,ldab,d,e,q,ldq,pt,ldpt, &
                         c,ldc,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(dp),intent(inout) :: ab(ldab,*),c(ldc,*)
                    real(dp),intent(out) :: d(*),e(*),pt(ldpt,*),q(ldq,*),work(*)
               end subroutine dgbbrd
#else
               module procedure la_dgbbrd
#endif
               module procedure la_qgbbrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgbbrd(vect,m,n,ncc,kl,ku,ab,ldab,d,e,q,ldq,pt,ldpt, &
                         c,ldc,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(sp),intent(inout) :: ab(ldab,*),c(ldc,*)
                    real(sp),intent(out) :: d(*),e(*),pt(ldpt,*),q(ldq,*),work(*)
               end subroutine sgbbrd
#else
               module procedure la_sgbbrd
#endif
               module procedure la_wgbbrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgbbrd(vect,m,n,ncc,kl,ku,ab,ldab,d,e,q,ldq,pt,ldpt, &
                         c,ldc,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(dp),intent(out) :: d(*),e(*),rwork(*)
                    complex(dp),intent(inout) :: ab(ldab,*),c(ldc,*)
                    complex(dp),intent(out) :: pt(ldpt,*),q(ldq,*),work(*)
               end subroutine zgbbrd
#else
               module procedure la_zgbbrd
#endif
          end interface gbbrd

          !> GBCON: estimates the reciprocal of the condition number of a complex
          !> general band matrix A, in either the 1-norm or the infinity-norm,
          !> using the LU factorization computed by CGBTRF.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as
          !> RCOND = 1 / ( norm(A) * norm(inv(A)) ).
          interface gbcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgbcon(norm,n,kl,ku,ab,ldab,ipiv,anorm,rcond,work,rwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond,rwork(*)
                    complex(sp),intent(in) :: ab(ldab,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgbcon
#else
               module procedure la_cgbcon
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgbcon(norm,n,kl,ku,ab,ldab,ipiv,anorm,rcond,work,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(dp),intent(in) :: anorm,ab(ldab,*)
                    real(dp),intent(out) :: rcond,work(*)
               end subroutine dgbcon
#else
               module procedure la_dgbcon
#endif
               module procedure la_qgbcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgbcon(norm,n,kl,ku,ab,ldab,ipiv,anorm,rcond,work,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(sp),intent(in) :: anorm,ab(ldab,*)
                    real(sp),intent(out) :: rcond,work(*)
               end subroutine sgbcon
#else
               module procedure la_sgbcon
#endif
               module procedure la_wgbcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgbcon(norm,n,kl,ku,ab,ldab,ipiv,anorm,rcond,work,rwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond,rwork(*)
                    complex(dp),intent(in) :: ab(ldab,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgbcon
#else
               module procedure la_zgbcon
#endif
          end interface gbcon

          !> GBEQU: computes row and column scalings intended to equilibrate an
          !> M-by-N band matrix A and reduce its condition number.  R returns the
          !> row scale factors and C the column scale factors, chosen to try to
          !> make the largest element in each row and column of the matrix B with
          !> elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
          !> R(i) and C(j) are restricted to be between SMLNUM = smallest safe
          !> number and BIGNUM = largest safe number.  Use of these scaling
          !> factors is not guaranteed to reduce the condition number of A but
          !> works well in practice.
          interface gbequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgbequ(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(sp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp),intent(in) :: ab(ldab,*)
               end subroutine cgbequ
#else
               module procedure la_cgbequ
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgbequ(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(dp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp),intent(in) :: ab(ldab,*)
               end subroutine dgbequ
#else
               module procedure la_dgbequ
#endif
               module procedure la_qgbequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgbequ(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(sp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp),intent(in) :: ab(ldab,*)
               end subroutine sgbequ
#else
               module procedure la_sgbequ
#endif
               module procedure la_wgbequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgbequ(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(dp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp),intent(in) :: ab(ldab,*)
               end subroutine zgbequ
#else
               module procedure la_zgbequ
#endif
          end interface gbequ

          !> GBEQUB: computes row and column scalings intended to equilibrate an
          !> M-by-N matrix A and reduce its condition number.  R returns the row
          !> scale factors and C the column scale factors, chosen to try to make
          !> the largest element in each row and column of the matrix B with
          !> elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
          !> the radix.
          !> R(i) and C(j) are restricted to be a power of the radix between
          !> SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
          !> of these scaling factors is not guaranteed to reduce the condition
          !> number of A but works well in practice.
          !> This routine differs from CGEEQU by restricting the scaling factors
          !> to a power of the radix.  Barring over- and underflow, scaling by
          !> these factors introduces no additional rounding errors.  However, the
          !> scaled entries' magnitudes are no longer approximately 1 but lie
          !> between sqrt(radix) and 1/sqrt(radix).
          interface gbequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgbequb(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(sp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp),intent(in) :: ab(ldab,*)
               end subroutine cgbequb
#else
               module procedure la_cgbequb
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgbequb(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(dp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp),intent(in) :: ab(ldab,*)
               end subroutine dgbequb
#else
               module procedure la_dgbequb
#endif
               module procedure la_qgbequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgbequb(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(sp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp),intent(in) :: ab(ldab,*)
               end subroutine sgbequb
#else
               module procedure la_sgbequb
#endif
               module procedure la_wgbequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgbequb(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(dp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp),intent(in) :: ab(ldab,*)
               end subroutine zgbequb
#else
               module procedure la_zgbequb
#endif
          end interface gbequb

          !> GBRFS: improves the computed solution to a system of linear
          !> equations when the coefficient matrix is banded, and provides
          !> error bounds and backward error estimates for the solution.
          interface gbrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgbrfs(trans,n,kl,ku,nrhs,ab,ldab,afb,ldafb,ipiv,b,ldb, &
                         x,ldx,ferr,berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine cgbrfs
#else
               module procedure la_cgbrfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgbrfs(trans,n,kl,ku,nrhs,ab,ldab,afb,ldafb,ipiv,b,ldb, &
                         x,ldx,ferr,berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dgbrfs
#else
               module procedure la_dgbrfs
#endif
               module procedure la_qgbrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgbrfs(trans,n,kl,ku,nrhs,ab,ldab,afb,ldafb,ipiv,b,ldb, &
                         x,ldx,ferr,berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine sgbrfs
#else
               module procedure la_sgbrfs
#endif
               module procedure la_wgbrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgbrfs(trans,n,kl,ku,nrhs,ab,ldab,afb,ldafb,ipiv,b,ldb, &
                         x,ldx,ferr,berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zgbrfs
#else
               module procedure la_zgbrfs
#endif
          end interface gbrfs

          !> GBSV: computes the solution to a complex system of linear equations
          !> A * X = B, where A is a band matrix of order N with KL subdiagonals
          !> and KU superdiagonals, and X and B are N-by-NRHS matrices.
          !> The LU decomposition with partial pivoting and row interchanges is
          !> used to factor A as A = L * U, where L is a product of permutation
          !> and unit lower triangular matrices with KL subdiagonals, and U is
          !> upper triangular with KL+KU superdiagonals.  The factored form of A
          !> is then used to solve the system of equations A * X = B.
          interface gbsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgbsv(n,kl,ku,nrhs,ab,ldab,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    complex(sp),intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine cgbsv
#else
               module procedure la_cgbsv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgbsv(n,kl,ku,nrhs,ab,ldab,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    real(dp),intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine dgbsv
#else
               module procedure la_dgbsv
#endif
               module procedure la_qgbsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgbsv(n,kl,ku,nrhs,ab,ldab,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    real(sp),intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine sgbsv
#else
               module procedure la_sgbsv
#endif
               module procedure la_wgbsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgbsv(n,kl,ku,nrhs,ab,ldab,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    complex(dp),intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine zgbsv
#else
               module procedure la_zgbsv
#endif
          end interface gbsv

          !> GBTRF: computes an LU factorization of a complex m-by-n band matrix A
          !> using partial pivoting with row interchanges.
          !> This is the blocked version of the algorithm, calling Level 3 BLAS.
          interface gbtrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgbtrf(m,n,kl,ku,ab,ldab,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    complex(sp),intent(inout) :: ab(ldab,*)
               end subroutine cgbtrf
#else
               module procedure la_cgbtrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgbtrf(m,n,kl,ku,ab,ldab,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(dp),intent(inout) :: ab(ldab,*)
               end subroutine dgbtrf
#else
               module procedure la_dgbtrf
#endif
               module procedure la_qgbtrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgbtrf(m,n,kl,ku,ab,ldab,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(sp),intent(inout) :: ab(ldab,*)
               end subroutine sgbtrf
#else
               module procedure la_sgbtrf
#endif
               module procedure la_wgbtrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgbtrf(m,n,kl,ku,ab,ldab,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    complex(dp),intent(inout) :: ab(ldab,*)
               end subroutine zgbtrf
#else
               module procedure la_zgbtrf
#endif
          end interface gbtrf

          !> GBTRS: solves a system of linear equations
          !> A * X = B,  A**T * X = B,  or  A**H * X = B
          !> with a general band matrix A using the LU factorization computed
          !> by CGBTRF.
          interface gbtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgbtrs(trans,n,kl,ku,nrhs,ab,ldab,ipiv,b,ldb,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(in) :: ab(ldab,*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine cgbtrs
#else
               module procedure la_cgbtrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgbtrs(trans,n,kl,ku,nrhs,ab,ldab,ipiv,b,ldb,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: ab(ldab,*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dgbtrs
#else
               module procedure la_dgbtrs
#endif
               module procedure la_qgbtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgbtrs(trans,n,kl,ku,nrhs,ab,ldab,ipiv,b,ldb,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: ab(ldab,*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine sgbtrs
#else
               module procedure la_sgbtrs
#endif
               module procedure la_wgbtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgbtrs(trans,n,kl,ku,nrhs,ab,ldab,ipiv,b,ldb,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(in) :: ab(ldab,*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zgbtrs
#else
               module procedure la_zgbtrs
#endif
          end interface gbtrs

          !> GEBAK: forms the right or left eigenvectors of a complex general
          !> matrix by backward transformation on the computed eigenvectors of the
          !> balanced matrix output by CGEBAL.
          interface gebak
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgebak(job,side,n,ilo,ihi,scale,m,v,ldv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job,side
                    integer(ilp),intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: scale(*)
                    complex(sp),intent(inout) :: v(ldv,*)
               end subroutine cgebak
#else
               module procedure la_cgebak
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgebak(job,side,n,ilo,ihi,scale,m,v,ldv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job,side
                    integer(ilp),intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: scale(*)
                    real(dp),intent(inout) :: v(ldv,*)
               end subroutine dgebak
#else
               module procedure la_dgebak
#endif
               module procedure la_qgebak
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgebak(job,side,n,ilo,ihi,scale,m,v,ldv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job,side
                    integer(ilp),intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(inout) :: v(ldv,*)
                    real(sp),intent(in) :: scale(*)
               end subroutine sgebak
#else
               module procedure la_sgebak
#endif
               module procedure la_wgebak
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgebak(job,side,n,ilo,ihi,scale,m,v,ldv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job,side
                    integer(ilp),intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: scale(*)
                    complex(dp),intent(inout) :: v(ldv,*)
               end subroutine zgebak
#else
               module procedure la_zgebak
#endif
          end interface gebak

          !> GEBAL: balances a general complex matrix A.  This involves, first,
          !> permuting A by a similarity transformation to isolate eigenvalues
          !> in the first 1 to ILO-1 and last IHI+1 to N elements on the
          !> diagonal; and second, applying a diagonal similarity transformation
          !> to rows and columns ILO to IHI to make the rows and columns as
          !> close in norm as possible.  Both steps are optional.
          !> Balancing may reduce the 1-norm of the matrix, and improve the
          !> accuracy of the computed eigenvalues and/or eigenvectors.
          interface gebal
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgebal(job,n,a,lda,ilo,ihi,scale,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job
                    integer(ilp),intent(out) :: ihi,ilo,info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: scale(*)
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine cgebal
#else
               module procedure la_cgebal
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgebal(job,n,a,lda,ilo,ihi,scale,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job
                    integer(ilp),intent(out) :: ihi,ilo,info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: scale(*)
               end subroutine dgebal
#else
               module procedure la_dgebal
#endif
               module procedure la_qgebal
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgebal(job,n,a,lda,ilo,ihi,scale,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job
                    integer(ilp),intent(out) :: ihi,ilo,info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: scale(*)
               end subroutine sgebal
#else
               module procedure la_sgebal
#endif
               module procedure la_wgebal
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgebal(job,n,a,lda,ilo,ihi,scale,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job
                    integer(ilp),intent(out) :: ihi,ilo,info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: scale(*)
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zgebal
#else
               module procedure la_zgebal
#endif
          end interface gebal

          !> GEBRD: reduces a general complex M-by-N matrix A to upper or lower
          !> bidiagonal form B by a unitary transformation: Q**H * A * P = B.
          !> If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
          interface gebrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgebrd(m,n,a,lda,d,e,tauq,taup,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(sp),intent(out) :: d(*),e(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: taup(*),tauq(*),work(*)
               end subroutine cgebrd
#else
               module procedure la_cgebrd
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgebrd(m,n,a,lda,d,e,tauq,taup,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: d(*),e(*),taup(*),tauq(*),work(*)
               end subroutine dgebrd
#else
               module procedure la_dgebrd
#endif
               module procedure la_qgebrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgebrd(m,n,a,lda,d,e,tauq,taup,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: d(*),e(*),taup(*),tauq(*),work(*)
               end subroutine sgebrd
#else
               module procedure la_sgebrd
#endif
               module procedure la_wgebrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgebrd(m,n,a,lda,d,e,tauq,taup,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(dp),intent(out) :: d(*),e(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: taup(*),tauq(*),work(*)
               end subroutine zgebrd
#else
               module procedure la_zgebrd
#endif
          end interface gebrd

          !> GECON: estimates the reciprocal of the condition number of a general
          !> complex matrix A, in either the 1-norm or the infinity-norm, using
          !> the LU factorization computed by CGETRF.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as
          !> RCOND = 1 / ( norm(A) * norm(inv(A)) ).
          interface gecon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgecon(norm,n,a,lda,anorm,rcond,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond,rwork(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgecon
#else
               module procedure la_cgecon
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgecon(norm,n,a,lda,anorm,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond,work(*)
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dgecon
#else
               module procedure la_dgecon
#endif
               module procedure la_qgecon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgecon(norm,n,a,lda,anorm,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond,work(*)
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine sgecon
#else
               module procedure la_sgecon
#endif
               module procedure la_wgecon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgecon(norm,n,a,lda,anorm,rcond,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond,rwork(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgecon
#else
               module procedure la_zgecon
#endif
          end interface gecon

          !> GEEQU: computes row and column scalings intended to equilibrate an
          !> M-by-N matrix A and reduce its condition number.  R returns the row
          !> scale factors and C the column scale factors, chosen to try to make
          !> the largest element in each row and column of the matrix B with
          !> elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
          !> R(i) and C(j) are restricted to be between SMLNUM = smallest safe
          !> number and BIGNUM = largest safe number.  Use of these scaling
          !> factors is not guaranteed to reduce the condition number of A but
          !> works well in practice.
          interface geequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgeequ(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp),intent(in) :: a(lda,*)
               end subroutine cgeequ
#else
               module procedure la_cgeequ
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgeequ(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp),intent(in) :: a(lda,*)
               end subroutine dgeequ
#else
               module procedure la_dgeequ
#endif
               module procedure la_qgeequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgeequ(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp),intent(in) :: a(lda,*)
               end subroutine sgeequ
#else
               module procedure la_sgeequ
#endif
               module procedure la_wgeequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgeequ(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp),intent(in) :: a(lda,*)
               end subroutine zgeequ
#else
               module procedure la_zgeequ
#endif
          end interface geequ

          !> GEEQUB: computes row and column scalings intended to equilibrate an
          !> M-by-N matrix A and reduce its condition number.  R returns the row
          !> scale factors and C the column scale factors, chosen to try to make
          !> the largest element in each row and column of the matrix B with
          !> elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
          !> the radix.
          !> R(i) and C(j) are restricted to be a power of the radix between
          !> SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
          !> of these scaling factors is not guaranteed to reduce the condition
          !> number of A but works well in practice.
          !> This routine differs from CGEEQU by restricting the scaling factors
          !> to a power of the radix.  Barring over- and underflow, scaling by
          !> these factors introduces no additional rounding errors.  However, the
          !> scaled entries' magnitudes are no longer approximately 1 but lie
          !> between sqrt(radix) and 1/sqrt(radix).
          interface geequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgeequb(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp),intent(in) :: a(lda,*)
               end subroutine cgeequb
#else
               module procedure la_cgeequb
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgeequb(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp),intent(in) :: a(lda,*)
               end subroutine dgeequb
#else
               module procedure la_dgeequb
#endif
               module procedure la_qgeequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgeequb(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp),intent(in) :: a(lda,*)
               end subroutine sgeequb
#else
               module procedure la_sgeequb
#endif
               module procedure la_wgeequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgeequb(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp),intent(in) :: a(lda,*)
               end subroutine zgeequb
#else
               module procedure la_zgeequb
#endif
          end interface geequb

          !> GEES: computes for an N-by-N complex nonsymmetric matrix A, the
          !> eigenvalues, the Schur form T, and, optionally, the matrix of Schur
          !> vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
          !> Optionally, it also orders the eigenvalues on the diagonal of the
          !> Schur form so that selected eigenvalues are at the top left.
          !> The leading columns of Z then form an orthonormal basis for the
          !> invariant subspace corresponding to the selected eigenvalues.
          !> A complex matrix is in Schur form if it is upper triangular.
          interface gees
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgees(jobvs,sort,select,n,a,lda,sdim,w,vs,ldvs,work,lwork, &
                         rwork,bwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvs,sort
                    integer(ilp),intent(out) :: info,sdim
                    integer(ilp),intent(in) :: lda,ldvs,lwork,n
                    logical(lk),intent(out) :: bwork(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: vs(ldvs,*),w(*),work(*)
                    procedure(la_select_c) :: select
               end subroutine cgees
#else
               module procedure la_cgees
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgees(jobvs,sort,select,n,a,lda,sdim,wr,wi,vs,ldvs,work, &
                         lwork,bwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvs,sort
                    integer(ilp),intent(out) :: info,sdim
                    integer(ilp),intent(in) :: lda,ldvs,lwork,n
                    logical(lk),intent(out) :: bwork(*)
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: vs(ldvs,*),wi(*),work(*),wr(*)
                    procedure(la_select_d) :: select
               end subroutine dgees
#else
               module procedure la_dgees
#endif
               module procedure la_qgees
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgees(jobvs,sort,select,n,a,lda,sdim,wr,wi,vs,ldvs,work, &
                         lwork,bwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvs,sort
                    integer(ilp),intent(out) :: info,sdim
                    integer(ilp),intent(in) :: lda,ldvs,lwork,n
                    logical(lk),intent(out) :: bwork(*)
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: vs(ldvs,*),wi(*),work(*),wr(*)
                    procedure(la_select_s) :: select
               end subroutine sgees
#else
               module procedure la_sgees
#endif
               module procedure la_wgees
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgees(jobvs,sort,select,n,a,lda,sdim,w,vs,ldvs,work,lwork, &
                         rwork,bwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvs,sort
                    integer(ilp),intent(out) :: info,sdim
                    integer(ilp),intent(in) :: lda,ldvs,lwork,n
                    logical(lk),intent(out) :: bwork(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: vs(ldvs,*),w(*),work(*)
                    procedure(la_select_z) :: select
               end subroutine zgees
#else
               module procedure la_zgees
#endif
          end interface gees

          !> GEEV: computes for an N-by-N complex nonsymmetric matrix A, the
          !> eigenvalues and, optionally, the left and/or right eigenvectors.
          !> The right eigenvector v(j) of A satisfies
          !> A * v(j) = lambda(j) * v(j)
          !> where lambda(j) is its eigenvalue.
          !> The left eigenvector u(j) of A satisfies
          !> u(j)**H * A = lambda(j) * u(j)**H
          !> where u(j)**H denotes the conjugate transpose of u(j).
          !> The computed eigenvectors are normalized to have Euclidean norm
          !> equal to 1 and largest component real.
          interface geev
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgeev(jobvl,jobvr,n,a,lda,w,vl,ldvl,vr,ldvr,work,lwork, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvl,jobvr
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: vl(ldvl,*),vr(ldvr,*),w(*),work(*)
               end subroutine cgeev
#else
               module procedure la_cgeev
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgeev(jobvl,jobvr,n,a,lda,wr,wi,vl,ldvl,vr,ldvr,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvl,jobvr
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: vl(ldvl,*),vr(ldvr,*),wi(*),work(*),wr(*)
               end subroutine dgeev
#else
               module procedure la_dgeev
#endif
               module procedure la_qgeev
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgeev(jobvl,jobvr,n,a,lda,wr,wi,vl,ldvl,vr,ldvr,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvl,jobvr
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: vl(ldvl,*),vr(ldvr,*),wi(*),work(*),wr(*)
               end subroutine sgeev
#else
               module procedure la_sgeev
#endif
               module procedure la_wgeev
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgeev(jobvl,jobvr,n,a,lda,w,vl,ldvl,vr,ldvr,work,lwork, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvl,jobvr
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: vl(ldvl,*),vr(ldvr,*),w(*),work(*)
               end subroutine zgeev
#else
               module procedure la_zgeev
#endif
          end interface geev

          !> GEHRD: reduces a complex general matrix A to upper Hessenberg form H by
          !> an unitary similarity transformation:  Q**H * A * Q = H .
          interface gehrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgehrd(n,ilo,ihi,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),work(*)
               end subroutine cgehrd
#else
               module procedure la_cgehrd
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgehrd(n,ilo,ihi,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: tau(*),work(*)
               end subroutine dgehrd
#else
               module procedure la_dgehrd
#endif
               module procedure la_qgehrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgehrd(n,ilo,ihi,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: tau(*),work(*)
               end subroutine sgehrd
#else
               module procedure la_sgehrd
#endif
               module procedure la_wgehrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgehrd(n,ilo,ihi,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),work(*)
               end subroutine zgehrd
#else
               module procedure la_zgehrd
#endif
          end interface gehrd

          !> GEJSV: computes the singular value decomposition (SVD) of a complex M-by-N
          !> matrix [A], where M >= N. The SVD of [A] is written as
          !> [A] = [U] * [SIGMA] * [V]^*,
          !> where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
          !> diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
          !> [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
          !> the singular values of [A]. The columns of [U] and [V] are the left and
          !> the right singular vectors of [A], respectively. The matrices [U] and [V]
          !> are computed and stored in the arrays U and V, respectively. The diagonal
          !> of [SIGMA] is computed and stored in the array SVA.
          interface gejsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgejsv(joba,jobu,jobv,jobr,jobt,jobp,m,n,a,lda,sva,u, &
                         ldu,v,ldv,cwork,lwork,rwork,lrwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldu,ldv,lwork,lrwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: u(ldu,*),v(ldv,*),cwork(lwork)
                    real(sp),intent(out) :: sva(n),rwork(lrwork)
                    character,intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine cgejsv
#else
               module procedure la_cgejsv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgejsv(joba,jobu,jobv,jobr,jobt,jobp,m,n,a,lda,sva,u, &
                         ldu,v,ldv,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldu,ldv,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: sva(n),u(ldu,*),v(ldv,*),work(lwork)
                    character,intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine dgejsv
#else
               module procedure la_dgejsv
#endif
               module procedure la_qgejsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgejsv(joba,jobu,jobv,jobr,jobt,jobp,m,n,a,lda,sva,u, &
                         ldu,v,ldv,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldu,ldv,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: sva(n),u(ldu,*),v(ldv,*),work(lwork)
                    character,intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine sgejsv
#else
               module procedure la_sgejsv
#endif
               module procedure la_wgejsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgejsv(joba,jobu,jobv,jobr,jobt,jobp,m,n,a,lda,sva,u, &
                         ldu,v,ldv,cwork,lwork,rwork,lrwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldu,ldv,lwork,lrwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: u(ldu,*),v(ldv,*),cwork(lwork)
                    real(dp),intent(out) :: sva(n),rwork(lrwork)
                    character,intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine zgejsv
#else
               module procedure la_zgejsv
#endif
          end interface gejsv

          !> GELQ: computes an LQ factorization of a complex M-by-N matrix A:
          !> A = ( L 0 ) *  Q
          !> where:
          !> Q is a N-by-N orthogonal matrix;
          !> L is a lower-triangular M-by-M matrix;
          !> 0 is a M-by-(N-M) zero matrix, if M < N.
          interface gelq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgelq(m,n,a,lda,t,tsize,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,tsize,lwork
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: t(*),work(*)
               end subroutine cgelq
#else
               module procedure la_cgelq
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgelq(m,n,a,lda,t,tsize,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,tsize,lwork
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: t(*),work(*)
               end subroutine dgelq
#else
               module procedure la_dgelq
#endif
               module procedure la_qgelq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgelq(m,n,a,lda,t,tsize,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,tsize,lwork
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: t(*),work(*)
               end subroutine sgelq
#else
               module procedure la_sgelq
#endif
               module procedure la_wgelq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgelq(m,n,a,lda,t,tsize,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,tsize,lwork
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: t(*),work(*)
               end subroutine zgelq
#else
               module procedure la_zgelq
#endif
          end interface gelq

          !> GELQF: computes an LQ factorization of a complex M-by-N matrix A:
          !> A = ( L 0 ) *  Q
          !> where:
          !> Q is a N-by-N orthogonal matrix;
          !> L is a lower-triangular M-by-M matrix;
          !> 0 is a M-by-(N-M) zero matrix, if M < N.
          interface gelqf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgelqf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),work(*)
               end subroutine cgelqf
#else
               module procedure la_cgelqf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgelqf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: tau(*),work(*)
               end subroutine dgelqf
#else
               module procedure la_dgelqf
#endif
               module procedure la_qgelqf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgelqf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: tau(*),work(*)
               end subroutine sgelqf
#else
               module procedure la_sgelqf
#endif
               module procedure la_wgelqf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgelqf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),work(*)
               end subroutine zgelqf
#else
               module procedure la_zgelqf
#endif
          end interface gelqf

          !> GELQT: computes a blocked LQ factorization of a complex M-by-N matrix A
          !> using the compact WY representation of Q.
          interface gelqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgelqt(m,n,mb,a,lda,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,mb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: t(ldt,*),work(*)
               end subroutine cgelqt
#else
               module procedure la_cgelqt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgelqt(m,n,mb,a,lda,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,mb
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: t(ldt,*),work(*)
               end subroutine dgelqt
#else
               module procedure la_dgelqt
#endif
               module procedure la_qgelqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgelqt(m,n,mb,a,lda,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,mb
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: t(ldt,*),work(*)
               end subroutine sgelqt
#else
               module procedure la_sgelqt
#endif
               module procedure la_wgelqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgelqt(m,n,mb,a,lda,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,mb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: t(ldt,*),work(*)
               end subroutine zgelqt
#else
               module procedure la_zgelqt
#endif
          end interface gelqt

          !> GELQT3: recursively computes a LQ factorization of a complex M-by-N
          !> matrix A, using the compact WY representation of Q.
          !> Based on the algorithm of Elmroth and Gustavson,
          !> IBM J. Res. Develop. Vol 44 No. 4 July 2000.
          interface gelqt3
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine cgelqt3(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,ldt
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: t(ldt,*)
               end subroutine cgelqt3
#else
               module procedure la_cgelqt3
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine dgelqt3(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,ldt
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: t(ldt,*)
               end subroutine dgelqt3
#else
               module procedure la_dgelqt3
#endif
               module procedure la_qgelqt3
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine sgelqt3(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,ldt
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: t(ldt,*)
               end subroutine sgelqt3
#else
               module procedure la_sgelqt3
#endif
               module procedure la_wgelqt3
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine zgelqt3(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,ldt
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: t(ldt,*)
               end subroutine zgelqt3
#else
               module procedure la_zgelqt3
#endif
          end interface gelqt3

          !> GELS: solves overdetermined or underdetermined complex linear systems
          !> involving an M-by-N matrix A, or its conjugate-transpose, using a QR
          !> or LQ factorization of A.  It is assumed that A has full rank.
          !> The following options are provided:
          !> 1. If TRANS = 'N' and m >= n:  find the least squares solution of
          !> an overdetermined system, i.e., solve the least squares problem
          !> minimize || B - A*X ||.
          !> 2. If TRANS = 'N' and m < n:  find the minimum norm solution of
          !> an underdetermined system A * X = B.
          !> 3. If TRANS = 'C' and m >= n:  find the minimum norm solution of
          !> an underdetermined system A**H * X = B.
          !> 4. If TRANS = 'C' and m < n:  find the least squares solution of
          !> an overdetermined system, i.e., solve the least squares problem
          !> minimize || B - A**H * X ||.
          !> Several right hand side vectors b and solution vectors x can be
          !> handled in a single call; they are stored as the columns of the
          !> M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !> matrix X.
          interface gels
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgels
#else
               module procedure la_cgels
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dgels
#else
               module procedure la_dgels
#endif
               module procedure la_qgels
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sgels
#else
               module procedure la_sgels
#endif
               module procedure la_wgels
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgels
#else
               module procedure la_zgels
#endif
          end interface gels

          !> GELSD: computes the minimum-norm solution to a real linear least
          !> squares problem:
          !> minimize 2-norm(| b - A*x |)
          !> using the singular value decomposition (SVD) of A. A is an M-by-N
          !> matrix which may be rank-deficient.
          !> Several right hand side vectors b and solution vectors x can be
          !> handled in a single call; they are stored as the columns of the
          !> M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !> matrix X.
          !> The problem is solved in three steps:
          !> (1) Reduce the coefficient matrix A to bidiagonal form with
          !> Householder transformations, reducing the original problem
          !> into a "bidiagonal least squares problem" (BLS)
          !> (2) Solve the BLS using a divide and conquer approach.
          !> (3) Apply back all the Householder transformations to solve
          !> the original least squares problem.
          !> The effective rank of A is determined by treating as zero those
          !> singular values which are less than RCOND times the largest singular
          !> value.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface gelsd
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgelsd(m,n,nrhs,a,lda,b,ldb,s,rcond,rank,work,lwork,rwork, &
                         iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank,iwork(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp),intent(in) :: rcond
                    real(sp),intent(out) :: rwork(*),s(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgelsd
#else
               module procedure la_cgelsd
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgelsd(m,n,nrhs,a,lda,b,ldb,s,rcond,rank,work,lwork,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank,iwork(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp),intent(in) :: rcond
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: s(*),work(*)
               end subroutine dgelsd
#else
               module procedure la_dgelsd
#endif
               module procedure la_qgelsd
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgelsd(m,n,nrhs,a,lda,b,ldb,s,rcond,rank,work,lwork,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank,iwork(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp),intent(in) :: rcond
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: s(*),work(*)
               end subroutine sgelsd
#else
               module procedure la_sgelsd
#endif
               module procedure la_wgelsd
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgelsd(m,n,nrhs,a,lda,b,ldb,s,rcond,rank,work,lwork,rwork, &
                         iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank,iwork(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp),intent(in) :: rcond
                    real(dp),intent(out) :: rwork(*),s(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgelsd
#else
               module procedure la_zgelsd
#endif
          end interface gelsd

          !> GELSS: computes the minimum norm solution to a complex linear
          !> least squares problem:
          !> Minimize 2-norm(| b - A*x |).
          !> using the singular value decomposition (SVD) of A. A is an M-by-N
          !> matrix which may be rank-deficient.
          !> Several right hand side vectors b and solution vectors x can be
          !> handled in a single call; they are stored as the columns of the
          !> M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
          !> X.
          !> The effective rank of A is determined by treating as zero those
          !> singular values which are less than RCOND times the largest singular
          !> value.
          interface gelss
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgelss(m,n,nrhs,a,lda,b,ldb,s,rcond,rank,work,lwork,rwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp),intent(in) :: rcond
                    real(sp),intent(out) :: rwork(*),s(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgelss
#else
               module procedure la_cgelss
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgelss(m,n,nrhs,a,lda,b,ldb,s,rcond,rank,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp),intent(in) :: rcond
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: s(*),work(*)
               end subroutine dgelss
#else
               module procedure la_dgelss
#endif
               module procedure la_qgelss
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgelss(m,n,nrhs,a,lda,b,ldb,s,rcond,rank,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp),intent(in) :: rcond
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: s(*),work(*)
               end subroutine sgelss
#else
               module procedure la_sgelss
#endif
               module procedure la_wgelss
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgelss(m,n,nrhs,a,lda,b,ldb,s,rcond,rank,work,lwork,rwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp),intent(in) :: rcond
                    real(dp),intent(out) :: rwork(*),s(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgelss
#else
               module procedure la_zgelss
#endif
          end interface gelss

          !> GELSY: computes the minimum-norm solution to a complex linear least
          !> squares problem:
          !> minimize || A * X - B ||
          !> using a complete orthogonal factorization of A.  A is an M-by-N
          !> matrix which may be rank-deficient.
          !> Several right hand side vectors b and solution vectors x can be
          !> handled in a single call; they are stored as the columns of the
          !> M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !> matrix X.
          !> The routine first computes a QR factorization with column pivoting:
          !> A * P = Q * [ R11 R12 ]
          !> [  0  R22 ]
          !> with R11 defined as the largest leading submatrix whose estimated
          !> condition number is less than 1/RCOND.  The order of R11, RANK,
          !> is the effective rank of A.
          !> Then, R22 is considered to be negligible, and R12 is annihilated
          !> by unitary transformations from the right, arriving at the
          !> complete orthogonal factorization:
          !> A * P = Q * [ T11 0 ] * Z
          !> [  0  0 ]
          !> The minimum-norm solution is then
          !> X = P * Z**H [ inv(T11)*Q1**H*B ]
          !> [        0         ]
          !> where Q1 consists of the first RANK columns of Q.
          !> This routine is basically identical to the original xGELSX except
          !> three differences:
          !> o The permutation of matrix B (the right hand side) is faster and
          !> more simple.
          !> o The call to the subroutine xGEQPF has been substituted by the
          !> the call to the subroutine xGEQP3. This subroutine is a Blas-3
          !> version of the QR factorization with column pivoting.
          !> o Matrix B (the right hand side) is updated with Blas-3.
          interface gelsy
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgelsy(m,n,nrhs,a,lda,b,ldb,jpvt,rcond,rank,work,lwork, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp),intent(in) :: rcond
                    integer(ilp),intent(inout) :: jpvt(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgelsy
#else
               module procedure la_cgelsy
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgelsy(m,n,nrhs,a,lda,b,ldb,jpvt,rcond,rank,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp),intent(in) :: rcond
                    integer(ilp),intent(inout) :: jpvt(*)
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dgelsy
#else
               module procedure la_dgelsy
#endif
               module procedure la_qgelsy
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgelsy(m,n,nrhs,a,lda,b,ldb,jpvt,rcond,rank,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp),intent(in) :: rcond
                    integer(ilp),intent(inout) :: jpvt(*)
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sgelsy
#else
               module procedure la_sgelsy
#endif
               module procedure la_wgelsy
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgelsy(m,n,nrhs,a,lda,b,ldb,jpvt,rcond,rank,work,lwork, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,rank
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp),intent(in) :: rcond
                    integer(ilp),intent(inout) :: jpvt(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgelsy
#else
               module procedure la_zgelsy
#endif
          end interface gelsy

          !> GEMLQ: overwrites the general real M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix defined as the product
          !> of blocked elementary reflectors computed by short wide
          !> LQ factorization (CGELQ)
          interface gemlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgemlq(side,trans,m,n,k,a,lda,t,tsize,c,ldc,work,lwork, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(sp),intent(in) :: a(lda,*),t(*)
                    complex(sp),intent(inout) :: c(ldc,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgemlq
#else
               module procedure la_cgemlq
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgemlq(side,trans,m,n,k,a,lda,t,tsize,c,ldc,work,lwork, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(dp),intent(in) :: a(lda,*),t(*)
                    real(dp),intent(inout) :: c(ldc,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dgemlq
#else
               module procedure la_dgemlq
#endif
               module procedure la_qgemlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgemlq(side,trans,m,n,k,a,lda,t,tsize,c,ldc,work,lwork, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(sp),intent(in) :: a(lda,*),t(*)
                    real(sp),intent(inout) :: c(ldc,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sgemlq
#else
               module procedure la_sgemlq
#endif
               module procedure la_wgemlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgemlq(side,trans,m,n,k,a,lda,t,tsize,c,ldc,work,lwork, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(dp),intent(in) :: a(lda,*),t(*)
                    complex(dp),intent(inout) :: c(ldc,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgemlq
#else
               module procedure la_zgemlq
#endif
          end interface gemlq

          !> GEMLQT: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q C            C Q
          !> TRANS = 'C':   Q**H C            C Q**H
          !> where Q is a complex unitary matrix defined as the product of K
          !> elementary reflectors:
          !> Q = H(1) H(2) . . . H(K) = I - V T V**H
          !> generated using the compact WY representation as returned by CGELQT.
          !> Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
          interface gemlqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgemlqt(side,trans,m,n,k,mb,v,ldv,t,ldt,c,ldc,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    complex(sp),intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp),intent(inout) :: c(ldc,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgemlqt
#else
               module procedure la_cgemlqt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgemlqt(side,trans,m,n,k,mb,v,ldv,t,ldt,c,ldc,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    real(dp),intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp),intent(inout) :: c(ldc,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dgemlqt
#else
               module procedure la_dgemlqt
#endif
               module procedure la_qgemlqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgemlqt(side,trans,m,n,k,mb,v,ldv,t,ldt,c,ldc,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    real(sp),intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp),intent(inout) :: c(ldc,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sgemlqt
#else
               module procedure la_sgemlqt
#endif
               module procedure la_wgemlqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgemlqt(side,trans,m,n,k,mb,v,ldv,t,ldt,c,ldc,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    complex(dp),intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp),intent(inout) :: c(ldc,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgemlqt
#else
               module procedure la_zgemlqt
#endif
          end interface gemlqt

          !> GEMQR: overwrites the general real M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix defined as the product
          !> of blocked elementary reflectors computed by tall skinny
          !> QR factorization (CGEQR)
          interface gemqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgemqr(side,trans,m,n,k,a,lda,t,tsize,c,ldc,work,lwork, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(sp),intent(in) :: a(lda,*),t(*)
                    complex(sp),intent(inout) :: c(ldc,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgemqr
#else
               module procedure la_cgemqr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgemqr(side,trans,m,n,k,a,lda,t,tsize,c,ldc,work,lwork, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(dp),intent(in) :: a(lda,*),t(*)
                    real(dp),intent(inout) :: c(ldc,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dgemqr
#else
               module procedure la_dgemqr
#endif
               module procedure la_qgemqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgemqr(side,trans,m,n,k,a,lda,t,tsize,c,ldc,work,lwork, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(sp),intent(in) :: a(lda,*),t(*)
                    real(sp),intent(inout) :: c(ldc,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sgemqr
#else
               module procedure la_sgemqr
#endif
               module procedure la_wgemqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgemqr(side,trans,m,n,k,a,lda,t,tsize,c,ldc,work,lwork, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(dp),intent(in) :: a(lda,*),t(*)
                    complex(dp),intent(inout) :: c(ldc,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgemqr
#else
               module procedure la_zgemqr
#endif
          end interface gemqr

          !> GEMQRT: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q C            C Q
          !> TRANS = 'C':    Q**H C            C Q**H
          !> where Q is a complex orthogonal matrix defined as the product of K
          !> elementary reflectors:
          !> Q = H(1) H(2) . . . H(K) = I - V T V**H
          !> generated using the compact WY representation as returned by CGEQRT.
          !> Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
          interface gemqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    complex(sp),intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp),intent(inout) :: c(ldc,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgemqrt
#else
               module procedure la_cgemqrt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    real(dp),intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp),intent(inout) :: c(ldc,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dgemqrt
#else
               module procedure la_dgemqrt
#endif
               module procedure la_qgemqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    real(sp),intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp),intent(inout) :: c(ldc,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sgemqrt
#else
               module procedure la_sgemqrt
#endif
               module procedure la_wgemqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    complex(dp),intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp),intent(inout) :: c(ldc,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgemqrt
#else
               module procedure la_zgemqrt
#endif
          end interface gemqrt

          !> GEQLF: computes a QL factorization of a complex M-by-N matrix A:
          !> A = Q * L.
          interface geqlf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgeqlf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),work(*)
               end subroutine cgeqlf
#else
               module procedure la_cgeqlf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgeqlf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: tau(*),work(*)
               end subroutine dgeqlf
#else
               module procedure la_dgeqlf
#endif
               module procedure la_qgeqlf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgeqlf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: tau(*),work(*)
               end subroutine sgeqlf
#else
               module procedure la_sgeqlf
#endif
               module procedure la_wgeqlf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgeqlf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),work(*)
               end subroutine zgeqlf
#else
               module procedure la_zgeqlf
#endif
          end interface geqlf

          !> GEQR: computes a QR factorization of a complex M-by-N matrix A:
          !> A = Q * ( R ),
          !> ( 0 )
          !> where:
          !> Q is a M-by-M orthogonal matrix;
          !> R is an upper-triangular N-by-N matrix;
          !> 0 is a (M-N)-by-N zero matrix, if M > N.
          interface geqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgeqr(m,n,a,lda,t,tsize,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,tsize,lwork
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: t(*),work(*)
               end subroutine cgeqr
#else
               module procedure la_cgeqr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgeqr(m,n,a,lda,t,tsize,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,tsize,lwork
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: t(*),work(*)
               end subroutine dgeqr
#else
               module procedure la_dgeqr
#endif
               module procedure la_qgeqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgeqr(m,n,a,lda,t,tsize,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,tsize,lwork
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: t(*),work(*)
               end subroutine sgeqr
#else
               module procedure la_sgeqr
#endif
               module procedure la_wgeqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgeqr(m,n,a,lda,t,tsize,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,tsize,lwork
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: t(*),work(*)
               end subroutine zgeqr
#else
               module procedure la_zgeqr
#endif
          end interface geqr

          !> GEQR2P: computes a QR factorization of a complex m-by-n matrix A:
          !> A = Q * ( R ),
          !> ( 0 )
          !> where:
          !> Q is a m-by-m orthogonal matrix;
          !> R is an upper-triangular n-by-n matrix with nonnegative diagonal
          !> entries;
          !> 0 is a (m-n)-by-n zero matrix, if m > n.
          interface geqr2p
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgeqr2p(m,n,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),work(*)
               end subroutine cgeqr2p
#else
               module procedure la_cgeqr2p
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgeqr2p(m,n,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: tau(*),work(*)
               end subroutine dgeqr2p
#else
               module procedure la_dgeqr2p
#endif
               module procedure la_qgeqr2p
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgeqr2p(m,n,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: tau(*),work(*)
               end subroutine sgeqr2p
#else
               module procedure la_sgeqr2p
#endif
               module procedure la_wgeqr2p
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgeqr2p(m,n,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),work(*)
               end subroutine zgeqr2p
#else
               module procedure la_zgeqr2p
#endif
          end interface geqr2p

          !> GEQRF: computes a QR factorization of a complex M-by-N matrix A:
          !> A = Q * ( R ),
          !> ( 0 )
          !> where:
          !> Q is a M-by-M orthogonal matrix;
          !> R is an upper-triangular N-by-N matrix;
          !> 0 is a (M-N)-by-N zero matrix, if M > N.
          interface geqrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgeqrf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),work(*)
               end subroutine cgeqrf
#else
               module procedure la_cgeqrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgeqrf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: tau(*),work(*)
               end subroutine dgeqrf
#else
               module procedure la_dgeqrf
#endif
               module procedure la_qgeqrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgeqrf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: tau(*),work(*)
               end subroutine sgeqrf
#else
               module procedure la_sgeqrf
#endif
               module procedure la_wgeqrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgeqrf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),work(*)
               end subroutine zgeqrf
#else
               module procedure la_zgeqrf
#endif
          end interface geqrf

          !> CGEQR2P computes a QR factorization of a complex M-by-N matrix A:
          !> A = Q * ( R ),
          !> ( 0 )
          !> where:
          !> Q is a M-by-M orthogonal matrix;
          !> R is an upper-triangular N-by-N matrix with nonnegative diagonal
          !> entries;
          !> 0 is a (M-N)-by-N zero matrix, if M > N.
          interface geqrfp
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgeqrfp(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),work(*)
               end subroutine cgeqrfp
#else
               module procedure la_cgeqrfp
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgeqrfp(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: tau(*),work(*)
               end subroutine dgeqrfp
#else
               module procedure la_dgeqrfp
#endif
               module procedure la_qgeqrfp
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgeqrfp(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: tau(*),work(*)
               end subroutine sgeqrfp
#else
               module procedure la_sgeqrfp
#endif
               module procedure la_wgeqrfp
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgeqrfp(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),work(*)
               end subroutine zgeqrfp
#else
               module procedure la_zgeqrfp
#endif
          end interface geqrfp

          !> GEQRT: computes a blocked QR factorization of a complex M-by-N matrix A
          !> using the compact WY representation of Q.
          interface geqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgeqrt(m,n,nb,a,lda,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,nb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: t(ldt,*),work(*)
               end subroutine cgeqrt
#else
               module procedure la_cgeqrt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgeqrt(m,n,nb,a,lda,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,nb
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: t(ldt,*),work(*)
               end subroutine dgeqrt
#else
               module procedure la_dgeqrt
#endif
               module procedure la_qgeqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgeqrt(m,n,nb,a,lda,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,nb
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: t(ldt,*),work(*)
               end subroutine sgeqrt
#else
               module procedure la_sgeqrt
#endif
               module procedure la_wgeqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgeqrt(m,n,nb,a,lda,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,nb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: t(ldt,*),work(*)
               end subroutine zgeqrt
#else
               module procedure la_zgeqrt
#endif
          end interface geqrt

          !> GEQRT2: computes a QR factorization of a complex M-by-N matrix A,
          !> using the compact WY representation of Q.
          interface geqrt2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgeqrt2(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: t(ldt,*)
               end subroutine cgeqrt2
#else
               module procedure la_cgeqrt2
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgeqrt2(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: t(ldt,*)
               end subroutine dgeqrt2
#else
               module procedure la_dgeqrt2
#endif
               module procedure la_qgeqrt2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgeqrt2(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: t(ldt,*)
               end subroutine sgeqrt2
#else
               module procedure la_sgeqrt2
#endif
               module procedure la_wgeqrt2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgeqrt2(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: t(ldt,*)
               end subroutine zgeqrt2
#else
               module procedure la_zgeqrt2
#endif
          end interface geqrt2

          !> GEQRT3: recursively computes a QR factorization of a complex M-by-N matrix A,
          !> using the compact WY representation of Q.
          !> Based on the algorithm of Elmroth and Gustavson,
          !> IBM J. Res. Develop. Vol 44 No. 4 July 2000.
          interface geqrt3
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine cgeqrt3(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,ldt
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: t(ldt,*)
               end subroutine cgeqrt3
#else
               module procedure la_cgeqrt3
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine dgeqrt3(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,ldt
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: t(ldt,*)
               end subroutine dgeqrt3
#else
               module procedure la_dgeqrt3
#endif
               module procedure la_qgeqrt3
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine sgeqrt3(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,ldt
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: t(ldt,*)
               end subroutine sgeqrt3
#else
               module procedure la_sgeqrt3
#endif
               module procedure la_wgeqrt3
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine zgeqrt3(m,n,a,lda,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,ldt
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: t(ldt,*)
               end subroutine zgeqrt3
#else
               module procedure la_zgeqrt3
#endif
          end interface geqrt3

          !> GERFS: improves the computed solution to a system of linear
          !> equations and provides error bounds and backward error estimates for
          !> the solution.
          interface gerfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgerfs(trans,n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx, &
                         ferr,berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine cgerfs
#else
               module procedure la_cgerfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgerfs(trans,n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx, &
                         ferr,berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dgerfs
#else
               module procedure la_dgerfs
#endif
               module procedure la_qgerfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgerfs(trans,n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx, &
                         ferr,berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine sgerfs
#else
               module procedure la_sgerfs
#endif
               module procedure la_wgerfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgerfs(trans,n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx, &
                         ferr,berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zgerfs
#else
               module procedure la_zgerfs
#endif
          end interface gerfs

          !> GERQF: computes an RQ factorization of a complex M-by-N matrix A:
          !> A = R * Q.
          interface gerqf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgerqf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),work(*)
               end subroutine cgerqf
#else
               module procedure la_cgerqf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgerqf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: tau(*),work(*)
               end subroutine dgerqf
#else
               module procedure la_dgerqf
#endif
               module procedure la_qgerqf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgerqf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: tau(*),work(*)
               end subroutine sgerqf
#else
               module procedure la_sgerqf
#endif
               module procedure la_wgerqf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgerqf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),work(*)
               end subroutine zgerqf
#else
               module procedure la_zgerqf
#endif
          end interface gerqf

          !> GESDD: computes the singular value decomposition (SVD) of a complex
          !> M-by-N matrix A, optionally computing the left and/or right singular
          !> vectors, by using divide-and-conquer method. The SVD is written
          !> A = U * SIGMA * conjugate-transpose(V)
          !> where SIGMA is an M-by-N matrix which is zero except for its
          !> min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
          !> V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
          !> are the singular values of A; they are real and non-negative, and
          !> are returned in descending order.  The first min(m,n) columns of
          !> U and V are the left and right singular vectors of A.
          !> Note that the routine returns VT = V**H, not V.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface gesdd
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgesdd(jobz,m,n,a,lda,s,u,ldu,vt,ldvt,work,lwork,rwork, &
                         iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp),intent(out) :: rwork(*),s(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine cgesdd
#else
               module procedure la_cgesdd
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgesdd(jobz,m,n,a,lda,s,u,ldu,vt,ldvt,work,lwork,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dgesdd
#else
               module procedure la_dgesdd
#endif
               module procedure la_qgesdd
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgesdd(jobz,m,n,a,lda,s,u,ldu,vt,ldvt,work,lwork,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sgesdd
#else
               module procedure la_sgesdd
#endif
               module procedure la_wgesdd
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgesdd(jobz,m,n,a,lda,s,u,ldu,vt,ldvt,work,lwork,rwork, &
                         iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp),intent(out) :: rwork(*),s(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine zgesdd
#else
               module procedure la_zgesdd
#endif
          end interface gesdd

          !> GESV: computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
          !> The LU decomposition with partial pivoting and row interchanges is
          !> used to factor A as
          !> A = P * L * U,
          !> where P is a permutation matrix, L is unit lower triangular, and U is
          !> upper triangular.  The factored form of A is then used to solve the
          !> system of equations A * X = B.
          interface gesv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgesv(n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cgesv
#else
               module procedure la_cgesv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgesv(n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine dgesv
#else
               module procedure la_dgesv
#endif
               module procedure la_qgesv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgesv(n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine sgesv
#else
               module procedure la_sgesv
#endif
               module procedure la_wgesv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgesv(n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zgesv
#else
               module procedure la_zgesv
#endif
          end interface gesv

          !> GESVD: computes the singular value decomposition (SVD) of a complex
          !> M-by-N matrix A, optionally computing the left and/or right singular
          !> vectors. The SVD is written
          !> A = U * SIGMA * conjugate-transpose(V)
          !> where SIGMA is an M-by-N matrix which is zero except for its
          !> min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
          !> V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
          !> are the singular values of A; they are real and non-negative, and
          !> are returned in descending order.  The first min(m,n) columns of
          !> U and V are the left and right singular vectors of A.
          !> Note that the routine returns V**H, not V.
          interface gesvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgesvd(jobu,jobvt,m,n,a,lda,s,u,ldu,vt,ldvt,work,lwork, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu,jobvt
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp),intent(out) :: rwork(*),s(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine cgesvd
#else
               module procedure la_cgesvd
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgesvd(jobu,jobvt,m,n,a,lda,s,u,ldu,vt,ldvt,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu,jobvt
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dgesvd
#else
               module procedure la_dgesvd
#endif
               module procedure la_qgesvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgesvd(jobu,jobvt,m,n,a,lda,s,u,ldu,vt,ldvt,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu,jobvt
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sgesvd
#else
               module procedure la_sgesvd
#endif
               module procedure la_wgesvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgesvd(jobu,jobvt,m,n,a,lda,s,u,ldu,vt,ldvt,work,lwork, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu,jobvt
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp),intent(out) :: rwork(*),s(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine zgesvd
#else
               module procedure la_zgesvd
#endif
          end interface gesvd

          !> GESVDQ: computes the singular value decomposition (SVD) of a complex
          !> M-by-N matrix A, where M >= N. The SVD of A is written as
          !> [++]   [xx]   [x0]   [xx]
          !> A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
          !> [++]   [xx]
          !> where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
          !> matrix, and V is an N-by-N unitary matrix. The diagonal elements
          !> of SIGMA are the singular values of A. The columns of U and V are the
          !> left and the right singular vectors of A, respectively.
          interface gesvdq
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgesvdq(joba,jobp,jobr,jobu,jobv,m,n,a,lda,s,u,ldu,v,ldv, &
                         numrank,iwork,liwork,cwork,lcwork,rwork,lrwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp),intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp),intent(out) :: numrank,info,iwork(*)
                    integer(ilp),intent(inout) :: lcwork
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: u(ldu,*),v(ldv,*),cwork(*)
                    real(sp),intent(out) :: s(*),rwork(*)
               end subroutine cgesvdq
#else
               module procedure la_cgesvdq
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgesvdq(joba,jobp,jobr,jobu,jobv,m,n,a,lda,s,u,ldu,v,ldv, &
                         numrank,iwork,liwork,work,lwork,rwork,lrwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp),intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp),intent(out) :: numrank,info,iwork(*)
                    integer(ilp),intent(inout) :: lwork
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: u(ldu,*),v(ldv,*),work(*),s(*),rwork(*)
               end subroutine dgesvdq
#else
               module procedure la_dgesvdq
#endif
               module procedure la_qgesvdq
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgesvdq(joba,jobp,jobr,jobu,jobv,m,n,a,lda,s,u,ldu,v,ldv, &
                         numrank,iwork,liwork,work,lwork,rwork,lrwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp),intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp),intent(out) :: numrank,info,iwork(*)
                    integer(ilp),intent(inout) :: lwork
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: u(ldu,*),v(ldv,*),work(*),s(*),rwork(*)
               end subroutine sgesvdq
#else
               module procedure la_sgesvdq
#endif
               module procedure la_wgesvdq
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgesvdq(joba,jobp,jobr,jobu,jobv,m,n,a,lda,s,u,ldu,v,ldv, &
                         numrank,iwork,liwork,cwork,lcwork,rwork,lrwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp),intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp),intent(out) :: numrank,info,iwork(*)
                    integer(ilp),intent(inout) :: lcwork
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: u(ldu,*),v(ldv,*),cwork(*)
                    real(dp),intent(out) :: s(*),rwork(*)
               end subroutine zgesvdq
#else
               module procedure la_zgesvdq
#endif
          end interface gesvdq

          !> GESVJ: computes the singular value decomposition (SVD) of a complex
          !> M-by-N matrix A, where M >= N. The SVD of A is written as
          !> [++]   [xx]   [x0]   [xx]
          !> A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
          !> [++]   [xx]
          !> where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
          !> matrix, and V is an N-by-N unitary matrix. The diagonal elements
          !> of SIGMA are the singular values of A. The columns of U and V are the
          !> left and the right singular vectors of A, respectively.
          interface gesvj
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgesvj(joba,jobu,jobv,m,n,a,lda,sva,mv,v,ldv,cwork, &
                         lwork,rwork,lrwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,lrwork,m,mv,n
                    character,intent(in) :: joba,jobu,jobv
                    complex(sp),intent(inout) :: a(lda,*),v(ldv,*),cwork(lwork)
                    real(sp),intent(inout) :: rwork(lrwork)
                    real(sp),intent(out) :: sva(n)
               end subroutine cgesvj
#else
               module procedure la_cgesvj
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgesvj(joba,jobu,jobv,m,n,a,lda,sva,mv,v,ldv,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,m,mv,n
                    character,intent(in) :: joba,jobu,jobv
                    real(dp),intent(inout) :: a(lda,*),v(ldv,*),work(lwork)
                    real(dp),intent(out) :: sva(n)
               end subroutine dgesvj
#else
               module procedure la_dgesvj
#endif
               module procedure la_qgesvj
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgesvj(joba,jobu,jobv,m,n,a,lda,sva,mv,v,ldv,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,m,mv,n
                    character,intent(in) :: joba,jobu,jobv
                    real(sp),intent(inout) :: a(lda,*),v(ldv,*),work(lwork)
                    real(sp),intent(out) :: sva(n)
               end subroutine sgesvj
#else
               module procedure la_sgesvj
#endif
               module procedure la_wgesvj
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgesvj(joba,jobu,jobv,m,n,a,lda,sva,mv,v,ldv,cwork, &
                         lwork,rwork,lrwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,lrwork,m,mv,n
                    character,intent(in) :: joba,jobu,jobv
                    complex(dp),intent(inout) :: a(lda,*),v(ldv,*),cwork(lwork)
                    real(dp),intent(inout) :: rwork(lrwork)
                    real(dp),intent(out) :: sva(n)
               end subroutine zgesvj
#else
               module procedure la_zgesvj
#endif
          end interface gesvj

          !> GETRF: computes an LU factorization of a general M-by-N matrix A
          !> using partial pivoting with row interchanges.
          !> The factorization has the form
          !> A = P * L * U
          !> where P is a permutation matrix, L is lower triangular with unit
          !> diagonal elements (lower trapezoidal if m > n), and U is upper
          !> triangular (upper trapezoidal if m < n).
          !> This is the right-looking Level 3 BLAS version of the algorithm.
          interface getrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgetrf(m,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,m,n
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine cgetrf
#else
               module procedure la_cgetrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgetrf(m,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dgetrf
#else
               module procedure la_dgetrf
#endif
               module procedure la_qgetrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgetrf(m,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine sgetrf
#else
               module procedure la_sgetrf
#endif
               module procedure la_wgetrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgetrf(m,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,m,n
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zgetrf
#else
               module procedure la_zgetrf
#endif
          end interface getrf

          !> GETRF2: computes an LU factorization of a general M-by-N matrix A
          !> using partial pivoting with row interchanges.
          !> The factorization has the form
          !> A = P * L * U
          !> where P is a permutation matrix, L is lower triangular with unit
          !> diagonal elements (lower trapezoidal if m > n), and U is upper
          !> triangular (upper trapezoidal if m < n).
          !> This is the recursive version of the algorithm. It divides
          !> the matrix into four submatrices:
          !> [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
          !> A = [ -----|----- ]  with n1 = min(m,n)/2
          !> [  A21 | A22  ]       n2 = n-n1
          !> [ A11 ]
          !> The subroutine calls itself to factor [ --- ],
          !> [ A12 ]
          !> [ A12 ]
          !> do the swaps on [ --- ], solve A12, update A22,
          !> [ A22 ]
          !> then calls itself to factor A22 and do the swaps on A21.
          interface getrf2
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine cgetrf2(m,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,m,n
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine cgetrf2
#else
               module procedure la_cgetrf2
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine dgetrf2(m,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dgetrf2
#else
               module procedure la_dgetrf2
#endif
               module procedure la_qgetrf2
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine sgetrf2(m,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine sgetrf2
#else
               module procedure la_sgetrf2
#endif
               module procedure la_wgetrf2
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine zgetrf2(m,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,m,n
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zgetrf2
#else
               module procedure la_zgetrf2
#endif
          end interface getrf2

          !> GETRI: computes the inverse of a matrix using the LU factorization
          !> computed by CGETRF.
          !> This method inverts U and then computes inv(A) by solving the system
          !> inv(A)*L = inv(U) for inv(A).
          interface getri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgetri(n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgetri
#else
               module procedure la_cgetri
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgetri(n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n,ipiv(*)
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dgetri
#else
               module procedure la_dgetri
#endif
               module procedure la_qgetri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgetri(n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n,ipiv(*)
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sgetri
#else
               module procedure la_sgetri
#endif
               module procedure la_wgetri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgetri(n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgetri
#else
               module procedure la_zgetri
#endif
          end interface getri

          !> GETRS: solves a system of linear equations
          !> A * X = B,  A**T * X = B,  or  A**H * X = B
          !> with a general N-by-N matrix A using the LU factorization computed
          !> by CGETRF.
          interface getrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgetrs(trans,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine cgetrs
#else
               module procedure la_cgetrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgetrs(trans,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dgetrs
#else
               module procedure la_dgetrs
#endif
               module procedure la_qgetrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgetrs(trans,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine sgetrs
#else
               module procedure la_sgetrs
#endif
               module procedure la_wgetrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgetrs(trans,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zgetrs
#else
               module procedure la_zgetrs
#endif
          end interface getrs

          !> GETSLS: solves overdetermined or underdetermined complex linear systems
          !> involving an M-by-N matrix A, using a tall skinny QR or short wide LQ
          !> factorization of A.  It is assumed that A has full rank.
          !> The following options are provided:
          !> 1. If TRANS = 'N' and m >= n:  find the least squares solution of
          !> an overdetermined system, i.e., solve the least squares problem
          !> minimize || B - A*X ||.
          !> 2. If TRANS = 'N' and m < n:  find the minimum norm solution of
          !> an underdetermined system A * X = B.
          !> 3. If TRANS = 'C' and m >= n:  find the minimum norm solution of
          !> an undetermined system A**T * X = B.
          !> 4. If TRANS = 'C' and m < n:  find the least squares solution of
          !> an overdetermined system, i.e., solve the least squares problem
          !> minimize || B - A**T * X ||.
          !> Several right hand side vectors b and solution vectors x can be
          !> handled in a single call; they are stored as the columns of the
          !> M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !> matrix X.
          interface getsls
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgetsls(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgetsls
#else
               module procedure la_cgetsls
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgetsls(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dgetsls
#else
               module procedure la_dgetsls
#endif
               module procedure la_qgetsls
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgetsls(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sgetsls
#else
               module procedure la_sgetsls
#endif
               module procedure la_wgetsls
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgetsls(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgetsls
#else
               module procedure la_zgetsls
#endif
          end interface getsls

          !> GETSQRHRT: computes a NB2-sized column blocked QR-factorization
          !> of a complex M-by-N matrix A with M >= N,
          !> A = Q * R.
          !> The routine uses internally a NB1-sized column blocked and MB1-sized
          !> row blocked TSQR-factorization and perfors the reconstruction
          !> of the Householder vectors from the TSQR output. The routine also
          !> converts the R_tsqr factor from the TSQR-factorization output into
          !> the R factor that corresponds to the Householder QR-factorization,
          !> A = Q_tsqr * R_tsqr = Q * R.
          !> The output Q and R factors are stored in the same format as in CGEQRT
          !> (Q is in blocked compact WY-representation). See the documentation
          !> of CGEQRT for more details on the format.
          interface getsqrhrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgetsqrhrt(m,n,mb1,nb1,nb2,a,lda,t,ldt,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: t(ldt,*),work(*)
               end subroutine cgetsqrhrt
#else
               module procedure la_cgetsqrhrt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgetsqrhrt(m,n,mb1,nb1,nb2,a,lda,t,ldt,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: t(ldt,*),work(*)
               end subroutine dgetsqrhrt
#else
               module procedure la_dgetsqrhrt
#endif
               module procedure la_qgetsqrhrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgetsqrhrt(m,n,mb1,nb1,nb2,a,lda,t,ldt,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: t(ldt,*),work(*)
               end subroutine sgetsqrhrt
#else
               module procedure la_sgetsqrhrt
#endif
               module procedure la_wgetsqrhrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgetsqrhrt(m,n,mb1,nb1,nb2,a,lda,t,ldt,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: t(ldt,*),work(*)
               end subroutine zgetsqrhrt
#else
               module procedure la_zgetsqrhrt
#endif
          end interface getsqrhrt

          !> GGBAK: forms the right or left eigenvectors of a complex generalized
          !> eigenvalue problem A*x = lambda*B*x, by backward transformation on
          !> the computed eigenvectors of the balanced pair of matrices output by
          !> CGGBAL.
          interface ggbak
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cggbak(job,side,n,ilo,ihi,lscale,rscale,m,v,ldv,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job,side
                    integer(ilp),intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: lscale(*),rscale(*)
                    complex(sp),intent(inout) :: v(ldv,*)
               end subroutine cggbak
#else
               module procedure la_cggbak
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dggbak(job,side,n,ilo,ihi,lscale,rscale,m,v,ldv,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job,side
                    integer(ilp),intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: lscale(*),rscale(*)
                    real(dp),intent(inout) :: v(ldv,*)
               end subroutine dggbak
#else
               module procedure la_dggbak
#endif
               module procedure la_qggbak
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sggbak(job,side,n,ilo,ihi,lscale,rscale,m,v,ldv,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job,side
                    integer(ilp),intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: lscale(*),rscale(*)
                    real(sp),intent(inout) :: v(ldv,*)
               end subroutine sggbak
#else
               module procedure la_sggbak
#endif
               module procedure la_wggbak
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zggbak(job,side,n,ilo,ihi,lscale,rscale,m,v,ldv,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job,side
                    integer(ilp),intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: lscale(*),rscale(*)
                    complex(dp),intent(inout) :: v(ldv,*)
               end subroutine zggbak
#else
               module procedure la_zggbak
#endif
          end interface ggbak

          !> GGBAL: balances a pair of general complex matrices (A,B).  This
          !> involves, first, permuting A and B by similarity transformations to
          !> isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
          !> elements on the diagonal; and second, applying a diagonal similarity
          !> transformation to rows and columns ILO to IHI to make the rows
          !> and columns as close in norm as possible. Both steps are optional.
          !> Balancing may reduce the 1-norm of the matrices, and improve the
          !> accuracy of the computed eigenvalues and/or eigenvectors in the
          !> generalized eigenvalue problem A*x = lambda*B*x.
          interface ggbal
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cggbal(job,n,a,lda,b,ldb,ilo,ihi,lscale,rscale,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job
                    integer(ilp),intent(out) :: ihi,ilo,info
                    integer(ilp),intent(in) :: lda,ldb,n
                    real(sp),intent(out) :: lscale(*),rscale(*),work(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cggbal
#else
               module procedure la_cggbal
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dggbal(job,n,a,lda,b,ldb,ilo,ihi,lscale,rscale,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job
                    integer(ilp),intent(out) :: ihi,ilo,info
                    integer(ilp),intent(in) :: lda,ldb,n
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: lscale(*),rscale(*),work(*)
               end subroutine dggbal
#else
               module procedure la_dggbal
#endif
               module procedure la_qggbal
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sggbal(job,n,a,lda,b,ldb,ilo,ihi,lscale,rscale,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job
                    integer(ilp),intent(out) :: ihi,ilo,info
                    integer(ilp),intent(in) :: lda,ldb,n
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: lscale(*),rscale(*),work(*)
               end subroutine sggbal
#else
               module procedure la_sggbal
#endif
               module procedure la_wggbal
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zggbal(job,n,a,lda,b,ldb,ilo,ihi,lscale,rscale,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: job
                    integer(ilp),intent(out) :: ihi,ilo,info
                    integer(ilp),intent(in) :: lda,ldb,n
                    real(dp),intent(out) :: lscale(*),rscale(*),work(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zggbal
#else
               module procedure la_zggbal
#endif
          end interface ggbal

          !> GGES: computes for a pair of N-by-N complex nonsymmetric matrices
          !> (A,B), the generalized eigenvalues, the generalized complex Schur
          !> form (S, T), and optionally left and/or right Schur vectors (VSL
          !> and VSR). This gives the generalized Schur factorization
          !> (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
          !> where (VSR)**H is the conjugate-transpose of VSR.
          !> Optionally, it also orders the eigenvalues so that a selected cluster
          !> of eigenvalues appears in the leading diagonal blocks of the upper
          !> triangular matrix S and the upper triangular matrix T. The leading
          !> columns of VSL and VSR then form an unitary basis for the
          !> corresponding left and right eigenspaces (deflating subspaces).
          !> (If only the generalized eigenvalues are needed, use the driver
          !> CGGEV instead, which is faster.)
          !> A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
          !> or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
          !> usually represented as the pair (alpha,beta), as there is a
          !> reasonable interpretation for beta=0, and even for both being zero.
          !> A pair of matrices (S,T) is in generalized complex Schur form if S
          !> and T are upper triangular and, in addition, the diagonal elements
          !> of T are non-negative real numbers.
          interface gges
#ifdef LA_EXTERNAL_LAPACK
               subroutine cgges(jobvsl,jobvsr,sort,selctg,n,a,lda,b,ldb,sdim,alpha, &
                         beta,vsl,ldvsl,vsr,ldvsr,work,lwork,rwork,bwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp),intent(out) :: info,sdim
                    integer(ilp),intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk),intent(out) :: bwork(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: alpha(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*),work(*)
                              
                    procedure(la_selctg_c) :: selctg
               end subroutine cgges
#else
               module procedure la_cgges
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dgges(jobvsl,jobvsr,sort,selctg,n,a,lda,b,ldb,sdim,alphar, &
                         alphai,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,bwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp),intent(out) :: info,sdim
                    integer(ilp),intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk),intent(out) :: bwork(*)
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: alphai(*),alphar(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*) &
                              ,work(*)
                    procedure(la_selctg_d) :: selctg
               end subroutine dgges
#else
               module procedure la_dgges
#endif
               module procedure la_qgges
#ifdef LA_EXTERNAL_LAPACK
               subroutine sgges(jobvsl,jobvsr,sort,selctg,n,a,lda,b,ldb,sdim,alphar, &
                         alphai,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,bwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp),intent(out) :: info,sdim
                    integer(ilp),intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk),intent(out) :: bwork(*)
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: alphai(*),alphar(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*) &
                              ,work(*)
                    procedure(la_selctg_s) :: selctg
               end subroutine sgges
#else
               module procedure la_sgges
#endif
               module procedure la_wgges
#ifdef LA_EXTERNAL_LAPACK
               subroutine zgges(jobvsl,jobvsr,sort,selctg,n,a,lda,b,ldb,sdim,alpha, &
                         beta,vsl,ldvsl,vsr,ldvsr,work,lwork,rwork,bwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp),intent(out) :: info,sdim
                    integer(ilp),intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk),intent(out) :: bwork(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: alpha(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*),work(*)
                              
                    procedure(la_selctg_z) :: selctg
               end subroutine zgges
#else
               module procedure la_zgges
#endif
          end interface gges

          !> GGEV: computes for a pair of N-by-N complex nonsymmetric matrices
          !> (A,B), the generalized eigenvalues, and optionally, the left and/or
          !> right generalized eigenvectors.
          !> A generalized eigenvalue for a pair of matrices (A,B) is a scalar
          !> lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
          !> singular. It is usually represented as the pair (alpha,beta), as
          !> there is a reasonable interpretation for beta=0, and even for both
          !> being zero.
          !> The right generalized eigenvector v(j) corresponding to the
          !> generalized eigenvalue lambda(j) of (A,B) satisfies
          !> A * v(j) = lambda(j) * B * v(j).
          !> The left generalized eigenvector u(j) corresponding to the
          !> generalized eigenvalues lambda(j) of (A,B) satisfies
          !> u(j)**H * A = lambda(j) * u(j)**H * B
          !> where u(j)**H is the conjugate-transpose of u(j).
          interface ggev
#ifdef LA_EXTERNAL_LAPACK
               subroutine cggev(jobvl,jobvr,n,a,lda,b,ldb,alpha,beta,vl,ldvl,vr,ldvr, &
                         work,lwork,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvl,jobvr
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: alpha(*),beta(*),vl(ldvl,*),vr(ldvr,*),work(*)
                              
               end subroutine cggev
#else
               module procedure la_cggev
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dggev(jobvl,jobvr,n,a,lda,b,ldb,alphar,alphai,beta,vl,ldvl, &
                         vr,ldvr,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvl,jobvr
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: alphai(*),alphar(*),beta(*),vl(ldvl,*),vr(ldvr,*), &
                              work(*)
               end subroutine dggev
#else
               module procedure la_dggev
#endif
               module procedure la_qggev
#ifdef LA_EXTERNAL_LAPACK
               subroutine sggev(jobvl,jobvr,n,a,lda,b,ldb,alphar,alphai,beta,vl,ldvl, &
                         vr,ldvr,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvl,jobvr
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: alphai(*),alphar(*),beta(*),vl(ldvl,*),vr(ldvr,*), &
                              work(*)
               end subroutine sggev
#else
               module procedure la_sggev
#endif
               module procedure la_wggev
#ifdef LA_EXTERNAL_LAPACK
               subroutine zggev(jobvl,jobvr,n,a,lda,b,ldb,alpha,beta,vl,ldvl,vr,ldvr, &
                         work,lwork,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobvl,jobvr
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: alpha(*),beta(*),vl(ldvl,*),vr(ldvr,*),work(*)
                              
               end subroutine zggev
#else
               module procedure la_zggev
#endif
          end interface ggev

          !> GGGLM: solves a general Gauss-Markov linear model (GLM) problem:
          !> minimize || y ||_2   subject to   d = A*x + B*y
          !> x
          !> where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
          !> given N-vector. It is assumed that M <= N <= M+P, and
          !> rank(A) = M    and    rank( A B ) = N.
          !> Under these assumptions, the constrained equation is always
          !> consistent, and there is a unique solution x and a minimal 2-norm
          !> solution y, which is obtained using a generalized QR factorization
          !> of the matrices (A, B) given by
          !> A = Q*(R),   B = Q*T*Z.
          !> (0)
          !> In particular, if matrix B is square nonsingular, then the problem
          !> GLM is equivalent to the following weighted linear least squares
          !> problem
          !> minimize || inv(B)*(d-A*x) ||_2
          !> x
          !> where inv(B) denotes the inverse of B.
          interface ggglm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cggglm(n,m,p,a,lda,b,ldb,d,x,y,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    complex(sp),intent(out) :: work(*),x(*),y(*)
               end subroutine cggglm
#else
               module procedure la_cggglm
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dggglm(n,m,p,a,lda,b,ldb,d,x,y,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    real(dp),intent(out) :: work(*),x(*),y(*)
               end subroutine dggglm
#else
               module procedure la_dggglm
#endif
               module procedure la_qggglm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sggglm(n,m,p,a,lda,b,ldb,d,x,y,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    real(sp),intent(out) :: work(*),x(*),y(*)
               end subroutine sggglm
#else
               module procedure la_sggglm
#endif
               module procedure la_wggglm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zggglm(n,m,p,a,lda,b,ldb,d,x,y,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    complex(dp),intent(out) :: work(*),x(*),y(*)
               end subroutine zggglm
#else
               module procedure la_zggglm
#endif
          end interface ggglm

          !> GGHRD: reduces a pair of complex matrices (A,B) to generalized upper
          !> Hessenberg form using unitary transformations, where A is a
          !> general matrix and B is upper triangular.  The form of the generalized
          !> eigenvalue problem is
          !> A*x = lambda*B*x,
          !> and B is typically made upper triangular by computing its QR
          !> factorization and moving the unitary matrix Q to the left side
          !> of the equation.
          !> This subroutine simultaneously reduces A to a Hessenberg matrix H:
          !> Q**H*A*Z = H
          !> and transforms B to another upper triangular matrix T:
          !> Q**H*B*Z = T
          !> in order to reduce the problem to its standard form
          !> H*y = lambda*T*y
          !> where y = Z**H*x.
          !> The unitary matrices Q and Z are determined as products of Givens
          !> rotations.  They may either be formed explicitly, or they may be
          !> postmultiplied into input matrices Q1 and Z1, so that
          !> Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
          !> Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
          !> If Q1 is the unitary matrix from the QR factorization of B in the
          !> original equation A*x = lambda*B*x, then GGHRD reduces the original
          !> problem to generalized Hessenberg form.
          interface gghrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgghrd(compq,compz,n,ilo,ihi,a,lda,b,ldb,q,ldq,z,ldz, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,compz
                    integer(ilp),intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine cgghrd
#else
               module procedure la_cgghrd
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgghrd(compq,compz,n,ilo,ihi,a,lda,b,ldb,q,ldq,z,ldz, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,compz
                    integer(ilp),intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine dgghrd
#else
               module procedure la_dgghrd
#endif
               module procedure la_qgghrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgghrd(compq,compz,n,ilo,ihi,a,lda,b,ldb,q,ldq,z,ldz, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,compz
                    integer(ilp),intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine sgghrd
#else
               module procedure la_sgghrd
#endif
               module procedure la_wgghrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgghrd(compq,compz,n,ilo,ihi,a,lda,b,ldb,q,ldq,z,ldz, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,compz
                    integer(ilp),intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine zgghrd
#else
               module procedure la_zgghrd
#endif
          end interface gghrd

          !> GGLSE: solves the linear equality-constrained least squares (LSE)
          !> problem:
          !> minimize || c - A*x ||_2   subject to   B*x = d
          !> where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
          !> M-vector, and d is a given P-vector. It is assumed that
          !> P <= N <= M+P, and
          !> rank(B) = P and  rank( (A) ) = N.
          !> ( (B) )
          !> These conditions ensure that the LSE problem has a unique solution,
          !> which is obtained using a generalized RQ factorization of the
          !> matrices (B, A) given by
          !> B = (0 R)*Q,   A = Z*T*Q.
          interface gglse
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    complex(sp),intent(out) :: work(*),x(*)
               end subroutine cgglse
#else
               module procedure la_cgglse
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    real(dp),intent(out) :: work(*),x(*)
               end subroutine dgglse
#else
               module procedure la_dgglse
#endif
               module procedure la_qgglse
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    real(sp),intent(out) :: work(*),x(*)
               end subroutine sgglse
#else
               module procedure la_sgglse
#endif
               module procedure la_wgglse
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    complex(dp),intent(out) :: work(*),x(*)
               end subroutine zgglse
#else
               module procedure la_zgglse
#endif
          end interface gglse

          !> GGQRF: computes a generalized QR factorization of an N-by-M matrix A
          !> and an N-by-P matrix B:
          !> A = Q*R,        B = Q*T*Z,
          !> where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
          !> and R and T assume one of the forms:
          !> if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,
          !> (  0  ) N-M                         N   M-N
          !> M
          !> where R11 is upper triangular, and
          !> if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,
          !> P-N  N                           ( T21 ) P
          !> P
          !> where T12 or T21 is upper triangular.
          !> In particular, if B is square and nonsingular, the GQR factorization
          !> of A and B implicitly gives the QR factorization of inv(B)*A:
          !> inv(B)*A = Z**H * (inv(T)*R)
          !> where inv(B) denotes the inverse of the matrix B, and Z' denotes the
          !> conjugate transpose of matrix Z.
          interface ggqrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cggqrf(n,m,p,a,lda,taua,b,ldb,taub,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: taua(*),taub(*),work(*)
               end subroutine cggqrf
#else
               module procedure la_cggqrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dggqrf(n,m,p,a,lda,taua,b,ldb,taub,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: taua(*),taub(*),work(*)
               end subroutine dggqrf
#else
               module procedure la_dggqrf
#endif
               module procedure la_qggqrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sggqrf(n,m,p,a,lda,taua,b,ldb,taub,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: taua(*),taub(*),work(*)
               end subroutine sggqrf
#else
               module procedure la_sggqrf
#endif
               module procedure la_wggqrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zggqrf(n,m,p,a,lda,taua,b,ldb,taub,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: taua(*),taub(*),work(*)
               end subroutine zggqrf
#else
               module procedure la_zggqrf
#endif
          end interface ggqrf

          !> GGRQF: computes a generalized RQ factorization of an M-by-N matrix A
          !> and a P-by-N matrix B:
          !> A = R*Q,        B = Z*T*Q,
          !> where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
          !> matrix, and R and T assume one of the forms:
          !> if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,
          !> N-M  M                           ( R21 ) N
          !> N
          !> where R12 or R21 is upper triangular, and
          !> if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,
          !> (  0  ) P-N                         P   N-P
          !> N
          !> where T11 is upper triangular.
          !> In particular, if B is square and nonsingular, the GRQ factorization
          !> of A and B implicitly gives the RQ factorization of A*inv(B):
          !> A*inv(B) = (R*inv(T))*Z**H
          !> where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
          !> conjugate transpose of the matrix Z.
          interface ggrqf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cggrqf(m,p,n,a,lda,taua,b,ldb,taub,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: taua(*),taub(*),work(*)
               end subroutine cggrqf
#else
               module procedure la_cggrqf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dggrqf(m,p,n,a,lda,taua,b,ldb,taub,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: taua(*),taub(*),work(*)
               end subroutine dggrqf
#else
               module procedure la_dggrqf
#endif
               module procedure la_qggrqf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sggrqf(m,p,n,a,lda,taua,b,ldb,taub,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: taua(*),taub(*),work(*)
               end subroutine sggrqf
#else
               module procedure la_sggrqf
#endif
               module procedure la_wggrqf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zggrqf(m,p,n,a,lda,taua,b,ldb,taub,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: taua(*),taub(*),work(*)
               end subroutine zggrqf
#else
               module procedure la_zggrqf
#endif
          end interface ggrqf

          !> GSVJ0: is called from CGESVJ as a pre-processor and that is its main
          !> purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
          !> it does not check convergence (stopping criterion). Few tuning
          !> parameters (marked by [TP]) are available for the implementer.
          interface gsvj0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgsvj0(jobv,m,n,a,lda,d,sva,mv,v,ldv,eps,sfmin,tol, &
                         nsweep,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(sp),intent(in) :: eps,sfmin,tol
                    character,intent(in) :: jobv
                    complex(sp),intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(sp),intent(out) :: work(lwork)
                    real(sp),intent(inout) :: sva(n)
               end subroutine cgsvj0
#else
               module procedure la_cgsvj0
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgsvj0(jobv,m,n,a,lda,d,sva,mv,v,ldv,eps,sfmin,tol, &
                         nsweep,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(dp),intent(in) :: eps,sfmin,tol
                    character,intent(in) :: jobv
                    real(dp),intent(inout) :: a(lda,*),sva(n),d(n),v(ldv,*)
                    real(dp),intent(out) :: work(lwork)
               end subroutine dgsvj0
#else
               module procedure la_dgsvj0
#endif
               module procedure la_qgsvj0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgsvj0(jobv,m,n,a,lda,d,sva,mv,v,ldv,eps,sfmin,tol, &
                         nsweep,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(sp),intent(in) :: eps,sfmin,tol
                    character,intent(in) :: jobv
                    real(sp),intent(inout) :: a(lda,*),sva(n),d(n),v(ldv,*)
                    real(sp),intent(out) :: work(lwork)
               end subroutine sgsvj0
#else
               module procedure la_sgsvj0
#endif
               module procedure la_wgsvj0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgsvj0(jobv,m,n,a,lda,d,sva,mv,v,ldv,eps,sfmin,tol, &
                         nsweep,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(dp),intent(in) :: eps,sfmin,tol
                    character,intent(in) :: jobv
                    complex(dp),intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(dp),intent(out) :: work(lwork)
                    real(dp),intent(inout) :: sva(n)
               end subroutine zgsvj0
#else
               module procedure la_zgsvj0
#endif
          end interface gsvj0

          !> GSVJ1: is called from CGESVJ as a pre-processor and that is its main
          !> purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
          !> it targets only particular pivots and it does not check convergence
          !> (stopping criterion). Few tuning parameters (marked by [TP]) are
          !> available for the implementer.
          !> Further Details
          !> ~~~~~~~~~~~~~~~
          !> GSVJ1 applies few sweeps of Jacobi rotations in the column space of
          !> the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
          !> off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
          !> block-entries (tiles) of the (1,2) off-diagonal block are marked by the
          !> [x]'s in the following scheme:
          !> | *  *  * [x] [x] [x]|
          !> | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
          !> | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
          !> |[x] [x] [x] *  *  * |
          !> |[x] [x] [x] *  *  * |
          !> |[x] [x] [x] *  *  * |
          !> In terms of the columns of A, the first N1 columns are rotated 'against'
          !> the remaining N-N1 columns, trying to increase the angle between the
          !> corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
          !> tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter.
          !> The number of sweeps is given in NSWEEP and the orthogonality threshold
          !> is given in TOL.
          interface gsvj1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgsvj1(jobv,m,n,n1,a,lda,d,sva,mv,v,ldv,eps,sfmin,tol, &
                          nsweep,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: eps,sfmin,tol
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character,intent(in) :: jobv
                    complex(sp),intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(sp),intent(out) :: work(lwork)
                    real(sp),intent(inout) :: sva(n)
               end subroutine cgsvj1
#else
               module procedure la_cgsvj1
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgsvj1(jobv,m,n,n1,a,lda,d,sva,mv,v,ldv,eps,sfmin,tol, &
                          nsweep,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: eps,sfmin,tol
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character,intent(in) :: jobv
                    real(dp),intent(inout) :: a(lda,*),d(n),sva(n),v(ldv,*)
                    real(dp),intent(out) :: work(lwork)
               end subroutine dgsvj1
#else
               module procedure la_dgsvj1
#endif
               module procedure la_qgsvj1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgsvj1(jobv,m,n,n1,a,lda,d,sva,mv,v,ldv,eps,sfmin,tol, &
                          nsweep,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: eps,sfmin,tol
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character,intent(in) :: jobv
                    real(sp),intent(inout) :: a(lda,*),d(n),sva(n),v(ldv,*)
                    real(sp),intent(out) :: work(lwork)
               end subroutine sgsvj1
#else
               module procedure la_sgsvj1
#endif
               module procedure la_wgsvj1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgsvj1(jobv,m,n,n1,a,lda,d,sva,mv,v,ldv,eps,sfmin,tol, &
                          nsweep,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: eps,sfmin,tol
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character,intent(in) :: jobv
                    complex(dp),intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(dp),intent(out) :: work(lwork)
                    real(dp),intent(inout) :: sva(n)
               end subroutine zgsvj1
#else
               module procedure la_zgsvj1
#endif
          end interface gsvj1

          !> GTCON: estimates the reciprocal of the condition number of a complex
          !> tridiagonal matrix A using the LU factorization as computed by
          !> CGTTRF.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
          interface gtcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgtcon(norm,n,dl,d,du,du2,ipiv,anorm,rcond,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond
                    complex(sp),intent(in) :: d(*),dl(*),du(*),du2(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cgtcon
#else
               module procedure la_cgtcon
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgtcon(norm,n,dl,d,du,du2,ipiv,anorm,rcond,work,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(dp),intent(in) :: anorm,d(*),dl(*),du(*),du2(*)
                    real(dp),intent(out) :: rcond,work(*)
               end subroutine dgtcon
#else
               module procedure la_dgtcon
#endif
               module procedure la_qgtcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgtcon(norm,n,dl,d,du,du2,ipiv,anorm,rcond,work,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(sp),intent(in) :: anorm,d(*),dl(*),du(*),du2(*)
                    real(sp),intent(out) :: rcond,work(*)
               end subroutine sgtcon
#else
               module procedure la_sgtcon
#endif
               module procedure la_wgtcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgtcon(norm,n,dl,d,du,du2,ipiv,anorm,rcond,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond
                    complex(dp),intent(in) :: d(*),dl(*),du(*),du2(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zgtcon
#else
               module procedure la_zgtcon
#endif
          end interface gtcon

          !> GTRFS: improves the computed solution to a system of linear
          !> equations when the coefficient matrix is tridiagonal, and provides
          !> error bounds and backward error estimates for the solution.
          interface gtrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgtrfs(trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb, &
                         x,ldx,ferr,berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf( &
                              *)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine cgtrfs
#else
               module procedure la_cgtrfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgtrfs(trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb, &
                         x,ldx,ferr,berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(*)
                              
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dgtrfs
#else
               module procedure la_dgtrfs
#endif
               module procedure la_qgtrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgtrfs(trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb, &
                         x,ldx,ferr,berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(*)
                              
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine sgtrfs
#else
               module procedure la_sgtrfs
#endif
               module procedure la_wgtrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgtrfs(trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb, &
                         x,ldx,ferr,berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf( &
                              *)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zgtrfs
#else
               module procedure la_zgtrfs
#endif
          end interface gtrfs

          !> GTSV:  solves the equation
          !> A*X = B,
          !> where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
          !> partial pivoting.
          !> Note that the equation  A**T *X = B  may be solved by interchanging the
          !> order of the arguments DU and DL.
          interface gtsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgtsv(n,nrhs,dl,d,du,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(sp),intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine cgtsv
#else
               module procedure la_cgtsv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgtsv(n,nrhs,dl,d,du,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(dp),intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine dgtsv
#else
               module procedure la_dgtsv
#endif
               module procedure la_qgtsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgtsv(n,nrhs,dl,d,du,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(sp),intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine sgtsv
#else
               module procedure la_sgtsv
#endif
               module procedure la_wgtsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgtsv(n,nrhs,dl,d,du,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(dp),intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine zgtsv
#else
               module procedure la_zgtsv
#endif
          end interface gtsv

          !> GTTRF: computes an LU factorization of a complex tridiagonal matrix A
          !> using elimination with partial pivoting and row interchanges.
          !> The factorization has the form
          !> A = L * U
          !> where L is a product of permutation and unit lower bidiagonal
          !> matrices and U is upper triangular with nonzeros in only the main
          !> diagonal and first two superdiagonals.
          interface gttrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgttrf(n,dl,d,du,du2,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(inout) :: d(*),dl(*),du(*)
                    complex(sp),intent(out) :: du2(*)
               end subroutine cgttrf
#else
               module procedure la_cgttrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgttrf(n,dl,d,du,du2,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: d(*),dl(*),du(*)
                    real(dp),intent(out) :: du2(*)
               end subroutine dgttrf
#else
               module procedure la_dgttrf
#endif
               module procedure la_qgttrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgttrf(n,dl,d,du,du2,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: d(*),dl(*),du(*)
                    real(sp),intent(out) :: du2(*)
               end subroutine sgttrf
#else
               module procedure la_sgttrf
#endif
               module procedure la_wgttrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgttrf(n,dl,d,du,du2,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(inout) :: d(*),dl(*),du(*)
                    complex(dp),intent(out) :: du2(*)
               end subroutine zgttrf
#else
               module procedure la_zgttrf
#endif
          end interface gttrf

          !> GTTRS: solves one of the systems of equations
          !> A * X = B,  A**T * X = B,  or  A**H * X = B,
          !> with a tridiagonal matrix A using the LU factorization computed
          !> by CGTTRF.
          interface gttrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cgttrs(trans,n,nrhs,dl,d,du,du2,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(inout) :: b(ldb,*)
                    complex(sp),intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine cgttrs
#else
               module procedure la_cgttrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dgttrs(trans,n,nrhs,dl,d,du,du2,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(dp),intent(inout) :: b(ldb,*)
                    real(dp),intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine dgttrs
#else
               module procedure la_dgttrs
#endif
               module procedure la_qgttrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sgttrs(trans,n,nrhs,dl,d,du,du2,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(sp),intent(inout) :: b(ldb,*)
                    real(sp),intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine sgttrs
#else
               module procedure la_sgttrs
#endif
               module procedure la_wgttrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zgttrs(trans,n,nrhs,dl,d,du,du2,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(inout) :: b(ldb,*)
                    complex(dp),intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine zgttrs
#else
               module procedure la_zgttrs
#endif
          end interface gttrs

          !> HB2ST_KERNELS: is an internal routine used by the CHETRD_HB2ST
          !> subroutine.
          interface hb2st_kernels
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chb2st_kernels(uplo,wantz,ttype,st,ed,sweep,n,nb,ib,a, &
                         lda,v,tau,ldvt,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    logical(lk),intent(in) :: wantz
                    integer(ilp),intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: v(*),tau(*),work(*)
               end subroutine chb2st_kernels
#else
               module procedure la_chb2st_kernels
#endif
               module procedure la_whb2st_kernels
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhb2st_kernels(uplo,wantz,ttype,st,ed,sweep,n,nb,ib,a, &
                         lda,v,tau,ldvt,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    logical(lk),intent(in) :: wantz
                    integer(ilp),intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: v(*),tau(*),work(*)
               end subroutine zhb2st_kernels
#else
               module procedure la_zhb2st_kernels
#endif
          end interface hb2st_kernels

          !> HBEV: computes all the eigenvalues and, optionally, eigenvectors of
          !> a complex Hermitian band matrix A.
          interface hbev
#ifdef LA_EXTERNAL_LAPACK
               subroutine chbev(jobz,uplo,n,kd,ab,ldab,w,z,ldz,work,rwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldz,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: ab(ldab,*)
                    complex(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine chbev
#else
               module procedure la_chbev
#endif
               module procedure la_whbev
#ifdef LA_EXTERNAL_LAPACK
               subroutine zhbev(jobz,uplo,n,kd,ab,ldab,w,z,ldz,work,rwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldz,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: ab(ldab,*)
                    complex(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine zhbev
#else
               module procedure la_zhbev
#endif
          end interface hbev

          !> HBEVD: computes all the eigenvalues and, optionally, eigenvectors of
          !> a complex Hermitian band matrix A.  If eigenvectors are desired, it
          !> uses a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface hbevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine chbevd(jobz,uplo,n,kd,ab,ldab,w,z,ldz,work,lwork,rwork, &
                         lrwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,ldz,liwork,lrwork,lwork,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: ab(ldab,*)
                    complex(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine chbevd
#else
               module procedure la_chbevd
#endif
               module procedure la_whbevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine zhbevd(jobz,uplo,n,kd,ab,ldab,w,z,ldz,work,lwork,rwork, &
                         lrwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,ldz,liwork,lrwork,lwork,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: ab(ldab,*)
                    complex(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine zhbevd
#else
               module procedure la_zhbevd
#endif
          end interface hbevd

          !> HBGST: reduces a complex Hermitian-definite banded generalized
          !> eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
          !> such that C has the same bandwidth as A.
          !> B must have been previously factorized as S**H*S by CPBSTF, using a
          !> split Cholesky factorization. A is overwritten by C = X**H*A*X, where
          !> X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
          !> bandwidth of A.
          interface hbgst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chbgst(vect,uplo,n,ka,kb,ab,ldab,bb,ldbb,x,ldx,work, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: ab(ldab,*)
                    complex(sp),intent(in) :: bb(ldbb,*)
                    complex(sp),intent(out) :: work(*),x(ldx,*)
               end subroutine chbgst
#else
               module procedure la_chbgst
#endif
               module procedure la_whbgst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhbgst(vect,uplo,n,ka,kb,ab,ldab,bb,ldbb,x,ldx,work, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: ab(ldab,*)
                    complex(dp),intent(in) :: bb(ldbb,*)
                    complex(dp),intent(out) :: work(*),x(ldx,*)
               end subroutine zhbgst
#else
               module procedure la_zhbgst
#endif
          end interface hbgst

          !> HBGV: computes all the eigenvalues, and optionally, the eigenvectors
          !> of a complex generalized Hermitian-definite banded eigenproblem, of
          !> the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
          !> and banded, and B is also positive definite.
          interface hbgv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chbgv(jobz,uplo,n,ka,kb,ab,ldab,bb,ldbb,w,z,ldz,work, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine chbgv
#else
               module procedure la_chbgv
#endif
               module procedure la_whbgv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhbgv(jobz,uplo,n,ka,kb,ab,ldab,bb,ldbb,w,z,ldz,work, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine zhbgv
#else
               module procedure la_zhbgv
#endif
          end interface hbgv

          !> HBGVD: computes all the eigenvalues, and optionally, the eigenvectors
          !> of a complex generalized Hermitian-definite banded eigenproblem, of
          !> the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
          !> and banded, and B is also positive definite.  If eigenvectors are
          !> desired, it uses a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface hbgvd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chbgvd(jobz,uplo,n,ka,kb,ab,ldab,bb,ldbb,w,z,ldz,work, &
                         lwork,rwork,lrwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lrwork,lwork,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine chbgvd
#else
               module procedure la_chbgvd
#endif
               module procedure la_whbgvd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhbgvd(jobz,uplo,n,ka,kb,ab,ldab,bb,ldbb,w,z,ldz,work, &
                         lwork,rwork,lrwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lrwork,lwork,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine zhbgvd
#else
               module procedure la_zhbgvd
#endif
          end interface hbgvd

          !> HBTRD: reduces a complex Hermitian band matrix A to real symmetric
          !> tridiagonal form T by a unitary similarity transformation:
          !> Q**H * A * Q = T.
          interface hbtrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chbtrd(vect,uplo,n,kd,ab,ldab,d,e,q,ldq,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldq,n
                    real(sp),intent(out) :: d(*),e(*)
                    complex(sp),intent(inout) :: ab(ldab,*),q(ldq,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chbtrd
#else
               module procedure la_chbtrd
#endif
               module procedure la_whbtrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhbtrd(vect,uplo,n,kd,ab,ldab,d,e,q,ldq,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldq,n
                    real(dp),intent(out) :: d(*),e(*)
                    complex(dp),intent(inout) :: ab(ldab,*),q(ldq,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhbtrd
#else
               module procedure la_zhbtrd
#endif
          end interface hbtrd

          !> HECON: estimates the reciprocal of the condition number of a complex
          !> Hermitian matrix A using the factorization A = U*D*U**H or
          !> A = L*D*L**H computed by CHETRF.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
          interface hecon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine checon(uplo,n,a,lda,ipiv,anorm,rcond,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine checon
#else
               module procedure la_checon
#endif
               module procedure la_whecon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhecon(uplo,n,a,lda,ipiv,anorm,rcond,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhecon
#else
               module procedure la_zhecon
#endif
          end interface hecon

          !> HECON_ROOK: estimates the reciprocal of the condition number of a complex
          !> Hermitian matrix A using the factorization A = U*D*U**H or
          !> A = L*D*L**H computed by CHETRF_ROOK.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
          interface hecon_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine checon_rook(uplo,n,a,lda,ipiv,anorm,rcond,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine checon_rook
#else
               module procedure la_checon_rook
#endif
               module procedure la_whecon_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhecon_rook(uplo,n,a,lda,ipiv,anorm,rcond,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhecon_rook
#else
               module procedure la_zhecon_rook
#endif
          end interface hecon_rook

          !> HEEQUB: computes row and column scalings intended to equilibrate a
          !> Hermitian matrix A (with respect to the Euclidean norm) and reduce
          !> its condition number. The scale factors S are computed by the BIN
          !> algorithm (see references) so that the scaled matrix B with elements
          !> B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
          !> the smallest possible condition number over all possible diagonal
          !> scalings.
          interface heequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cheequb(uplo,n,a,lda,s,scond,amax,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: amax,scond,s(*)
                    character,intent(in) :: uplo
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cheequb
#else
               module procedure la_cheequb
#endif
               module procedure la_wheequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zheequb(uplo,n,a,lda,s,scond,amax,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: amax,scond,s(*)
                    character,intent(in) :: uplo
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zheequb
#else
               module procedure la_zheequb
#endif
          end interface heequb

          !> HEEV: computes all eigenvalues and, optionally, eigenvectors of a
          !> complex Hermitian matrix A.
          interface heev
#ifdef LA_EXTERNAL_LAPACK
               subroutine cheev(jobz,uplo,n,a,lda,w,work,lwork,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cheev
#else
               module procedure la_cheev
#endif
               module procedure la_wheev
#ifdef LA_EXTERNAL_LAPACK
               subroutine zheev(jobz,uplo,n,a,lda,w,work,lwork,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zheev
#else
               module procedure la_zheev
#endif
          end interface heev

          !> HEEVD: computes all eigenvalues and, optionally, eigenvectors of a
          !> complex Hermitian matrix A.  If eigenvectors are desired, it uses a
          !> divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface heevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine cheevd(jobz,uplo,n,a,lda,w,work,lwork,rwork,lrwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,liwork,lrwork,lwork,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cheevd
#else
               module procedure la_cheevd
#endif
               module procedure la_wheevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine zheevd(jobz,uplo,n,a,lda,w,work,lwork,rwork,lrwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,liwork,lrwork,lwork,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zheevd
#else
               module procedure la_zheevd
#endif
          end interface heevd

          !> HEEVR: computes selected eigenvalues and, optionally, eigenvectors
          !> of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
          !> be selected by specifying either a range of values or a range of
          !> indices for the desired eigenvalues.
          !> HEEVR first reduces the matrix A to tridiagonal form T with a call
          !> to CHETRD.  Then, whenever possible, HEEVR calls CSTEMR to compute
          !> the eigenspectrum using Relatively Robust Representations.  CSTEMR
          !> computes eigenvalues by the dqds algorithm, while orthogonal
          !> eigenvectors are computed from various "good" L D L^T representations
          !> (also known as Relatively Robust Representations). Gram-Schmidt
          !> orthogonalization is avoided as far as possible. More specifically,
          !> the various steps of the algorithm are as follows.
          !> For each unreduced block (submatrix) of T,
          !> (a) Compute T - sigma I  = L D L^T, so that L and D
          !> define all the wanted eigenvalues to high relative accuracy.
          !> This means that small relative changes in the entries of D and L
          !> cause only small relative changes in the eigenvalues and
          !> eigenvectors. The standard (unfactored) representation of the
          !> tridiagonal matrix T does not have this property in general.
          !> (b) Compute the eigenvalues to suitable accuracy.
          !> If the eigenvectors are desired, the algorithm attains full
          !> accuracy of the computed eigenvalues only right before
          !> the corresponding vectors have to be computed, see steps c) and d).
          !> (c) For each cluster of close eigenvalues, select a new
          !> shift close to the cluster, find a new factorization, and refine
          !> the shifted eigenvalues to suitable accuracy.
          !> (d) For each eigenvalue with a large enough relative separation compute
          !> the corresponding eigenvector by forming a rank revealing twisted
          !> factorization. Go back to (c) for any clusters that remain.
          !> The desired accuracy of the output can be specified by the input
          !> parameter ABSTOL.
          !> For more details, see CSTEMR's documentation and:
          !> - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
          !> to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
          !> Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
          !> - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
          !> Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
          !> 2004.  Also LAPACK Working Note 154.
          !> - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
          !> tridiagonal eigenvalue/eigenvector problem",
          !> Computer Science Division Technical Report No. UCB/CSD-97-971,
          !> UC Berkeley, May 1997.
          !> Note 1 : HEEVR calls CSTEMR when the full spectrum is requested
          !> on machines which conform to the ieee-754 floating point standard.
          !> HEEVR calls SSTEBZ and CSTEIN on non-ieee machines and
          !> when partial spectrum requests are made.
          !> Normal execution of CSTEMR may create NaNs and infinities and
          !> hence may abort due to a floating point exception in environments
          !> which do not handle NaNs and infinities in the ieee standard default
          !> manner.
          interface heevr
#ifdef LA_EXTERNAL_LAPACK
               subroutine cheevr(jobz,range,uplo,n,a,lda,vl,vu,il,iu,abstol,m,w,z, &
                         ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range,uplo
                    integer(ilp),intent(in) :: il,iu,lda,ldz,liwork,lrwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp),intent(in) :: abstol,vl,vu
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine cheevr
#else
               module procedure la_cheevr
#endif
               module procedure la_wheevr
#ifdef LA_EXTERNAL_LAPACK
               subroutine zheevr(jobz,range,uplo,n,a,lda,vl,vu,il,iu,abstol,m,w,z, &
                         ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range,uplo
                    integer(ilp),intent(in) :: il,iu,lda,ldz,liwork,lrwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp),intent(in) :: abstol,vl,vu
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine zheevr
#else
               module procedure la_zheevr
#endif
          end interface heevr

          !> HEGST: reduces a complex Hermitian-definite generalized
          !> eigenproblem to standard form.
          !> If ITYPE = 1, the problem is A*x = lambda*B*x,
          !> and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
          !> If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !> B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
          !> B must have been previously factorized as U**H*U or L*L**H by CPOTRF.
          interface hegst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chegst(itype,uplo,n,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,lda,ldb,n
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine chegst
#else
               module procedure la_chegst
#endif
               module procedure la_whegst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhegst(itype,uplo,n,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,lda,ldb,n
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zhegst
#else
               module procedure la_zhegst
#endif
          end interface hegst

          !> HEGV: computes all the eigenvalues, and optionally, the eigenvectors
          !> of a complex generalized Hermitian-definite eigenproblem, of the form
          !> A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !> Here A and B are assumed to be Hermitian and B is also
          !> positive definite.
          interface hegv
#ifdef LA_EXTERNAL_LAPACK
               subroutine chegv(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,lda,ldb,lwork,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chegv
#else
               module procedure la_chegv
#endif
               module procedure la_whegv
#ifdef LA_EXTERNAL_LAPACK
               subroutine zhegv(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,lda,ldb,lwork,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhegv
#else
               module procedure la_zhegv
#endif
          end interface hegv

          !> HEGVD: computes all the eigenvalues, and optionally, the eigenvectors
          !> of a complex generalized Hermitian-definite eigenproblem, of the form
          !> A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !> B are assumed to be Hermitian and B is also positive definite.
          !> If eigenvectors are desired, it uses a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface hegvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine chegvd(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork, &
                         lrwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: itype,lda,ldb,liwork,lrwork,lwork,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chegvd
#else
               module procedure la_chegvd
#endif
               module procedure la_whegvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine zhegvd(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork, &
                         lrwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: itype,lda,ldb,liwork,lrwork,lwork,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhegvd
#else
               module procedure la_zhegvd
#endif
          end interface hegvd

          !> HERFS: improves the computed solution to a system of linear
          !> equations when the coefficient matrix is Hermitian indefinite, and
          !> provides error bounds and backward error estimates for the solution.
          interface herfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cherfs(uplo,n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,ferr, &
                          berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine cherfs
#else
               module procedure la_cherfs
#endif
               module procedure la_wherfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zherfs(uplo,n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,ferr, &
                          berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zherfs
#else
               module procedure la_zherfs
#endif
          end interface herfs

          !> HESV: computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
          !> matrices.
          !> The diagonal pivoting method is used to factor A as
          !> A = U * D * U**H,  if UPLO = 'U', or
          !> A = L * D * L**H,  if UPLO = 'L',
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and D is Hermitian and block diagonal with
          !> 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
          !> used to solve the system of equations A * X = B.
          interface hesv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chesv(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chesv
#else
               module procedure la_chesv
#endif
               module procedure la_whesv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhesv(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhesv
#else
               module procedure la_zhesv
#endif
          end interface hesv

          !> HESV_AA: computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
          !> matrices.
          !> Aasen's algorithm is used to factor A as
          !> A = U**H * T * U,  if UPLO = 'U', or
          !> A = L * T * L**H,  if UPLO = 'L',
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and T is Hermitian and tridiagonal. The factored form
          !> of A is then used to solve the system of equations A * X = B.
          interface hesv_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chesv_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chesv_aa
#else
               module procedure la_chesv_aa
#endif
               module procedure la_whesv_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhesv_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhesv_aa
#else
               module procedure la_zhesv_aa
#endif
          end interface hesv_aa

          !> HESV_RK: computes the solution to a complex system of linear
          !> equations A * X = B, where A is an N-by-N Hermitian matrix
          !> and X and B are N-by-NRHS matrices.
          !> The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
          !> to factor A as
          !> A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
          !> A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
          !> where U (or L) is unit upper (or lower) triangular matrix,
          !> U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !> matrix, P**T is the transpose of P, and D is Hermitian and block
          !> diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !> CHETRF_RK is called to compute the factorization of a complex
          !> Hermitian matrix.  The factored form of A is then used to solve
          !> the system of equations A * X = B by calling BLAS3 routine CHETRS_3.
          interface hesv_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chesv_rk(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: e(*),work(*)
               end subroutine chesv_rk
#else
               module procedure la_chesv_rk
#endif
               module procedure la_whesv_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhesv_rk(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: e(*),work(*)
               end subroutine zhesv_rk
#else
               module procedure la_zhesv_rk
#endif
          end interface hesv_rk

          !> HESV_ROOK: computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
          !> matrices.
          !> The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
          !> to factor A as
          !> A = U * D * U**T,  if UPLO = 'U', or
          !> A = L * D * L**T,  if UPLO = 'L',
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and D is Hermitian and block diagonal with
          !> 1-by-1 and 2-by-2 diagonal blocks.
          !> CHETRF_ROOK is called to compute the factorization of a complex
          !> Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
          !> pivoting method.
          !> The factored form of A is then used to solve the system
          !> of equations A * X = B by calling CHETRS_ROOK (uses BLAS 2).
          interface hesv_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chesv_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chesv_rook
#else
               module procedure la_chesv_rook
#endif
               module procedure la_whesv_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhesv_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhesv_rook
#else
               module procedure la_zhesv_rook
#endif
          end interface hesv_rook

          !> HESWAPR: applies an elementary permutation on the rows and the columns of
          !> a hermitian matrix.
          interface heswapr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cheswapr(uplo,n,a,lda,i1,i2)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: i1,i2,lda,n
                    complex(sp),intent(inout) :: a(lda,n)
               end subroutine cheswapr
#else
               module procedure la_cheswapr
#endif
               module procedure la_wheswapr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zheswapr(uplo,n,a,lda,i1,i2)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: i1,i2,lda,n
                    complex(dp),intent(inout) :: a(lda,n)
               end subroutine zheswapr
#else
               module procedure la_zheswapr
#endif
          end interface heswapr

          !> HETF2_RK: computes the factorization of a complex Hermitian matrix A
          !> using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !> A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
          !> where U (or L) is unit upper (or lower) triangular matrix,
          !> U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !> matrix, P**T is the transpose of P, and D is Hermitian and block
          !> diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !> This is the unblocked version of the algorithm, calling Level 2 BLAS.
          !> For more information see Further Details section.
          interface hetf2_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetf2_rk(uplo,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: e(*)
               end subroutine chetf2_rk
#else
               module procedure la_chetf2_rk
#endif
               module procedure la_whetf2_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetf2_rk(uplo,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: e(*)
               end subroutine zhetf2_rk
#else
               module procedure la_zhetf2_rk
#endif
          end interface hetf2_rk

          !> HETF2_ROOK: computes the factorization of a complex Hermitian matrix A
          !> using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
          !> A = U*D*U**H  or  A = L*D*L**H
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, U**H is the conjugate transpose of U, and D is
          !> Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !> This is the unblocked version of the algorithm, calling Level 2 BLAS.
          interface hetf2_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetf2_rook(uplo,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine chetf2_rook
#else
               module procedure la_chetf2_rook
#endif
               module procedure la_whetf2_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetf2_rook(uplo,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zhetf2_rook
#else
               module procedure la_zhetf2_rook
#endif
          end interface hetf2_rook

          !> HETRD: reduces a complex Hermitian matrix A to real symmetric
          !> tridiagonal form T by a unitary similarity transformation:
          !> Q**H * A * Q = T.
          interface hetrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrd(uplo,n,a,lda,d,e,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(sp),intent(out) :: d(*),e(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),work(*)
               end subroutine chetrd
#else
               module procedure la_chetrd
#endif
               module procedure la_whetrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrd(uplo,n,a,lda,d,e,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(dp),intent(out) :: d(*),e(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),work(*)
               end subroutine zhetrd
#else
               module procedure la_zhetrd
#endif
          end interface hetrd

          !> HETRD_HB2ST: reduces a complex Hermitian band matrix A to real symmetric
          !> tridiagonal form T by a unitary similarity transformation:
          !> Q**H * A * Q = T.
          interface hetrd_hb2st
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrd_hb2st(stage1,vect,uplo,n,kd,ab,ldab,d,e,hous, &
                         lhous,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: stage1,uplo,vect
                    integer(ilp),intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp),intent(out) :: info
                    real(sp),intent(out) :: d(*),e(*)
                    complex(sp),intent(inout) :: ab(ldab,*)
                    complex(sp),intent(out) :: hous(*),work(*)
               end subroutine chetrd_hb2st
#else
               module procedure la_chetrd_hb2st
#endif
               module procedure la_whetrd_hb2st
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrd_hb2st(stage1,vect,uplo,n,kd,ab,ldab,d,e,hous, &
                         lhous,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: stage1,uplo,vect
                    integer(ilp),intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp),intent(out) :: info
                    real(dp),intent(out) :: d(*),e(*)
                    complex(dp),intent(inout) :: ab(ldab,*)
                    complex(dp),intent(out) :: hous(*),work(*)
               end subroutine zhetrd_hb2st
#else
               module procedure la_zhetrd_hb2st
#endif
          end interface hetrd_hb2st

          !> HETRD_HE2HB: reduces a complex Hermitian matrix A to complex Hermitian
          !> band-diagonal form AB by a unitary similarity transformation:
          !> Q**H * A * Q = AB.
          interface hetrd_he2hb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrd_he2hb(uplo,n,kd,a,lda,ab,ldab,tau,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldab,lwork,n,kd
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine chetrd_he2hb
#else
               module procedure la_chetrd_he2hb
#endif
               module procedure la_whetrd_he2hb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrd_he2hb(uplo,n,kd,a,lda,ab,ldab,tau,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldab,lwork,n,kd
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine zhetrd_he2hb
#else
               module procedure la_zhetrd_he2hb
#endif
          end interface hetrd_he2hb

          !> HETRF: computes the factorization of a complex Hermitian matrix A
          !> using the Bunch-Kaufman diagonal pivoting method.  The form of the
          !> factorization is
          !> A = U*D*U**H  or  A = L*D*L**H
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and D is Hermitian and block diagonal with
          !> 1-by-1 and 2-by-2 diagonal blocks.
          !> This is the blocked version of the algorithm, calling Level 3 BLAS.
          interface hetrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrf(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chetrf
#else
               module procedure la_chetrf
#endif
               module procedure la_whetrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrf(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhetrf
#else
               module procedure la_zhetrf
#endif
          end interface hetrf

          !> HETRF_AA: computes the factorization of a complex hermitian matrix A
          !> using the Aasen's algorithm.  The form of the factorization is
          !> A = U**H*T*U  or  A = L*T*L**H
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and T is a hermitian tridiagonal matrix.
          !> This is the blocked version of the algorithm, calling Level 3 BLAS.
          interface hetrf_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrf_aa(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,lda,lwork
                    integer(ilp),intent(out) :: info,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chetrf_aa
#else
               module procedure la_chetrf_aa
#endif
               module procedure la_whetrf_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrf_aa(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,lda,lwork
                    integer(ilp),intent(out) :: info,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhetrf_aa
#else
               module procedure la_zhetrf_aa
#endif
          end interface hetrf_aa

          !> HETRF_RK: computes the factorization of a complex Hermitian matrix A
          !> using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !> A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
          !> where U (or L) is unit upper (or lower) triangular matrix,
          !> U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !> matrix, P**T is the transpose of P, and D is Hermitian and block
          !> diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !> This is the blocked version of the algorithm, calling Level 3 BLAS.
          !> For more information see Further Details section.
          interface hetrf_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrf_rk(uplo,n,a,lda,e,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: e(*),work(*)
               end subroutine chetrf_rk
#else
               module procedure la_chetrf_rk
#endif
               module procedure la_whetrf_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrf_rk(uplo,n,a,lda,e,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: e(*),work(*)
               end subroutine zhetrf_rk
#else
               module procedure la_zhetrf_rk
#endif
          end interface hetrf_rk

          !> HETRF_ROOK: computes the factorization of a complex Hermitian matrix A
          !> using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
          !> The form of the factorization is
          !> A = U*D*U**T  or  A = L*D*L**T
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and D is Hermitian and block diagonal with
          !> 1-by-1 and 2-by-2 diagonal blocks.
          !> This is the blocked version of the algorithm, calling Level 3 BLAS.
          interface hetrf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrf_rook(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chetrf_rook
#else
               module procedure la_chetrf_rook
#endif
               module procedure la_whetrf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrf_rook(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhetrf_rook
#else
               module procedure la_zhetrf_rook
#endif
          end interface hetrf_rook

          !> HETRI: computes the inverse of a complex Hermitian indefinite matrix
          !> A using the factorization A = U*D*U**H or A = L*D*L**H computed by
          !> CHETRF.
          interface hetri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetri(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chetri
#else
               module procedure la_chetri
#endif
               module procedure la_whetri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetri(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhetri
#else
               module procedure la_zhetri
#endif
          end interface hetri

          !> HETRI_ROOK: computes the inverse of a complex Hermitian indefinite matrix
          !> A using the factorization A = U*D*U**H or A = L*D*L**H computed by
          !> CHETRF_ROOK.
          interface hetri_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetri_rook(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chetri_rook
#else
               module procedure la_chetri_rook
#endif
               module procedure la_whetri_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetri_rook(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhetri_rook
#else
               module procedure la_zhetri_rook
#endif
          end interface hetri_rook

          !> HETRS: solves a system of linear equations A*X = B with a complex
          !> Hermitian matrix A using the factorization A = U*D*U**H or
          !> A = L*D*L**H computed by CHETRF.
          interface hetrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrs(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine chetrs
#else
               module procedure la_chetrs
#endif
               module procedure la_whetrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrs(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zhetrs
#else
               module procedure la_zhetrs
#endif
          end interface hetrs

          !> HETRS2: solves a system of linear equations A*X = B with a complex
          !> Hermitian matrix A using the factorization A = U*D*U**H or
          !> A = L*D*L**H computed by CHETRF and converted by CSYCONV.
          interface hetrs2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrs2(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chetrs2
#else
               module procedure la_chetrs2
#endif
               module procedure la_whetrs2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrs2(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhetrs2
#else
               module procedure la_zhetrs2
#endif
          end interface hetrs2

          !> HETRS_3: solves a system of linear equations A * X = B with a complex
          !> Hermitian matrix A using the factorization computed
          !> by CHETRF_RK or CHETRF_BK:
          !> A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
          !> where U (or L) is unit upper (or lower) triangular matrix,
          !> U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !> matrix, P**T is the transpose of P, and D is Hermitian and block
          !> diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !> This algorithm is using Level 3 BLAS.
          interface hetrs_3
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrs_3(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(in) :: a(lda,*),e(*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine chetrs_3
#else
               module procedure la_chetrs_3
#endif
               module procedure la_whetrs_3
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrs_3(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(in) :: a(lda,*),e(*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zhetrs_3
#else
               module procedure la_zhetrs_3
#endif
          end interface hetrs_3

          !> HETRS_AA: solves a system of linear equations A*X = B with a complex
          !> hermitian matrix A using the factorization A = U**H*T*U or
          !> A = L*T*L**H computed by CHETRF_AA.
          interface hetrs_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrs_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chetrs_aa
#else
               module procedure la_chetrs_aa
#endif
               module procedure la_whetrs_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrs_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhetrs_aa
#else
               module procedure la_zhetrs_aa
#endif
          end interface hetrs_aa

          !> HETRS_ROOK: solves a system of linear equations A*X = B with a complex
          !> Hermitian matrix A using the factorization A = U*D*U**H or
          !> A = L*D*L**H computed by CHETRF_ROOK.
          interface hetrs_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chetrs_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine chetrs_rook
#else
               module procedure la_chetrs_rook
#endif
               module procedure la_whetrs_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhetrs_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zhetrs_rook
#else
               module procedure la_zhetrs_rook
#endif
          end interface hetrs_rook

          !> Level 3 BLAS like routine for C in RFP Format.
          !> HFRK: performs one of the Hermitian rank--k operations
          !> C := alpha*A*A**H + beta*C,
          !> or
          !> C := alpha*A**H*A + beta*C,
          !> where alpha and beta are real scalars, C is an n--by--n Hermitian
          !> matrix and A is an n--by--k matrix in the first case and a k--by--n
          !> matrix in the second case.
          interface hfrk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chfrk(transr,uplo,trans,n,k,alpha,a,lda,beta,c)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: alpha,beta
                    integer(ilp),intent(in) :: k,lda,n
                    character,intent(in) :: trans,transr,uplo
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: c(*)
               end subroutine chfrk
#else
               module procedure la_chfrk
#endif
               module procedure la_whfrk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhfrk(transr,uplo,trans,n,k,alpha,a,lda,beta,c)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: alpha,beta
                    integer(ilp),intent(in) :: k,lda,n
                    character,intent(in) :: trans,transr,uplo
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: c(*)
               end subroutine zhfrk
#else
               module procedure la_zhfrk
#endif
          end interface hfrk

          !> HGEQZ: computes the eigenvalues of a complex matrix pair (H,T),
          !> where H is an upper Hessenberg matrix and T is upper triangular,
          !> using the single-shift QZ method.
          !> Matrix pairs of this type are produced by the reduction to
          !> generalized upper Hessenberg form of a complex matrix pair (A,B):
          !> A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
          !> as computed by CGGHRD.
          !> If JOB='S', then the Hessenberg-triangular pair (H,T) is
          !> also reduced to generalized Schur form,
          !> H = Q*S*Z**H,  T = Q*P*Z**H,
          !> where Q and Z are unitary matrices and S and P are upper triangular.
          !> Optionally, the unitary matrix Q from the generalized Schur
          !> factorization may be postmultiplied into an input matrix Q1, and the
          !> unitary matrix Z may be postmultiplied into an input matrix Z1.
          !> If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
          !> the matrix pair (A,B) to generalized Hessenberg form, then the output
          !> matrices Q1*Q and Z1*Z are the unitary factors from the generalized
          !> Schur factorization of (A,B):
          !> A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
          !> To avoid overflow, eigenvalues of the matrix pair (H,T)
          !> (equivalently, of (A,B)) are computed as a pair of complex values
          !> (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
          !> eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
          !> A*x = lambda*B*x
          !> and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
          !> alternate form of the GNEP
          !> mu*A*y = B*y.
          !> The values of alpha and beta for the i-th eigenvalue can be read
          !> directly from the generalized Schur form:  alpha = S(i,i),
          !> beta = P(i,i).
          !> Ref: C.B. Moler
          !> Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
          !> pp. 241--256.
          interface hgeqz
#ifdef LA_EXTERNAL_LAPACK
               subroutine chgeqz(job,compq,compz,n,ilo,ihi,h,ldh,t,ldt,alpha,beta,q, &
                         ldq,z,ldz,work,lwork,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,compz,job
                    integer(ilp),intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(out) :: alpha(*),beta(*),work(*)
                    complex(sp),intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine chgeqz
#else
               module procedure la_chgeqz
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dhgeqz(job,compq,compz,n,ilo,ihi,h,ldh,t,ldt,alphar,alphai, &
                         beta,q,ldq,z,ldz,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,compz,job
                    integer(ilp),intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(out) :: alphai(*),alphar(*),beta(*),work(*)
                    real(dp),intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine dhgeqz
#else
               module procedure la_dhgeqz
#endif
               module procedure la_qhgeqz
#ifdef LA_EXTERNAL_LAPACK
               subroutine shgeqz(job,compq,compz,n,ilo,ihi,h,ldh,t,ldt,alphar,alphai, &
                         beta,q,ldq,z,ldz,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,compz,job
                    integer(ilp),intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(out) :: alphai(*),alphar(*),beta(*),work(*)
                    real(sp),intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine shgeqz
#else
               module procedure la_shgeqz
#endif
               module procedure la_whgeqz
#ifdef LA_EXTERNAL_LAPACK
               subroutine zhgeqz(job,compq,compz,n,ilo,ihi,h,ldh,t,ldt,alpha,beta,q, &
                         ldq,z,ldz,work,lwork,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,compz,job
                    integer(ilp),intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(out) :: alpha(*),beta(*),work(*)
                    complex(dp),intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine zhgeqz
#else
               module procedure la_zhgeqz
#endif
          end interface hgeqz

          !> HPCON: estimates the reciprocal of the condition number of a complex
          !> Hermitian packed matrix A using the factorization A = U*D*U**H or
          !> A = L*D*L**H computed by CHPTRF.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
          interface hpcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chpcon(uplo,n,ap,ipiv,anorm,rcond,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond
                    complex(sp),intent(in) :: ap(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chpcon
#else
               module procedure la_chpcon
#endif
               module procedure la_whpcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhpcon(uplo,n,ap,ipiv,anorm,rcond,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond
                    complex(dp),intent(in) :: ap(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhpcon
#else
               module procedure la_zhpcon
#endif
          end interface hpcon

          !> HPEV: computes all the eigenvalues and, optionally, eigenvectors of a
          !> complex Hermitian matrix in packed storage.
          interface hpev
#ifdef LA_EXTERNAL_LAPACK
               subroutine chpev(jobz,uplo,n,ap,w,z,ldz,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: ap(*)
                    complex(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine chpev
#else
               module procedure la_chpev
#endif
               module procedure la_whpev
#ifdef LA_EXTERNAL_LAPACK
               subroutine zhpev(jobz,uplo,n,ap,w,z,ldz,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: ap(*)
                    complex(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine zhpev
#else
               module procedure la_zhpev
#endif
          end interface hpev

          !> HPEVD: computes all the eigenvalues and, optionally, eigenvectors of
          !> a complex Hermitian matrix A in packed storage.  If eigenvectors are
          !> desired, it uses a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface hpevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine chpevd(jobz,uplo,n,ap,w,z,ldz,work,lwork,rwork,lrwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: ap(*)
                    complex(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine chpevd
#else
               module procedure la_chpevd
#endif
               module procedure la_whpevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine zhpevd(jobz,uplo,n,ap,w,z,ldz,work,lwork,rwork,lrwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: ap(*)
                    complex(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine zhpevd
#else
               module procedure la_zhpevd
#endif
          end interface hpevd

          !> HPGST: reduces a complex Hermitian-definite generalized
          !> eigenproblem to standard form, using packed storage.
          !> If ITYPE = 1, the problem is A*x = lambda*B*x,
          !> and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
          !> If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !> B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
          !> B must have been previously factorized as U**H*U or L*L**H by CPPTRF.
          interface hpgst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chpgst(itype,uplo,n,ap,bp,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,n
                    complex(sp),intent(inout) :: ap(*)
                    complex(sp),intent(in) :: bp(*)
               end subroutine chpgst
#else
               module procedure la_chpgst
#endif
               module procedure la_whpgst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhpgst(itype,uplo,n,ap,bp,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,n
                    complex(dp),intent(inout) :: ap(*)
                    complex(dp),intent(in) :: bp(*)
               end subroutine zhpgst
#else
               module procedure la_zhpgst
#endif
          end interface hpgst

          !> HPGV: computes all the eigenvalues and, optionally, the eigenvectors
          !> of a complex generalized Hermitian-definite eigenproblem, of the form
          !> A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !> Here A and B are assumed to be Hermitian, stored in packed format,
          !> and B is also positive definite.
          interface hpgv
#ifdef LA_EXTERNAL_LAPACK
               subroutine chpgv(itype,jobz,uplo,n,ap,bp,w,z,ldz,work,rwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,ldz,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: ap(*),bp(*)
                    complex(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine chpgv
#else
               module procedure la_chpgv
#endif
               module procedure la_whpgv
#ifdef LA_EXTERNAL_LAPACK
               subroutine zhpgv(itype,jobz,uplo,n,ap,bp,w,z,ldz,work,rwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,ldz,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: ap(*),bp(*)
                    complex(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine zhpgv
#else
               module procedure la_zhpgv
#endif
          end interface hpgv

          !> HPGVD: computes all the eigenvalues and, optionally, the eigenvectors
          !> of a complex generalized Hermitian-definite eigenproblem, of the form
          !> A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !> B are assumed to be Hermitian, stored in packed format, and B is also
          !> positive definite.
          !> If eigenvectors are desired, it uses a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface hpgvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine chpgvd(itype,jobz,uplo,n,ap,bp,w,z,ldz,work,lwork,rwork, &
                         lrwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: itype,ldz,liwork,lrwork,lwork,n
                    real(sp),intent(out) :: rwork(*),w(*)
                    complex(sp),intent(inout) :: ap(*),bp(*)
                    complex(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine chpgvd
#else
               module procedure la_chpgvd
#endif
               module procedure la_whpgvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine zhpgvd(itype,jobz,uplo,n,ap,bp,w,z,ldz,work,lwork,rwork, &
                         lrwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: itype,ldz,liwork,lrwork,lwork,n
                    real(dp),intent(out) :: rwork(*),w(*)
                    complex(dp),intent(inout) :: ap(*),bp(*)
                    complex(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine zhpgvd
#else
               module procedure la_zhpgvd
#endif
          end interface hpgvd

          !> HPRFS: improves the computed solution to a system of linear
          !> equations when the coefficient matrix is Hermitian indefinite
          !> and packed, and provides error bounds and backward error estimates
          !> for the solution.
          interface hprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chprfs(uplo,n,nrhs,ap,afp,ipiv,b,ldb,x,ldx,ferr,berr, &
                         work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine chprfs
#else
               module procedure la_chprfs
#endif
               module procedure la_whprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhprfs(uplo,n,nrhs,ap,afp,ipiv,b,ldb,x,ldx,ferr,berr, &
                         work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zhprfs
#else
               module procedure la_zhprfs
#endif
          end interface hprfs

          !> HPSV: computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N Hermitian matrix stored in packed format and X
          !> and B are N-by-NRHS matrices.
          !> The diagonal pivoting method is used to factor A as
          !> A = U * D * U**H,  if UPLO = 'U', or
          !> A = L * D * L**H,  if UPLO = 'L',
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, D is Hermitian and block diagonal with 1-by-1
          !> and 2-by-2 diagonal blocks.  The factored form of A is then used to
          !> solve the system of equations A * X = B.
          interface hpsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chpsv(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(sp),intent(inout) :: ap(*),b(ldb,*)
               end subroutine chpsv
#else
               module procedure la_chpsv
#endif
               module procedure la_whpsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhpsv(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(dp),intent(inout) :: ap(*),b(ldb,*)
               end subroutine zhpsv
#else
               module procedure la_zhpsv
#endif
          end interface hpsv

          !> HPTRD: reduces a complex Hermitian matrix A stored in packed form to
          !> real symmetric tridiagonal form T by a unitary similarity
          !> transformation: Q**H * A * Q = T.
          interface hptrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chptrd(uplo,n,ap,d,e,tau,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: d(*),e(*)
                    complex(sp),intent(inout) :: ap(*)
                    complex(sp),intent(out) :: tau(*)
               end subroutine chptrd
#else
               module procedure la_chptrd
#endif
               module procedure la_whptrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhptrd(uplo,n,ap,d,e,tau,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: d(*),e(*)
                    complex(dp),intent(inout) :: ap(*)
                    complex(dp),intent(out) :: tau(*)
               end subroutine zhptrd
#else
               module procedure la_zhptrd
#endif
          end interface hptrd

          !> HPTRF: computes the factorization of a complex Hermitian packed
          !> matrix A using the Bunch-Kaufman diagonal pivoting method:
          !> A = U*D*U**H  or  A = L*D*L**H
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and D is Hermitian and block diagonal with
          !> 1-by-1 and 2-by-2 diagonal blocks.
          interface hptrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chptrf(uplo,n,ap,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(inout) :: ap(*)
               end subroutine chptrf
#else
               module procedure la_chptrf
#endif
               module procedure la_whptrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhptrf(uplo,n,ap,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(inout) :: ap(*)
               end subroutine zhptrf
#else
               module procedure la_zhptrf
#endif
          end interface hptrf

          !> HPTRI: computes the inverse of a complex Hermitian indefinite matrix
          !> A in packed storage using the factorization A = U*D*U**H or
          !> A = L*D*L**H computed by CHPTRF.
          interface hptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chptri(uplo,n,ap,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    complex(sp),intent(inout) :: ap(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chptri
#else
               module procedure la_chptri
#endif
               module procedure la_whptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhptri(uplo,n,ap,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    complex(dp),intent(inout) :: ap(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhptri
#else
               module procedure la_zhptri
#endif
          end interface hptri

          !> HPTRS: solves a system of linear equations A*X = B with a complex
          !> Hermitian matrix A stored in packed format using the factorization
          !> A = U*D*U**H or A = L*D*L**H computed by CHPTRF.
          interface hptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chptrs(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(in) :: ap(*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine chptrs
#else
               module procedure la_chptrs
#endif
               module procedure la_whptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhptrs(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(in) :: ap(*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zhptrs
#else
               module procedure la_zhptrs
#endif
          end interface hptrs

          !> HSEIN: uses inverse iteration to find specified right and/or left
          !> eigenvectors of a complex upper Hessenberg matrix H.
          !> The right eigenvector x and the left eigenvector y of the matrix H
          !> corresponding to an eigenvalue w are defined by:
          !> H * x = w * x,     y**h * H = w * y**h
          !> where y**h denotes the conjugate transpose of the vector y.
          interface hsein
#ifdef LA_EXTERNAL_LAPACK
               subroutine chsein(side,eigsrc,initv,select,n,h,ldh,w,vl,ldvl,vr,ldvr, &
                         mm,m,work,rwork,ifaill,ifailr,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: eigsrc,initv,side
                    integer(ilp),intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp),intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(in) :: h(ldh,*)
                    complex(sp),intent(inout) :: vl(ldvl,*),vr(ldvr,*),w(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine chsein
#else
               module procedure la_chsein
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dhsein(side,eigsrc,initv,select,n,h,ldh,wr,wi,vl,ldvl,vr, &
                         ldvr,mm,m,work,ifaill,ifailr,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: eigsrc,initv,side
                    integer(ilp),intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp),intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk),intent(inout) :: select(*)
                    real(dp),intent(in) :: h(ldh,*),wi(*)
                    real(dp),intent(inout) :: vl(ldvl,*),vr(ldvr,*),wr(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dhsein
#else
               module procedure la_dhsein
#endif
               module procedure la_qhsein
#ifdef LA_EXTERNAL_LAPACK
               subroutine shsein(side,eigsrc,initv,select,n,h,ldh,wr,wi,vl,ldvl,vr, &
                         ldvr,mm,m,work,ifaill,ifailr,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: eigsrc,initv,side
                    integer(ilp),intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp),intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk),intent(inout) :: select(*)
                    real(sp),intent(in) :: h(ldh,*),wi(*)
                    real(sp),intent(inout) :: vl(ldvl,*),vr(ldvr,*),wr(*)
                    real(sp),intent(out) :: work(*)
               end subroutine shsein
#else
               module procedure la_shsein
#endif
               module procedure la_whsein
#ifdef LA_EXTERNAL_LAPACK
               subroutine zhsein(side,eigsrc,initv,select,n,h,ldh,w,vl,ldvl,vr,ldvr, &
                         mm,m,work,rwork,ifaill,ifailr,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: eigsrc,initv,side
                    integer(ilp),intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp),intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(in) :: h(ldh,*)
                    complex(dp),intent(inout) :: vl(ldvl,*),vr(ldvr,*),w(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zhsein
#else
               module procedure la_zhsein
#endif
          end interface hsein

          !> HSEQR: computes the eigenvalues of a Hessenberg matrix H
          !> and, optionally, the matrices T and Z from the Schur decomposition
          !> H = Z T Z**H, where T is an upper triangular matrix (the
          !> Schur form), and Z is the unitary matrix of Schur vectors.
          !> Optionally Z may be postmultiplied into an input unitary
          !> matrix Q so that this routine can give the Schur factorization
          !> of a matrix A which has been reduced to the Hessenberg form H
          !> by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
          interface hseqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine chseqr(job,compz,n,ilo,ihi,h,ldh,w,z,ldz,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    character,intent(in) :: compz,job
                    complex(sp),intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp),intent(out) :: w(*),work(*)
               end subroutine chseqr
#else
               module procedure la_chseqr
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dhseqr(job,compz,n,ilo,ihi,h,ldh,wr,wi,z,ldz,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    character,intent(in) :: compz,job
                    real(dp),intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp),intent(out) :: wi(*),work(*),wr(*)
               end subroutine dhseqr
#else
               module procedure la_dhseqr
#endif
               module procedure la_qhseqr
#ifdef LA_EXTERNAL_LAPACK
               subroutine shseqr(job,compz,n,ilo,ihi,h,ldh,wr,wi,z,ldz,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    character,intent(in) :: compz,job
                    real(sp),intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp),intent(out) :: wi(*),work(*),wr(*)
               end subroutine shseqr
#else
               module procedure la_shseqr
#endif
               module procedure la_whseqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zhseqr(job,compz,n,ilo,ihi,h,ldh,w,z,ldz,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    character,intent(in) :: compz,job
                    complex(dp),intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp),intent(out) :: w(*),work(*)
               end subroutine zhseqr
#else
               module procedure la_zhseqr
#endif
          end interface hseqr

          !> ISNAN: returns .TRUE. if its argument is NaN, and .FALSE.
          !> otherwise.  To be replaced by the Fortran 2003 intrinsic in the
          !> future.
          interface isnan
#ifdef LA_EXTERNAL_LAPACK
               pure logical(lk) function disnan(din)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: din
               end function disnan
#else
               module procedure la_disnan
#endif
               module procedure la_qisnan
#ifdef LA_EXTERNAL_LAPACK
               pure logical(lk) function sisnan(sin)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: sin
               end function sisnan
#else
               module procedure la_sisnan
#endif
          end interface isnan

          !> LA_GBAMV:  performs one of the matrix-vector operations
          !> y := alpha*abs(A)*abs(x) + beta*abs(y),
          !> or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),
          !> where alpha and beta are scalars, x and y are vectors and A is an
          !> m by n matrix.
          !> This function is primarily used in calculating error bounds.
          !> To protect against underflow during evaluation, components in
          !> the resulting vector are perturbed away from zero by (N+1)
          !> times the underflow threshold.  To prevent unnecessarily large
          !> errors for block-structure embedded in general matrices,
          !> "symbolically" zero components are not perturbed.  A zero
          !> entry is considered "symbolic" if all multiplications involved
          !> in computing that entry have at least one zero multiplicand.
          interface la_gbamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine cla_gbamv(trans,m,n,kl,ku,alpha,ab,ldab,x,incx,beta,y,incy)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: alpha,beta
                    integer(ilp),intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    complex(sp),intent(in) :: ab(ldab,*),x(*)
                    real(sp),intent(inout) :: y(*)
               end subroutine cla_gbamv
#else
               module procedure la_cla_gbamv
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dla_gbamv(trans,m,n,kl,ku,alpha,ab,ldab,x,incx,beta,y,incy)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: alpha,beta,ab(ldab,*),x(*)
                    integer(ilp),intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    real(dp),intent(inout) :: y(*)
               end subroutine dla_gbamv
#else
               module procedure la_dla_gbamv
#endif
               module procedure la_qla_gbamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine sla_gbamv(trans,m,n,kl,ku,alpha,ab,ldab,x,incx,beta,y,incy)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: alpha,beta,ab(ldab,*),x(*)
                    integer(ilp),intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    real(sp),intent(inout) :: y(*)
               end subroutine sla_gbamv
#else
               module procedure la_sla_gbamv
#endif
               module procedure la_wla_gbamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine zla_gbamv(trans,m,n,kl,ku,alpha,ab,ldab,x,incx,beta,y,incy)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: alpha,beta
                    integer(ilp),intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    complex(dp),intent(in) :: ab(ldab,*),x(*)
                    real(dp),intent(inout) :: y(*)
               end subroutine zla_gbamv
#else
               module procedure la_zla_gbamv
#endif
          end interface la_gbamv

          !> LA_GBRCOND: Estimates the Skeel condition number of  op(A) * op2(C)
          !> where op2 is determined by CMODE as follows
          !> CMODE =  1    op2(C) = C
          !> CMODE =  0    op2(C) = I
          !> CMODE = -1    op2(C) = inv(C)
          !> The Skeel condition number  cond(A) = norminf( |inv(A)||A| )
          !> is computed by computing scaling factors R such that
          !> diag(R)*A*op2(C) is row equilibrated and computing the standard
          !> infinity-norm condition number.
          interface la_gbrcond
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dla_gbrcond(trans,n,kl,ku,ab,ldab,afb,ldafb,ipiv,cmode, &
                         c,info,work,iwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: n,ldab,ldafb,kl,ku,cmode,ipiv(*)
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(in) :: ab(ldab,*),afb(ldafb,*),c(*)
                    real(dp),intent(out) :: work(*)
               end function dla_gbrcond
#else
               module procedure la_dla_gbrcond
#endif
               module procedure la_qla_gbrcond
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function sla_gbrcond(trans,n,kl,ku,ab,ldab,afb,ldafb,ipiv,cmode, &
                         c,info,work,iwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: n,ldab,ldafb,kl,ku,cmode,ipiv(*)
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(in) :: ab(ldab,*),afb(ldafb,*),c(*)
                    real(sp),intent(out) :: work(*)
               end function sla_gbrcond
#else
               module procedure la_sla_gbrcond
#endif
          end interface la_gbrcond

          !> LA_GBRCOND_C: Computes the infinity norm condition number of
          !> op(A) * inv(diag(C)) where C is a REAL vector.
          interface la_gbrcond_c
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function cla_gbrcond_c(trans,n,kl,ku,ab,ldab,afb,ldafb,ipiv,c, &
                         capply,info,work,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    logical(lk),intent(in) :: capply
                    integer(ilp),intent(in) :: n,kl,ku,ldab,ldafb,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(in) :: ab(ldab,*),afb(ldafb,*)
                    complex(sp),intent(out) :: work(*)
                    real(sp),intent(in) :: c(*)
                    real(sp),intent(out) :: rwork(*)
               end function cla_gbrcond_c
#else
               module procedure la_cla_gbrcond_c
#endif
               module procedure la_wla_gbrcond_c
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zla_gbrcond_c(trans,n,kl,ku,ab,ldab,afb,ldafb,ipiv,c, &
                         capply,info,work,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    logical(lk),intent(in) :: capply
                    integer(ilp),intent(in) :: n,kl,ku,ldab,ldafb,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(in) :: ab(ldab,*),afb(ldafb,*)
                    complex(dp),intent(out) :: work(*)
                    real(dp),intent(in) :: c(*)
                    real(dp),intent(out) :: rwork(*)
               end function zla_gbrcond_c
#else
               module procedure la_zla_gbrcond_c
#endif
          end interface la_gbrcond_c

          !> LA_GBRPVGRW: computes the reciprocal pivot growth factor
          !> norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !> much less than 1, the stability of the LU factorization of the
          !> (equilibrated) matrix A could be poor. This also means that the
          !> solution X, estimated condition numbers, and error bounds could be
          !> unreliable.
          interface la_gbrpvgrw
#ifdef LA_EXTERNAL_LAPACK
               pure real(sp) function cla_gbrpvgrw(n,kl,ku,ncols,ab,ldab,afb,ldafb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    complex(sp),intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function cla_gbrpvgrw
#else
               module procedure la_cla_gbrpvgrw
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure real(dp) function dla_gbrpvgrw(n,kl,ku,ncols,ab,ldab,afb,ldafb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    real(dp),intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function dla_gbrpvgrw
#else
               module procedure la_dla_gbrpvgrw
#endif
               module procedure la_qla_gbrpvgrw
#ifdef LA_EXTERNAL_LAPACK
               pure real(sp) function sla_gbrpvgrw(n,kl,ku,ncols,ab,ldab,afb,ldafb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    real(sp),intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function sla_gbrpvgrw
#else
               module procedure la_sla_gbrpvgrw
#endif
               module procedure la_wla_gbrpvgrw
#ifdef LA_EXTERNAL_LAPACK
               pure real(dp) function zla_gbrpvgrw(n,kl,ku,ncols,ab,ldab,afb,ldafb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    complex(dp),intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function zla_gbrpvgrw
#else
               module procedure la_zla_gbrpvgrw
#endif
          end interface la_gbrpvgrw

          !> LA_GEAMV:  performs one of the matrix-vector operations
          !> y := alpha*abs(A)*abs(x) + beta*abs(y),
          !> or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),
          !> where alpha and beta are scalars, x and y are vectors and A is an
          !> m by n matrix.
          !> This function is primarily used in calculating error bounds.
          !> To protect against underflow during evaluation, components in
          !> the resulting vector are perturbed away from zero by (N+1)
          !> times the underflow threshold.  To prevent unnecessarily large
          !> errors for block-structure embedded in general matrices,
          !> "symbolically" zero components are not perturbed.  A zero
          !> entry is considered "symbolic" if all multiplications involved
          !> in computing that entry have at least one zero multiplicand.
          interface la_geamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine cla_geamv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: alpha,beta
                    integer(ilp),intent(in) :: incx,incy,lda,m,n,trans
                    complex(sp),intent(in) :: a(lda,*),x(*)
                    real(sp),intent(inout) :: y(*)
               end subroutine cla_geamv
#else
               module procedure la_cla_geamv
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dla_geamv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp),intent(in) :: incx,incy,lda,m,n,trans
                    real(dp),intent(inout) :: y(*)
               end subroutine dla_geamv
#else
               module procedure la_dla_geamv
#endif
               module procedure la_qla_geamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine sla_geamv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp),intent(in) :: incx,incy,lda,m,n,trans
                    real(sp),intent(inout) :: y(*)
               end subroutine sla_geamv
#else
               module procedure la_sla_geamv
#endif
               module procedure la_wla_geamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine zla_geamv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: alpha,beta
                    integer(ilp),intent(in) :: incx,incy,lda,m,n,trans
                    complex(dp),intent(in) :: a(lda,*),x(*)
                    real(dp),intent(inout) :: y(*)
               end subroutine zla_geamv
#else
               module procedure la_zla_geamv
#endif
          end interface la_geamv

          !> LA_GERCOND: estimates the Skeel condition number of op(A) * op2(C)
          !> where op2 is determined by CMODE as follows
          !> CMODE =  1    op2(C) = C
          !> CMODE =  0    op2(C) = I
          !> CMODE = -1    op2(C) = inv(C)
          !> The Skeel condition number cond(A) = norminf( |inv(A)||A| )
          !> is computed by computing scaling factors R such that
          !> diag(R)*A*op2(C) is row equilibrated and computing the standard
          !> infinity-norm condition number.
          interface la_gercond
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dla_gercond(trans,n,a,lda,af,ldaf,ipiv,cmode,c,info, &
                         work,iwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp),intent(out) :: work(*)
               end function dla_gercond
#else
               module procedure la_dla_gercond
#endif
               module procedure la_qla_gercond
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function sla_gercond(trans,n,a,lda,af,ldaf,ipiv,cmode,c,info, &
                         work,iwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp),intent(out) :: work(*)
               end function sla_gercond
#else
               module procedure la_sla_gercond
#endif
          end interface la_gercond

          !> LA_GERCOND_C: computes the infinity norm condition number of
          !> op(A) * inv(diag(C)) where C is a REAL vector.
          interface la_gercond_c
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function cla_gercond_c(trans,n,a,lda,af,ldaf,ipiv,c,capply,info, &
                         work,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    logical(lk),intent(in) :: capply
                    integer(ilp),intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp),intent(out) :: work(*)
                    real(sp),intent(in) :: c(*)
                    real(sp),intent(out) :: rwork(*)
               end function cla_gercond_c
#else
               module procedure la_cla_gercond_c
#endif
               module procedure la_wla_gercond_c
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zla_gercond_c(trans,n,a,lda,af,ldaf,ipiv,c,capply,info, &
                         work,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    logical(lk),intent(in) :: capply
                    integer(ilp),intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp),intent(out) :: work(*)
                    real(dp),intent(in) :: c(*)
                    real(dp),intent(out) :: rwork(*)
               end function zla_gercond_c
#else
               module procedure la_zla_gercond_c
#endif
          end interface la_gercond_c

          !> LA_GERPVGRW: computes the reciprocal pivot growth factor
          !> norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !> much less than 1, the stability of the LU factorization of the
          !> (equilibrated) matrix A could be poor. This also means that the
          !> solution X, estimated condition numbers, and error bounds could be
          !> unreliable.
          interface la_gerpvgrw
#ifdef LA_EXTERNAL_LAPACK
               pure real(sp) function cla_gerpvgrw(n,ncols,a,lda,af,ldaf)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,ncols,lda,ldaf
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*)
               end function cla_gerpvgrw
#else
               module procedure la_cla_gerpvgrw
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure real(dp) function dla_gerpvgrw(n,ncols,a,lda,af,ldaf)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,ncols,lda,ldaf
                    real(dp),intent(in) :: a(lda,*),af(ldaf,*)
               end function dla_gerpvgrw
#else
               module procedure la_dla_gerpvgrw
#endif
               module procedure la_qla_gerpvgrw
#ifdef LA_EXTERNAL_LAPACK
               pure real(sp) function sla_gerpvgrw(n,ncols,a,lda,af,ldaf)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,ncols,lda,ldaf
                    real(sp),intent(in) :: a(lda,*),af(ldaf,*)
               end function sla_gerpvgrw
#else
               module procedure la_sla_gerpvgrw
#endif
               module procedure la_wla_gerpvgrw
#ifdef LA_EXTERNAL_LAPACK
               pure real(dp) function zla_gerpvgrw(n,ncols,a,lda,af,ldaf)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,ncols,lda,ldaf
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*)
               end function zla_gerpvgrw
#else
               module procedure la_zla_gerpvgrw
#endif
          end interface la_gerpvgrw

          !> CLA_SYAMV  performs the matrix-vector operation
          !> y := alpha*abs(A)*abs(x) + beta*abs(y),
          !> where alpha and beta are scalars, x and y are vectors and A is an
          !> n by n symmetric matrix.
          !> This function is primarily used in calculating error bounds.
          !> To protect against underflow during evaluation, components in
          !> the resulting vector are perturbed away from zero by (N+1)
          !> times the underflow threshold.  To prevent unnecessarily large
          !> errors for block-structure embedded in general matrices,
          !> "symbolically" zero components are not perturbed.  A zero
          !> entry is considered "symbolic" if all multiplications involved
          !> in computing that entry have at least one zero multiplicand.
          interface la_heamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine cla_heamv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: alpha,beta
                    integer(ilp),intent(in) :: incx,incy,lda,n,uplo
                    complex(sp),intent(in) :: a(lda,*),x(*)
                    real(sp),intent(inout) :: y(*)
               end subroutine cla_heamv
#else
               module procedure la_cla_heamv
#endif
               module procedure la_wla_heamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine zla_heamv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: alpha,beta
                    integer(ilp),intent(in) :: incx,incy,lda,n,uplo
                    complex(dp),intent(in) :: a(lda,*),x(*)
                    real(dp),intent(inout) :: y(*)
               end subroutine zla_heamv
#else
               module procedure la_zla_heamv
#endif
          end interface la_heamv

          !> LA_HERCOND_C: computes the infinity norm condition number of
          !> op(A) * inv(diag(C)) where C is a REAL vector.
          interface la_hercond_c
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function cla_hercond_c(uplo,n,a,lda,af,ldaf,ipiv,c,capply,info, &
                         work,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    logical(lk),intent(in) :: capply
                    integer(ilp),intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp),intent(out) :: work(*)
                    real(sp),intent(in) :: c(*)
                    real(sp),intent(out) :: rwork(*)
               end function cla_hercond_c
#else
               module procedure la_cla_hercond_c
#endif
               module procedure la_wla_hercond_c
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zla_hercond_c(uplo,n,a,lda,af,ldaf,ipiv,c,capply,info, &
                         work,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    logical(lk),intent(in) :: capply
                    integer(ilp),intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp),intent(out) :: work(*)
                    real(dp),intent(in) :: c(*)
                    real(dp),intent(out) :: rwork(*)
               end function zla_hercond_c
#else
               module procedure la_zla_hercond_c
#endif
          end interface la_hercond_c

          !> LA_HERPVGRW: computes the reciprocal pivot growth factor
          !> norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !> much less than 1, the stability of the LU factorization of the
          !> (equilibrated) matrix A could be poor. This also means that the
          !> solution X, estimated condition numbers, and error bounds could be
          !> unreliable.
          interface la_herpvgrw
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function cla_herpvgrw(uplo,n,info,a,lda,af,ldaf,ipiv,work)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp),intent(out) :: work(*)
               end function cla_herpvgrw
#else
               module procedure la_cla_herpvgrw
#endif
               module procedure la_wla_herpvgrw
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zla_herpvgrw(uplo,n,info,a,lda,af,ldaf,ipiv,work)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp),intent(out) :: work(*)
               end function zla_herpvgrw
#else
               module procedure la_zla_herpvgrw
#endif
          end interface la_herpvgrw

          !> LA_LIN_BERR: computes componentwise relative backward error from
          !> the formula
          !> max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )
          !> where abs(Z) is the componentwise absolute value of the matrix
          !> or vector Z.
          interface la_lin_berr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cla_lin_berr(n,nz,nrhs,res,ayb,berr)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,nz,nrhs
                    real(sp),intent(in) :: ayb(n,nrhs)
                    real(sp),intent(out) :: berr(nrhs)
                    complex(sp),intent(in) :: res(n,nrhs)
               end subroutine cla_lin_berr
#else
               module procedure la_cla_lin_berr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dla_lin_berr(n,nz,nrhs,res,ayb,berr)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,nz,nrhs
                    real(dp),intent(in) :: ayb(n,nrhs),res(n,nrhs)
                    real(dp),intent(out) :: berr(nrhs)
               end subroutine dla_lin_berr
#else
               module procedure la_dla_lin_berr
#endif
               module procedure la_qla_lin_berr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sla_lin_berr(n,nz,nrhs,res,ayb,berr)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,nz,nrhs
                    real(sp),intent(in) :: ayb(n,nrhs),res(n,nrhs)
                    real(sp),intent(out) :: berr(nrhs)
               end subroutine sla_lin_berr
#else
               module procedure la_sla_lin_berr
#endif
               module procedure la_wla_lin_berr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zla_lin_berr(n,nz,nrhs,res,ayb,berr)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,nz,nrhs
                    real(dp),intent(in) :: ayb(n,nrhs)
                    real(dp),intent(out) :: berr(nrhs)
                    complex(dp),intent(in) :: res(n,nrhs)
               end subroutine zla_lin_berr
#else
               module procedure la_zla_lin_berr
#endif
          end interface la_lin_berr

          !> LA_PORCOND: Estimates the Skeel condition number of  op(A) * op2(C)
          !> where op2 is determined by CMODE as follows
          !> CMODE =  1    op2(C) = C
          !> CMODE =  0    op2(C) = I
          !> CMODE = -1    op2(C) = inv(C)
          !> The Skeel condition number  cond(A) = norminf( |inv(A)||A| )
          !> is computed by computing scaling factors R such that
          !> diag(R)*A*op2(C) is row equilibrated and computing the standard
          !> infinity-norm condition number.
          interface la_porcond
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dla_porcond(uplo,n,a,lda,af,ldaf,cmode,c,info,work, &
                         iwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,lda,ldaf,cmode
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp),intent(out) :: work(*)
               end function dla_porcond
#else
               module procedure la_dla_porcond
#endif
               module procedure la_qla_porcond
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function sla_porcond(uplo,n,a,lda,af,ldaf,cmode,c,info,work, &
                         iwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,lda,ldaf,cmode
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp),intent(out) :: work(*)
               end function sla_porcond
#else
               module procedure la_sla_porcond
#endif
          end interface la_porcond

          !> LA_PORCOND_C: Computes the infinity norm condition number of
          !> op(A) * inv(diag(C)) where C is a REAL vector
          interface la_porcond_c
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function cla_porcond_c(uplo,n,a,lda,af,ldaf,c,capply,info,work, &
                         rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    logical(lk),intent(in) :: capply
                    integer(ilp),intent(in) :: n,lda,ldaf
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp),intent(out) :: work(*)
                    real(sp),intent(in) :: c(*)
                    real(sp),intent(out) :: rwork(*)
               end function cla_porcond_c
#else
               module procedure la_cla_porcond_c
#endif
               module procedure la_wla_porcond_c
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zla_porcond_c(uplo,n,a,lda,af,ldaf,c,capply,info,work, &
                         rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    logical(lk),intent(in) :: capply
                    integer(ilp),intent(in) :: n,lda,ldaf
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp),intent(out) :: work(*)
                    real(dp),intent(in) :: c(*)
                    real(dp),intent(out) :: rwork(*)
               end function zla_porcond_c
#else
               module procedure la_zla_porcond_c
#endif
          end interface la_porcond_c

          !> LA_PORPVGRW: computes the reciprocal pivot growth factor
          !> norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !> much less than 1, the stability of the LU factorization of the
          !> (equilibrated) matrix A could be poor. This also means that the
          !> solution X, estimated condition numbers, and error bounds could be
          !> unreliable.
          interface la_porpvgrw
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function cla_porpvgrw(uplo,ncols,a,lda,af,ldaf,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: ncols,lda,ldaf
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp),intent(out) :: work(*)
               end function cla_porpvgrw
#else
               module procedure la_cla_porpvgrw
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dla_porpvgrw(uplo,ncols,a,lda,af,ldaf,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: ncols,lda,ldaf
                    real(dp),intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp),intent(out) :: work(*)
               end function dla_porpvgrw
#else
               module procedure la_dla_porpvgrw
#endif
               module procedure la_qla_porpvgrw
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function sla_porpvgrw(uplo,ncols,a,lda,af,ldaf,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: ncols,lda,ldaf
                    real(sp),intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp),intent(out) :: work(*)
               end function sla_porpvgrw
#else
               module procedure la_sla_porpvgrw
#endif
               module procedure la_wla_porpvgrw
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zla_porpvgrw(uplo,ncols,a,lda,af,ldaf,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: ncols,lda,ldaf
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp),intent(out) :: work(*)
               end function zla_porpvgrw
#else
               module procedure la_zla_porpvgrw
#endif
          end interface la_porpvgrw

          !> LA_SYAMV:  performs the matrix-vector operation
          !> y := alpha*abs(A)*abs(x) + beta*abs(y),
          !> where alpha and beta are scalars, x and y are vectors and A is an
          !> n by n symmetric matrix.
          !> This function is primarily used in calculating error bounds.
          !> To protect against underflow during evaluation, components in
          !> the resulting vector are perturbed away from zero by (N+1)
          !> times the underflow threshold.  To prevent unnecessarily large
          !> errors for block-structure embedded in general matrices,
          !> "symbolically" zero components are not perturbed.  A zero
          !> entry is considered "symbolic" if all multiplications involved
          !> in computing that entry have at least one zero multiplicand.
          interface la_syamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine cla_syamv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: alpha,beta
                    integer(ilp),intent(in) :: incx,incy,lda,n,uplo
                    complex(sp),intent(in) :: a(lda,*),x(*)
                    real(sp),intent(inout) :: y(*)
               end subroutine cla_syamv
#else
               module procedure la_cla_syamv
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dla_syamv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp),intent(in) :: incx,incy,lda,n,uplo
                    real(dp),intent(inout) :: y(*)
               end subroutine dla_syamv
#else
               module procedure la_dla_syamv
#endif
               module procedure la_qla_syamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine sla_syamv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp),intent(in) :: incx,incy,lda,n,uplo
                    real(sp),intent(inout) :: y(*)
               end subroutine sla_syamv
#else
               module procedure la_sla_syamv
#endif
               module procedure la_wla_syamv
#ifdef LA_EXTERNAL_LAPACK
               subroutine zla_syamv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: alpha,beta
                    integer(ilp),intent(in) :: incx,incy,lda,n,uplo
                    complex(dp),intent(in) :: a(lda,*),x(*)
                    real(dp),intent(inout) :: y(*)
               end subroutine zla_syamv
#else
               module procedure la_zla_syamv
#endif
          end interface la_syamv

          !> LA_SYRCOND: estimates the Skeel condition number of  op(A) * op2(C)
          !> where op2 is determined by CMODE as follows
          !> CMODE =  1    op2(C) = C
          !> CMODE =  0    op2(C) = I
          !> CMODE = -1    op2(C) = inv(C)
          !> The Skeel condition number cond(A) = norminf( |inv(A)||A| )
          !> is computed by computing scaling factors R such that
          !> diag(R)*A*op2(C) is row equilibrated and computing the standard
          !> infinity-norm condition number.
          interface la_syrcond
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dla_syrcond(uplo,n,a,lda,af,ldaf,ipiv,cmode,c,info, &
                         work,iwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp),intent(out) :: work(*)
               end function dla_syrcond
#else
               module procedure la_dla_syrcond
#endif
               module procedure la_qla_syrcond
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function sla_syrcond(uplo,n,a,lda,af,ldaf,ipiv,cmode,c,info, &
                         work,iwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp),intent(out) :: work(*)
               end function sla_syrcond
#else
               module procedure la_sla_syrcond
#endif
          end interface la_syrcond

          !> LA_SYRCOND_C: Computes the infinity norm condition number of
          !> op(A) * inv(diag(C)) where C is a REAL vector.
          interface la_syrcond_c
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function cla_syrcond_c(uplo,n,a,lda,af,ldaf,ipiv,c,capply,info, &
                         work,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    logical(lk),intent(in) :: capply
                    integer(ilp),intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp),intent(out) :: work(*)
                    real(sp),intent(in) :: c(*)
                    real(sp),intent(out) :: rwork(*)
               end function cla_syrcond_c
#else
               module procedure la_cla_syrcond_c
#endif
               module procedure la_wla_syrcond_c
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zla_syrcond_c(uplo,n,a,lda,af,ldaf,ipiv,c,capply,info, &
                         work,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    logical(lk),intent(in) :: capply
                    integer(ilp),intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp),intent(out) :: work(*)
                    real(dp),intent(in) :: c(*)
                    real(dp),intent(out) :: rwork(*)
               end function zla_syrcond_c
#else
               module procedure la_zla_syrcond_c
#endif
          end interface la_syrcond_c

          !> LA_SYRPVGRW: computes the reciprocal pivot growth factor
          !> norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !> much less than 1, the stability of the LU factorization of the
          !> (equilibrated) matrix A could be poor. This also means that the
          !> solution X, estimated condition numbers, and error bounds could be
          !> unreliable.
          interface la_syrpvgrw
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function cla_syrpvgrw(uplo,n,info,a,lda,af,ldaf,ipiv,work)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp),intent(out) :: work(*)
               end function cla_syrpvgrw
#else
               module procedure la_cla_syrpvgrw
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dla_syrpvgrw(uplo,n,info,a,lda,af,ldaf,ipiv,work)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,info,lda,ldaf,ipiv(*)
                    real(dp),intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp),intent(out) :: work(*)
               end function dla_syrpvgrw
#else
               module procedure la_dla_syrpvgrw
#endif
               module procedure la_qla_syrpvgrw
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function sla_syrpvgrw(uplo,n,info,a,lda,af,ldaf,ipiv,work)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,info,lda,ldaf,ipiv(*)
                    real(sp),intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp),intent(out) :: work(*)
               end function sla_syrpvgrw
#else
               module procedure la_sla_syrpvgrw
#endif
               module procedure la_wla_syrpvgrw
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zla_syrpvgrw(uplo,n,info,a,lda,af,ldaf,ipiv,work)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp),intent(out) :: work(*)
               end function zla_syrpvgrw
#else
               module procedure la_zla_syrpvgrw
#endif
          end interface la_syrpvgrw

          !> LA_WWADDW: adds a vector W into a doubled-single vector (X, Y).
          !> This works for all extant IBM's hex and binary floating point
          !> arithmetic, but not for decimal.
          interface la_wwaddw
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cla_wwaddw(n,x,y,w)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(inout) :: x(*),y(*)
                    complex(sp),intent(in) :: w(*)
               end subroutine cla_wwaddw
#else
               module procedure la_cla_wwaddw
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dla_wwaddw(n,x,y,w)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: x(*),y(*)
                    real(dp),intent(in) :: w(*)
               end subroutine dla_wwaddw
#else
               module procedure la_dla_wwaddw
#endif
               module procedure la_qla_wwaddw
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sla_wwaddw(n,x,y,w)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: x(*),y(*)
                    real(sp),intent(in) :: w(*)
               end subroutine sla_wwaddw
#else
               module procedure la_sla_wwaddw
#endif
               module procedure la_wla_wwaddw
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zla_wwaddw(n,x,y,w)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(inout) :: x(*),y(*)
                    complex(dp),intent(in) :: w(*)
               end subroutine zla_wwaddw
#else
               module procedure la_zla_wwaddw
#endif
          end interface la_wwaddw

          !> LABAD: takes as input the values computed by DLAMCH for underflow and
          !> overflow, and returns the square root of each of these values if the
          !> log of LARGE is sufficiently large.  This subroutine is intended to
          !> identify machines with a large exponent range, such as the Crays, and
          !> redefine the underflow and overflow limits to be the square roots of
          !> the values computed by DLAMCH.  This subroutine is needed because
          !> DLAMCH does not compensate for poor arithmetic in the upper half of
          !> the exponent range, as is found on a Cray.
          interface labad
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlabad(small,large)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(inout) :: large,small
               end subroutine dlabad
#else
               module procedure la_dlabad
#endif
               module procedure la_qlabad
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slabad(small,large)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(inout) :: large,small
               end subroutine slabad
#else
               module procedure la_slabad
#endif
          end interface labad

          !> LABRD: reduces the first NB rows and columns of a complex general
          !> m by n matrix A to upper or lower real bidiagonal form by a unitary
          !> transformation Q**H * A * P, and returns the matrices X and Y which
          !> are needed to apply the transformation to the unreduced part of A.
          !> If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
          !> bidiagonal form.
          !> This is an auxiliary routine called by CGEBRD
          interface labrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clabrd(m,n,nb,a,lda,d,e,tauq,taup,x,ldx,y,ldy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: lda,ldx,ldy,m,n,nb
                    real(sp),intent(out) :: d(*),e(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine clabrd
#else
               module procedure la_clabrd
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlabrd(m,n,nb,a,lda,d,e,tauq,taup,x,ldx,y,ldy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: lda,ldx,ldy,m,n,nb
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: d(*),e(*),taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine dlabrd
#else
               module procedure la_dlabrd
#endif
               module procedure la_qlabrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slabrd(m,n,nb,a,lda,d,e,tauq,taup,x,ldx,y,ldy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: lda,ldx,ldy,m,n,nb
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: d(*),e(*),taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine slabrd
#else
               module procedure la_slabrd
#endif
               module procedure la_wlabrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlabrd(m,n,nb,a,lda,d,e,tauq,taup,x,ldx,y,ldy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: lda,ldx,ldy,m,n,nb
                    real(dp),intent(out) :: d(*),e(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine zlabrd
#else
               module procedure la_zlabrd
#endif
          end interface labrd

          !> LACGV: conjugates a complex vector of length N.
          interface lacgv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clacgv(n,x,incx)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    complex(sp),intent(inout) :: x(*)
               end subroutine clacgv
#else
               module procedure la_clacgv
#endif
               module procedure la_wlacgv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlacgv(n,x,incx)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    complex(dp),intent(inout) :: x(*)
               end subroutine zlacgv
#else
               module procedure la_zlacgv
#endif
          end interface lacgv

          !> LACON: estimates the 1-norm of a square, complex matrix A.
          !> Reverse communication is used for evaluating matrix-vector products.
          interface lacon
#ifdef LA_EXTERNAL_LAPACK
               subroutine clacon(n,v,x,est,kase)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(inout) :: kase
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: est
                    complex(sp),intent(out) :: v(n)
                    complex(sp),intent(inout) :: x(n)
               end subroutine clacon
#else
               module procedure la_clacon
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dlacon(n,v,x,isgn,est,kase)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(inout) :: kase
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: est,x(*)
                    integer(ilp),intent(out) :: isgn(*)
                    real(dp),intent(out) :: v(*)
               end subroutine dlacon
#else
               module procedure la_dlacon
#endif
               module procedure la_qlacon
#ifdef LA_EXTERNAL_LAPACK
               subroutine slacon(n,v,x,isgn,est,kase)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(inout) :: kase
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: est,x(*)
                    integer(ilp),intent(out) :: isgn(*)
                    real(sp),intent(out) :: v(*)
               end subroutine slacon
#else
               module procedure la_slacon
#endif
               module procedure la_wlacon
#ifdef LA_EXTERNAL_LAPACK
               subroutine zlacon(n,v,x,est,kase)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(inout) :: kase
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: est
                    complex(dp),intent(out) :: v(n)
                    complex(dp),intent(inout) :: x(n)
               end subroutine zlacon
#else
               module procedure la_zlacon
#endif
          end interface lacon

          !> LACPY: copies all or part of a two-dimensional matrix A to another
          !> matrix B.
          interface lacpy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clacpy(uplo,m,n,a,lda,b,ldb)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,ldb,m,n
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(out) :: b(ldb,*)
               end subroutine clacpy
#else
               module procedure la_clacpy
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlacpy(uplo,m,n,a,lda,b,ldb)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,ldb,m,n
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(out) :: b(ldb,*)
               end subroutine dlacpy
#else
               module procedure la_dlacpy
#endif
               module procedure la_qlacpy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slacpy(uplo,m,n,a,lda,b,ldb)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,ldb,m,n
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(out) :: b(ldb,*)
               end subroutine slacpy
#else
               module procedure la_slacpy
#endif
               module procedure la_wlacpy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlacpy(uplo,m,n,a,lda,b,ldb)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,ldb,m,n
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(out) :: b(ldb,*)
               end subroutine zlacpy
#else
               module procedure la_zlacpy
#endif
          end interface lacpy

          !> LACRM: performs a very simple matrix-matrix multiplication:
          !> C := A * B,
          !> where A is M by N and complex; B is N by N and real;
          !> C is M by N and complex.
          interface lacrm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clacrm(m,n,a,lda,b,ldb,c,ldc,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: lda,ldb,ldc,m,n
                    real(sp),intent(in) :: b(ldb,*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(out) :: c(ldc,*)
               end subroutine clacrm
#else
               module procedure la_clacrm
#endif
               module procedure la_wlacrm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlacrm(m,n,a,lda,b,ldb,c,ldc,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: lda,ldb,ldc,m,n
                    real(dp),intent(in) :: b(ldb,*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(out) :: c(ldc,*)
               end subroutine zlacrm
#else
               module procedure la_zlacrm
#endif
          end interface lacrm

          !> LACRT: performs the operation
          !> (  c  s )( x )  ==> ( x )
          !> ( -s  c )( y )      ( y )
          !> where c and s are complex and the vectors x and y are complex.
          interface lacrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clacrt(n,cx,incx,cy,incy,c,s)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,incy,n
                    complex(sp),intent(in) :: c,s
                    complex(sp),intent(inout) :: cx(*),cy(*)
               end subroutine clacrt
#else
               module procedure la_clacrt
#endif
               module procedure la_wlacrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlacrt(n,cx,incx,cy,incy,c,s)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,incy,n
                    complex(dp),intent(in) :: c,s
                    complex(dp),intent(inout) :: cx(*),cy(*)
               end subroutine zlacrt
#else
               module procedure la_zlacrt
#endif
          end interface lacrt

          !> LADIV_F: := X / Y, where X and Y are complex.  The computation of X / Y
          !> will not overflow on an intermediary step unless the results
          !> overflows.
          interface ladiv_f
#ifdef LA_EXTERNAL_LAPACK
               pure complex(sp) function cladiv(x,y)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    complex(sp),intent(in) :: x,y
               end function cladiv
#else
               module procedure la_cladiv
#endif
               module procedure la_wladiv
#ifdef LA_EXTERNAL_LAPACK
               pure complex(dp) function zladiv(x,y)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    complex(dp),intent(in) :: x,y
               end function zladiv
#else
               module procedure la_zladiv
#endif
          end interface ladiv_f

          !> LADIV_S: performs complex division in  real arithmetic
          !> a + i*b
          !> p + i*q = ---------
          !> c + i*d
          !> The algorithm is due to Michael Baudin and Robert L. Smith
          !> and can be found in the paper
          !> "A Robust Complex Division in Scilab"
          interface ladiv_s
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dladiv(a,b,c,d,p,q)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: a,b,c,d
                    real(dp),intent(out) :: p,q
               end subroutine dladiv
#else
               module procedure la_dladiv
#endif
               module procedure la_qladiv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sladiv(a,b,c,d,p,q)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: a,b,c,d
                    real(sp),intent(out) :: p,q
               end subroutine sladiv
#else
               module procedure la_sladiv
#endif
          end interface ladiv_s

          interface ladiv1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dladiv1(a,b,c,d,p,q)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(inout) :: a
                    real(dp),intent(in) :: b,c,d
                    real(dp),intent(out) :: p,q
               end subroutine dladiv1
#else
               module procedure la_dladiv1
#endif
               module procedure la_qladiv1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sladiv1(a,b,c,d,p,q)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(inout) :: a
                    real(sp),intent(in) :: b,c,d
                    real(sp),intent(out) :: p,q
               end subroutine sladiv1
#else
               module procedure la_sladiv1
#endif
          end interface ladiv1

          interface ladiv2
#ifdef LA_EXTERNAL_LAPACK
               pure real(dp) function dladiv2(a,b,c,d,r,t)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: a,b,c,d,r,t
               end function dladiv2
#else
               module procedure la_dladiv2
#endif
               module procedure la_qladiv2
#ifdef LA_EXTERNAL_LAPACK
               pure real(sp) function sladiv2(a,b,c,d,r,t)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: a,b,c,d,r,t
               end function sladiv2
#else
               module procedure la_sladiv2
#endif
          end interface ladiv2

          !> LAEBZ: contains the iteration loops which compute and use the
          !> function N(w), which is the count of eigenvalues of a symmetric
          !> tridiagonal matrix T less than or equal to its argument  w.  It
          !> performs a choice of two types of loops:
          !> IJOB=1, followed by
          !> IJOB=2: It takes as input a list of intervals and returns a list of
          !> sufficiently small intervals whose union contains the same
          !> eigenvalues as the union of the original intervals.
          !> The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
          !> The output interval (AB(j,1),AB(j,2)] will contain
          !> eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.
          !> IJOB=3: It performs a binary search in each input interval
          !> (AB(j,1),AB(j,2)] for a point  w(j)  such that
          !> N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
          !> the search.  If such a w(j) is found, then on output
          !> AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
          !> (AB(j,1),AB(j,2)] will be a small interval containing the
          !> point where N(w) jumps through NVAL(j), unless that point
          !> lies outside the initial interval.
          !> Note that the intervals are in all cases half-open intervals,
          !> i.e., of the form  (a,b] , which includes  b  but not  a .
          !> To avoid underflow, the matrix should be scaled so that its largest
          !> element is no greater than  overflow**(1/2) * underflow**(1/4)
          !> in absolute value.  To assure the most accurate computation
          !> of small eigenvalues, the matrix should be scaled to be
          !> not much smaller than that, either.
          !> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !> Matrix", Report CS41, Computer Science Dept., Stanford
          !> University, July 21, 1966
          !> Note: the arguments are, in general, *not* checked for unreasonable
          !> values.
          interface laebz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaebz(ijob,nitmax,n,mmax,minp,nbmin,abstol,reltol,pivmin, &
                         d,e,e2,nval,ab,c,mout,nab,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ijob,minp,mmax,n,nbmin,nitmax
                    integer(ilp),intent(out) :: info,mout,iwork(*)
                    real(dp),intent(in) :: abstol,pivmin,reltol,d(*),e(*),e2(*)
                    integer(ilp),intent(inout) :: nab(mmax,*),nval(*)
                    real(dp),intent(inout) :: ab(mmax,*),c(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlaebz
#else
               module procedure la_dlaebz
#endif
               module procedure la_qlaebz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaebz(ijob,nitmax,n,mmax,minp,nbmin,abstol,reltol,pivmin, &
                         d,e,e2,nval,ab,c,mout,nab,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ijob,minp,mmax,n,nbmin,nitmax
                    integer(ilp),intent(out) :: info,mout,iwork(*)
                    real(sp),intent(in) :: abstol,pivmin,reltol,d(*),e(*),e2(*)
                    integer(ilp),intent(inout) :: nab(mmax,*),nval(*)
                    real(sp),intent(inout) :: ab(mmax,*),c(*)
                    real(sp),intent(out) :: work(*)
               end subroutine slaebz
#else
               module procedure la_slaebz
#endif
          end interface laebz

          !> Using the divide and conquer method, LAED0: computes all eigenvalues
          !> of a symmetric tridiagonal matrix which is one diagonal block of
          !> those from reducing a dense or band Hermitian matrix and
          !> corresponding eigenvectors of the dense or band matrix.
          interface laed0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claed0(qsiz,n,d,e,q,ldq,qstore,ldqs,rwork,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldq,ldqs,n,qsiz
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: q(ldq,*)
                    complex(sp),intent(out) :: qstore(ldqs,*)
               end subroutine claed0
#else
               module procedure la_claed0
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaed0(icompq,qsiz,n,d,e,q,ldq,qstore,ldqs,work,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: icompq,ldq,ldqs,n,qsiz
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(inout) :: d(*),e(*),q(ldq,*)
                    real(dp),intent(out) :: qstore(ldqs,*),work(*)
               end subroutine dlaed0
#else
               module procedure la_dlaed0
#endif
               module procedure la_qlaed0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaed0(icompq,qsiz,n,d,e,q,ldq,qstore,ldqs,work,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: icompq,ldq,ldqs,n,qsiz
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(inout) :: d(*),e(*),q(ldq,*)
                    real(sp),intent(out) :: qstore(ldqs,*),work(*)
               end subroutine slaed0
#else
               module procedure la_slaed0
#endif
               module procedure la_wlaed0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaed0(qsiz,n,d,e,q,ldq,qstore,ldqs,rwork,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldq,ldqs,n,qsiz
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: q(ldq,*)
                    complex(dp),intent(out) :: qstore(ldqs,*)
               end subroutine zlaed0
#else
               module procedure la_zlaed0
#endif
          end interface laed0

          !> LAED1: computes the updated eigensystem of a diagonal
          !> matrix after modification by a rank-one symmetric matrix.  This
          !> routine is used only for the eigenproblem which requires all
          !> eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
          !> the case in which eigenvalues only or eigenvalues and eigenvectors
          !> of a full symmetric matrix (which was reduced to tridiagonal form)
          !> are desired.
          !> T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
          !> where Z = Q**T*u, u is a vector of length N with ones in the
          !> CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
          !> The eigenvectors of the original matrix are stored in Q, and the
          !> eigenvalues are in D.  The algorithm consists of three stages:
          !> The first stage consists of deflating the size of the problem
          !> when there are multiple eigenvalues or if there is a zero in
          !> the Z vector.  For each such occurrence the dimension of the
          !> secular equation problem is reduced by one.  This stage is
          !> performed by the routine DLAED2.
          !> The second stage consists of calculating the updated
          !> eigenvalues. This is done by finding the roots of the secular
          !> equation via the routine DLAED4 (as called by DLAED3).
          !> This routine also calculates the eigenvectors of the current
          !> problem.
          !> The final stage consists of computing the updated eigenvectors
          !> directly using the updated eigenvalues.  The eigenvectors for
          !> the current problem are multiplied with the eigenvectors from
          !> the overall problem.
          interface laed1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaed1(n,d,q,ldq,indxq,rho,cutpnt,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: cutpnt,ldq,n
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(inout) :: rho,d(*),q(ldq,*)
                    integer(ilp),intent(inout) :: indxq(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlaed1
#else
               module procedure la_dlaed1
#endif
               module procedure la_qlaed1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaed1(n,d,q,ldq,indxq,rho,cutpnt,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: cutpnt,ldq,n
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(inout) :: rho,d(*),q(ldq,*)
                    integer(ilp),intent(inout) :: indxq(*)
                    real(sp),intent(out) :: work(*)
               end subroutine slaed1
#else
               module procedure la_slaed1
#endif
          end interface laed1

          !> This subroutine computes the I-th updated eigenvalue of a symmetric
          !> rank-one modification to a diagonal matrix whose elements are
          !> given in the array d, and that
          !> D(i) < D(j)  for  i < j
          !> and that RHO > 0.  This is arranged by the calling routine, and is
          !> no loss in generality.  The rank-one modified system is thus
          !> diag( D )  +  RHO * Z * Z_transpose.
          !> where we assume the Euclidean norm of Z is 1.
          !> The method consists of approximating the rational functions in the
          !> secular equation by simpler interpolating rational functions.
          interface laed4
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaed4(n,i,d,z,delta,rho,dlam,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(out) :: dlam,delta(*)
                    real(dp),intent(in) :: rho,d(*),z(*)
               end subroutine dlaed4
#else
               module procedure la_dlaed4
#endif
               module procedure la_qlaed4
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaed4(n,i,d,z,delta,rho,dlam,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(out) :: dlam,delta(*)
                    real(sp),intent(in) :: rho,d(*),z(*)
               end subroutine slaed4
#else
               module procedure la_slaed4
#endif
          end interface laed4

          !> This subroutine computes the I-th eigenvalue of a symmetric rank-one
          !> modification of a 2-by-2 diagonal matrix
          !> diag( D )  +  RHO * Z * transpose(Z) .
          !> The diagonal elements in the array D are assumed to satisfy
          !> D(i) < D(j)  for  i < j .
          !> We also assume RHO > 0 and that the Euclidean norm of the vector
          !> Z is one.
          interface laed5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaed5(i,d,z,delta,rho,dlam)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i
                    real(dp),intent(out) :: dlam,delta(2)
                    real(dp),intent(in) :: rho,d(2),z(2)
               end subroutine dlaed5
#else
               module procedure la_dlaed5
#endif
               module procedure la_qlaed5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaed5(i,d,z,delta,rho,dlam)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i
                    real(sp),intent(out) :: dlam,delta(2)
                    real(sp),intent(in) :: rho,d(2),z(2)
               end subroutine slaed5
#else
               module procedure la_slaed5
#endif
          end interface laed5

          !> LAED6: computes the positive or negative root (closest to the origin)
          !> of
          !> z(1)        z(2)        z(3)
          !> f(x) =   rho + --------- + ---------- + ---------
          !> d(1)-x      d(2)-x      d(3)-x
          !> It is assumed that
          !> if ORGATI = .true. the root is between d(2) and d(3);
          !> otherwise it is between d(1) and d(2)
          !> This routine will be called by DLAED4 when necessary. In most cases,
          !> the root sought is the smallest in magnitude, though it might not be
          !> in some extremely rare situations.
          interface laed6
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaed6(kniter,orgati,rho,d,z,finit,tau,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: orgati
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kniter
                    real(dp),intent(in) :: finit,rho,d(3),z(3)
                    real(dp),intent(out) :: tau
               end subroutine dlaed6
#else
               module procedure la_dlaed6
#endif
               module procedure la_qlaed6
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaed6(kniter,orgati,rho,d,z,finit,tau,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: orgati
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kniter
                    real(sp),intent(in) :: finit,rho,d(3),z(3)
                    real(sp),intent(out) :: tau
               end subroutine slaed6
#else
               module procedure la_slaed6
#endif
          end interface laed6

          !> LAED7: computes the updated eigensystem of a diagonal
          !> matrix after modification by a rank-one symmetric matrix. This
          !> routine is used only for the eigenproblem which requires all
          !> eigenvalues and optionally eigenvectors of a dense or banded
          !> Hermitian matrix that has been reduced to tridiagonal form.
          !> T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)
          !> where Z = Q**Hu, u is a vector of length N with ones in the
          !> CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
          !> The eigenvectors of the original matrix are stored in Q, and the
          !> eigenvalues are in D.  The algorithm consists of three stages:
          !> The first stage consists of deflating the size of the problem
          !> when there are multiple eigenvalues or if there is a zero in
          !> the Z vector.  For each such occurrence the dimension of the
          !> secular equation problem is reduced by one.  This stage is
          !> performed by the routine SLAED2.
          !> The second stage consists of calculating the updated
          !> eigenvalues. This is done by finding the roots of the secular
          !> equation via the routine SLAED4 (as called by SLAED3).
          !> This routine also calculates the eigenvectors of the current
          !> problem.
          !> The final stage consists of computing the updated eigenvectors
          !> directly using the updated eigenvalues.  The eigenvectors for
          !> the current problem are multiplied with the eigenvectors from
          !> the overall problem.
          interface laed7
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claed7(n,cutpnt,qsiz,tlvls,curlvl,curpbm,d,q,ldq,rho, &
               indxq,qstore,qptr,prmptr,perm,givptr,givcol,givnum,work,rwork,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: curlvl,curpbm,cutpnt,ldq,n,qsiz,tlvls
                    integer(ilp),intent(out) :: info,indxq(*),iwork(*)
                    real(sp),intent(inout) :: rho,d(*),givnum(2,*),qstore(*)
                    integer(ilp),intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)
                              
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: q(ldq,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine claed7
#else
               module procedure la_claed7
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaed7(icompq,n,qsiz,tlvls,curlvl,curpbm,d,q,ldq,indxq, &
               rho,cutpnt,qstore,qptr,prmptr,perm,givptr,givcol,givnum,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: curlvl,curpbm,cutpnt,icompq,ldq,n,qsiz, &
                              tlvls
                    integer(ilp),intent(out) :: info,indxq(*),iwork(*)
                    real(dp),intent(inout) :: rho,d(*),givnum(2,*),q(ldq,*),qstore(*)
                    integer(ilp),intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)
                              
                    real(dp),intent(out) :: work(*)
               end subroutine dlaed7
#else
               module procedure la_dlaed7
#endif
               module procedure la_qlaed7
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaed7(icompq,n,qsiz,tlvls,curlvl,curpbm,d,q,ldq,indxq, &
               rho,cutpnt,qstore,qptr,prmptr,perm,givptr,givcol,givnum,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: curlvl,curpbm,cutpnt,icompq,ldq,n,qsiz, &
                              tlvls
                    integer(ilp),intent(out) :: info,indxq(*),iwork(*)
                    real(sp),intent(inout) :: rho,d(*),givnum(2,*),q(ldq,*),qstore(*)
                    integer(ilp),intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)
                              
                    real(sp),intent(out) :: work(*)
               end subroutine slaed7
#else
               module procedure la_slaed7
#endif
               module procedure la_wlaed7
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaed7(n,cutpnt,qsiz,tlvls,curlvl,curpbm,d,q,ldq,rho, &
               indxq,qstore,qptr,prmptr,perm,givptr,givcol,givnum,work,rwork,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: curlvl,curpbm,cutpnt,ldq,n,qsiz,tlvls
                    integer(ilp),intent(out) :: info,indxq(*),iwork(*)
                    real(dp),intent(inout) :: rho,d(*),givnum(2,*),qstore(*)
                    integer(ilp),intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)
                              
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: q(ldq,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zlaed7
#else
               module procedure la_zlaed7
#endif
          end interface laed7

          !> LAED8: merges the two sets of eigenvalues together into a single
          !> sorted set.  Then it tries to deflate the size of the problem.
          !> There are two ways in which deflation can occur:  when two or more
          !> eigenvalues are close together or if there is a tiny element in the
          !> Z vector.  For each such occurrence the order of the related secular
          !> equation problem is reduced by one.
          interface laed8
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claed8(k,n,qsiz,q,ldq,d,rho,cutpnt,z,dlamda,q2,ldq2,w, &
                         indxp,indx,indxq,perm,givptr,givcol,givnum,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: cutpnt,ldq,ldq2,n,qsiz
                    integer(ilp),intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm( &
                              *)
                    real(sp),intent(inout) :: rho,d(*),z(*)
                    integer(ilp),intent(inout) :: indxq(*)
                    real(sp),intent(out) :: dlamda(*),givnum(2,*),w(*)
                    complex(sp),intent(inout) :: q(ldq,*)
                    complex(sp),intent(out) :: q2(ldq2,*)
               end subroutine claed8
#else
               module procedure la_claed8
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaed8(icompq,k,n,qsiz,d,q,ldq,indxq,rho,cutpnt,z, &
                         dlamda,q2,ldq2,w,perm,givptr,givcol,givnum,indxp,indx,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: cutpnt,icompq,ldq,ldq2,n,qsiz
                    integer(ilp),intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm( &
                              *)
                    real(dp),intent(inout) :: rho,d(*),q(ldq,*),z(*)
                    integer(ilp),intent(inout) :: indxq(*)
                    real(dp),intent(out) :: dlamda(*),givnum(2,*),q2(ldq2,*),w(*)
               end subroutine dlaed8
#else
               module procedure la_dlaed8
#endif
               module procedure la_qlaed8
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaed8(icompq,k,n,qsiz,d,q,ldq,indxq,rho,cutpnt,z, &
                         dlamda,q2,ldq2,w,perm,givptr,givcol,givnum,indxp,indx,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: cutpnt,icompq,ldq,ldq2,n,qsiz
                    integer(ilp),intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm( &
                              *)
                    real(sp),intent(inout) :: rho,d(*),q(ldq,*),z(*)
                    integer(ilp),intent(inout) :: indxq(*)
                    real(sp),intent(out) :: dlamda(*),givnum(2,*),q2(ldq2,*),w(*)
               end subroutine slaed8
#else
               module procedure la_slaed8
#endif
               module procedure la_wlaed8
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaed8(k,n,qsiz,q,ldq,d,rho,cutpnt,z,dlamda,q2,ldq2,w, &
                         indxp,indx,indxq,perm,givptr,givcol,givnum,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: cutpnt,ldq,ldq2,n,qsiz
                    integer(ilp),intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm( &
                              *)
                    real(dp),intent(inout) :: rho,d(*),z(*)
                    integer(ilp),intent(inout) :: indxq(*)
                    real(dp),intent(out) :: dlamda(*),givnum(2,*),w(*)
                    complex(dp),intent(inout) :: q(ldq,*)
                    complex(dp),intent(out) :: q2(ldq2,*)
               end subroutine zlaed8
#else
               module procedure la_zlaed8
#endif
          end interface laed8

          !> LAED9: finds the roots of the secular equation, as defined by the
          !> values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
          !> appropriate calls to DLAED4 and then stores the new matrix of
          !> eigenvectors for use in calculating the next level of Z vectors.
          interface laed9
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaed9(k,kstart,kstop,n,d,q,ldq,rho,dlamda,w,s,lds, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,kstart,kstop,ldq,lds,n
                    real(dp),intent(in) :: rho
                    real(dp),intent(out) :: d(*),q(ldq,*),s(lds,*)
                    real(dp),intent(inout) :: dlamda(*),w(*)
               end subroutine dlaed9
#else
               module procedure la_dlaed9
#endif
               module procedure la_qlaed9
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaed9(k,kstart,kstop,n,d,q,ldq,rho,dlamda,w,s,lds, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,kstart,kstop,ldq,lds,n
                    real(sp),intent(in) :: rho
                    real(sp),intent(out) :: d(*),q(ldq,*),s(lds,*)
                    real(sp),intent(inout) :: dlamda(*),w(*)
               end subroutine slaed9
#else
               module procedure la_slaed9
#endif
          end interface laed9

          !> LAEDA: computes the Z vector corresponding to the merge step in the
          !> CURLVLth step of the merge process with TLVLS steps for the CURPBMth
          !> problem.
          interface laeda
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaeda(n,tlvls,curlvl,curpbm,prmptr,perm,givptr,givcol, &
                         givnum,q,qptr,z,ztemp,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: curlvl,curpbm,n,tlvls,givcol(2,*),givptr(*),perm( &
                              *),prmptr(*),qptr(*)
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: givnum(2,*),q(*)
                    real(dp),intent(out) :: z(*),ztemp(*)
               end subroutine dlaeda
#else
               module procedure la_dlaeda
#endif
               module procedure la_qlaeda
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaeda(n,tlvls,curlvl,curpbm,prmptr,perm,givptr,givcol, &
                         givnum,q,qptr,z,ztemp,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: curlvl,curpbm,n,tlvls,givcol(2,*),givptr(*),perm( &
                              *),prmptr(*),qptr(*)
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: givnum(2,*),q(*)
                    real(sp),intent(out) :: z(*),ztemp(*)
               end subroutine slaeda
#else
               module procedure la_slaeda
#endif
          end interface laeda

          !> LAEIN: uses inverse iteration to find a right or left eigenvector
          !> corresponding to the eigenvalue W of a complex upper Hessenberg
          !> matrix H.
          interface laein
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claein(rightv,noinit,n,h,ldh,w,v,b,ldb,rwork,eps3, &
                         smlnum,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: noinit,rightv
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldh,n
                    real(sp),intent(in) :: eps3,smlnum
                    complex(sp),intent(in) :: w,h(ldh,*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(out) :: b(ldb,*)
                    complex(sp),intent(inout) :: v(*)
               end subroutine claein
#else
               module procedure la_claein
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaein(rightv,noinit,n,h,ldh,wr,wi,vr,vi,b,ldb,work, &
                         eps3,smlnum,bignum,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: noinit,rightv
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldh,n
                    real(dp),intent(in) :: bignum,eps3,smlnum,wi,wr,h(ldh,*)
                    real(dp),intent(out) :: b(ldb,*),work(*)
                    real(dp),intent(inout) :: vi(*),vr(*)
               end subroutine dlaein
#else
               module procedure la_dlaein
#endif
               module procedure la_qlaein
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaein(rightv,noinit,n,h,ldh,wr,wi,vr,vi,b,ldb,work, &
                         eps3,smlnum,bignum,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: noinit,rightv
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldh,n
                    real(sp),intent(in) :: bignum,eps3,smlnum,wi,wr,h(ldh,*)
                    real(sp),intent(out) :: b(ldb,*),work(*)
                    real(sp),intent(inout) :: vi(*),vr(*)
               end subroutine slaein
#else
               module procedure la_slaein
#endif
               module procedure la_wlaein
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaein(rightv,noinit,n,h,ldh,w,v,b,ldb,rwork,eps3, &
                         smlnum,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: noinit,rightv
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldh,n
                    real(dp),intent(in) :: eps3,smlnum
                    complex(dp),intent(in) :: w,h(ldh,*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(out) :: b(ldb,*)
                    complex(dp),intent(inout) :: v(*)
               end subroutine zlaein
#else
               module procedure la_zlaein
#endif
          end interface laein

          !> LAESY: computes the eigendecomposition of a 2-by-2 symmetric matrix
          !> ( ( A, B );( B, C ) )
          !> provided the norm of the matrix of eigenvectors is larger than
          !> some threshold value.
          !> RT1 is the eigenvalue of larger absolute value, and RT2 of
          !> smaller absolute value.  If the eigenvectors are computed, then
          !> on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence
          !> [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
          !> [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]
          interface laesy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claesy(a,b,c,rt1,rt2,evscal,cs1,sn1)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    complex(sp),intent(in) :: a,b,c
                    complex(sp),intent(out) :: cs1,evscal,rt1,rt2,sn1
               end subroutine claesy
#else
               module procedure la_claesy
#endif
               module procedure la_wlaesy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaesy(a,b,c,rt1,rt2,evscal,cs1,sn1)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    complex(dp),intent(in) :: a,b,c
                    complex(dp),intent(out) :: cs1,evscal,rt1,rt2,sn1
               end subroutine zlaesy
#else
               module procedure la_zlaesy
#endif
          end interface laesy

          !> LAEXC: swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
          !> an upper quasi-triangular matrix T by an orthogonal similarity
          !> transformation.
          !> T must be in Schur canonical form, that is, block upper triangular
          !> with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
          !> has its diagonal elements equal and its off-diagonal elements of
          !> opposite sign.
          interface laexc
#ifdef LA_EXTERNAL_LAPACK
               subroutine dlaexc(wantq,n,t,ldt,q,ldq,j1,n1,n2,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantq
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: j1,ldq,ldt,n,n1,n2
                    real(dp),intent(inout) :: q(ldq,*),t(ldt,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlaexc
#else
               module procedure la_dlaexc
#endif
               module procedure la_qlaexc
#ifdef LA_EXTERNAL_LAPACK
               subroutine slaexc(wantq,n,t,ldt,q,ldq,j1,n1,n2,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantq
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: j1,ldq,ldt,n,n1,n2
                    real(sp),intent(inout) :: q(ldq,*),t(ldt,*)
                    real(sp),intent(out) :: work(*)
               end subroutine slaexc
#else
               module procedure la_slaexc
#endif
          end interface laexc

          !> LAGTF: factorizes the matrix (T - lambda*I), where T is an n by n
          !> tridiagonal matrix and lambda is a scalar, as
          !> T - lambda*I = PLU,
          !> where P is a permutation matrix, L is a unit lower tridiagonal matrix
          !> with at most one non-zero sub-diagonal elements per column and U is
          !> an upper triangular matrix with at most two non-zero super-diagonal
          !> elements per column.
          !> The factorization is obtained by Gaussian elimination with partial
          !> pivoting and implicit row scaling.
          !> The parameter LAMBDA is included in the routine so that LAGTF may
          !> be used, in conjunction with DLAGTS, to obtain eigenvectors of T by
          !> inverse iteration.
          interface lagtf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlagtf(n,a,lambda,b,c,tol,d,in,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,in(*)
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: lambda,tol
                    real(dp),intent(inout) :: a(*),b(*),c(*)
                    real(dp),intent(out) :: d(*)
               end subroutine dlagtf
#else
               module procedure la_dlagtf
#endif
               module procedure la_qlagtf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slagtf(n,a,lambda,b,c,tol,d,in,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,in(*)
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: lambda,tol
                    real(sp),intent(inout) :: a(*),b(*),c(*)
                    real(sp),intent(out) :: d(*)
               end subroutine slagtf
#else
               module procedure la_slagtf
#endif
          end interface lagtf

          !> LAGTM: performs a matrix-vector product of the form
          !> B := alpha * A * X + beta * B
          !> where A is a tridiagonal matrix of order N, B and X are N by NRHS
          !> matrices, and alpha and beta are real scalars, each of which may be
          !> 0., 1., or -1.
          interface lagtm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clagtm(trans,n,nrhs,alpha,dl,d,du,x,ldx,beta,b,ldb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(sp),intent(in) :: alpha,beta
                    complex(sp),intent(inout) :: b(ldb,*)
                    complex(sp),intent(in) :: d(*),dl(*),du(*),x(ldx,*)
               end subroutine clagtm
#else
               module procedure la_clagtm
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlagtm(trans,n,nrhs,alpha,dl,d,du,x,ldx,beta,b,ldb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(dp),intent(in) :: alpha,beta,d(*),dl(*),du(*),x(ldx,*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dlagtm
#else
               module procedure la_dlagtm
#endif
               module procedure la_qlagtm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slagtm(trans,n,nrhs,alpha,dl,d,du,x,ldx,beta,b,ldb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(sp),intent(in) :: alpha,beta,d(*),dl(*),du(*),x(ldx,*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine slagtm
#else
               module procedure la_slagtm
#endif
               module procedure la_wlagtm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlagtm(trans,n,nrhs,alpha,dl,d,du,x,ldx,beta,b,ldb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(dp),intent(in) :: alpha,beta
                    complex(dp),intent(inout) :: b(ldb,*)
                    complex(dp),intent(in) :: d(*),dl(*),du(*),x(ldx,*)
               end subroutine zlagtm
#else
               module procedure la_zlagtm
#endif
          end interface lagtm

          !> LAGTS: may be used to solve one of the systems of equations
          !> (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,
          !> where T is an n by n tridiagonal matrix, for x, following the
          !> factorization of (T - lambda*I) as
          !> (T - lambda*I) = P*L*U ,
          !> by routine DLAGTF. The choice of equation to be solved is
          !> controlled by the argument JOB, and in each case there is an option
          !> to perturb zero or very small diagonal elements of U, this option
          !> being intended for use in applications such as inverse iteration.
          interface lagts
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlagts(job,n,a,b,c,d,in,y,tol,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: job,n,in(*)
                    real(dp),intent(inout) :: tol,y(*)
                    real(dp),intent(in) :: a(*),b(*),c(*),d(*)
               end subroutine dlagts
#else
               module procedure la_dlagts
#endif
               module procedure la_qlagts
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slagts(job,n,a,b,c,d,in,y,tol,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: job,n,in(*)
                    real(sp),intent(inout) :: tol,y(*)
                    real(sp),intent(in) :: a(*),b(*),c(*),d(*)
               end subroutine slagts
#else
               module procedure la_slagts
#endif
          end interface lagts

          !> LAHEF: computes a partial factorization of a complex Hermitian
          !> matrix A using the Bunch-Kaufman diagonal pivoting method. The
          !> partial factorization has the form:
          !> A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
          !> ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
          !> A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
          !> ( L21  I ) (  0  A22 ) (  0      I     )
          !> where the order of D is at most NB. The actual order is returned in
          !> the argument KB, and is either NB or NB-1, or N if N <= NB.
          !> Note that U**H denotes the conjugate transpose of U.
          !> LAHEF is an auxiliary routine called by CHETRF. It uses blocked code
          !> (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
          !> A22 (if UPLO = 'L').
          interface lahef
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clahef(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: w(ldw,*)
               end subroutine clahef
#else
               module procedure la_clahef
#endif
               module procedure la_wlahef
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlahef(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: w(ldw,*)
               end subroutine zlahef
#else
               module procedure la_zlahef
#endif
          end interface lahef

          !> LAHEF_AA: factorizes a panel of a complex hermitian matrix A using
          !> the Aasen's algorithm. The panel consists of a set of NB rows of A
          !> when UPLO is U, or a set of NB columns when UPLO is L.
          !> In order to factorize the panel, the Aasen's algorithm requires the
          !> last row, or column, of the previous panel. The first row, or column,
          !> of A is set to be the first row, or column, of an identity matrix,
          !> which is used to factorize the first panel.
          !> The resulting J-th row of U, or J-th column of L, is stored in the
          !> (J-1)-th row, or column, of A (without the unit diagonals), while
          !> the diagonal and subdiagonal of A are overwritten by those of T.
          interface lahef_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clahef_aa(uplo,j1,m,nb,a,lda,ipiv,h,ldh,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp),intent(out) :: ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*),h(ldh,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine clahef_aa
#else
               module procedure la_clahef_aa
#endif
               module procedure la_wlahef_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlahef_aa(uplo,j1,m,nb,a,lda,ipiv,h,ldh,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp),intent(out) :: ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*),h(ldh,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zlahef_aa
#else
               module procedure la_zlahef_aa
#endif
          end interface lahef_aa

          !> LAHEF_RK: computes a partial factorization of a complex Hermitian
          !> matrix A using the bounded Bunch-Kaufman (rook) diagonal
          !> pivoting method. The partial factorization has the form:
          !> A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !> ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
          !> A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L',
          !> ( L21  I ) (  0  A22 ) (  0       I    )
          !> where the order of D is at most NB. The actual order is returned in
          !> the argument KB, and is either NB or NB-1, or N if N <= NB.
          !> LAHEF_RK is an auxiliary routine called by CHETRF_RK. It uses
          !> blocked code (calling Level 3 BLAS) to update the submatrix
          !> A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
          interface lahef_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clahef_rk(uplo,n,nb,kb,a,lda,e,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: w(ldw,*),e(*)
               end subroutine clahef_rk
#else
               module procedure la_clahef_rk
#endif
               module procedure la_wlahef_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlahef_rk(uplo,n,nb,kb,a,lda,e,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: w(ldw,*),e(*)
               end subroutine zlahef_rk
#else
               module procedure la_zlahef_rk
#endif
          end interface lahef_rk

          !> LAHEF_ROOK: computes a partial factorization of a complex Hermitian
          !> matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting
          !> method. The partial factorization has the form:
          !> A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
          !> ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
          !> A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
          !> ( L21  I ) (  0  A22 ) (  0      I     )
          !> where the order of D is at most NB. The actual order is returned in
          !> the argument KB, and is either NB or NB-1, or N if N <= NB.
          !> Note that U**H denotes the conjugate transpose of U.
          !> LAHEF_ROOK is an auxiliary routine called by CHETRF_ROOK. It uses
          !> blocked code (calling Level 3 BLAS) to update the submatrix
          !> A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
          interface lahef_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clahef_rook(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: w(ldw,*)
               end subroutine clahef_rook
#else
               module procedure la_clahef_rook
#endif
               module procedure la_wlahef_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlahef_rook(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: w(ldw,*)
               end subroutine zlahef_rook
#else
               module procedure la_zlahef_rook
#endif
          end interface lahef_rook

          !> LAHQR: is an auxiliary routine called by CHSEQR to update the
          !> eigenvalues and Schur decomposition already computed by CHSEQR, by
          !> dealing with the Hessenberg submatrix in rows and columns ILO to
          !> IHI.
          interface lahqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clahqr(wantt,wantz,n,ilo,ihi,h,ldh,w,iloz,ihiz,z,ldz, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    complex(sp),intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp),intent(out) :: w(*)
               end subroutine clahqr
#else
               module procedure la_clahqr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlahqr(wantt,wantz,n,ilo,ihi,h,ldh,wr,wi,iloz,ihiz,z, &
                         ldz,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    real(dp),intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp),intent(out) :: wi(*),wr(*)
               end subroutine dlahqr
#else
               module procedure la_dlahqr
#endif
               module procedure la_qlahqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slahqr(wantt,wantz,n,ilo,ihi,h,ldh,wr,wi,iloz,ihiz,z, &
                         ldz,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    real(sp),intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp),intent(out) :: wi(*),wr(*)
               end subroutine slahqr
#else
               module procedure la_slahqr
#endif
               module procedure la_wlahqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlahqr(wantt,wantz,n,ilo,ihi,h,ldh,w,iloz,ihiz,z,ldz, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    complex(dp),intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp),intent(out) :: w(*)
               end subroutine zlahqr
#else
               module procedure la_zlahqr
#endif
          end interface lahqr

          !> LAIC1: applies one step of incremental condition estimation in
          !> its simplest version:
          !> Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
          !> lower triangular matrix L, such that
          !> twonorm(L*x) = sest
          !> Then LAIC1 computes sestpr, s, c such that
          !> the vector
          !> [ s*x ]
          !> xhat = [  c  ]
          !> is an approximate singular vector of
          !> [ L      0  ]
          !> Lhat = [ w**H gamma ]
          !> in the sense that
          !> twonorm(Lhat*xhat) = sestpr.
          !> Depending on JOB, an estimate for the largest or smallest singular
          !> value is computed.
          !> Note that [s c]**H and sestpr**2 is an eigenpair of the system
          !> diag(sest*sest, 0) + [alpha  gamma] * [ conjg(alpha) ]
          !> [ conjg(gamma) ]
          !> where  alpha =  x**H*w.
          interface laic1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claic1(job,j,x,sest,w,gamma,sestpr,s,c)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: j,job
                    real(sp),intent(in) :: sest
                    real(sp),intent(out) :: sestpr
                    complex(sp),intent(out) :: c,s
                    complex(sp),intent(in) :: gamma,w(j),x(j)
               end subroutine claic1
#else
               module procedure la_claic1
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaic1(job,j,x,sest,w,gamma,sestpr,s,c)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: j,job
                    real(dp),intent(out) :: c,s,sestpr
                    real(dp),intent(in) :: gamma,sest,w(j),x(j)
               end subroutine dlaic1
#else
               module procedure la_dlaic1
#endif
               module procedure la_qlaic1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaic1(job,j,x,sest,w,gamma,sestpr,s,c)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: j,job
                    real(sp),intent(out) :: c,s,sestpr
                    real(sp),intent(in) :: gamma,sest,w(j),x(j)
               end subroutine slaic1
#else
               module procedure la_slaic1
#endif
               module procedure la_wlaic1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaic1(job,j,x,sest,w,gamma,sestpr,s,c)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: j,job
                    real(dp),intent(in) :: sest
                    real(dp),intent(out) :: sestpr
                    complex(dp),intent(out) :: c,s
                    complex(dp),intent(in) :: gamma,w(j),x(j)
               end subroutine zlaic1
#else
               module procedure la_zlaic1
#endif
          end interface laic1

          !> This routine is not for general use.  It exists solely to avoid
          !> over-optimization in DISNAN.
          !> LAISNAN: checks for NaNs by comparing its two arguments for
          !> inequality.  NaN is the only floating-point value where NaN != NaN
          !> returns .TRUE.  To check for NaNs, pass the same variable as both
          !> arguments.
          !> A compiler must assume that the two arguments are
          !> not the same variable, and the test will not be optimized away.
          !> Interprocedural or whole-program optimization may delete this
          !> test.  The ISNAN functions will be replaced by the correct
          !> Fortran 03 intrinsic once the intrinsic is widely available.
          interface laisnan
#ifdef LA_EXTERNAL_LAPACK
               pure logical(lk) function dlaisnan(din1,din2)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: din1,din2
               end function dlaisnan
#else
               module procedure la_dlaisnan
#endif
               module procedure la_qlaisnan
#ifdef LA_EXTERNAL_LAPACK
               pure logical(lk) function slaisnan(sin1,sin2)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: sin1,sin2
               end function slaisnan
#else
               module procedure la_slaisnan
#endif
          end interface laisnan

          !> LALS0: applies back the multiplying factors of either the left or the
          !> right singular vector matrix of a diagonal matrix appended by a row
          !> to the right hand side matrix B in solving the least squares problem
          !> using the divide-and-conquer SVD approach.
          !> For the left singular vector matrix, three types of orthogonal
          !> matrices are involved:
          !> (1L) Givens rotations: the number of such rotations is GIVPTR; the
          !> pairs of columns/rows they were applied to are stored in GIVCOL;
          !> and the C- and S-values of these rotations are stored in GIVNUM.
          !> (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
          !> row, and for J=2:N, PERM(J)-th row of B is to be moved to the
          !> J-th row.
          !> (3L) The left singular vector matrix of the remaining matrix.
          !> For the right singular vector matrix, four types of orthogonal
          !> matrices are involved:
          !> (1R) The right singular vector matrix of the remaining matrix.
          !> (2R) If SQRE = 1, one extra Givens rotation to generate the right
          !> null space.
          !> (3R) The inverse transformation of (2L).
          !> (4R) The inverse transformation of (1L).
          interface lals0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clals0(icompq,nl,nr,sqre,nrhs,b,ldb,bx,ldbx,perm,givptr, &
                         givcol,ldgcol,givnum,ldgnum,poles,difl,difr,z,k,c,s,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs, &
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles( &
                              ldgnum,*),z(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: b(ldb,*)
                    complex(sp),intent(out) :: bx(ldbx,*)
               end subroutine clals0
#else
               module procedure la_clals0
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlals0(icompq,nl,nr,sqre,nrhs,b,ldb,bx,ldbx,perm,givptr, &
                         givcol,ldgcol,givnum,ldgnum,poles,difl,difr,z,k,c,s,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs, &
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles( &
                              ldgnum,*),z(*)
                    real(dp),intent(inout) :: b(ldb,*)
                    real(dp),intent(out) :: bx(ldbx,*),work(*)
               end subroutine dlals0
#else
               module procedure la_dlals0
#endif
               module procedure la_qlals0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slals0(icompq,nl,nr,sqre,nrhs,b,ldb,bx,ldbx,perm,givptr, &
                         givcol,ldgcol,givnum,ldgnum,poles,difl,difr,z,k,c,s,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs, &
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles( &
                              ldgnum,*),z(*)
                    real(sp),intent(inout) :: b(ldb,*)
                    real(sp),intent(out) :: bx(ldbx,*),work(*)
               end subroutine slals0
#else
               module procedure la_slals0
#endif
               module procedure la_wlals0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlals0(icompq,nl,nr,sqre,nrhs,b,ldb,bx,ldbx,perm,givptr, &
                         givcol,ldgcol,givnum,ldgnum,poles,difl,difr,z,k,c,s,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs, &
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles( &
                              ldgnum,*),z(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: b(ldb,*)
                    complex(dp),intent(out) :: bx(ldbx,*)
               end subroutine zlals0
#else
               module procedure la_zlals0
#endif
          end interface lals0

          !> LALSA: is an itermediate step in solving the least squares problem
          !> by computing the SVD of the coefficient matrix in compact form (The
          !> singular vectors are computed as products of simple orthorgonal
          !> matrices.).
          !> If ICOMPQ = 0, LALSA applies the inverse of the left singular vector
          !> matrix of an upper bidiagonal matrix to the right hand side; and if
          !> ICOMPQ = 1, LALSA applies the right singular vector matrix to the
          !> right hand side. The singular vector matrices were generated in
          !> compact form by LALSA.
          interface lalsa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clalsa(icompq,smlsiz,n,nrhs,b,ldb,bx,ldbx,u,ldu,vt,k, &
               difl,difr,z,poles,givptr,givcol,ldgcol,perm,givnum,c,s,rwork,iwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol( &
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu, &
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: b(ldb,*)
                    complex(sp),intent(out) :: bx(ldbx,*)
               end subroutine clalsa
#else
               module procedure la_clalsa
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlalsa(icompq,smlsiz,n,nrhs,b,ldb,bx,ldbx,u,ldu,vt,k, &
               difl,difr,z,poles,givptr,givcol,ldgcol,perm,givnum,c,s,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol( &
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(inout) :: b(ldb,*)
                    real(dp),intent(out) :: bx(ldbx,*),work(*)
                    real(dp),intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu, &
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
               end subroutine dlalsa
#else
               module procedure la_dlalsa
#endif
               module procedure la_qlalsa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slalsa(icompq,smlsiz,n,nrhs,b,ldb,bx,ldbx,u,ldu,vt,k, &
               difl,difr,z,poles,givptr,givcol,ldgcol,perm,givnum,c,s,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol( &
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(inout) :: b(ldb,*)
                    real(sp),intent(out) :: bx(ldbx,*),work(*)
                    real(sp),intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu, &
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
               end subroutine slalsa
#else
               module procedure la_slalsa
#endif
               module procedure la_wlalsa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlalsa(icompq,smlsiz,n,nrhs,b,ldb,bx,ldbx,u,ldu,vt,k, &
               difl,difr,z,poles,givptr,givcol,ldgcol,perm,givnum,c,s,rwork,iwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol( &
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu, &
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: b(ldb,*)
                    complex(dp),intent(out) :: bx(ldbx,*)
               end subroutine zlalsa
#else
               module procedure la_zlalsa
#endif
          end interface lalsa

          !> LALSD: uses the singular value decomposition of A to solve the least
          !> squares problem of finding X to minimize the Euclidean norm of each
          !> column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
          !> are N-by-NRHS. The solution X overwrites B.
          !> The singular values of A smaller than RCOND times the largest
          !> singular value are treated as zero in solving the least squares
          !> problem; in this case a minimum norm solution is returned.
          !> The actual singular values are returned in D in ascending order.
          !> This code makes very mild assumptions about floating point
          !> arithmetic. It will work on machines with a guard digit in
          !> add/subtract, or on those binary machines without guard digits
          !> which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
          !> It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface lalsd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clalsd(uplo,smlsiz,n,nrhs,d,e,b,ldb,rcond,rank,work, &
                         rwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,rank,iwork(*)
                    integer(ilp),intent(in) :: ldb,n,nrhs,smlsiz
                    real(sp),intent(in) :: rcond
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine clalsd
#else
               module procedure la_clalsd
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlalsd(uplo,smlsiz,n,nrhs,d,e,b,ldb,rcond,rank,work, &
                         iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,rank,iwork(*)
                    integer(ilp),intent(in) :: ldb,n,nrhs,smlsiz
                    real(dp),intent(in) :: rcond
                    real(dp),intent(inout) :: b(ldb,*),d(*),e(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlalsd
#else
               module procedure la_dlalsd
#endif
               module procedure la_qlalsd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slalsd(uplo,smlsiz,n,nrhs,d,e,b,ldb,rcond,rank,work, &
                         iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,rank,iwork(*)
                    integer(ilp),intent(in) :: ldb,n,nrhs,smlsiz
                    real(sp),intent(in) :: rcond
                    real(sp),intent(inout) :: b(ldb,*),d(*),e(*)
                    real(sp),intent(out) :: work(*)
               end subroutine slalsd
#else
               module procedure la_slalsd
#endif
               module procedure la_wlalsd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlalsd(uplo,smlsiz,n,nrhs,d,e,b,ldb,rcond,rank,work, &
                         rwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,rank,iwork(*)
                    integer(ilp),intent(in) :: ldb,n,nrhs,smlsiz
                    real(dp),intent(in) :: rcond
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zlalsd
#else
               module procedure la_zlalsd
#endif
          end interface lalsd

          !> LAMRG: will create a permutation list which will merge the elements
          !> of A (which is composed of two independently sorted sets) into a
          !> single set which is sorted in ascending order.
          interface lamrg
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlamrg(n1,n2,a,dtrd1,dtrd2,index)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: dtrd1,dtrd2,n1,n2
                    integer(ilp),intent(out) :: index(*)
                    real(dp),intent(in) :: a(*)
               end subroutine dlamrg
#else
               module procedure la_dlamrg
#endif
               module procedure la_qlamrg
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slamrg(n1,n2,a,strd1,strd2,index)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n1,n2,strd1,strd2
                    integer(ilp),intent(out) :: index(*)
                    real(sp),intent(in) :: a(*)
               end subroutine slamrg
#else
               module procedure la_slamrg
#endif
          end interface lamrg

          !> LAMSWLQ: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix defined as the product of blocked
          !> elementary reflectors computed by short wide LQ
          !> factorization (CLASWLQ)
          interface lamswlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clamswlq(side,trans,m,n,k,mb,nb,a,lda,t,ldt,c,ldc, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(sp),intent(in) :: a(lda,*),t(ldt,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: c(ldc,*)
               end subroutine clamswlq
#else
               module procedure la_clamswlq
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlamswlq(side,trans,m,n,k,mb,nb,a,lda,t,ldt,c,ldc, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(dp),intent(in) :: a(lda,*),t(ldt,*)
                    real(dp),intent(out) :: work(*)
                    real(dp),intent(inout) :: c(ldc,*)
               end subroutine dlamswlq
#else
               module procedure la_dlamswlq
#endif
               module procedure la_qlamswlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slamswlq(side,trans,m,n,k,mb,nb,a,lda,t,ldt,c,ldc, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(sp),intent(in) :: a(lda,*),t(ldt,*)
                    real(sp),intent(out) :: work(*)
                    real(sp),intent(inout) :: c(ldc,*)
               end subroutine slamswlq
#else
               module procedure la_slamswlq
#endif
               module procedure la_wlamswlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlamswlq(side,trans,m,n,k,mb,nb,a,lda,t,ldt,c,ldc, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(dp),intent(in) :: a(lda,*),t(ldt,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: c(ldc,*)
               end subroutine zlamswlq
#else
               module procedure la_zlamswlq
#endif
          end interface lamswlq

          !> LAMTSQR: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix defined as the product
          !> of blocked elementary reflectors computed by tall skinny
          !> QR factorization (CLATSQR)
          interface lamtsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clamtsqr(side,trans,m,n,k,mb,nb,a,lda,t,ldt,c,ldc, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(sp),intent(in) :: a(lda,*),t(ldt,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: c(ldc,*)
               end subroutine clamtsqr
#else
               module procedure la_clamtsqr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlamtsqr(side,trans,m,n,k,mb,nb,a,lda,t,ldt,c,ldc, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(dp),intent(in) :: a(lda,*),t(ldt,*)
                    real(dp),intent(out) :: work(*)
                    real(dp),intent(inout) :: c(ldc,*)
               end subroutine dlamtsqr
#else
               module procedure la_dlamtsqr
#endif
               module procedure la_qlamtsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slamtsqr(side,trans,m,n,k,mb,nb,a,lda,t,ldt,c,ldc, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(sp),intent(in) :: a(lda,*),t(ldt,*)
                    real(sp),intent(out) :: work(*)
                    real(sp),intent(inout) :: c(ldc,*)
               end subroutine slamtsqr
#else
               module procedure la_slamtsqr
#endif
               module procedure la_wlamtsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlamtsqr(side,trans,m,n,k,mb,nb,a,lda,t,ldt,c,ldc, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(dp),intent(in) :: a(lda,*),t(ldt,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: c(ldc,*)
               end subroutine zlamtsqr
#else
               module procedure la_zlamtsqr
#endif
          end interface lamtsqr

          !> LANEG: computes the Sturm count, the number of negative pivots
          !> encountered while factoring tridiagonal T - sigma I = L D L^T.
          !> This implementation works directly on the factors without forming
          !> the tridiagonal matrix T.  The Sturm count is also the number of
          !> eigenvalues of T less than sigma.
          !> This routine is called from DLARRB.
          !> The current routine does not use the PIVMIN parameter but rather
          !> requires IEEE-754 propagation of Infinities and NaNs.  This
          !> routine also has no input range restrictions but does require
          !> default exception handling such that x/0 produces Inf when x is
          !> non-zero, and Inf/Inf produces NaN.  For more information, see:
          !> Marques, Riedy, and Voemel, "Benefits of IEEE-754 Features in
          !> Modern Symmetric Tridiagonal Eigensolvers," SIAM Journal on
          !> Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624
          !> (Tech report version in LAWN 172 with the same title.)
          interface laneg
#ifdef LA_EXTERNAL_LAPACK
               pure integer(ilp) function dlaneg(n,d,lld,sigma,pivmin,r)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,r
                    real(dp),intent(in) :: pivmin,sigma,d(*),lld(*)
               end function dlaneg
#else
               module procedure la_dlaneg
#endif
               module procedure la_qlaneg
#ifdef LA_EXTERNAL_LAPACK
               pure integer(ilp) function slaneg(n,d,lld,sigma,pivmin,r)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n,r
                    real(sp),intent(in) :: pivmin,sigma,d(*),lld(*)
               end function slaneg
#else
               module procedure la_slaneg
#endif
          end interface laneg

          !> LANGB:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the element of  largest absolute value  of an
          !> n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.
          interface langb
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clangb(norm,n,kl,ku,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: kl,ku,ldab,n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: ab(ldab,*)
               end function clangb
#else
               module procedure la_clangb
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dlangb(norm,n,kl,ku,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: kl,ku,ldab,n
                    real(dp),intent(in) :: ab(ldab,*)
                    real(dp),intent(out) :: work(*)
               end function dlangb
#else
               module procedure la_dlangb
#endif
               module procedure la_qlangb
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function slangb(norm,n,kl,ku,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: kl,ku,ldab,n
                    real(sp),intent(in) :: ab(ldab,*)
                    real(sp),intent(out) :: work(*)
               end function slangb
#else
               module procedure la_slangb
#endif
               module procedure la_wlangb
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlangb(norm,n,kl,ku,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: kl,ku,ldab,n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: ab(ldab,*)
               end function zlangb
#else
               module procedure la_zlangb
#endif
          end interface langb

          !> LANGE:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> complex matrix A.
          interface lange
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clange(norm,m,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: a(lda,*)
               end function clange
#else
               module procedure la_clange
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dlange(norm,m,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(out) :: work(*)
               end function dlange
#else
               module procedure la_dlange
#endif
               module procedure la_qlange
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function slange(norm,m,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(out) :: work(*)
               end function slange
#else
               module procedure la_slange
#endif
               module procedure la_wlange
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlange(norm,m,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: a(lda,*)
               end function zlange
#else
               module procedure la_zlange
#endif
          end interface lange

          !> LANGT:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> complex tridiagonal matrix A.
          interface langt
#ifdef LA_EXTERNAL_LAPACK
               pure real(sp) function clangt(norm,n,dl,d,du)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(in) :: d(*),dl(*),du(*)
               end function clangt
#else
               module procedure la_clangt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure real(dp) function dlangt(norm,n,dl,d,du)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: d(*),dl(*),du(*)
               end function dlangt
#else
               module procedure la_dlangt
#endif
               module procedure la_qlangt
#ifdef LA_EXTERNAL_LAPACK
               pure real(sp) function slangt(norm,n,dl,d,du)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: d(*),dl(*),du(*)
               end function slangt
#else
               module procedure la_slangt
#endif
               module procedure la_wlangt
#ifdef LA_EXTERNAL_LAPACK
               pure real(dp) function zlangt(norm,n,dl,d,du)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(in) :: d(*),dl(*),du(*)
               end function zlangt
#else
               module procedure la_zlangt
#endif
          end interface langt

          !> LANHB:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the element of  largest absolute value  of an
          !> n by n hermitian band matrix A,  with k super-diagonals.
          interface lanhb
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clanhb(norm,uplo,n,k,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: k,ldab,n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: ab(ldab,*)
               end function clanhb
#else
               module procedure la_clanhb
#endif
               module procedure la_wlanhb
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlanhb(norm,uplo,n,k,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: k,ldab,n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: ab(ldab,*)
               end function zlanhb
#else
               module procedure la_zlanhb
#endif
          end interface lanhb

          !> LANHE:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> complex hermitian matrix A.
          interface lanhe
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clanhe(norm,uplo,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: a(lda,*)
               end function clanhe
#else
               module procedure la_clanhe
#endif
               module procedure la_wlanhe
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlanhe(norm,uplo,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: a(lda,*)
               end function zlanhe
#else
               module procedure la_zlanhe
#endif
          end interface lanhe

          !> LANHF:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> complex Hermitian matrix A in RFP format.
          interface lanhf
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clanhf(norm,transr,uplo,n,a,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,transr,uplo
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: work(0:*)
                    complex(sp),intent(in) :: a(0:*)
               end function clanhf
#else
               module procedure la_clanhf
#endif
               module procedure la_wlanhf
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlanhf(norm,transr,uplo,n,a,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,transr,uplo
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: work(0:*)
                    complex(dp),intent(in) :: a(0:*)
               end function zlanhf
#else
               module procedure la_zlanhf
#endif
          end interface lanhf

          !> LANHP:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> complex hermitian matrix A,  supplied in packed form.
          interface lanhp
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clanhp(norm,uplo,n,ap,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: ap(*)
               end function clanhp
#else
               module procedure la_clanhp
#endif
               module procedure la_wlanhp
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlanhp(norm,uplo,n,ap,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: ap(*)
               end function zlanhp
#else
               module procedure la_zlanhp
#endif
          end interface lanhp

          !> LANHS:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> Hessenberg matrix A.
          interface lanhs
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clanhs(norm,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: a(lda,*)
               end function clanhs
#else
               module procedure la_clanhs
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dlanhs(norm,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(out) :: work(*)
               end function dlanhs
#else
               module procedure la_dlanhs
#endif
               module procedure la_qlanhs
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function slanhs(norm,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(out) :: work(*)
               end function slanhs
#else
               module procedure la_slanhs
#endif
               module procedure la_wlanhs
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlanhs(norm,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: a(lda,*)
               end function zlanhs
#else
               module procedure la_zlanhs
#endif
          end interface lanhs

          !> LANHT:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> complex Hermitian tridiagonal matrix A.
          interface lanht
#ifdef LA_EXTERNAL_LAPACK
               pure real(sp) function clanht(norm,n,d,e)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: d(*)
                    complex(sp),intent(in) :: e(*)
               end function clanht
#else
               module procedure la_clanht
#endif
               module procedure la_wlanht
#ifdef LA_EXTERNAL_LAPACK
               pure real(dp) function zlanht(norm,n,d,e)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: d(*)
                    complex(dp),intent(in) :: e(*)
               end function zlanht
#else
               module procedure la_zlanht
#endif
          end interface lanht

          !> LANSB:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the element of  largest absolute value  of an
          !> n by n symmetric band matrix A,  with k super-diagonals.
          interface lansb
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clansb(norm,uplo,n,k,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: k,ldab,n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: ab(ldab,*)
               end function clansb
#else
               module procedure la_clansb
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dlansb(norm,uplo,n,k,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: k,ldab,n
                    real(dp),intent(in) :: ab(ldab,*)
                    real(dp),intent(out) :: work(*)
               end function dlansb
#else
               module procedure la_dlansb
#endif
               module procedure la_qlansb
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function slansb(norm,uplo,n,k,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: k,ldab,n
                    real(sp),intent(in) :: ab(ldab,*)
                    real(sp),intent(out) :: work(*)
               end function slansb
#else
               module procedure la_slansb
#endif
               module procedure la_wlansb
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlansb(norm,uplo,n,k,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: k,ldab,n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: ab(ldab,*)
               end function zlansb
#else
               module procedure la_zlansb
#endif
          end interface lansb

          !> LANSF: returns the value of the one norm, or the Frobenius norm, or
          !> the infinity norm, or the element of largest absolute value of a
          !> real symmetric matrix A in RFP format.
          interface lansf
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dlansf(norm,transr,uplo,n,a,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,transr,uplo
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: a(0:*)
                    real(dp),intent(out) :: work(0:*)
               end function dlansf
#else
               module procedure la_dlansf
#endif
               module procedure la_qlansf
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function slansf(norm,transr,uplo,n,a,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,transr,uplo
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: a(0:*)
                    real(sp),intent(out) :: work(0:*)
               end function slansf
#else
               module procedure la_slansf
#endif
          end interface lansf

          !> LANSP:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> complex symmetric matrix A,  supplied in packed form.
          interface lansp
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clansp(norm,uplo,n,ap,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: ap(*)
               end function clansp
#else
               module procedure la_clansp
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dlansp(norm,uplo,n,ap,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: ap(*)
                    real(dp),intent(out) :: work(*)
               end function dlansp
#else
               module procedure la_dlansp
#endif
               module procedure la_qlansp
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function slansp(norm,uplo,n,ap,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: ap(*)
                    real(sp),intent(out) :: work(*)
               end function slansp
#else
               module procedure la_slansp
#endif
               module procedure la_wlansp
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlansp(norm,uplo,n,ap,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: ap(*)
               end function zlansp
#else
               module procedure la_zlansp
#endif
          end interface lansp

          !> LANST:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> real symmetric tridiagonal matrix A.
          interface lanst
#ifdef LA_EXTERNAL_LAPACK
               pure real(dp) function dlanst(norm,n,d,e)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: d(*),e(*)
               end function dlanst
#else
               module procedure la_dlanst
#endif
               module procedure la_qlanst
#ifdef LA_EXTERNAL_LAPACK
               pure real(sp) function slanst(norm,n,d,e)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: d(*),e(*)
               end function slanst
#else
               module procedure la_slanst
#endif
          end interface lanst

          !> LANSY:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> complex symmetric matrix A.
          interface lansy
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clansy(norm,uplo,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: a(lda,*)
               end function clansy
#else
               module procedure la_clansy
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dlansy(norm,uplo,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(out) :: work(*)
               end function dlansy
#else
               module procedure la_dlansy
#endif
               module procedure la_qlansy
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function slansy(norm,uplo,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(out) :: work(*)
               end function slansy
#else
               module procedure la_slansy
#endif
               module procedure la_wlansy
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlansy(norm,uplo,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: norm,uplo
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: a(lda,*)
               end function zlansy
#else
               module procedure la_zlansy
#endif
          end interface lansy

          !> LANTB:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the element of  largest absolute value  of an
          !> n by n triangular band matrix A,  with ( k + 1 ) diagonals.
          interface lantb
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clantb(norm,uplo,diag,n,k,ab,ldab,work)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: k,ldab,n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: ab(ldab,*)
               end function clantb
#else
               module procedure la_clantb
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dlantb(norm,uplo,diag,n,k,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: k,ldab,n
                    real(dp),intent(in) :: ab(ldab,*)
                    real(dp),intent(out) :: work(*)
               end function dlantb
#else
               module procedure la_dlantb
#endif
               module procedure la_qlantb
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function slantb(norm,uplo,diag,n,k,ab,ldab,work)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: k,ldab,n
                    real(sp),intent(in) :: ab(ldab,*)
                    real(sp),intent(out) :: work(*)
               end function slantb
#else
               module procedure la_slantb
#endif
               module procedure la_wlantb
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlantb(norm,uplo,diag,n,k,ab,ldab,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: k,ldab,n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: ab(ldab,*)
               end function zlantb
#else
               module procedure la_zlantb
#endif
          end interface lantb

          !> LANTP:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> triangular matrix A, supplied in packed form.
          interface lantp
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clantp(norm,uplo,diag,n,ap,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: ap(*)
               end function clantp
#else
               module procedure la_clantp
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dlantp(norm,uplo,diag,n,ap,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: ap(*)
                    real(dp),intent(out) :: work(*)
               end function dlantp
#else
               module procedure la_dlantp
#endif
               module procedure la_qlantp
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function slantp(norm,uplo,diag,n,ap,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: ap(*)
                    real(sp),intent(out) :: work(*)
               end function slantp
#else
               module procedure la_slantp
#endif
               module procedure la_wlantp
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlantp(norm,uplo,diag,n,ap,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: ap(*)
               end function zlantp
#else
               module procedure la_zlantp
#endif
          end interface lantp

          !> LANTR:  returns the value of the one norm,  or the Frobenius norm, or
          !> the  infinity norm,  or the  element of  largest absolute value  of a
          !> trapezoidal or triangular matrix A.
          interface lantr
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function clantr(norm,uplo,diag,m,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(in) :: a(lda,*)
               end function clantr
#else
               module procedure la_clantr
#endif
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function dlantr(norm,uplo,diag,m,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(out) :: work(*)
               end function dlantr
#else
               module procedure la_dlantr
#endif
               module procedure la_qlantr
#ifdef LA_EXTERNAL_LAPACK
               real(sp) function slantr(norm,uplo,diag,m,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(out) :: work(*)
               end function slantr
#else
               module procedure la_slantr
#endif
               module procedure la_wlantr
#ifdef LA_EXTERNAL_LAPACK
               real(dp) function zlantr(norm,uplo,diag,m,n,a,lda,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(in) :: a(lda,*)
               end function zlantr
#else
               module procedure la_zlantr
#endif
          end interface lantr

          !> LAORHR_COL_GETRFNP: computes the modified LU factorization without
          !> pivoting of a real general M-by-N matrix A. The factorization has
          !> the form:
          !> A - S = L * U,
          !> where:
          !> S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !> D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !> as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !> i-1 steps of Gaussian elimination. This means that the diagonal
          !> element at each step of "modified" Gaussian elimination is
          !> at least one in absolute value (so that division-by-zero not
          !> not possible during the division by the diagonal element);
          !> L is a M-by-N lower triangular matrix with unit diagonal elements
          !> (lower trapezoidal if M > N);
          !> and U is a M-by-N upper triangular matrix
          !> (upper trapezoidal if M < N).
          !> This routine is an auxiliary routine used in the Householder
          !> reconstruction routine DORHR_COL. In DORHR_COL, this routine is
          !> applied to an M-by-N matrix A with orthonormal columns, where each
          !> element is bounded by one in absolute value. With the choice of
          !> the matrix S above, one can show that the diagonal element at each
          !> step of Gaussian elimination is the largest (in absolute value) in
          !> the column on or below the diagonal, so that no pivoting is required
          !> for numerical stability [1].
          !> For more details on the Householder reconstruction algorithm,
          !> including the modified LU factorization, see [1].
          !> This is the blocked right-looking version of the algorithm,
          !> calling Level 3 BLAS to update the submatrix. To factorize a block,
          !> this routine calls the recursive routine LAORHR_COL_GETRFNP2.
          !> [1] "Reconstructing Householder vectors from tall-skinny QR",
          !> G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !> E. Solomonik, J. Parallel Distrib. Comput.,
          !> vol. 85, pp. 3-31, 2015.
          interface laorhr_col_getrfnp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaorhr_col_getrfnp(m,n,a,lda,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: d(*)
               end subroutine dlaorhr_col_getrfnp
#else
               module procedure la_dlaorhr_col_getrfnp
#endif
               module procedure la_qlaorhr_col_getrfnp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaorhr_col_getrfnp(m,n,a,lda,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: d(*)
               end subroutine slaorhr_col_getrfnp
#else
               module procedure la_slaorhr_col_getrfnp
#endif
          end interface laorhr_col_getrfnp

          !> LAORHR_COL_GETRFNP2: computes the modified LU factorization without
          !> pivoting of a real general M-by-N matrix A. The factorization has
          !> the form:
          !> A - S = L * U,
          !> where:
          !> S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !> D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !> as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !> i-1 steps of Gaussian elimination. This means that the diagonal
          !> element at each step of "modified" Gaussian elimination is at
          !> least one in absolute value (so that division-by-zero not
          !> possible during the division by the diagonal element);
          !> L is a M-by-N lower triangular matrix with unit diagonal elements
          !> (lower trapezoidal if M > N);
          !> and U is a M-by-N upper triangular matrix
          !> (upper trapezoidal if M < N).
          !> This routine is an auxiliary routine used in the Householder
          !> reconstruction routine DORHR_COL. In DORHR_COL, this routine is
          !> applied to an M-by-N matrix A with orthonormal columns, where each
          !> element is bounded by one in absolute value. With the choice of
          !> the matrix S above, one can show that the diagonal element at each
          !> step of Gaussian elimination is the largest (in absolute value) in
          !> the column on or below the diagonal, so that no pivoting is required
          !> for numerical stability [1].
          !> For more details on the Householder reconstruction algorithm,
          !> including the modified LU factorization, see [1].
          !> This is the recursive version of the LU factorization algorithm.
          !> Denote A - S by B. The algorithm divides the matrix B into four
          !> submatrices:
          !> [  B11 | B12  ]  where B11 is n1 by n1,
          !> B = [ -----|----- ]        B21 is (m-n1) by n1,
          !> [  B21 | B22  ]        B12 is n1 by n2,
          !> B22 is (m-n1) by n2,
          !> with n1 = min(m,n)/2, n2 = n-n1.
          !> The subroutine calls itself to factor B11, solves for B21,
          !> solves for B12, updates B22, then calls itself to factor B22.
          !> For more details on the recursive LU algorithm, see [2].
          !> LAORHR_COL_GETRFNP2 is called to factorize a block by the blocked
          !> routine DLAORHR_COL_GETRFNP, which uses blocked code calling
          !> Level 3 BLAS to update the submatrix. However, LAORHR_COL_GETRFNP2
          !> is self-sufficient and can be used without DLAORHR_COL_GETRFNP.
          !> [1] "Reconstructing Householder vectors from tall-skinny QR",
          !> G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !> E. Solomonik, J. Parallel Distrib. Comput.,
          !> vol. 85, pp. 3-31, 2015.
          !> [2] "Recursion leads to automatic variable blocking for dense linear
          !> algebra algorithms", F. Gustavson, IBM J. of Res. and Dev.,
          !> vol. 41, no. 6, pp. 737-755, 1997.
          interface laorhr_col_getrfnp2
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine dlaorhr_col_getrfnp2(m,n,a,lda,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: d(*)
               end subroutine dlaorhr_col_getrfnp2
#else
               module procedure la_dlaorhr_col_getrfnp2
#endif
               module procedure la_qlaorhr_col_getrfnp2
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine slaorhr_col_getrfnp2(m,n,a,lda,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: d(*)
               end subroutine slaorhr_col_getrfnp2
#else
               module procedure la_slaorhr_col_getrfnp2
#endif
          end interface laorhr_col_getrfnp2

          !> Given two column vectors X and Y, let
          !> A = ( X Y ).
          !> The subroutine first computes the QR factorization of A = Q*R,
          !> and then computes the SVD of the 2-by-2 upper triangular matrix R.
          !> The smaller singular value of R is returned in SSMIN, which is used
          !> as the measurement of the linear dependency of the vectors X and Y.
          interface lapll
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clapll(n,x,incx,y,incy,ssmin)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,incy,n
                    real(sp),intent(out) :: ssmin
                    complex(sp),intent(inout) :: x(*),y(*)
               end subroutine clapll
#else
               module procedure la_clapll
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlapll(n,x,incx,y,incy,ssmin)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,incy,n
                    real(dp),intent(out) :: ssmin
                    real(dp),intent(inout) :: x(*),y(*)
               end subroutine dlapll
#else
               module procedure la_dlapll
#endif
               module procedure la_qlapll
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slapll(n,x,incx,y,incy,ssmin)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,incy,n
                    real(sp),intent(out) :: ssmin
                    real(sp),intent(inout) :: x(*),y(*)
               end subroutine slapll
#else
               module procedure la_slapll
#endif
               module procedure la_wlapll
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlapll(n,x,incx,y,incy,ssmin)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,incy,n
                    real(dp),intent(out) :: ssmin
                    complex(dp),intent(inout) :: x(*),y(*)
               end subroutine zlapll
#else
               module procedure la_zlapll
#endif
          end interface lapll

          !> LAPMR: rearranges the rows of the M by N matrix X as specified
          !> by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
          !> If FORWRD = .TRUE.,  forward permutation:
          !> X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
          !> If FORWRD = .FALSE., backward permutation:
          !> X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
          interface lapmr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clapmr(forwrd,m,n,x,ldx,k)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: forwrd
                    integer(ilp),intent(in) :: ldx,m,n
                    integer(ilp),intent(inout) :: k(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine clapmr
#else
               module procedure la_clapmr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlapmr(forwrd,m,n,x,ldx,k)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: forwrd
                    integer(ilp),intent(in) :: ldx,m,n
                    integer(ilp),intent(inout) :: k(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dlapmr
#else
               module procedure la_dlapmr
#endif
               module procedure la_qlapmr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slapmr(forwrd,m,n,x,ldx,k)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: forwrd
                    integer(ilp),intent(in) :: ldx,m,n
                    integer(ilp),intent(inout) :: k(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine slapmr
#else
               module procedure la_slapmr
#endif
               module procedure la_wlapmr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlapmr(forwrd,m,n,x,ldx,k)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: forwrd
                    integer(ilp),intent(in) :: ldx,m,n
                    integer(ilp),intent(inout) :: k(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zlapmr
#else
               module procedure la_zlapmr
#endif
          end interface lapmr

          !> LAPMT: rearranges the columns of the M by N matrix X as specified
          !> by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
          !> If FORWRD = .TRUE.,  forward permutation:
          !> X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
          !> If FORWRD = .FALSE., backward permutation:
          !> X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
          interface lapmt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clapmt(forwrd,m,n,x,ldx,k)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: forwrd
                    integer(ilp),intent(in) :: ldx,m,n
                    integer(ilp),intent(inout) :: k(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine clapmt
#else
               module procedure la_clapmt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlapmt(forwrd,m,n,x,ldx,k)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: forwrd
                    integer(ilp),intent(in) :: ldx,m,n
                    integer(ilp),intent(inout) :: k(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dlapmt
#else
               module procedure la_dlapmt
#endif
               module procedure la_qlapmt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slapmt(forwrd,m,n,x,ldx,k)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: forwrd
                    integer(ilp),intent(in) :: ldx,m,n
                    integer(ilp),intent(inout) :: k(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine slapmt
#else
               module procedure la_slapmt
#endif
               module procedure la_wlapmt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlapmt(forwrd,m,n,x,ldx,k)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: forwrd
                    integer(ilp),intent(in) :: ldx,m,n
                    integer(ilp),intent(inout) :: k(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zlapmt
#else
               module procedure la_zlapmt
#endif
          end interface lapmt

          !> LAQGB: equilibrates a general M by N band matrix A with KL
          !> subdiagonals and KU superdiagonals using the row and scaling factors
          !> in the vectors R and C.
          interface laqgb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqgb(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,equed)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(sp),intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp),intent(inout) :: ab(ldab,*)
               end subroutine claqgb
#else
               module procedure la_claqgb
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaqgb(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,equed)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(dp),intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp),intent(inout) :: ab(ldab,*)
               end subroutine dlaqgb
#else
               module procedure la_dlaqgb
#endif
               module procedure la_qlaqgb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaqgb(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,equed)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(sp),intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp),intent(inout) :: ab(ldab,*)
               end subroutine slaqgb
#else
               module procedure la_slaqgb
#endif
               module procedure la_wlaqgb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqgb(m,n,kl,ku,ab,ldab,r,c,rowcnd,colcnd,amax,equed)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    integer(ilp),intent(in) :: kl,ku,ldab,m,n
                    real(dp),intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp),intent(inout) :: ab(ldab,*)
               end subroutine zlaqgb
#else
               module procedure la_zlaqgb
#endif
          end interface laqgb

          !> LAQGE: equilibrates a general M by N matrix A using the row and
          !> column scaling factors in the vectors R and C.
          interface laqge
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqge(m,n,a,lda,r,c,rowcnd,colcnd,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine claqge
#else
               module procedure la_claqge
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaqge(m,n,a,lda,r,c,rowcnd,colcnd,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dlaqge
#else
               module procedure la_dlaqge
#endif
               module procedure la_qlaqge
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaqge(m,n,a,lda,r,c,rowcnd,colcnd,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine slaqge
#else
               module procedure la_slaqge
#endif
               module procedure la_wlaqge
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqge(m,n,a,lda,r,c,rowcnd,colcnd,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zlaqge
#else
               module procedure la_zlaqge
#endif
          end interface laqge

          !> LAQHB: equilibrates an Hermitian band matrix A using the scaling
          !> factors in the vector S.
          interface laqhb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqhb(uplo,n,kd,ab,ldab,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(in) :: amax,scond
                    real(sp),intent(out) :: s(*)
                    complex(sp),intent(inout) :: ab(ldab,*)
               end subroutine claqhb
#else
               module procedure la_claqhb
#endif
               module procedure la_wlaqhb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqhb(uplo,n,kd,ab,ldab,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(in) :: amax,scond
                    real(dp),intent(out) :: s(*)
                    complex(dp),intent(inout) :: ab(ldab,*)
               end subroutine zlaqhb
#else
               module procedure la_zlaqhb
#endif
          end interface laqhb

          !> LAQHE: equilibrates a Hermitian matrix A using the scaling factors
          !> in the vector S.
          interface laqhe
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqhe(uplo,n,a,lda,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(in) :: amax,scond,s(*)
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine claqhe
#else
               module procedure la_claqhe
#endif
               module procedure la_wlaqhe
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqhe(uplo,n,a,lda,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(in) :: amax,scond,s(*)
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zlaqhe
#else
               module procedure la_zlaqhe
#endif
          end interface laqhe

          !> LAQHP: equilibrates a Hermitian matrix A using the scaling factors
          !> in the vector S.
          interface laqhp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqhp(uplo,n,ap,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: amax,scond,s(*)
                    complex(sp),intent(inout) :: ap(*)
               end subroutine claqhp
#else
               module procedure la_claqhp
#endif
               module procedure la_wlaqhp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqhp(uplo,n,ap,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: amax,scond,s(*)
                    complex(dp),intent(inout) :: ap(*)
               end subroutine zlaqhp
#else
               module procedure la_zlaqhp
#endif
          end interface laqhp

          !> LAQPS: computes a step of QR factorization with column pivoting
          !> of a complex M-by-N matrix A by using Blas-3.  It tries to factorize
          !> NB columns from A starting from the row OFFSET+1, and updates all
          !> of the matrix with Blas-3 xGEMM.
          !> In some cases, due to catastrophic cancellations, it cannot
          !> factorize NB columns.  Hence, the actual number of factorized
          !> columns is returned in KB.
          !> Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
          interface laqps
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqps(m,n,offset,nb,kb,a,lda,jpvt,tau,vn1,vn2,auxv,f, &
                         ldf)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: kb
                    integer(ilp),intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp),intent(inout) :: jpvt(*)
                    real(sp),intent(inout) :: vn1(*),vn2(*)
                    complex(sp),intent(inout) :: a(lda,*),auxv(*),f(ldf,*)
                    complex(sp),intent(out) :: tau(*)
               end subroutine claqps
#else
               module procedure la_claqps
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaqps(m,n,offset,nb,kb,a,lda,jpvt,tau,vn1,vn2,auxv,f, &
                         ldf)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: kb
                    integer(ilp),intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp),intent(inout) :: jpvt(*)
                    real(dp),intent(inout) :: a(lda,*),auxv(*),f(ldf,*),vn1(*),vn2(*)
                    real(dp),intent(out) :: tau(*)
               end subroutine dlaqps
#else
               module procedure la_dlaqps
#endif
               module procedure la_qlaqps
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaqps(m,n,offset,nb,kb,a,lda,jpvt,tau,vn1,vn2,auxv,f, &
                         ldf)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: kb
                    integer(ilp),intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp),intent(inout) :: jpvt(*)
                    real(sp),intent(inout) :: a(lda,*),auxv(*),f(ldf,*),vn1(*),vn2(*)
                    real(sp),intent(out) :: tau(*)
               end subroutine slaqps
#else
               module procedure la_slaqps
#endif
               module procedure la_wlaqps
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqps(m,n,offset,nb,kb,a,lda,jpvt,tau,vn1,vn2,auxv,f, &
                         ldf)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: kb
                    integer(ilp),intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp),intent(inout) :: jpvt(*)
                    real(dp),intent(inout) :: vn1(*),vn2(*)
                    complex(dp),intent(inout) :: a(lda,*),auxv(*),f(ldf,*)
                    complex(dp),intent(out) :: tau(*)
               end subroutine zlaqps
#else
               module procedure la_zlaqps
#endif
          end interface laqps

          !> LAQR0: computes the eigenvalues of a Hessenberg matrix H
          !> and, optionally, the matrices T and Z from the Schur decomposition
          !> H = Z T Z**H, where T is an upper triangular matrix (the
          !> Schur form), and Z is the unitary matrix of Schur vectors.
          !> Optionally Z may be postmultiplied into an input unitary
          !> matrix Q so that this routine can give the Schur factorization
          !> of a matrix A which has been reduced to the Hessenberg form H
          !> by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
          interface laqr0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqr0(wantt,wantz,n,ilo,ihi,h,ldh,w,iloz,ihiz,z,ldz, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    complex(sp),intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp),intent(out) :: w(*),work(*)
               end subroutine claqr0
#else
               module procedure la_claqr0
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dlaqr0(wantt,wantz,n,ilo,ihi,h,ldh,wr,wi,iloz,ihiz,z,ldz, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    real(dp),intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp),intent(out) :: wi(*),work(*),wr(*)
               end subroutine dlaqr0
#else
               module procedure la_dlaqr0
#endif
               module procedure la_qlaqr0
#ifdef LA_EXTERNAL_LAPACK
               subroutine slaqr0(wantt,wantz,n,ilo,ihi,h,ldh,wr,wi,iloz,ihiz,z,ldz, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    real(sp),intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp),intent(out) :: wi(*),work(*),wr(*)
               end subroutine slaqr0
#else
               module procedure la_slaqr0
#endif
               module procedure la_wlaqr0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqr0(wantt,wantz,n,ilo,ihi,h,ldh,w,iloz,ihiz,z,ldz, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    complex(dp),intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp),intent(out) :: w(*),work(*)
               end subroutine zlaqr0
#else
               module procedure la_zlaqr0
#endif
          end interface laqr0

          !> Given a 2-by-2 or 3-by-3 matrix H, LAQR1: sets v to a
          !> scalar multiple of the first column of the product
          !> (*)  K = (H - s1*I)*(H - s2*I)
          !> scaling to avoid overflows and most underflows.
          !> This is useful for starting double implicit shift bulges
          !> in the QR algorithm.
          interface laqr1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqr1(n,h,ldh,s1,s2,v)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    complex(sp),intent(in) :: s1,s2,h(ldh,*)
                    integer(ilp),intent(in) :: ldh,n
                    complex(sp),intent(out) :: v(*)
               end subroutine claqr1
#else
               module procedure la_claqr1
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaqr1(n,h,ldh,sr1,si1,sr2,si2,v)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: si1,si2,sr1,sr2,h(ldh,*)
                    integer(ilp),intent(in) :: ldh,n
                    real(dp),intent(out) :: v(*)
               end subroutine dlaqr1
#else
               module procedure la_dlaqr1
#endif
               module procedure la_qlaqr1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaqr1(n,h,ldh,sr1,si1,sr2,si2,v)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: si1,si2,sr1,sr2,h(ldh,*)
                    integer(ilp),intent(in) :: ldh,n
                    real(sp),intent(out) :: v(*)
               end subroutine slaqr1
#else
               module procedure la_slaqr1
#endif
               module procedure la_wlaqr1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqr1(n,h,ldh,s1,s2,v)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    complex(dp),intent(in) :: s1,s2,h(ldh,*)
                    integer(ilp),intent(in) :: ldh,n
                    complex(dp),intent(out) :: v(*)
               end subroutine zlaqr1
#else
               module procedure la_zlaqr1
#endif
          end interface laqr1

          !> LAQR4: implements one level of recursion for CLAQR0.
          !> It is a complete implementation of the small bulge multi-shift
          !> QR algorithm.  It may be called by CLAQR0 and, for large enough
          !> deflation window size, it may be called by CLAQR3.  This
          !> subroutine is identical to CLAQR0 except that it calls CLAQR2
          !> instead of CLAQR3.
          !> LAQR4 computes the eigenvalues of a Hessenberg matrix H
          !> and, optionally, the matrices T and Z from the Schur decomposition
          !> H = Z T Z**H, where T is an upper triangular matrix (the
          !> Schur form), and Z is the unitary matrix of Schur vectors.
          !> Optionally Z may be postmultiplied into an input unitary
          !> matrix Q so that this routine can give the Schur factorization
          !> of a matrix A which has been reduced to the Hessenberg form H
          !> by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
          interface laqr4
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqr4(wantt,wantz,n,ilo,ihi,h,ldh,w,iloz,ihiz,z,ldz, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    complex(sp),intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp),intent(out) :: w(*),work(*)
               end subroutine claqr4
#else
               module procedure la_claqr4
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dlaqr4(wantt,wantz,n,ilo,ihi,h,ldh,wr,wi,iloz,ihiz,z,ldz, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    real(dp),intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp),intent(out) :: wi(*),work(*),wr(*)
               end subroutine dlaqr4
#else
               module procedure la_dlaqr4
#endif
               module procedure la_qlaqr4
#ifdef LA_EXTERNAL_LAPACK
               subroutine slaqr4(wantt,wantz,n,ilo,ihi,h,ldh,wr,wi,iloz,ihiz,z,ldz, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    real(sp),intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp),intent(out) :: wi(*),work(*),wr(*)
               end subroutine slaqr4
#else
               module procedure la_slaqr4
#endif
               module procedure la_wlaqr4
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqr4(wantt,wantz,n,ilo,ihi,h,ldh,w,iloz,ihiz,z,ldz, &
                         work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp),intent(out) :: info
                    logical(lk),intent(in) :: wantt,wantz
                    complex(dp),intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp),intent(out) :: w(*),work(*)
               end subroutine zlaqr4
#else
               module procedure la_zlaqr4
#endif
          end interface laqr4

          !> LAQR5: called by CLAQR0 performs a
          !> single small-bulge multi-shift QR sweep.
          interface laqr5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqr5(wantt,wantz,kacc22,n,ktop,kbot,nshfts,s,h,ldh, &
                         iloz,ihiz,z,ldz,v,ldv,u,ldu,nv,wv,ldwv,nh,wh,ldwh)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv, &
                              ldz,n,nh,nshfts,nv
                    logical(lk),intent(in) :: wantt,wantz
                    complex(sp),intent(inout) :: h(ldh,*),s(*),z(ldz,*)
                    complex(sp),intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine claqr5
#else
               module procedure la_claqr5
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaqr5(wantt,wantz,kacc22,n,ktop,kbot,nshfts,sr,si,h,ldh, &
                          iloz,ihiz,z,ldz,v,ldv,u,ldu,nv,wv,ldwv,nh,wh,ldwh)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv, &
                              ldz,n,nh,nshfts,nv
                    logical(lk),intent(in) :: wantt,wantz
                    real(dp),intent(inout) :: h(ldh,*),si(*),sr(*),z(ldz,*)
                    real(dp),intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine dlaqr5
#else
               module procedure la_dlaqr5
#endif
               module procedure la_qlaqr5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaqr5(wantt,wantz,kacc22,n,ktop,kbot,nshfts,sr,si,h,ldh, &
                          iloz,ihiz,z,ldz,v,ldv,u,ldu,nv,wv,ldwv,nh,wh,ldwh)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv, &
                              ldz,n,nh,nshfts,nv
                    logical(lk),intent(in) :: wantt,wantz
                    real(sp),intent(inout) :: h(ldh,*),si(*),sr(*),z(ldz,*)
                    real(sp),intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine slaqr5
#else
               module procedure la_slaqr5
#endif
               module procedure la_wlaqr5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqr5(wantt,wantz,kacc22,n,ktop,kbot,nshfts,s,h,ldh, &
                         iloz,ihiz,z,ldz,v,ldv,u,ldu,nv,wv,ldwv,nh,wh,ldwh)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv, &
                              ldz,n,nh,nshfts,nv
                    logical(lk),intent(in) :: wantt,wantz
                    complex(dp),intent(inout) :: h(ldh,*),s(*),z(ldz,*)
                    complex(dp),intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine zlaqr5
#else
               module procedure la_zlaqr5
#endif
          end interface laqr5

          !> LAQSB: equilibrates a symmetric band matrix A using the scaling
          !> factors in the vector S.
          interface laqsb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqsb(uplo,n,kd,ab,ldab,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(in) :: amax,scond,s(*)
                    complex(sp),intent(inout) :: ab(ldab,*)
               end subroutine claqsb
#else
               module procedure la_claqsb
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaqsb(uplo,n,kd,ab,ldab,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(in) :: amax,scond,s(*)
                    real(dp),intent(inout) :: ab(ldab,*)
               end subroutine dlaqsb
#else
               module procedure la_dlaqsb
#endif
               module procedure la_qlaqsb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaqsb(uplo,n,kd,ab,ldab,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(in) :: amax,scond,s(*)
                    real(sp),intent(inout) :: ab(ldab,*)
               end subroutine slaqsb
#else
               module procedure la_slaqsb
#endif
               module procedure la_wlaqsb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqsb(uplo,n,kd,ab,ldab,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(in) :: amax,scond,s(*)
                    complex(dp),intent(inout) :: ab(ldab,*)
               end subroutine zlaqsb
#else
               module procedure la_zlaqsb
#endif
          end interface laqsb

          !> LAQSP: equilibrates a symmetric matrix A using the scaling factors
          !> in the vector S.
          interface laqsp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqsp(uplo,n,ap,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: amax,scond,s(*)
                    complex(sp),intent(inout) :: ap(*)
               end subroutine claqsp
#else
               module procedure la_claqsp
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaqsp(uplo,n,ap,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: amax,scond,s(*)
                    real(dp),intent(inout) :: ap(*)
               end subroutine dlaqsp
#else
               module procedure la_dlaqsp
#endif
               module procedure la_qlaqsp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaqsp(uplo,n,ap,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: amax,scond,s(*)
                    real(sp),intent(inout) :: ap(*)
               end subroutine slaqsp
#else
               module procedure la_slaqsp
#endif
               module procedure la_wlaqsp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqsp(uplo,n,ap,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: amax,scond,s(*)
                    complex(dp),intent(inout) :: ap(*)
               end subroutine zlaqsp
#else
               module procedure la_zlaqsp
#endif
          end interface laqsp

          !> LAQSY: equilibrates a symmetric matrix A using the scaling factors
          !> in the vector S.
          interface laqsy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqsy(uplo,n,a,lda,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(in) :: amax,scond,s(*)
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine claqsy
#else
               module procedure la_claqsy
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaqsy(uplo,n,a,lda,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(in) :: amax,scond,s(*)
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dlaqsy
#else
               module procedure la_dlaqsy
#endif
               module procedure la_qlaqsy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaqsy(uplo,n,a,lda,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(in) :: amax,scond,s(*)
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine slaqsy
#else
               module procedure la_slaqsy
#endif
               module procedure la_wlaqsy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqsy(uplo,n,a,lda,s,scond,amax,equed)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(out) :: equed
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(in) :: amax,scond,s(*)
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zlaqsy
#else
               module procedure la_zlaqsy
#endif
          end interface laqsy

          !> LAQTR: solves the real quasi-triangular system
          !> op(T)*p = scale*c,               if LREAL = .TRUE.
          !> or the complex quasi-triangular systems
          !> op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.
          !> in real arithmetic, where T is upper quasi-triangular.
          !> If LREAL = .FALSE., then the first diagonal block of T must be
          !> 1 by 1, B is the specially structured matrix
          !> B = [ b(1) b(2) ... b(n) ]
          !> [       w            ]
          !> [           w        ]
          !> [              .     ]
          !> [                 w  ]
          !> op(A) = A or A**T, A**T denotes the transpose of
          !> matrix A.
          !> On input, X = [ c ].  On output, X = [ p ].
          !> [ d ]                  [ q ]
          !> This subroutine is designed for the condition number estimation
          !> in routine DTRSNA.
          interface laqtr
#ifdef LA_EXTERNAL_LAPACK
               subroutine dlaqtr(ltran,lreal,n,t,ldt,b,w,scale,x,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: lreal,ltran
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldt,n
                    real(dp),intent(out) :: scale,work(*)
                    real(dp),intent(in) :: w,b(*),t(ldt,*)
                    real(dp),intent(inout) :: x(*)
               end subroutine dlaqtr
#else
               module procedure la_dlaqtr
#endif
               module procedure la_qlaqtr
#ifdef LA_EXTERNAL_LAPACK
               subroutine slaqtr(ltran,lreal,n,t,ldt,b,w,scale,x,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: lreal,ltran
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldt,n
                    real(sp),intent(out) :: scale,work(*)
                    real(sp),intent(in) :: w,b(*),t(ldt,*)
                    real(sp),intent(inout) :: x(*)
               end subroutine slaqtr
#else
               module procedure la_slaqtr
#endif
          end interface laqtr

          !> LAQZ0: computes the eigenvalues of a matrix pair (H,T),
          !> where H is an upper Hessenberg matrix and T is upper triangular,
          !> using the double-shift QZ method.
          !> Matrix pairs of this type are produced by the reduction to
          !> generalized upper Hessenberg form of a matrix pair (A,B):
          !> A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
          !> as computed by CGGHRD.
          !> If JOB='S', then the Hessenberg-triangular pair (H,T) is
          !> also reduced to generalized Schur form,
          !> H = Q*S*Z**H,  T = Q*P*Z**H,
          !> where Q and Z are unitary matrices, P and S are an upper triangular
          !> matrices.
          !> Optionally, the unitary matrix Q from the generalized Schur
          !> factorization may be postmultiplied into an input matrix Q1, and the
          !> unitary matrix Z may be postmultiplied into an input matrix Z1.
          !> If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
          !> the matrix pair (A,B) to generalized upper Hessenberg form, then the
          !> output matrices Q1*Q and Z1*Z are the unitary factors from the
          !> generalized Schur factorization of (A,B):
          !> A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
          !> To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
          !> of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
          !> complex and beta real.
          !> If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
          !> generalized nonsymmetric eigenvalue problem (GNEP)
          !> A*x = lambda*B*x
          !> and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
          !> alternate form of the GNEP
          !> mu*A*y = B*y.
          !> Eigenvalues can be read directly from the generalized Schur
          !> form:
          !> alpha = S(i,i), beta = P(i,i).
          !> Ref: C.B. Moler
          !> Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
          !> pp. 241--256.
          !> Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
          !> Algorithm with Aggressive Early Deflation", SIAM J. Numer.
          !> Anal., 29(2006), pp. 199--227.
          !> Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
          !> multipole rational QZ method with agressive early deflation"
          interface laqz0
#ifdef LA_EXTERNAL_LAPACK
               recursive subroutine claqz0(wants,wantq,wantz,n,ilo,ihi,a,lda,b,ldb, &
                         alpha,beta,q,ldq,z,ldz,work,lwork,rwork,rec,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: wants,wantq,wantz
                    integer(ilp),intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(sp),intent(inout) :: alpha(*),beta(*),work(*)
                    real(sp),intent(out) :: rwork(*)
               end subroutine claqz0
#else
               module procedure la_claqz0
#endif
#ifdef LA_EXTERNAL_LAPACK
               recursive subroutine dlaqz0(wants,wantq,wantz,n,ilo,ihi,a,lda,b,ldb, &
                         alphar,alphai,beta,q,ldq,z,ldz,work,lwork,rec,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: wants,wantq,wantz
                    integer(ilp),intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp),intent(out) :: info
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(dp),intent(inout) :: alphar(*),alphai(*),beta(*),work(*)
               end subroutine dlaqz0
#else
               module procedure la_dlaqz0
#endif
               module procedure la_qlaqz0
#ifdef LA_EXTERNAL_LAPACK
               recursive subroutine slaqz0(wants,wantq,wantz,n,ilo,ihi,a,lda,b,ldb, &
                         alphar,alphai,beta,q,ldq,z,ldz,work,lwork,rec,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: wants,wantq,wantz
                    integer(ilp),intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp),intent(out) :: info
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(sp),intent(inout) :: alphar(*),alphai(*),beta(*),work(*)
               end subroutine slaqz0
#else
               module procedure la_slaqz0
#endif
               module procedure la_wlaqz0
#ifdef LA_EXTERNAL_LAPACK
               recursive subroutine zlaqz0(wants,wantq,wantz,n,ilo,ihi,a,lda,b,ldb, &
                         alpha,beta,q,ldq,z,ldz,work,lwork,rwork,rec,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: wants,wantq,wantz
                    integer(ilp),intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(dp),intent(inout) :: alpha(*),beta(*),work(*)
                    real(dp),intent(out) :: rwork(*)
               end subroutine zlaqz0
#else
               module procedure la_zlaqz0
#endif
          end interface laqz0

          !> LAQZ1: chases a 1x1 shift bulge in a matrix pencil down a single position
          interface laqz1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claqz1(ilq,ilz,k,istartm,istopm,ihi,a,lda,b,ldb,nq, &
                         qstart,q,ldq,nz,zstart,z,ldz)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: ilq,ilz
                    integer(ilp),intent(in) :: k,lda,ldb,ldq,ldz,istartm,istopm,nq,nz,qstart, &
                              zstart,ihi
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine claqz1
#else
               module procedure la_claqz1
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaqz1(a,lda,b,ldb,sr1,sr2,si,beta1,beta2,v)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: lda,ldb
                    real(dp),intent(in) :: a(lda,*),b(ldb,*),sr1,sr2,si,beta1,beta2
                    real(dp),intent(out) :: v(*)
               end subroutine dlaqz1
#else
               module procedure la_dlaqz1
#endif
               module procedure la_qlaqz1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaqz1(a,lda,b,ldb,sr1,sr2,si,beta1,beta2,v)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: lda,ldb
                    real(sp),intent(in) :: a(lda,*),b(ldb,*),sr1,sr2,si,beta1,beta2
                    real(sp),intent(out) :: v(*)
               end subroutine slaqz1
#else
               module procedure la_slaqz1
#endif
               module procedure la_wlaqz1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaqz1(ilq,ilz,k,istartm,istopm,ihi,a,lda,b,ldb,nq, &
                         qstart,q,ldq,nz,zstart,z,ldz)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: ilq,ilz
                    integer(ilp),intent(in) :: k,lda,ldb,ldq,ldz,istartm,istopm,nq,nz,qstart, &
                              zstart,ihi
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine zlaqz1
#else
               module procedure la_zlaqz1
#endif
          end interface laqz1

          !> LAQZ4: Executes a single multishift QZ sweep
          interface laqz4
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaqz4(ilschur,ilq,ilz,n,ilo,ihi,nshifts,nblock_desired,sr, &
                si,ss,a,lda,b,ldb,q,ldq,z,ldz,qc,ldqc,zc,ldzc,work,lwork,info)
                          
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: ilschur,ilq,ilz
                    integer(ilp),intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,nshifts, &
                              nblock_desired,ldqc,ldzc
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*),qc(ldqc,*),zc( &
                              ldzc,*)
                    real(dp),intent(inout) :: work(*)
                    real(dp),intent(inout) :: sr(*),si(*),ss(*)
                    integer(ilp),intent(out) :: info
               end subroutine dlaqz4
#else
               module procedure la_dlaqz4
#endif
               module procedure la_qlaqz4
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaqz4(ilschur,ilq,ilz,n,ilo,ihi,nshifts,nblock_desired,sr, &
                si,ss,a,lda,b,ldb,q,ldq,z,ldz,qc,ldqc,zc,ldzc,work,lwork,info)
                          
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: ilschur,ilq,ilz
                    integer(ilp),intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,nshifts, &
                              nblock_desired,ldqc,ldzc
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*),qc(ldqc,*),zc( &
                              ldzc,*)
                    real(sp),intent(inout) :: work(*)
                    real(sp),intent(inout) :: sr(*),si(*),ss(*)
                    integer(ilp),intent(out) :: info
               end subroutine slaqz4
#else
               module procedure la_slaqz4
#endif
          end interface laqz4

          !> LAR1V: computes the (scaled) r-th column of the inverse of
          !> the sumbmatrix in rows B1 through BN of the tridiagonal matrix
          !> L D L**T - sigma I. When sigma is close to an eigenvalue, the
          !> computed vector is an accurate eigenvector. Usually, r corresponds
          !> to the index where the eigenvector is largest in magnitude.
          !> The following steps accomplish this computation :
          !> (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
          !> (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
          !> (c) Computation of the diagonal elements of the inverse of
          !> L D L**T - sigma I by combining the above transforms, and choosing
          !> r as the index where the diagonal of the inverse is (one of the)
          !> largest in magnitude.
          !> (d) Computation of the (scaled) r-th column of the inverse using the
          !> twisted factorization obtained by combining the top part of the
          !> the stationary and the bottom part of the progressive transform.
          interface lar1v
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clar1v(n,b1,bn,lambda,d,l,ld,lld,pivmin,gaptol,z,wantnc, &
                          negcnt,ztz,mingma,r,isuppz,nrminv,resid,rqcorr,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantnc
                    integer(ilp),intent(in) :: b1,bn,n
                    integer(ilp),intent(out) :: negcnt,isuppz(*)
                    integer(ilp),intent(inout) :: r
                    real(sp),intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(sp),intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    complex(sp),intent(inout) :: z(*)
               end subroutine clar1v
#else
               module procedure la_clar1v
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlar1v(n,b1,bn,lambda,d,l,ld,lld,pivmin,gaptol,z,wantnc, &
                          negcnt,ztz,mingma,r,isuppz,nrminv,resid,rqcorr,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantnc
                    integer(ilp),intent(in) :: b1,bn,n
                    integer(ilp),intent(out) :: negcnt,isuppz(*)
                    integer(ilp),intent(inout) :: r
                    real(dp),intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(dp),intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    real(dp),intent(inout) :: z(*)
               end subroutine dlar1v
#else
               module procedure la_dlar1v
#endif
               module procedure la_qlar1v
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slar1v(n,b1,bn,lambda,d,l,ld,lld,pivmin,gaptol,z,wantnc, &
                          negcnt,ztz,mingma,r,isuppz,nrminv,resid,rqcorr,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantnc
                    integer(ilp),intent(in) :: b1,bn,n
                    integer(ilp),intent(out) :: negcnt,isuppz(*)
                    integer(ilp),intent(inout) :: r
                    real(sp),intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(sp),intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    real(sp),intent(inout) :: z(*)
               end subroutine slar1v
#else
               module procedure la_slar1v
#endif
               module procedure la_wlar1v
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlar1v(n,b1,bn,lambda,d,l,ld,lld,pivmin,gaptol,z,wantnc, &
                          negcnt,ztz,mingma,r,isuppz,nrminv,resid,rqcorr,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantnc
                    integer(ilp),intent(in) :: b1,bn,n
                    integer(ilp),intent(out) :: negcnt,isuppz(*)
                    integer(ilp),intent(inout) :: r
                    real(dp),intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(dp),intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    complex(dp),intent(inout) :: z(*)
               end subroutine zlar1v
#else
               module procedure la_zlar1v
#endif
          end interface lar1v

          !> LAR2V: applies a vector of complex plane rotations with real cosines
          !> from both sides to a sequence of 2-by-2 complex Hermitian matrices,
          !> defined by the elements of the vectors x, y and z. For i = 1,2,...,n
          !> (       x(i)  z(i) ) :=
          !> ( conjg(z(i)) y(i) )
          !> (  c(i) conjg(s(i)) ) (       x(i)  z(i) ) ( c(i) -conjg(s(i)) )
          !> ( -s(i)       c(i)  ) ( conjg(z(i)) y(i) ) ( s(i)        c(i)  )
          interface lar2v
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clar2v(n,x,y,z,incx,c,s,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,n
                    real(sp),intent(in) :: c(*)
                    complex(sp),intent(in) :: s(*)
                    complex(sp),intent(inout) :: x(*),y(*),z(*)
               end subroutine clar2v
#else
               module procedure la_clar2v
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlar2v(n,x,y,z,incx,c,s,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,n
                    real(dp),intent(in) :: c(*),s(*)
                    real(dp),intent(inout) :: x(*),y(*),z(*)
               end subroutine dlar2v
#else
               module procedure la_dlar2v
#endif
               module procedure la_qlar2v
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slar2v(n,x,y,z,incx,c,s,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,n
                    real(sp),intent(in) :: c(*),s(*)
                    real(sp),intent(inout) :: x(*),y(*),z(*)
               end subroutine slar2v
#else
               module procedure la_slar2v
#endif
               module procedure la_wlar2v
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlar2v(n,x,y,z,incx,c,s,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,n
                    real(dp),intent(in) :: c(*)
                    complex(dp),intent(in) :: s(*)
                    complex(dp),intent(inout) :: x(*),y(*),z(*)
               end subroutine zlar2v
#else
               module procedure la_zlar2v
#endif
          end interface lar2v

          !> LARCM: performs a very simple matrix-matrix multiplication:
          !> C := A * B,
          !> where A is M by M and real; B is M by N and complex;
          !> C is M by N and complex.
          interface larcm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarcm(m,n,a,lda,b,ldb,c,ldc,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: lda,ldb,ldc,m,n
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(in) :: b(ldb,*)
                    complex(sp),intent(out) :: c(ldc,*)
               end subroutine clarcm
#else
               module procedure la_clarcm
#endif
               module procedure la_wlarcm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarcm(m,n,a,lda,b,ldb,c,ldc,rwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: lda,ldb,ldc,m,n
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(in) :: b(ldb,*)
                    complex(dp),intent(out) :: c(ldc,*)
               end subroutine zlarcm
#else
               module procedure la_zlarcm
#endif
          end interface larcm

          !> LARF: applies a complex elementary reflector H to a complex M-by-N
          !> matrix C, from either the left or the right. H is represented in the
          !> form
          !> H = I - tau * v * v**H
          !> where tau is a complex scalar and v is a complex vector.
          !> If tau = 0, then H is taken to be the unit matrix.
          !> To apply H**H (the conjugate transpose of H), supply conjg(tau) instead
          !> tau.
          interface larf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarf(side,m,n,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side
                    integer(ilp),intent(in) :: incv,ldc,m,n
                    complex(sp),intent(in) :: tau,v(*)
                    complex(sp),intent(inout) :: c(ldc,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine clarf
#else
               module procedure la_clarf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarf(side,m,n,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side
                    integer(ilp),intent(in) :: incv,ldc,m,n
                    real(dp),intent(in) :: tau,v(*)
                    real(dp),intent(inout) :: c(ldc,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlarf
#else
               module procedure la_dlarf
#endif
               module procedure la_qlarf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarf(side,m,n,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side
                    integer(ilp),intent(in) :: incv,ldc,m,n
                    real(sp),intent(in) :: tau,v(*)
                    real(sp),intent(inout) :: c(ldc,*)
                    real(sp),intent(out) :: work(*)
               end subroutine slarf
#else
               module procedure la_slarf
#endif
               module procedure la_wlarf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarf(side,m,n,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side
                    integer(ilp),intent(in) :: incv,ldc,m,n
                    complex(dp),intent(in) :: tau,v(*)
                    complex(dp),intent(inout) :: c(ldc,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zlarf
#else
               module procedure la_zlarf
#endif
          end interface larf

          !> LARFB: applies a complex block reflector H or its transpose H**H to a
          !> complex M-by-N matrix C, from either the left or the right.
          interface larfb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarfb(side,trans,direct,storev,m,n,k,v,ldv,t,ldt,c, &
                         ldc,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    complex(sp),intent(inout) :: c(ldc,*)
                    complex(sp),intent(in) :: t(ldt,*),v(ldv,*)
                    complex(sp),intent(out) :: work(ldwork,*)
               end subroutine clarfb
#else
               module procedure la_clarfb
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarfb(side,trans,direct,storev,m,n,k,v,ldv,t,ldt,c, &
                         ldc,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    real(dp),intent(inout) :: c(ldc,*)
                    real(dp),intent(in) :: t(ldt,*),v(ldv,*)
                    real(dp),intent(out) :: work(ldwork,*)
               end subroutine dlarfb
#else
               module procedure la_dlarfb
#endif
               module procedure la_qlarfb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarfb(side,trans,direct,storev,m,n,k,v,ldv,t,ldt,c, &
                         ldc,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    real(sp),intent(inout) :: c(ldc,*)
                    real(sp),intent(in) :: t(ldt,*),v(ldv,*)
                    real(sp),intent(out) :: work(ldwork,*)
               end subroutine slarfb
#else
               module procedure la_slarfb
#endif
               module procedure la_wlarfb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarfb(side,trans,direct,storev,m,n,k,v,ldv,t,ldt,c, &
                         ldc,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    complex(dp),intent(inout) :: c(ldc,*)
                    complex(dp),intent(in) :: t(ldt,*),v(ldv,*)
                    complex(dp),intent(out) :: work(ldwork,*)
               end subroutine zlarfb
#else
               module procedure la_zlarfb
#endif
          end interface larfb

          !> LARFB_GETT: applies a complex Householder block reflector H from the
          !> left to a complex (K+M)-by-N  "triangular-pentagonal" matrix
          !> composed of two block matrices: an upper trapezoidal K-by-N matrix A
          !> stored in the array A, and a rectangular M-by-(N-K) matrix B, stored
          !> in the array B. The block reflector H is stored in a compact
          !> WY-representation, where the elementary reflectors are in the
          !> arrays A, B and T. See Further Details section.
          interface larfb_gett
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarfb_gett(ident,m,n,k,t,ldt,a,lda,b,ldb,work,ldwork)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: ident
                    integer(ilp),intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(in) :: t(ldt,*)
                    complex(sp),intent(out) :: work(ldwork,*)
               end subroutine clarfb_gett
#else
               module procedure la_clarfb_gett
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarfb_gett(ident,m,n,k,t,ldt,a,lda,b,ldb,work,ldwork)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: ident
                    integer(ilp),intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(in) :: t(ldt,*)
                    real(dp),intent(out) :: work(ldwork,*)
               end subroutine dlarfb_gett
#else
               module procedure la_dlarfb_gett
#endif
               module procedure la_qlarfb_gett
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarfb_gett(ident,m,n,k,t,ldt,a,lda,b,ldb,work,ldwork)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: ident
                    integer(ilp),intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(in) :: t(ldt,*)
                    real(sp),intent(out) :: work(ldwork,*)
               end subroutine slarfb_gett
#else
               module procedure la_slarfb_gett
#endif
               module procedure la_wlarfb_gett
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarfb_gett(ident,m,n,k,t,ldt,a,lda,b,ldb,work,ldwork)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: ident
                    integer(ilp),intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(in) :: t(ldt,*)
                    complex(dp),intent(out) :: work(ldwork,*)
               end subroutine zlarfb_gett
#else
               module procedure la_zlarfb_gett
#endif
          end interface larfb_gett

          !> LARFG: generates a complex elementary reflector H of order n, such
          !> that
          !> H**H * ( alpha ) = ( beta ),   H**H * H = I.
          !> (   x   )   (   0  )
          !> where alpha and beta are scalars, with beta real, and x is an
          !> (n-1)-element complex vector. H is represented in the form
          !> H = I - tau * ( 1 ) * ( 1 v**H ) ,
          !> ( v )
          !> where tau is a complex scalar and v is a complex (n-1)-element
          !> vector. Note that H is not hermitian.
          !> If the elements of x are all zero and alpha is real, then tau = 0
          !> and H is taken to be the unit matrix.
          !> Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .
          interface larfg
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarfg(n,alpha,x,incx,tau)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    complex(sp),intent(inout) :: alpha,x(*)
                    complex(sp),intent(out) :: tau
               end subroutine clarfg
#else
               module procedure la_clarfg
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarfg(n,alpha,x,incx,tau)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    real(dp),intent(inout) :: alpha,x(*)
                    real(dp),intent(out) :: tau
               end subroutine dlarfg
#else
               module procedure la_dlarfg
#endif
               module procedure la_qlarfg
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarfg(n,alpha,x,incx,tau)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    real(sp),intent(inout) :: alpha,x(*)
                    real(sp),intent(out) :: tau
               end subroutine slarfg
#else
               module procedure la_slarfg
#endif
               module procedure la_wlarfg
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarfg(n,alpha,x,incx,tau)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    complex(dp),intent(inout) :: alpha,x(*)
                    complex(dp),intent(out) :: tau
               end subroutine zlarfg
#else
               module procedure la_zlarfg
#endif
          end interface larfg

          !> LARFGP: generates a complex elementary reflector H of order n, such
          !> that
          !> H**H * ( alpha ) = ( beta ),   H**H * H = I.
          !> (   x   )   (   0  )
          !> where alpha and beta are scalars, beta is real and non-negative, and
          !> x is an (n-1)-element complex vector.  H is represented in the form
          !> H = I - tau * ( 1 ) * ( 1 v**H ) ,
          !> ( v )
          !> where tau is a complex scalar and v is a complex (n-1)-element
          !> vector. Note that H is not hermitian.
          !> If the elements of x are all zero and alpha is real, then tau = 0
          !> and H is taken to be the unit matrix.
          interface larfgp
#ifdef LA_EXTERNAL_LAPACK
               subroutine clarfgp(n,alpha,x,incx,tau)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    complex(sp),intent(inout) :: alpha,x(*)
                    complex(sp),intent(out) :: tau
               end subroutine clarfgp
#else
               module procedure la_clarfgp
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dlarfgp(n,alpha,x,incx,tau)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    real(dp),intent(inout) :: alpha,x(*)
                    real(dp),intent(out) :: tau
               end subroutine dlarfgp
#else
               module procedure la_dlarfgp
#endif
               module procedure la_qlarfgp
#ifdef LA_EXTERNAL_LAPACK
               subroutine slarfgp(n,alpha,x,incx,tau)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    real(sp),intent(inout) :: alpha,x(*)
                    real(sp),intent(out) :: tau
               end subroutine slarfgp
#else
               module procedure la_slarfgp
#endif
               module procedure la_wlarfgp
#ifdef LA_EXTERNAL_LAPACK
               subroutine zlarfgp(n,alpha,x,incx,tau)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    complex(dp),intent(inout) :: alpha,x(*)
                    complex(dp),intent(out) :: tau
               end subroutine zlarfgp
#else
               module procedure la_zlarfgp
#endif
          end interface larfgp

          !> LARFT: forms the triangular factor T of a complex block reflector H
          !> of order n, which is defined as a product of k elementary reflectors.
          !> If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
          !> If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
          !> If STOREV = 'C', the vector which defines the elementary reflector
          !> H(i) is stored in the i-th column of the array V, and
          !> H  =  I - V * T * V**H
          !> If STOREV = 'R', the vector which defines the elementary reflector
          !> H(i) is stored in the i-th row of the array V, and
          !> H  =  I - V**H * T * V
          interface larft
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarft(direct,storev,n,k,v,ldv,tau,t,ldt)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,storev
                    integer(ilp),intent(in) :: k,ldt,ldv,n
                    complex(sp),intent(out) :: t(ldt,*)
                    complex(sp),intent(in) :: tau(*),v(ldv,*)
               end subroutine clarft
#else
               module procedure la_clarft
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarft(direct,storev,n,k,v,ldv,tau,t,ldt)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,storev
                    integer(ilp),intent(in) :: k,ldt,ldv,n
                    real(dp),intent(out) :: t(ldt,*)
                    real(dp),intent(in) :: tau(*),v(ldv,*)
               end subroutine dlarft
#else
               module procedure la_dlarft
#endif
               module procedure la_qlarft
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarft(direct,storev,n,k,v,ldv,tau,t,ldt)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,storev
                    integer(ilp),intent(in) :: k,ldt,ldv,n
                    real(sp),intent(out) :: t(ldt,*)
                    real(sp),intent(in) :: tau(*),v(ldv,*)
               end subroutine slarft
#else
               module procedure la_slarft
#endif
               module procedure la_wlarft
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarft(direct,storev,n,k,v,ldv,tau,t,ldt)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,storev
                    integer(ilp),intent(in) :: k,ldt,ldv,n
                    complex(dp),intent(out) :: t(ldt,*)
                    complex(dp),intent(in) :: tau(*),v(ldv,*)
               end subroutine zlarft
#else
               module procedure la_zlarft
#endif
          end interface larft

          !> LARFY: applies an elementary reflector, or Householder matrix, H,
          !> to an n x n Hermitian matrix C, from both the left and the right.
          !> H is represented in the form
          !> H = I - tau * v * v'
          !> where  tau  is a scalar and  v  is a vector.
          !> If  tau  is  zero, then  H  is taken to be the unit matrix.
          interface larfy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarfy(uplo,n,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incv,ldc,n
                    complex(sp),intent(in) :: tau,v(*)
                    complex(sp),intent(inout) :: c(ldc,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine clarfy
#else
               module procedure la_clarfy
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarfy(uplo,n,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incv,ldc,n
                    real(dp),intent(in) :: tau,v(*)
                    real(dp),intent(inout) :: c(ldc,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlarfy
#else
               module procedure la_dlarfy
#endif
               module procedure la_qlarfy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarfy(uplo,n,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incv,ldc,n
                    real(sp),intent(in) :: tau,v(*)
                    real(sp),intent(inout) :: c(ldc,*)
                    real(sp),intent(out) :: work(*)
               end subroutine slarfy
#else
               module procedure la_slarfy
#endif
               module procedure la_wlarfy
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarfy(uplo,n,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incv,ldc,n
                    complex(dp),intent(in) :: tau,v(*)
                    complex(dp),intent(inout) :: c(ldc,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zlarfy
#else
               module procedure la_zlarfy
#endif
          end interface larfy

          !> LARGV: generates a vector of complex plane rotations with real
          !> cosines, determined by elements of the complex vectors x and y.
          !> For i = 1,2,...,n
          !> (        c(i)   s(i) ) ( x(i) ) = ( r(i) )
          !> ( -conjg(s(i))  c(i) ) ( y(i) ) = (   0  )
          !> where c(i)**2 + ABS(s(i))**2 = 1
          !> The following conventions are used (these are the same as in CLARTG,
          !> but differ from the BLAS1 routine CROTG):
          !> If y(i)=0, then c(i)=1 and s(i)=0.
          !> If x(i)=0, then c(i)=0 and s(i) is chosen so that r(i) is real.
          interface largv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clargv(n,x,incx,y,incy,c,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,incy,n
                    real(sp),intent(out) :: c(*)
                    complex(sp),intent(inout) :: x(*),y(*)
               end subroutine clargv
#else
               module procedure la_clargv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlargv(n,x,incx,y,incy,c,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,incy,n
                    real(dp),intent(out) :: c(*)
                    real(dp),intent(inout) :: x(*),y(*)
               end subroutine dlargv
#else
               module procedure la_dlargv
#endif
               module procedure la_qlargv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slargv(n,x,incx,y,incy,c,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,incy,n
                    real(sp),intent(out) :: c(*)
                    real(sp),intent(inout) :: x(*),y(*)
               end subroutine slargv
#else
               module procedure la_slargv
#endif
               module procedure la_wlargv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlargv(n,x,incx,y,incy,c,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,incy,n
                    real(dp),intent(out) :: c(*)
                    complex(dp),intent(inout) :: x(*),y(*)
               end subroutine zlargv
#else
               module procedure la_zlargv
#endif
          end interface largv

          !> LARNV: returns a vector of n random complex numbers from a uniform or
          !> normal distribution.
          interface larnv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarnv(idist,iseed,n,x)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: idist,n
                    integer(ilp),intent(inout) :: iseed(4)
                    complex(sp),intent(out) :: x(*)
               end subroutine clarnv
#else
               module procedure la_clarnv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarnv(idist,iseed,n,x)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: idist,n
                    integer(ilp),intent(inout) :: iseed(4)
                    real(dp),intent(out) :: x(*)
               end subroutine dlarnv
#else
               module procedure la_dlarnv
#endif
               module procedure la_qlarnv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarnv(idist,iseed,n,x)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: idist,n
                    integer(ilp),intent(inout) :: iseed(4)
                    real(sp),intent(out) :: x(*)
               end subroutine slarnv
#else
               module procedure la_slarnv
#endif
               module procedure la_wlarnv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarnv(idist,iseed,n,x)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: idist,n
                    integer(ilp),intent(inout) :: iseed(4)
                    complex(dp),intent(out) :: x(*)
               end subroutine zlarnv
#else
               module procedure la_zlarnv
#endif
          end interface larnv

          !> Compute the splitting points with threshold SPLTOL.
          !> LARRA: sets any "small" off-diagonal elements to zero.
          interface larra
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarra(n,d,e,e2,spltol,tnrm,nsplit,isplit,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,nsplit,isplit(*)
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: spltol,tnrm,d(*)
                    real(dp),intent(inout) :: e(*),e2(*)
               end subroutine dlarra
#else
               module procedure la_dlarra
#endif
               module procedure la_qlarra
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarra(n,d,e,e2,spltol,tnrm,nsplit,isplit,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,nsplit,isplit(*)
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: spltol,tnrm,d(*)
                    real(sp),intent(inout) :: e(*),e2(*)
               end subroutine slarra
#else
               module procedure la_slarra
#endif
          end interface larra

          !> Given the relatively robust representation(RRR) L D L^T, LARRB:
          !> does "limited" bisection to refine the eigenvalues of L D L^T,
          !> W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
          !> guesses for these eigenvalues are input in W, the corresponding estimate
          !> of the error in these guesses and their gaps are input in WERR
          !> and WGAP, respectively. During bisection, intervals
          !> [left, right] are maintained by storing their mid-points and
          !> semi-widths in the arrays W and WERR respectively.
          interface larrb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarrb(n,d,lld,ifirst,ilast,rtol1,rtol2,offset,w,wgap, &
                         werr,work,iwork,pivmin,spdiam,twist,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ifirst,ilast,n,offset,twist
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(in) :: pivmin,rtol1,rtol2,spdiam,d(*),lld(*)
                    real(dp),intent(inout) :: w(*),werr(*),wgap(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlarrb
#else
               module procedure la_dlarrb
#endif
               module procedure la_qlarrb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarrb(n,d,lld,ifirst,ilast,rtol1,rtol2,offset,w,wgap, &
                         werr,work,iwork,pivmin,spdiam,twist,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ifirst,ilast,n,offset,twist
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(in) :: pivmin,rtol1,rtol2,spdiam,d(*),lld(*)
                    real(sp),intent(inout) :: w(*),werr(*),wgap(*)
                    real(sp),intent(out) :: work(*)
               end subroutine slarrb
#else
               module procedure la_slarrb
#endif
          end interface larrb

          !> Find the number of eigenvalues of the symmetric tridiagonal matrix T
          !> that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T
          !> if JOBT = 'L'.
          interface larrc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarrc(jobt,n,vl,vu,d,e,pivmin,eigcnt,lcnt,rcnt,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobt
                    integer(ilp),intent(out) :: eigcnt,info,lcnt,rcnt
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: pivmin,vl,vu,d(*),e(*)
               end subroutine dlarrc
#else
               module procedure la_dlarrc
#endif
               module procedure la_qlarrc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarrc(jobt,n,vl,vu,d,e,pivmin,eigcnt,lcnt,rcnt,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobt
                    integer(ilp),intent(out) :: eigcnt,info,lcnt,rcnt
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: pivmin,vl,vu,d(*),e(*)
               end subroutine slarrc
#else
               module procedure la_slarrc
#endif
          end interface larrc

          !> LARRD: computes the eigenvalues of a symmetric tridiagonal
          !> matrix T to suitable accuracy. This is an auxiliary code to be
          !> called from DSTEMR.
          !> The user may ask for all eigenvalues, all eigenvalues
          !> in the half-open interval (VL, VU], or the IL-th through IU-th
          !> eigenvalues.
          !> To avoid overflow, the matrix must be scaled so that its
          !> largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
          !> accuracy, it should not be much smaller than that.
          !> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !> Matrix", Report CS41, Computer Science Dept., Stanford
          !> University, July 21, 1966.
          interface larrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarrd(range,order,n,vl,vu,il,iu,gers,reltol,d,e,e2, &
               pivmin,nsplit,isplit,m,w,werr,wl,wu,iblock,indexw,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: order,range
                    integer(ilp),intent(in) :: il,iu,n,nsplit,isplit(*)
                    integer(ilp),intent(out) :: info,m,iblock(*),indexw(*),iwork(*)
                    real(dp),intent(in) :: pivmin,reltol,vl,vu,d(*),e(*),e2(*),gers(*)
                    real(dp),intent(out) :: wl,wu,w(*),werr(*),work(*)
               end subroutine dlarrd
#else
               module procedure la_dlarrd
#endif
               module procedure la_qlarrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarrd(range,order,n,vl,vu,il,iu,gers,reltol,d,e,e2, &
               pivmin,nsplit,isplit,m,w,werr,wl,wu,iblock,indexw,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: order,range
                    integer(ilp),intent(in) :: il,iu,n,nsplit,isplit(*)
                    integer(ilp),intent(out) :: info,m,iblock(*),indexw(*),iwork(*)
                    real(sp),intent(in) :: pivmin,reltol,vl,vu,d(*),e(*),e2(*),gers(*)
                    real(sp),intent(out) :: wl,wu,w(*),werr(*),work(*)
               end subroutine slarrd
#else
               module procedure la_slarrd
#endif
          end interface larrd

          !> To find the desired eigenvalues of a given real symmetric
          !> tridiagonal matrix T, LARRE: sets any "small" off-diagonal
          !> elements to zero, and for each unreduced block T_i, it finds
          !> (a) a suitable shift at one end of the block's spectrum,
          !> (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and
          !> (c) eigenvalues of each L_i D_i L_i^T.
          !> The representations and eigenvalues found are then used by
          !> DSTEMR to compute the eigenvectors of T.
          !> The accuracy varies depending on whether bisection is used to
          !> find a few eigenvalues or the dqds algorithm (subroutine DLASQ2) to
          !> conpute all and then discard any unwanted one.
          !> As an added benefit, LARRE also outputs the n
          !> Gerschgorin intervals for the matrices L_i D_i L_i^T.
          interface larre
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarre(range,n,vl,vu,il,iu,d,e,e2,rtol1,rtol2,spltol, &
               nsplit,isplit,m,w,werr,wgap,iblock,indexw,gers,pivmin,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: range
                    integer(ilp),intent(in) :: il,iu,n
                    integer(ilp),intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*), &
                              indexw(*)
                    real(dp),intent(out) :: pivmin,gers(*),w(*),werr(*),wgap(*),work(*)
                    real(dp),intent(in) :: rtol1,rtol2,spltol
                    real(dp),intent(inout) :: vl,vu,d(*),e(*),e2(*)
               end subroutine dlarre
#else
               module procedure la_dlarre
#endif
               module procedure la_qlarre
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarre(range,n,vl,vu,il,iu,d,e,e2,rtol1,rtol2,spltol, &
               nsplit,isplit,m,w,werr,wgap,iblock,indexw,gers,pivmin,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: range
                    integer(ilp),intent(in) :: il,iu,n
                    integer(ilp),intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*), &
                              indexw(*)
                    real(sp),intent(out) :: pivmin,gers(*),w(*),werr(*),wgap(*),work(*)
                    real(sp),intent(in) :: rtol1,rtol2,spltol
                    real(sp),intent(inout) :: vl,vu,d(*),e(*),e2(*)
               end subroutine slarre
#else
               module procedure la_slarre
#endif
          end interface larre

          !> Given the initial representation L D L^T and its cluster of close
          !> eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...
          !> W( CLEND ), LARRF: finds a new relatively robust representation
          !> L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
          !> eigenvalues of L(+) D(+) L(+)^T is relatively isolated.
          interface larrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarrf(n,d,l,ld,clstrt,clend,w,wgap,werr,spdiam,clgapl, &
                         clgapr,pivmin,sigma,dplus,lplus,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: clstrt,clend,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: clgapl,clgapr,pivmin,spdiam,d(*),l(*),ld(*),w(*),werr( &
                              *)
                    real(dp),intent(out) :: sigma,dplus(*),lplus(*),work(*)
                    real(dp),intent(inout) :: wgap(*)
               end subroutine dlarrf
#else
               module procedure la_dlarrf
#endif
               module procedure la_qlarrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarrf(n,d,l,ld,clstrt,clend,w,wgap,werr,spdiam,clgapl, &
                         clgapr,pivmin,sigma,dplus,lplus,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: clstrt,clend,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: clgapl,clgapr,pivmin,spdiam,d(*),l(*),ld(*),w(*),werr( &
                              *)
                    real(sp),intent(out) :: sigma,dplus(*),lplus(*),work(*)
                    real(sp),intent(inout) :: wgap(*)
               end subroutine slarrf
#else
               module procedure la_slarrf
#endif
          end interface larrf

          !> Given the initial eigenvalue approximations of T, LARRJ:
          !> does  bisection to refine the eigenvalues of T,
          !> W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
          !> guesses for these eigenvalues are input in W, the corresponding estimate
          !> of the error in these guesses in WERR. During bisection, intervals
          !> [left, right] are maintained by storing their mid-points and
          !> semi-widths in the arrays W and WERR respectively.
          interface larrj
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarrj(n,d,e2,ifirst,ilast,rtol,offset,w,werr,work,iwork, &
                         pivmin,spdiam,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ifirst,ilast,n,offset
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(in) :: pivmin,rtol,spdiam,d(*),e2(*)
                    real(dp),intent(inout) :: w(*),werr(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlarrj
#else
               module procedure la_dlarrj
#endif
               module procedure la_qlarrj
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarrj(n,d,e2,ifirst,ilast,rtol,offset,w,werr,work,iwork, &
                         pivmin,spdiam,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ifirst,ilast,n,offset
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(in) :: pivmin,rtol,spdiam,d(*),e2(*)
                    real(sp),intent(inout) :: w(*),werr(*)
                    real(sp),intent(out) :: work(*)
               end subroutine slarrj
#else
               module procedure la_slarrj
#endif
          end interface larrj

          !> LARRK: computes one eigenvalue of a symmetric tridiagonal
          !> matrix T to suitable accuracy. This is an auxiliary code to be
          !> called from DSTEMR.
          !> To avoid overflow, the matrix must be scaled so that its
          !> largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
          !> accuracy, it should not be much smaller than that.
          !> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !> Matrix", Report CS41, Computer Science Dept., Stanford
          !> University, July 21, 1966.
          interface larrk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarrk(n,iw,gl,gu,d,e2,pivmin,reltol,w,werr,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: iw,n
                    real(dp),intent(in) :: pivmin,reltol,gl,gu,d(*),e2(*)
                    real(dp),intent(out) :: w,werr
               end subroutine dlarrk
#else
               module procedure la_dlarrk
#endif
               module procedure la_qlarrk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarrk(n,iw,gl,gu,d,e2,pivmin,reltol,w,werr,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: iw,n
                    real(sp),intent(in) :: pivmin,reltol,gl,gu,d(*),e2(*)
                    real(sp),intent(out) :: w,werr
               end subroutine slarrk
#else
               module procedure la_slarrk
#endif
          end interface larrk

          !> Perform tests to decide whether the symmetric tridiagonal matrix T
          !> warrants expensive computations which guarantee high relative accuracy
          !> in the eigenvalues.
          interface larrr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarrr(n,d,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: d(*)
                    real(dp),intent(inout) :: e(*)
               end subroutine dlarrr
#else
               module procedure la_dlarrr
#endif
               module procedure la_qlarrr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarrr(n,d,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: d(*)
                    real(sp),intent(inout) :: e(*)
               end subroutine slarrr
#else
               module procedure la_slarrr
#endif
          end interface larrr

          !> LARRV: computes the eigenvectors of the tridiagonal matrix
          !> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
          !> The input eigenvalues should have been computed by SLARRE.
          interface larrv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarrv(n,vl,vu,d,l,pivmin,isplit,m,dol,dou,minrgp,rtol1, &
               rtol2,w,werr,wgap,iblock,indexw,gers,z,ldz,isuppz,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)
                              
                    integer(ilp),intent(out) :: info,isuppz(*),iwork(*)
                    real(sp),intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(sp),intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(out) :: z(ldz,*)
               end subroutine clarrv
#else
               module procedure la_clarrv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarrv(n,vl,vu,d,l,pivmin,isplit,m,dol,dou,minrgp,rtol1, &
               rtol2,w,werr,wgap,iblock,indexw,gers,z,ldz,isuppz,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)
                              
                    integer(ilp),intent(out) :: info,isuppz(*),iwork(*)
                    real(dp),intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(dp),intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine dlarrv
#else
               module procedure la_dlarrv
#endif
               module procedure la_qlarrv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarrv(n,vl,vu,d,l,pivmin,isplit,m,dol,dou,minrgp,rtol1, &
               rtol2,w,werr,wgap,iblock,indexw,gers,z,ldz,isuppz,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)
                              
                    integer(ilp),intent(out) :: info,isuppz(*),iwork(*)
                    real(sp),intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(sp),intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine slarrv
#else
               module procedure la_slarrv
#endif
               module procedure la_wlarrv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarrv(n,vl,vu,d,l,pivmin,isplit,m,dol,dou,minrgp,rtol1, &
               rtol2,w,werr,wgap,iblock,indexw,gers,z,ldz,isuppz,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)
                              
                    integer(ilp),intent(out) :: info,isuppz(*),iwork(*)
                    real(dp),intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(dp),intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(out) :: z(ldz,*)
               end subroutine zlarrv
#else
               module procedure la_zlarrv
#endif
          end interface larrv

          !> !
          !>
          !> LARTG: generates a plane rotation so that
          !> [  C         S  ] . [ F ]  =  [ R ]
          !> [ -conjg(S)  C  ]   [ G ]     [ 0 ]
          !> where C is real and C**2 + |S|**2 = 1.
          !> The mathematical formulas used for C and S are
          !> sgn(x) = {  x / |x|,   x != 0
          !> {  1,         x = 0
          !> R = sgn(F) * sqrt(|F|**2 + |G|**2)
          !> C = |F| / sqrt(|F|**2 + |G|**2)
          !> S = sgn(F) * conjg(G) / sqrt(|F|**2 + |G|**2)
          !> When F and G are real, the formulas simplify to C = F/R and
          !> S = G/R, and the returned values of C, S, and R should be
          !> identical to those returned by LARTG.
          !> The algorithm used to compute these quantities incorporates scaling
          !> to avoid overflow or underflow in computing the square root of the
          !> sum of squares.
          !> This is a faster version of the BLAS1 routine CROTG, except for
          !> the following differences:
          !> F and G are unchanged on return.
          !> If G=0, then C=1 and S=0.
          !> If F=0, then C=0 and S is chosen so that R is real.
          !> Below, wp=>sp stands for single precision from LA_CONSTANTS module.
          interface lartg
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clartg(f,g,c,s,r)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(out) :: c
                    complex(sp),intent(in) :: f,g
                    complex(sp),intent(out) :: r,s
               end subroutine clartg
#else
               module procedure la_clartg
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlartg(f,g,c,s,r)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(out) :: c,r,s
                    real(dp),intent(in) :: f,g
               end subroutine dlartg
#else
               module procedure la_dlartg
#endif
               module procedure la_qlartg
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slartg(f,g,c,s,r)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(out) :: c,r,s
                    real(sp),intent(in) :: f,g
               end subroutine slartg
#else
               module procedure la_slartg
#endif
               module procedure la_wlartg
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlartg(f,g,c,s,r)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(out) :: c
                    complex(dp),intent(in) :: f,g
                    complex(dp),intent(out) :: r,s
               end subroutine zlartg
#else
               module procedure la_zlartg
#endif
          end interface lartg

          !> LARTGP: generates a plane rotation so that
          !> [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
          !> [ -SN  CS  ]     [ G ]     [ 0 ]
          !> This is a slower, more accurate version of the Level 1 BLAS routine DROTG,
          !> with the following other differences:
          !> F and G are unchanged on return.
          !> If G=0, then CS=(+/-)1 and SN=0.
          !> If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.
          !> The sign is chosen so that R >= 0.
          interface lartgp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlartgp(f,g,cs,sn,r)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(out) :: cs,r,sn
                    real(dp),intent(in) :: f,g
               end subroutine dlartgp
#else
               module procedure la_dlartgp
#endif
               module procedure la_qlartgp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slartgp(f,g,cs,sn,r)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(out) :: cs,r,sn
                    real(sp),intent(in) :: f,g
               end subroutine slartgp
#else
               module procedure la_slartgp
#endif
          end interface lartgp

          !> LARTGS: generates a plane rotation designed to introduce a bulge in
          !> Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
          !> problem. X and Y are the top-row entries, and SIGMA is the shift.
          !> The computed CS and SN define a plane rotation satisfying
          !> [  CS  SN  ]  .  [ X^2 - SIGMA ]  =  [ R ],
          !> [ -SN  CS  ]     [    X * Y    ]     [ 0 ]
          !> with R nonnegative.  If X^2 - SIGMA and X * Y are 0, then the
          !> rotation is by PI/2.
          interface lartgs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlartgs(x,y,sigma,cs,sn)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(out) :: cs,sn
                    real(dp),intent(in) :: sigma,x,y
               end subroutine dlartgs
#else
               module procedure la_dlartgs
#endif
               module procedure la_qlartgs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slartgs(x,y,sigma,cs,sn)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(out) :: cs,sn
                    real(sp),intent(in) :: sigma,x,y
               end subroutine slartgs
#else
               module procedure la_slartgs
#endif
          end interface lartgs

          !> LARTV: applies a vector of complex plane rotations with real cosines
          !> to elements of the complex vectors x and y. For i = 1,2,...,n
          !> ( x(i) ) := (        c(i)   s(i) ) ( x(i) )
          !> ( y(i) )    ( -conjg(s(i))  c(i) ) ( y(i) )
          interface lartv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clartv(n,x,incx,y,incy,c,s,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,incy,n
                    real(sp),intent(in) :: c(*)
                    complex(sp),intent(in) :: s(*)
                    complex(sp),intent(inout) :: x(*),y(*)
               end subroutine clartv
#else
               module procedure la_clartv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlartv(n,x,incx,y,incy,c,s,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,incy,n
                    real(dp),intent(in) :: c(*),s(*)
                    real(dp),intent(inout) :: x(*),y(*)
               end subroutine dlartv
#else
               module procedure la_dlartv
#endif
               module procedure la_qlartv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slartv(n,x,incx,y,incy,c,s,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,incy,n
                    real(sp),intent(in) :: c(*),s(*)
                    real(sp),intent(inout) :: x(*),y(*)
               end subroutine slartv
#else
               module procedure la_slartv
#endif
               module procedure la_wlartv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlartv(n,x,incx,y,incy,c,s,incc)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incc,incx,incy,n
                    real(dp),intent(in) :: c(*)
                    complex(dp),intent(in) :: s(*)
                    complex(dp),intent(inout) :: x(*),y(*)
               end subroutine zlartv
#else
               module procedure la_zlartv
#endif
          end interface lartv

          !> LARUV: returns a vector of n random real numbers from a uniform (0,1)
          !> distribution (n <= 128).
          !> This is an auxiliary routine called by DLARNV and ZLARNV.
          interface laruv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaruv(iseed,n,x)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n
                    integer(ilp),intent(inout) :: iseed(4)
                    real(dp),intent(out) :: x(n)
               end subroutine dlaruv
#else
               module procedure la_dlaruv
#endif
               module procedure la_qlaruv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaruv(iseed,n,x)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: n
                    integer(ilp),intent(inout) :: iseed(4)
                    real(sp),intent(out) :: x(n)
               end subroutine slaruv
#else
               module procedure la_slaruv
#endif
          end interface laruv

          !> LARZ: applies a complex elementary reflector H to a complex
          !> M-by-N matrix C, from either the left or the right. H is represented
          !> in the form
          !> H = I - tau * v * v**H
          !> where tau is a complex scalar and v is a complex vector.
          !> If tau = 0, then H is taken to be the unit matrix.
          !> To apply H**H (the conjugate transpose of H), supply conjg(tau) instead
          !> tau.
          !> H is a product of k elementary reflectors as returned by CTZRZF.
          interface larz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarz(side,m,n,l,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side
                    integer(ilp),intent(in) :: incv,l,ldc,m,n
                    complex(sp),intent(in) :: tau,v(*)
                    complex(sp),intent(inout) :: c(ldc,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine clarz
#else
               module procedure la_clarz
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarz(side,m,n,l,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side
                    integer(ilp),intent(in) :: incv,l,ldc,m,n
                    real(dp),intent(in) :: tau,v(*)
                    real(dp),intent(inout) :: c(ldc,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlarz
#else
               module procedure la_dlarz
#endif
               module procedure la_qlarz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarz(side,m,n,l,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side
                    integer(ilp),intent(in) :: incv,l,ldc,m,n
                    real(sp),intent(in) :: tau,v(*)
                    real(sp),intent(inout) :: c(ldc,*)
                    real(sp),intent(out) :: work(*)
               end subroutine slarz
#else
               module procedure la_slarz
#endif
               module procedure la_wlarz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarz(side,m,n,l,v,incv,tau,c,ldc,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side
                    integer(ilp),intent(in) :: incv,l,ldc,m,n
                    complex(dp),intent(in) :: tau,v(*)
                    complex(dp),intent(inout) :: c(ldc,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zlarz
#else
               module procedure la_zlarz
#endif
          end interface larz

          !> LARZB: applies a complex block reflector H or its transpose H**H
          !> to a complex distributed M-by-N  C from the left or the right.
          !> Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
          interface larzb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarzb(side,trans,direct,storev,m,n,k,l,v,ldv,t,ldt,c, &
                         ldc,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    complex(sp),intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    complex(sp),intent(out) :: work(ldwork,*)
               end subroutine clarzb
#else
               module procedure la_clarzb
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarzb(side,trans,direct,storev,m,n,k,l,v,ldv,t,ldt,c, &
                         ldc,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    real(dp),intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    real(dp),intent(out) :: work(ldwork,*)
               end subroutine dlarzb
#else
               module procedure la_dlarzb
#endif
               module procedure la_qlarzb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarzb(side,trans,direct,storev,m,n,k,l,v,ldv,t,ldt,c, &
                         ldc,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    real(sp),intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    real(sp),intent(out) :: work(ldwork,*)
               end subroutine slarzb
#else
               module procedure la_slarzb
#endif
               module procedure la_wlarzb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarzb(side,trans,direct,storev,m,n,k,l,v,ldv,t,ldt,c, &
                         ldc,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    complex(dp),intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    complex(dp),intent(out) :: work(ldwork,*)
               end subroutine zlarzb
#else
               module procedure la_zlarzb
#endif
          end interface larzb

          !> LARZT: forms the triangular factor T of a complex block reflector
          !> H of order > n, which is defined as a product of k elementary
          !> reflectors.
          !> If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
          !> If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
          !> If STOREV = 'C', the vector which defines the elementary reflector
          !> H(i) is stored in the i-th column of the array V, and
          !> H  =  I - V * T * V**H
          !> If STOREV = 'R', the vector which defines the elementary reflector
          !> H(i) is stored in the i-th row of the array V, and
          !> H  =  I - V**H * T * V
          !> Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
          interface larzt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clarzt(direct,storev,n,k,v,ldv,tau,t,ldt)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,storev
                    integer(ilp),intent(in) :: k,ldt,ldv,n
                    complex(sp),intent(out) :: t(ldt,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(inout) :: v(ldv,*)
               end subroutine clarzt
#else
               module procedure la_clarzt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlarzt(direct,storev,n,k,v,ldv,tau,t,ldt)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,storev
                    integer(ilp),intent(in) :: k,ldt,ldv,n
                    real(dp),intent(out) :: t(ldt,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(inout) :: v(ldv,*)
               end subroutine dlarzt
#else
               module procedure la_dlarzt
#endif
               module procedure la_qlarzt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slarzt(direct,storev,n,k,v,ldv,tau,t,ldt)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,storev
                    integer(ilp),intent(in) :: k,ldt,ldv,n
                    real(sp),intent(out) :: t(ldt,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(inout) :: v(ldv,*)
               end subroutine slarzt
#else
               module procedure la_slarzt
#endif
               module procedure la_wlarzt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlarzt(direct,storev,n,k,v,ldv,tau,t,ldt)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,storev
                    integer(ilp),intent(in) :: k,ldt,ldv,n
                    complex(dp),intent(out) :: t(ldt,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(inout) :: v(ldv,*)
               end subroutine zlarzt
#else
               module procedure la_zlarzt
#endif
          end interface larzt

          !> LASCL: multiplies the M by N complex matrix A by the real scalar
          !> CTO/CFROM.  This is done without over/underflow as long as the final
          !> result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
          !> A may be full, upper triangular, lower triangular, upper Hessenberg,
          !> or banded.
          interface lascl
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clascl(type,kl,ku,cfrom,cto,m,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: type
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,lda,m,n
                    real(sp),intent(in) :: cfrom,cto
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine clascl
#else
               module procedure la_clascl
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlascl(type,kl,ku,cfrom,cto,m,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: type
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,lda,m,n
                    real(dp),intent(in) :: cfrom,cto
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dlascl
#else
               module procedure la_dlascl
#endif
               module procedure la_qlascl
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slascl(type,kl,ku,cfrom,cto,m,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: type
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,lda,m,n
                    real(sp),intent(in) :: cfrom,cto
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine slascl
#else
               module procedure la_slascl
#endif
               module procedure la_wlascl
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlascl(type,kl,ku,cfrom,cto,m,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: type
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kl,ku,lda,m,n
                    real(dp),intent(in) :: cfrom,cto
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zlascl
#else
               module procedure la_zlascl
#endif
          end interface lascl

          !> Using a divide and conquer approach, LASD0: computes the singular
          !> value decomposition (SVD) of a real upper bidiagonal N-by-M
          !> matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
          !> The algorithm computes orthogonal matrices U and VT such that
          !> B = U * S * VT. The singular values S are overwritten on D.
          !> A related subroutine, DLASDA, computes only the singular values,
          !> and optionally, the singular vectors in compact form.
          interface lasd0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasd0(n,sqre,d,e,u,ldu,vt,ldvt,smlsiz,iwork,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu,ldvt,n,smlsiz,sqre
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dlasd0
#else
               module procedure la_dlasd0
#endif
               module procedure la_qlasd0
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasd0(n,sqre,d,e,u,ldu,vt,ldvt,smlsiz,iwork,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu,ldvt,n,smlsiz,sqre
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine slasd0
#else
               module procedure la_slasd0
#endif
          end interface lasd0

          !> LASD1: computes the SVD of an upper bidiagonal N-by-M matrix B,
          !> where N = NL + NR + 1 and M = N + SQRE. LASD1 is called from DLASD0.
          !> A related subroutine DLASD7 handles the case in which the singular
          !> values (and the singular vectors in factored form) are desired.
          !> LASD1 computes the SVD as follows:
          !> ( D1(in)    0    0       0 )
          !> B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
          !> (   0       0   D2(in)   0 )
          !> = U(out) * ( D(out) 0) * VT(out)
          !> where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
          !> with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
          !> elsewhere; and the entry b is empty if SQRE = 0.
          !> The left singular vectors of the original matrix are stored in U, and
          !> the transpose of the right singular vectors are stored in VT, and the
          !> singular values are in D.  The algorithm consists of three stages:
          !> The first stage consists of deflating the size of the problem
          !> when there are multiple singular values or when there are zeros in
          !> the Z vector.  For each such occurrence the dimension of the
          !> secular equation problem is reduced by one.  This stage is
          !> performed by the routine DLASD2.
          !> The second stage consists of calculating the updated
          !> singular values. This is done by finding the square roots of the
          !> roots of the secular equation via the routine DLASD4 (as called
          !> by DLASD3). This routine also calculates the singular vectors of
          !> the current problem.
          !> The final stage consists of computing the updated singular vectors
          !> directly using the updated singular values.  The singular vectors
          !> for the current problem are multiplied with the singular vectors
          !> from the overall problem.
          interface lasd1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasd1(nl,nr,sqre,d,alpha,beta,u,ldu,vt,ldvt,idxq,iwork, &
                          work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu,ldvt,nl,nr,sqre
                    real(dp),intent(inout) :: alpha,beta,d(*),u(ldu,*),vt(ldvt,*)
                    integer(ilp),intent(inout) :: idxq(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlasd1
#else
               module procedure la_dlasd1
#endif
               module procedure la_qlasd1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasd1(nl,nr,sqre,d,alpha,beta,u,ldu,vt,ldvt,idxq,iwork, &
                          work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu,ldvt,nl,nr,sqre
                    real(sp),intent(inout) :: alpha,beta,d(*),u(ldu,*),vt(ldvt,*)
                    integer(ilp),intent(inout) :: idxq(*)
                    real(sp),intent(out) :: work(*)
               end subroutine slasd1
#else
               module procedure la_slasd1
#endif
          end interface lasd1

          !> This subroutine computes the square root of the I-th updated
          !> eigenvalue of a positive symmetric rank-one modification to
          !> a positive diagonal matrix whose entries are given as the squares
          !> of the corresponding entries in the array d, and that
          !> 0 <= D(i) < D(j)  for  i < j
          !> and that RHO > 0. This is arranged by the calling routine, and is
          !> no loss in generality.  The rank-one modified system is thus
          !> diag( D ) * diag( D ) +  RHO * Z * Z_transpose.
          !> where we assume the Euclidean norm of Z is 1.
          !> The method consists of approximating the rational functions in the
          !> secular equation by simpler interpolating rational functions.
          interface lasd4
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasd4(n,i,d,z,delta,rho,sigma,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: rho,d(*),z(*)
                    real(dp),intent(out) :: sigma,delta(*),work(*)
               end subroutine dlasd4
#else
               module procedure la_dlasd4
#endif
               module procedure la_qlasd4
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasd4(n,i,d,z,delta,rho,sigma,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: rho,d(*),z(*)
                    real(sp),intent(out) :: sigma,delta(*),work(*)
               end subroutine slasd4
#else
               module procedure la_slasd4
#endif
          end interface lasd4

          !> This subroutine computes the square root of the I-th eigenvalue
          !> of a positive symmetric rank-one modification of a 2-by-2 diagonal
          !> matrix
          !> diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .
          !> The diagonal entries in the array D are assumed to satisfy
          !> 0 <= D(i) < D(j)  for  i < j .
          !> We also assume RHO > 0 and that the Euclidean norm of the vector
          !> Z is one.
          interface lasd5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasd5(i,d,z,delta,rho,dsigma,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i
                    real(dp),intent(out) :: dsigma,delta(2),work(2)
                    real(dp),intent(in) :: rho,d(2),z(2)
               end subroutine dlasd5
#else
               module procedure la_dlasd5
#endif
               module procedure la_qlasd5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasd5(i,d,z,delta,rho,dsigma,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i
                    real(sp),intent(out) :: dsigma,delta(2),work(2)
                    real(sp),intent(in) :: rho,d(2),z(2)
               end subroutine slasd5
#else
               module procedure la_slasd5
#endif
          end interface lasd5

          !> LASD6: computes the SVD of an updated upper bidiagonal matrix B
          !> obtained by merging two smaller ones by appending a row. This
          !> routine is used only for the problem which requires all singular
          !> values and optionally singular vector matrices in factored form.
          !> B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
          !> A related subroutine, DLASD1, handles the case in which all singular
          !> values and singular vectors of the bidiagonal matrix are desired.
          !> LASD6 computes the SVD as follows:
          !> ( D1(in)    0    0       0 )
          !> B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
          !> (   0       0   D2(in)   0 )
          !> = U(out) * ( D(out) 0) * VT(out)
          !> where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
          !> with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
          !> elsewhere; and the entry b is empty if SQRE = 0.
          !> The singular values of B can be computed using D1, D2, the first
          !> components of all the right singular vectors of the lower block, and
          !> the last components of all the right singular vectors of the upper
          !> block. These components are stored and updated in VF and VL,
          !> respectively, in LASD6. Hence U and VT are not explicitly
          !> referenced.
          !> The singular values are stored in D. The algorithm consists of two
          !> stages:
          !> The first stage consists of deflating the size of the problem
          !> when there are multiple singular values or if there is a zero
          !> in the Z vector. For each such occurrence the dimension of the
          !> secular equation problem is reduced by one. This stage is
          !> performed by the routine DLASD7.
          !> The second stage consists of calculating the updated
          !> singular values. This is done by finding the roots of the
          !> secular equation via the routine DLASD4 (as called by DLASD8).
          !> This routine also updates VF and VL and computes the distances
          !> between the updated singular values and the old singular
          !> values.
          !> LASD6 is called from DLASDA.
          interface lasd6
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasd6(icompq,nl,nr,sqre,d,vf,vl,alpha,beta,idxq,perm, &
               givptr,givcol,ldgcol,givnum,ldgnum,poles,difl,difr,z,k,c,s,work,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: givptr,info,k,givcol(ldgcol,*),iwork(*),perm(*)
                              
                    integer(ilp),intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(dp),intent(inout) :: alpha,beta,d(*),vf(*),vl(*)
                    real(dp),intent(out) :: c,s,difl(*),difr(*),givnum(ldgnum,*),poles(ldgnum,*), &
                              work(*),z(*)
                    integer(ilp),intent(inout) :: idxq(*)
               end subroutine dlasd6
#else
               module procedure la_dlasd6
#endif
               module procedure la_qlasd6
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasd6(icompq,nl,nr,sqre,d,vf,vl,alpha,beta,idxq,perm, &
               givptr,givcol,ldgcol,givnum,ldgnum,poles,difl,difr,z,k,c,s,work,iwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: givptr,info,k,givcol(ldgcol,*),iwork(*),perm(*)
                              
                    integer(ilp),intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(sp),intent(inout) :: alpha,beta,d(*),vf(*),vl(*)
                    real(sp),intent(out) :: c,s,difl(*),difr(*),givnum(ldgnum,*),poles(ldgnum,*), &
                              work(*),z(*)
                    integer(ilp),intent(inout) :: idxq(*)
               end subroutine slasd6
#else
               module procedure la_slasd6
#endif
          end interface lasd6

          !> LASD7: merges the two sets of singular values together into a single
          !> sorted set. Then it tries to deflate the size of the problem. There
          !> are two ways in which deflation can occur:  when two or more singular
          !> values are close together or if there is a tiny entry in the Z
          !> vector. For each such occurrence the order of the related
          !> secular equation problem is reduced by one.
          !> LASD7 is called from DLASD6.
          interface lasd7
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasd7(icompq,nl,nr,sqre,k,d,z,zw,vf,vfw,vl,vlw,alpha, &
               beta,dsigma,idx,idxp,idxq,perm,givptr,givcol,ldgcol,givnum,ldgnum,c,s, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: givptr,info,k,givcol(ldgcol,*),idx(*),idxp(*), &
                              perm(*)
                    integer(ilp),intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(dp),intent(in) :: alpha,beta
                    real(dp),intent(out) :: c,s,dsigma(*),givnum(ldgnum,*),vfw(*),vlw(*),z(*),zw( &
                              *)
                    integer(ilp),intent(inout) :: idxq(*)
                    real(dp),intent(inout) :: d(*),vf(*),vl(*)
               end subroutine dlasd7
#else
               module procedure la_dlasd7
#endif
               module procedure la_qlasd7
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasd7(icompq,nl,nr,sqre,k,d,z,zw,vf,vfw,vl,vlw,alpha, &
               beta,dsigma,idx,idxp,idxq,perm,givptr,givcol,ldgcol,givnum,ldgnum,c,s, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: givptr,info,k,givcol(ldgcol,*),idx(*),idxp(*), &
                              perm(*)
                    integer(ilp),intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(sp),intent(in) :: alpha,beta
                    real(sp),intent(out) :: c,s,dsigma(*),givnum(ldgnum,*),vfw(*),vlw(*),z(*),zw( &
                              *)
                    integer(ilp),intent(inout) :: idxq(*)
                    real(sp),intent(inout) :: d(*),vf(*),vl(*)
               end subroutine slasd7
#else
               module procedure la_slasd7
#endif
          end interface lasd7

          !> LASD8: finds the square roots of the roots of the secular equation,
          !> as defined by the values in DSIGMA and Z. It makes the appropriate
          !> calls to DLASD4, and stores, for each  element in D, the distance
          !> to its two nearest poles (elements in DSIGMA). It also updates
          !> the arrays VF and VL, the first and last components of all the
          !> right singular vectors of the original bidiagonal matrix.
          !> LASD8 is called from DLASD6.
          interface lasd8
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasd8(icompq,k,d,z,vf,vl,difl,difr,lddifr,dsigma,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: icompq,k,lddifr
                    integer(ilp),intent(out) :: info
                    real(dp),intent(out) :: d(*),difl(*),difr(lddifr,*),work(*)
                    real(dp),intent(inout) :: dsigma(*),vf(*),vl(*),z(*)
               end subroutine dlasd8
#else
               module procedure la_dlasd8
#endif
               module procedure la_qlasd8
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasd8(icompq,k,d,z,vf,vl,difl,difr,lddifr,dsigma,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: icompq,k,lddifr
                    integer(ilp),intent(out) :: info
                    real(sp),intent(out) :: d(*),difl(*),difr(lddifr,*),work(*)
                    real(sp),intent(inout) :: dsigma(*),vf(*),vl(*),z(*)
               end subroutine slasd8
#else
               module procedure la_slasd8
#endif
          end interface lasd8

          !> Using a divide and conquer approach, LASDA: computes the singular
          !> value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
          !> B with diagonal D and offdiagonal E, where M = N + SQRE. The
          !> algorithm computes the singular values in the SVD B = U * S * VT.
          !> The orthogonal matrices U and VT are optionally computed in
          !> compact form.
          !> A related subroutine, DLASD0, computes the singular values and
          !> the singular vectors in explicit form.
          interface lasda
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasda(icompq,smlsiz,n,sqre,d,e,u,ldu,vt,k,difl,difr,z, &
                          poles,givptr,givcol,ldgcol,perm,givnum,c,s,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: icompq,ldgcol,ldu,n,smlsiz,sqre
                    integer(ilp),intent(out) :: info,givcol(ldgcol,*),givptr(*),iwork(*),k(*), &
                              perm(ldgcol,*)
                    real(dp),intent(out) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu, &
                              *),s(*),u(ldu,*),vt(ldu,*),work(*),z(ldu,*)
                    real(dp),intent(inout) :: d(*),e(*)
               end subroutine dlasda
#else
               module procedure la_dlasda
#endif
               module procedure la_qlasda
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasda(icompq,smlsiz,n,sqre,d,e,u,ldu,vt,k,difl,difr,z, &
                          poles,givptr,givcol,ldgcol,perm,givnum,c,s,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: icompq,ldgcol,ldu,n,smlsiz,sqre
                    integer(ilp),intent(out) :: info,givcol(ldgcol,*),givptr(*),iwork(*),k(*), &
                              perm(ldgcol,*)
                    real(sp),intent(out) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu, &
                              *),s(*),u(ldu,*),vt(ldu,*),work(*),z(ldu,*)
                    real(sp),intent(inout) :: d(*),e(*)
               end subroutine slasda
#else
               module procedure la_slasda
#endif
          end interface lasda

          !> LASDQ: computes the singular value decomposition (SVD) of a real
          !> (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
          !> E, accumulating the transformations if desired. Letting B denote
          !> the input bidiagonal matrix, the algorithm computes orthogonal
          !> matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose
          !> of P). The singular values S are overwritten on D.
          !> The input matrix U  is changed to U  * Q  if desired.
          !> The input matrix VT is changed to P**T * VT if desired.
          !> The input matrix C  is changed to Q**T * C  if desired.
          !> See "Computing  Small Singular Values of Bidiagonal Matrices With
          !> Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
          !> LAPACK Working Note #3, for a detailed description of the algorithm.
          interface lasdq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasdq(uplo,sqre,n,ncvt,nru,ncc,d,e,vt,ldvt,u,ldu,c, &
                         ldc,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru,sqre
                    real(dp),intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlasdq
#else
               module procedure la_dlasdq
#endif
               module procedure la_qlasdq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasdq(uplo,sqre,n,ncvt,nru,ncc,d,e,vt,ldvt,u,ldu,c, &
                         ldc,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru,sqre
                    real(sp),intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(sp),intent(out) :: work(*)
               end subroutine slasdq
#else
               module procedure la_slasdq
#endif
          end interface lasdq

          !> LASET: initializes a 2-D array A to BETA on the diagonal and
          !> ALPHA on the offdiagonals.
          interface laset
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claset(uplo,m,n,alpha,beta,a,lda)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,m,n
                    complex(sp),intent(in) :: alpha,beta
                    complex(sp),intent(out) :: a(lda,*)
               end subroutine claset
#else
               module procedure la_claset
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaset(uplo,m,n,alpha,beta,a,lda)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(in) :: alpha,beta
                    real(dp),intent(out) :: a(lda,*)
               end subroutine dlaset
#else
               module procedure la_dlaset
#endif
               module procedure la_qlaset
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaset(uplo,m,n,alpha,beta,a,lda)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(in) :: alpha,beta
                    real(sp),intent(out) :: a(lda,*)
               end subroutine slaset
#else
               module procedure la_slaset
#endif
               module procedure la_wlaset
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaset(uplo,m,n,alpha,beta,a,lda)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,m,n
                    complex(dp),intent(in) :: alpha,beta
                    complex(dp),intent(out) :: a(lda,*)
               end subroutine zlaset
#else
               module procedure la_zlaset
#endif
          end interface laset

          !> LASQ1: computes the singular values of a real N-by-N bidiagonal
          !> matrix with diagonal D and off-diagonal E. The singular values
          !> are computed to high relative accuracy, in the absence of
          !> denormalization, underflow and overflow. The algorithm was first
          !> presented in
          !> "Accurate singular values and differential qd algorithms" by K. V.
          !> Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
          !> 1994,
          !> and the present implementation is described in "An implementation of
          !> the dqds Algorithm (Positive Case)", LAPACK Working Note.
          interface lasq1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasq1(n,d,e,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlasq1
#else
               module procedure la_dlasq1
#endif
               module procedure la_qlasq1
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasq1(n,d,e,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: work(*)
               end subroutine slasq1
#else
               module procedure la_slasq1
#endif
          end interface lasq1

          !> LASQ4: computes an approximation TAU to the smallest eigenvalue
          !> using values of d from the previous transform.
          interface lasq4
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasq4(i0,n0,z,pp,n0in,dmin,dmin1,dmin2,dn,dn1,dn2,tau, &
                         ttype,g)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i0,n0,n0in,pp
                    integer(ilp),intent(out) :: ttype
                    real(dp),intent(in) :: dmin,dmin1,dmin2,dn,dn1,dn2,z(*)
                    real(dp),intent(inout) :: g
                    real(dp),intent(out) :: tau
               end subroutine dlasq4
#else
               module procedure la_dlasq4
#endif
               module procedure la_qlasq4
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasq4(i0,n0,z,pp,n0in,dmin,dmin1,dmin2,dn,dn1,dn2,tau, &
                         ttype,g)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i0,n0,n0in,pp
                    integer(ilp),intent(out) :: ttype
                    real(sp),intent(in) :: dmin,dmin1,dmin2,dn,dn1,dn2,z(*)
                    real(sp),intent(inout) :: g
                    real(sp),intent(out) :: tau
               end subroutine slasq4
#else
               module procedure la_slasq4
#endif
          end interface lasq4

          !> LASQ5: computes one dqds transform in ping-pong form, one
          !> version for IEEE machines another for non IEEE machines.
          interface lasq5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasq5(i0,n0,z,pp,tau,sigma,dmin,dmin1,dmin2,dn,dnm1, &
                         dnm2,ieee,eps)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: ieee
                    integer(ilp),intent(in) :: i0,n0,pp
                    real(dp),intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(dp),intent(inout) :: tau,z(*)
                    real(dp),intent(in) :: sigma,eps
               end subroutine dlasq5
#else
               module procedure la_dlasq5
#endif
               module procedure la_qlasq5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasq5(i0,n0,z,pp,tau,sigma,dmin,dmin1,dmin2,dn,dnm1, &
                         dnm2,ieee,eps)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: ieee
                    integer(ilp),intent(in) :: i0,n0,pp
                    real(sp),intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(sp),intent(inout) :: tau,z(*)
                    real(sp),intent(in) :: sigma,eps
               end subroutine slasq5
#else
               module procedure la_slasq5
#endif
          end interface lasq5

          !> LASQ6: computes one dqd (shift equal to zero) transform in
          !> ping-pong form, with protection against underflow and overflow.
          interface lasq6
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasq6(i0,n0,z,pp,dmin,dmin1,dmin2,dn,dnm1,dnm2)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i0,n0,pp
                    real(dp),intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(dp),intent(inout) :: z(*)
               end subroutine dlasq6
#else
               module procedure la_dlasq6
#endif
               module procedure la_qlasq6
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasq6(i0,n0,z,pp,dmin,dmin1,dmin2,dn,dnm1,dnm2)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: i0,n0,pp
                    real(sp),intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(sp),intent(inout) :: z(*)
               end subroutine slasq6
#else
               module procedure la_slasq6
#endif
          end interface lasq6

          !> LASR: applies a sequence of real plane rotations to a complex matrix
          !> A, from either the left or the right.
          !> When SIDE = 'L', the transformation takes the form
          !> A := P*A
          !> and when SIDE = 'R', the transformation takes the form
          !> A := A*P**T
          !> where P is an orthogonal matrix consisting of a sequence of z plane
          !> rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
          !> and P**T is the transpose of P.
          !> When DIRECT = 'F' (Forward sequence), then
          !> P = P(z-1) * ... * P(2) * P(1)
          !> and when DIRECT = 'B' (Backward sequence), then
          !> P = P(1) * P(2) * ... * P(z-1)
          !> where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
          !> R(k) = (  c(k)  s(k) )
          !> = ( -s(k)  c(k) ).
          !> When PIVOT = 'V' (Variable pivot), the rotation is performed
          !> for the plane (k,k+1), i.e., P(k) has the form
          !> P(k) = (  1                                            )
          !> (       ...                                     )
          !> (              1                                )
          !> (                   c(k)  s(k)                  )
          !> (                  -s(k)  c(k)                  )
          !> (                                1              )
          !> (                                     ...       )
          !> (                                            1  )
          !> where R(k) appears as a rank-2 modification to the identity matrix in
          !> rows and columns k and k+1.
          !> When PIVOT = 'T' (Top pivot), the rotation is performed for the
          !> plane (1,k+1), so P(k) has the form
          !> P(k) = (  c(k)                    s(k)                 )
          !> (         1                                     )
          !> (              ...                              )
          !> (                     1                         )
          !> ( -s(k)                    c(k)                 )
          !> (                                 1             )
          !> (                                      ...      )
          !> (                                             1 )
          !> where R(k) appears in rows and columns 1 and k+1.
          !> Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
          !> performed for the plane (k,z), giving P(k) the form
          !> P(k) = ( 1                                             )
          !> (      ...                                      )
          !> (             1                                 )
          !> (                  c(k)                    s(k) )
          !> (                         1                     )
          !> (                              ...              )
          !> (                                     1         )
          !> (                 -s(k)                    c(k) )
          !> where R(k) appears in rows and columns k and z.  The rotations are
          !> performed without ever forming P(k) explicitly.
          interface lasr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clasr(side,pivot,direct,m,n,c,s,a,lda)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,pivot,side
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(in) :: c(*),s(*)
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine clasr
#else
               module procedure la_clasr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasr(side,pivot,direct,m,n,c,s,a,lda)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,pivot,side
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: c(*),s(*)
               end subroutine dlasr
#else
               module procedure la_dlasr
#endif
               module procedure la_qlasr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasr(side,pivot,direct,m,n,c,s,a,lda)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,pivot,side
                    integer(ilp),intent(in) :: lda,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: c(*),s(*)
               end subroutine slasr
#else
               module procedure la_slasr
#endif
               module procedure la_wlasr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlasr(side,pivot,direct,m,n,c,s,a,lda)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,pivot,side
                    integer(ilp),intent(in) :: lda,m,n
                    real(dp),intent(in) :: c(*),s(*)
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zlasr
#else
               module procedure la_zlasr
#endif
          end interface lasr

          !> Sort the numbers in D in increasing order (if ID = 'I') or
          !> in decreasing order (if ID = 'D' ).
          !> Use Quick Sort, reverting to Insertion sort on arrays of
          !> size <= 20. Dimension of STACK limits N to about 2**32.
          interface lasrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasrt(id,n,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: id
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: d(*)
               end subroutine dlasrt
#else
               module procedure la_dlasrt
#endif
               module procedure la_qlasrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasrt(id,n,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: id
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: d(*)
               end subroutine slasrt
#else
               module procedure la_slasrt
#endif
          end interface lasrt

          !> !
          !>
          !> LASSQ:  returns the values  scl  and  smsq  such that
          !> ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
          !> where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
          !> assumed to be non-negative.
          !> scale and sumsq must be supplied in SCALE and SUMSQ and
          !> scl and smsq are overwritten on SCALE and SUMSQ respectively.
          !> If scale * sqrt( sumsq ) > tbig then
          !> we require:   scale >= sqrt( TINY*EPS ) / sbig   on entry,
          !> and if 0 < scale * sqrt( sumsq ) < tsml then
          !> we require:   scale <= sqrt( HUGE ) / ssml       on entry,
          !> where
          !> tbig -- upper threshold for values whose square is representable;
          !> sbig -- scaling constant for big numbers; \see la_constants.f90
          !> tsml -- lower threshold for values whose square is representable;
          !> ssml -- scaling constant for small numbers; \see la_constants.f90
          !> and
          !> TINY*EPS -- tiniest representable number;
          !> HUGE     -- biggest representable number.
          interface lassq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine classq(n,x,incx,scl,sumsq)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    real(sp),intent(inout) :: scl,sumsq
                    complex(sp),intent(in) :: x(*)
               end subroutine classq
#else
               module procedure la_classq
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlassq(n,x,incx,scl,sumsq)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    real(dp),intent(inout) :: scl,sumsq
                    real(dp),intent(in) :: x(*)
               end subroutine dlassq
#else
               module procedure la_dlassq
#endif
               module procedure la_qlassq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slassq(n,x,incx,scl,sumsq)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    real(sp),intent(inout) :: scl,sumsq
                    real(sp),intent(in) :: x(*)
               end subroutine slassq
#else
               module procedure la_slassq
#endif
               module procedure la_wlassq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlassq(n,x,incx,scl,sumsq)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    real(dp),intent(inout) :: scl,sumsq
                    complex(dp),intent(in) :: x(*)
               end subroutine zlassq
#else
               module procedure la_zlassq
#endif
          end interface lassq

          !> LASWLQ: computes a blocked Tall-Skinny LQ factorization of
          !> a complex M-by-N matrix A for M <= N:
          !> A = ( L 0 ) *  Q,
          !> where:
          !> Q is a n-by-N orthogonal matrix, stored on exit in an implicit
          !> form in the elements above the diagonal of the array A and in
          !> the elements of the array T;
          !> L is a lower-triangular M-by-M matrix stored on exit in
          !> the elements on and below the diagonal of the array A.
          !> 0 is a M-by-(N-M) zero matrix, if M < N, and is not stored.
          interface laswlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claswlq(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*),t(ldt,*)
               end subroutine claswlq
#else
               module procedure la_claswlq
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaswlq(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: work(*),t(ldt,*)
               end subroutine dlaswlq
#else
               module procedure la_dlaswlq
#endif
               module procedure la_qlaswlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaswlq(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: work(*),t(ldt,*)
               end subroutine slaswlq
#else
               module procedure la_slaswlq
#endif
               module procedure la_wlaswlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaswlq(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*),t(ldt,*)
               end subroutine zlaswlq
#else
               module procedure la_zlaswlq
#endif
          end interface laswlq

          !> LASWP: performs a series of row interchanges on the matrix A.
          !> One row interchange is initiated for each of rows K1 through K2 of A.
          interface laswp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claswp(n,a,lda,k1,k2,ipiv,incx)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine claswp
#else
               module procedure la_claswp
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlaswp(n,a,lda,k1,k2,ipiv,incx)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dlaswp
#else
               module procedure la_dlaswp
#endif
               module procedure la_qlaswp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slaswp(n,a,lda,k1,k2,ipiv,incx)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine slaswp
#else
               module procedure la_slaswp
#endif
               module procedure la_wlaswp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaswp(n,a,lda,k1,k2,ipiv,incx)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zlaswp
#else
               module procedure la_zlaswp
#endif
          end interface laswp

          !> LASYF: computes a partial factorization of a complex symmetric matrix
          !> A using the Bunch-Kaufman diagonal pivoting method. The partial
          !> factorization has the form:
          !> A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !> ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
          !> A  =  ( L11  0 ) ( D    0  ) ( L11**T L21**T )  if UPLO = 'L'
          !> ( L21  I ) ( 0   A22 ) (  0       I    )
          !> where the order of D is at most NB. The actual order is returned in
          !> the argument KB, and is either NB or NB-1, or N if N <= NB.
          !> Note that U**T denotes the transpose of U.
          !> LASYF is an auxiliary routine called by CSYTRF. It uses blocked code
          !> (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
          !> A22 (if UPLO = 'L').
          interface lasyf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clasyf(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: w(ldw,*)
               end subroutine clasyf
#else
               module procedure la_clasyf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasyf(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: w(ldw,*)
               end subroutine dlasyf
#else
               module procedure la_dlasyf
#endif
               module procedure la_qlasyf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasyf(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: w(ldw,*)
               end subroutine slasyf
#else
               module procedure la_slasyf
#endif
               module procedure la_wlasyf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlasyf(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: w(ldw,*)
               end subroutine zlasyf
#else
               module procedure la_zlasyf
#endif
          end interface lasyf

          !> DLATRF_AA factorizes a panel of a complex symmetric matrix A using
          !> the Aasen's algorithm. The panel consists of a set of NB rows of A
          !> when UPLO is U, or a set of NB columns when UPLO is L.
          !> In order to factorize the panel, the Aasen's algorithm requires the
          !> last row, or column, of the previous panel. The first row, or column,
          !> of A is set to be the first row, or column, of an identity matrix,
          !> which is used to factorize the first panel.
          !> The resulting J-th row of U, or J-th column of L, is stored in the
          !> (J-1)-th row, or column, of A (without the unit diagonals), while
          !> the diagonal and subdiagonal of A are overwritten by those of T.
          interface lasyf_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clasyf_aa(uplo,j1,m,nb,a,lda,ipiv,h,ldh,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp),intent(out) :: ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*),h(ldh,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine clasyf_aa
#else
               module procedure la_clasyf_aa
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasyf_aa(uplo,j1,m,nb,a,lda,ipiv,h,ldh,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp),intent(out) :: ipiv(*)
                    real(dp),intent(inout) :: a(lda,*),h(ldh,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dlasyf_aa
#else
               module procedure la_dlasyf_aa
#endif
               module procedure la_qlasyf_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasyf_aa(uplo,j1,m,nb,a,lda,ipiv,h,ldh,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp),intent(out) :: ipiv(*)
                    real(sp),intent(inout) :: a(lda,*),h(ldh,*)
                    real(sp),intent(out) :: work(*)
               end subroutine slasyf_aa
#else
               module procedure la_slasyf_aa
#endif
               module procedure la_wlasyf_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlasyf_aa(uplo,j1,m,nb,a,lda,ipiv,h,ldh,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp),intent(out) :: ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*),h(ldh,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zlasyf_aa
#else
               module procedure la_zlasyf_aa
#endif
          end interface lasyf_aa

          !> LASYF_RK: computes a partial factorization of a complex symmetric
          !> matrix A using the bounded Bunch-Kaufman (rook) diagonal
          !> pivoting method. The partial factorization has the form:
          !> A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !> ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
          !> A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
          !> ( L21  I ) (  0  A22 ) (  0       I    )
          !> where the order of D is at most NB. The actual order is returned in
          !> the argument KB, and is either NB or NB-1, or N if N <= NB.
          !> LASYF_RK is an auxiliary routine called by CSYTRF_RK. It uses
          !> blocked code (calling Level 3 BLAS) to update the submatrix
          !> A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
          interface lasyf_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clasyf_rk(uplo,n,nb,kb,a,lda,e,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: e(*),w(ldw,*)
               end subroutine clasyf_rk
#else
               module procedure la_clasyf_rk
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasyf_rk(uplo,n,nb,kb,a,lda,e,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: e(*),w(ldw,*)
               end subroutine dlasyf_rk
#else
               module procedure la_dlasyf_rk
#endif
               module procedure la_qlasyf_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasyf_rk(uplo,n,nb,kb,a,lda,e,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: e(*),w(ldw,*)
               end subroutine slasyf_rk
#else
               module procedure la_slasyf_rk
#endif
               module procedure la_wlasyf_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlasyf_rk(uplo,n,nb,kb,a,lda,e,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: e(*),w(ldw,*)
               end subroutine zlasyf_rk
#else
               module procedure la_zlasyf_rk
#endif
          end interface lasyf_rk

          !> LASYF_ROOK: computes a partial factorization of a complex symmetric
          !> matrix A using the bounded Bunch-Kaufman ("rook") diagonal
          !> pivoting method. The partial factorization has the form:
          !> A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !> ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
          !> A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
          !> ( L21  I ) (  0  A22 ) (  0       I    )
          !> where the order of D is at most NB. The actual order is returned in
          !> the argument KB, and is either NB or NB-1, or N if N <= NB.
          !> LASYF_ROOK is an auxiliary routine called by CSYTRF_ROOK. It uses
          !> blocked code (calling Level 3 BLAS) to update the submatrix
          !> A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
          interface lasyf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clasyf_rook(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: w(ldw,*)
               end subroutine clasyf_rook
#else
               module procedure la_clasyf_rook
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlasyf_rook(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: w(ldw,*)
               end subroutine dlasyf_rook
#else
               module procedure la_dlasyf_rook
#endif
               module procedure la_qlasyf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slasyf_rook(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: w(ldw,*)
               end subroutine slasyf_rook
#else
               module procedure la_slasyf_rook
#endif
               module procedure la_wlasyf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlasyf_rook(uplo,n,nb,kb,a,lda,ipiv,w,ldw,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,kb,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: w(ldw,*)
               end subroutine zlasyf_rook
#else
               module procedure la_zlasyf_rook
#endif
          end interface lasyf_rook

          !> LATBS: solves one of the triangular systems
          !> A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
          !> with scaling to prevent overflow, where A is an upper or lower
          !> triangular band matrix.  Here A**T denotes the transpose of A, x and b
          !> are n-element vectors, and s is a scaling factor, usually less than
          !> or equal to 1, chosen so that the components of x will be less than
          !> the overflow threshold.  If the unscaled problem will not cause
          !> overflow, the Level 2 BLAS routine CTBSV is called.  If the matrix A
          !> is singular (A(j,j) = 0 for some j), then s is set to 0 and a
          !> non-trivial solution to A*x = 0 is returned.
          interface latbs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clatbs(uplo,trans,diag,normin,n,kd,ab,ldab,x,scale,cnorm, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(out) :: scale
                    real(sp),intent(inout) :: cnorm(*)
                    complex(sp),intent(in) :: ab(ldab,*)
                    complex(sp),intent(inout) :: x(*)
               end subroutine clatbs
#else
               module procedure la_clatbs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlatbs(uplo,trans,diag,normin,n,kd,ab,ldab,x,scale,cnorm, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(out) :: scale
                    real(dp),intent(in) :: ab(ldab,*)
                    real(dp),intent(inout) :: cnorm(*),x(*)
               end subroutine dlatbs
#else
               module procedure la_dlatbs
#endif
               module procedure la_qlatbs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slatbs(uplo,trans,diag,normin,n,kd,ab,ldab,x,scale,cnorm, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(out) :: scale
                    real(sp),intent(in) :: ab(ldab,*)
                    real(sp),intent(inout) :: cnorm(*),x(*)
               end subroutine slatbs
#else
               module procedure la_slatbs
#endif
               module procedure la_wlatbs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlatbs(uplo,trans,diag,normin,n,kd,ab,ldab,x,scale,cnorm, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(out) :: scale
                    real(dp),intent(inout) :: cnorm(*)
                    complex(dp),intent(in) :: ab(ldab,*)
                    complex(dp),intent(inout) :: x(*)
               end subroutine zlatbs
#else
               module procedure la_zlatbs
#endif
          end interface latbs

          !> LATDF: computes the contribution to the reciprocal Dif-estimate
          !> by solving for x in Z * x = b, where b is chosen such that the norm
          !> of x is as large as possible. It is assumed that LU decomposition
          !> of Z has been computed by CGETC2. On entry RHS = f holds the
          !> contribution from earlier solved sub-systems, and on return RHS = x.
          !> The factorization of Z returned by CGETC2 has the form
          !> Z = P * L * U * Q, where P and Q are permutation matrices. L is lower
          !> triangular with unit diagonal elements and U is upper triangular.
          interface latdf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clatdf(ijob,n,z,ldz,rhs,rdsum,rdscal,ipiv,jpiv)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(sp),intent(inout) :: rdscal,rdsum
                    complex(sp),intent(inout) :: rhs(*),z(ldz,*)
               end subroutine clatdf
#else
               module procedure la_clatdf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlatdf(ijob,n,z,ldz,rhs,rdsum,rdscal,ipiv,jpiv)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(dp),intent(inout) :: rdscal,rdsum,rhs(*),z(ldz,*)
               end subroutine dlatdf
#else
               module procedure la_dlatdf
#endif
               module procedure la_qlatdf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slatdf(ijob,n,z,ldz,rhs,rdsum,rdscal,ipiv,jpiv)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(sp),intent(inout) :: rdscal,rdsum,rhs(*),z(ldz,*)
               end subroutine slatdf
#else
               module procedure la_slatdf
#endif
               module procedure la_wlatdf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlatdf(ijob,n,z,ldz,rhs,rdsum,rdscal,ipiv,jpiv)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(dp),intent(inout) :: rdscal,rdsum
                    complex(dp),intent(inout) :: rhs(*),z(ldz,*)
               end subroutine zlatdf
#else
               module procedure la_zlatdf
#endif
          end interface latdf

          !> LATPS: solves one of the triangular systems
          !> A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
          !> with scaling to prevent overflow, where A is an upper or lower
          !> triangular matrix stored in packed form.  Here A**T denotes the
          !> transpose of A, A**H denotes the conjugate transpose of A, x and b
          !> are n-element vectors, and s is a scaling factor, usually less than
          !> or equal to 1, chosen so that the components of x will be less than
          !> the overflow threshold.  If the unscaled problem will not cause
          !> overflow, the Level 2 BLAS routine CTPSV is called. If the matrix A
          !> is singular (A(j,j) = 0 for some j), then s is set to 0 and a
          !> non-trivial solution to A*x = 0 is returned.
          interface latps
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clatps(uplo,trans,diag,normin,n,ap,x,scale,cnorm,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: scale
                    real(sp),intent(inout) :: cnorm(*)
                    complex(sp),intent(in) :: ap(*)
                    complex(sp),intent(inout) :: x(*)
               end subroutine clatps
#else
               module procedure la_clatps
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlatps(uplo,trans,diag,normin,n,ap,x,scale,cnorm,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: scale
                    real(dp),intent(in) :: ap(*)
                    real(dp),intent(inout) :: cnorm(*),x(*)
               end subroutine dlatps
#else
               module procedure la_dlatps
#endif
               module procedure la_qlatps
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slatps(uplo,trans,diag,normin,n,ap,x,scale,cnorm,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: scale
                    real(sp),intent(in) :: ap(*)
                    real(sp),intent(inout) :: cnorm(*),x(*)
               end subroutine slatps
#else
               module procedure la_slatps
#endif
               module procedure la_wlatps
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlatps(uplo,trans,diag,normin,n,ap,x,scale,cnorm,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: scale
                    real(dp),intent(inout) :: cnorm(*)
                    complex(dp),intent(in) :: ap(*)
                    complex(dp),intent(inout) :: x(*)
               end subroutine zlatps
#else
               module procedure la_zlatps
#endif
          end interface latps

          !> LATRD: reduces NB rows and columns of a complex Hermitian matrix A to
          !> Hermitian tridiagonal form by a unitary similarity
          !> transformation Q**H * A * Q, and returns the matrices V and W which are
          !> needed to apply the transformation to the unreduced part of A.
          !> If UPLO = 'U', LATRD reduces the last NB rows and columns of a
          !> matrix, of which the upper triangle is supplied;
          !> if UPLO = 'L', LATRD reduces the first NB rows and columns of a
          !> matrix, of which the lower triangle is supplied.
          !> This is an auxiliary routine called by CHETRD.
          interface latrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clatrd(uplo,n,nb,a,lda,e,tau,w,ldw)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    real(sp),intent(out) :: e(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),w(ldw,*)
               end subroutine clatrd
#else
               module procedure la_clatrd
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlatrd(uplo,n,nb,a,lda,e,tau,w,ldw)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: e(*),tau(*),w(ldw,*)
               end subroutine dlatrd
#else
               module procedure la_dlatrd
#endif
               module procedure la_qlatrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slatrd(uplo,n,nb,a,lda,e,tau,w,ldw)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: e(*),tau(*),w(ldw,*)
               end subroutine slatrd
#else
               module procedure la_slatrd
#endif
               module procedure la_wlatrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlatrd(uplo,n,nb,a,lda,e,tau,w,ldw)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: lda,ldw,n,nb
                    real(dp),intent(out) :: e(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),w(ldw,*)
               end subroutine zlatrd
#else
               module procedure la_zlatrd
#endif
          end interface latrd

          !> LATRS: solves one of the triangular systems
          !> A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
          !> with scaling to prevent overflow.  Here A is an upper or lower
          !> triangular matrix, A**T denotes the transpose of A, A**H denotes the
          !> conjugate transpose of A, x and b are n-element vectors, and s is a
          !> scaling factor, usually less than or equal to 1, chosen so that the
          !> components of x will be less than the overflow threshold.  If the
          !> unscaled problem will not cause overflow, the Level 2 BLAS routine
          !> CTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
          !> then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
          interface latrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clatrs(uplo,trans,diag,normin,n,a,lda,x,scale,cnorm,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: scale
                    real(sp),intent(inout) :: cnorm(*)
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: x(*)
               end subroutine clatrs
#else
               module procedure la_clatrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlatrs(uplo,trans,diag,normin,n,a,lda,x,scale,cnorm,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: scale
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(inout) :: cnorm(*),x(*)
               end subroutine dlatrs
#else
               module procedure la_dlatrs
#endif
               module procedure la_qlatrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slatrs(uplo,trans,diag,normin,n,a,lda,x,scale,cnorm,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: scale
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(inout) :: cnorm(*),x(*)
               end subroutine slatrs
#else
               module procedure la_slatrs
#endif
               module procedure la_wlatrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlatrs(uplo,trans,diag,normin,n,a,lda,x,scale,cnorm,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,normin,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: scale
                    real(dp),intent(inout) :: cnorm(*)
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: x(*)
               end subroutine zlatrs
#else
               module procedure la_zlatrs
#endif
          end interface latrs

          !> LATRZ: factors the M-by-(M+L) complex upper trapezoidal matrix
          !> [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z by means
          !> of unitary transformations, where  Z is an (M+L)-by-(M+L) unitary
          !> matrix and, R and A1 are M-by-M upper triangular matrices.
          interface latrz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clatrz(m,n,l,a,lda,tau,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: l,lda,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),work(*)
               end subroutine clatrz
#else
               module procedure la_clatrz
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlatrz(m,n,l,a,lda,tau,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: l,lda,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: tau(*),work(*)
               end subroutine dlatrz
#else
               module procedure la_dlatrz
#endif
               module procedure la_qlatrz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slatrz(m,n,l,a,lda,tau,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: l,lda,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: tau(*),work(*)
               end subroutine slatrz
#else
               module procedure la_slatrz
#endif
               module procedure la_wlatrz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlatrz(m,n,l,a,lda,tau,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: l,lda,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),work(*)
               end subroutine zlatrz
#else
               module procedure la_zlatrz
#endif
          end interface latrz

          !> LATSQR: computes a blocked Tall-Skinny QR factorization of
          !> a complex M-by-N matrix A for M >= N:
          !> A = Q * ( R ),
          !> ( 0 )
          !> where:
          !> Q is a M-by-M orthogonal matrix, stored on exit in an implicit
          !> form in the elements below the diagonal of the array A and in
          !> the elements of the array T;
          !> R is an upper-triangular N-by-N matrix, stored on exit in
          !> the elements on and above the diagonal of the array A.
          !> 0 is a (M-N)-by-N zero matrix, and is not stored.
          interface latsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clatsqr(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*),t(ldt,*)
               end subroutine clatsqr
#else
               module procedure la_clatsqr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlatsqr(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: work(*),t(ldt,*)
               end subroutine dlatsqr
#else
               module procedure la_dlatsqr
#endif
               module procedure la_qlatsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slatsqr(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: work(*),t(ldt,*)
               end subroutine slatsqr
#else
               module procedure la_slatsqr
#endif
               module procedure la_wlatsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlatsqr(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*),t(ldt,*)
               end subroutine zlatsqr
#else
               module procedure la_zlatsqr
#endif
          end interface latsqr

          !> LAUNHR_COL_GETRFNP: computes the modified LU factorization without
          !> pivoting of a complex general M-by-N matrix A. The factorization has
          !> the form:
          !> A - S = L * U,
          !> where:
          !> S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !> D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !> as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !> i-1 steps of Gaussian elimination. This means that the diagonal
          !> element at each step of "modified" Gaussian elimination is
          !> at least one in absolute value (so that division-by-zero not
          !> not possible during the division by the diagonal element);
          !> L is a M-by-N lower triangular matrix with unit diagonal elements
          !> (lower trapezoidal if M > N);
          !> and U is a M-by-N upper triangular matrix
          !> (upper trapezoidal if M < N).
          !> This routine is an auxiliary routine used in the Householder
          !> reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
          !> applied to an M-by-N matrix A with orthonormal columns, where each
          !> element is bounded by one in absolute value. With the choice of
          !> the matrix S above, one can show that the diagonal element at each
          !> step of Gaussian elimination is the largest (in absolute value) in
          !> the column on or below the diagonal, so that no pivoting is required
          !> for numerical stability [1].
          !> For more details on the Householder reconstruction algorithm,
          !> including the modified LU factorization, see [1].
          !> This is the blocked right-looking version of the algorithm,
          !> calling Level 3 BLAS to update the submatrix. To factorize a block,
          !> this routine calls the recursive routine LAUNHR_COL_GETRFNP2.
          !> [1] "Reconstructing Householder vectors from tall-skinny QR",
          !> G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !> E. Solomonik, J. Parallel Distrib. Comput.,
          !> vol. 85, pp. 3-31, 2015.
          interface launhr_col_getrfnp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine claunhr_col_getrfnp(m,n,a,lda,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: d(*)
               end subroutine claunhr_col_getrfnp
#else
               module procedure la_claunhr_col_getrfnp
#endif
               module procedure la_wlaunhr_col_getrfnp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlaunhr_col_getrfnp(m,n,a,lda,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: d(*)
               end subroutine zlaunhr_col_getrfnp
#else
               module procedure la_zlaunhr_col_getrfnp
#endif
          end interface launhr_col_getrfnp

          !> LAUNHR_COL_GETRFNP2: computes the modified LU factorization without
          !> pivoting of a complex general M-by-N matrix A. The factorization has
          !> the form:
          !> A - S = L * U,
          !> where:
          !> S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !> D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !> as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !> i-1 steps of Gaussian elimination. This means that the diagonal
          !> element at each step of "modified" Gaussian elimination is at
          !> least one in absolute value (so that division-by-zero not
          !> possible during the division by the diagonal element);
          !> L is a M-by-N lower triangular matrix with unit diagonal elements
          !> (lower trapezoidal if M > N);
          !> and U is a M-by-N upper triangular matrix
          !> (upper trapezoidal if M < N).
          !> This routine is an auxiliary routine used in the Householder
          !> reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
          !> applied to an M-by-N matrix A with orthonormal columns, where each
          !> element is bounded by one in absolute value. With the choice of
          !> the matrix S above, one can show that the diagonal element at each
          !> step of Gaussian elimination is the largest (in absolute value) in
          !> the column on or below the diagonal, so that no pivoting is required
          !> for numerical stability [1].
          !> For more details on the Householder reconstruction algorithm,
          !> including the modified LU factorization, see [1].
          !> This is the recursive version of the LU factorization algorithm.
          !> Denote A - S by B. The algorithm divides the matrix B into four
          !> submatrices:
          !> [  B11 | B12  ]  where B11 is n1 by n1,
          !> B = [ -----|----- ]        B21 is (m-n1) by n1,
          !> [  B21 | B22  ]        B12 is n1 by n2,
          !> B22 is (m-n1) by n2,
          !> with n1 = min(m,n)/2, n2 = n-n1.
          !> The subroutine calls itself to factor B11, solves for B21,
          !> solves for B12, updates B22, then calls itself to factor B22.
          !> For more details on the recursive LU algorithm, see [2].
          !> LAUNHR_COL_GETRFNP2 is called to factorize a block by the blocked
          !> routine CLAUNHR_COL_GETRFNP, which uses blocked code calling
          !> Level 3 BLAS to update the submatrix. However, LAUNHR_COL_GETRFNP2
          !> is self-sufficient and can be used without CLAUNHR_COL_GETRFNP.
          !> [1] "Reconstructing Householder vectors from tall-skinny QR",
          !> G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !> E. Solomonik, J. Parallel Distrib. Comput.,
          !> vol. 85, pp. 3-31, 2015.
          !> [2] "Recursion leads to automatic variable blocking for dense linear
          !> algebra algorithms", F. Gustavson, IBM J. of Res. and Dev.,
          !> vol. 41, no. 6, pp. 737-755, 1997.
          interface launhr_col_getrfnp2
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine claunhr_col_getrfnp2(m,n,a,lda,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: d(*)
               end subroutine claunhr_col_getrfnp2
#else
               module procedure la_claunhr_col_getrfnp2
#endif
               module procedure la_wlaunhr_col_getrfnp2
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine zlaunhr_col_getrfnp2(m,n,a,lda,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: d(*)
               end subroutine zlaunhr_col_getrfnp2
#else
               module procedure la_zlaunhr_col_getrfnp2
#endif
          end interface launhr_col_getrfnp2

          !> LAUUM: computes the product U * U**H or L**H * L, where the triangular
          !> factor U or L is stored in the upper or lower triangular part of
          !> the array A.
          !> If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
          !> overwriting the factor U in A.
          !> If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
          !> overwriting the factor L in A.
          !> This is the blocked form of the algorithm, calling Level 3 BLAS.
          interface lauum
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine clauum(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine clauum
#else
               module procedure la_clauum
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dlauum(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dlauum
#else
               module procedure la_dlauum
#endif
               module procedure la_qlauum
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine slauum(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine slauum
#else
               module procedure la_slauum
#endif
               module procedure la_wlauum
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zlauum(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zlauum
#else
               module procedure la_zlauum
#endif
          end interface lauum

          !> OPGTR: generates a real orthogonal matrix Q which is defined as the
          !> product of n-1 elementary reflectors H(i) of order n, as returned by
          !> DSPTRD using packed storage:
          !> if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !> if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
          interface opgtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dopgtr(uplo,n,ap,tau,q,ldq,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldq,n
                    real(dp),intent(in) :: ap(*),tau(*)
                    real(dp),intent(out) :: q(ldq,*),work(*)
               end subroutine dopgtr
#else
               module procedure la_dopgtr
#endif
               module procedure la_qopgtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sopgtr(uplo,n,ap,tau,q,ldq,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldq,n
                    real(sp),intent(in) :: ap(*),tau(*)
                    real(sp),intent(out) :: q(ldq,*),work(*)
               end subroutine sopgtr
#else
               module procedure la_sopgtr
#endif
          end interface opgtr

          !> OPMTR: overwrites the general real M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**T * C       C * Q**T
          !> where Q is a real orthogonal matrix of order nq, with nq = m if
          !> SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !> nq-1 elementary reflectors, as returned by DSPTRD using packed
          !> storage:
          !> if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !> if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
          interface opmtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dopmtr(side,uplo,trans,m,n,ap,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldc,m,n
                    real(dp),intent(inout) :: ap(*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dopmtr
#else
               module procedure la_dopmtr
#endif
               module procedure la_qopmtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sopmtr(side,uplo,trans,m,n,ap,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldc,m,n
                    real(sp),intent(inout) :: ap(*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sopmtr
#else
               module procedure la_sopmtr
#endif
          end interface opmtr

          !> ORBDB: simultaneously bidiagonalizes the blocks of an M-by-M
          !> partitioned orthogonal matrix X:
          !> [ B11 | B12 0  0 ]
          !> [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**T
          !> X = [-----------] = [---------] [----------------] [---------]   .
          !> [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]
          !> [  0  |  0  0  I ]
          !> X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
          !> not the case, then X must be transposed and/or permuted. This can be
          !> done in constant time using the TRANS and SIGNS options. See DORCSD
          !> for details.)
          !> The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
          !> (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
          !> represented implicitly by Householder vectors.
          !> B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
          !> implicitly by angles THETA, PHI.
          interface orbdb
#ifdef LA_EXTERNAL_LAPACK
               subroutine dorbdb(trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22, &
                         ldx22,theta,phi,taup1,taup2,tauq1,tauq2,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: signs,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(dp),intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),tauq2(*), &
                              work(*)
                    real(dp),intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)
                              
               end subroutine dorbdb
#else
               module procedure la_dorbdb
#endif
               module procedure la_qorbdb
#ifdef LA_EXTERNAL_LAPACK
               subroutine sorbdb(trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22, &
                         ldx22,theta,phi,taup1,taup2,tauq1,tauq2,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: signs,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(sp),intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),tauq2(*), &
                              work(*)
                    real(sp),intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)
                              
               end subroutine sorbdb
#else
               module procedure la_sorbdb
#endif
          end interface orbdb

          !> ORBDB1: simultaneously bidiagonalizes the blocks of a tall and skinny
          !> matrix X with orthonomal columns:
          !> [ B11 ]
          !> [ X11 ]   [ P1 |    ] [  0  ]
          !> [-----] = [---------] [-----] Q1**T .
          !> [ X21 ]   [    | P2 ] [ B21 ]
          !> [  0  ]
          !> X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P,
          !> M-P, or M-Q. Routines DORBDB2, DORBDB3, and DORBDB4 handle cases in
          !> which Q is not the minimum dimension.
          !> The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !> and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !> Householder vectors.
          !> B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by
          !> angles THETA, PHI.
          interface orbdb1
#ifdef LA_EXTERNAL_LAPACK
               subroutine dorbdb1(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp),intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(dp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb1
#else
               module procedure la_dorbdb1
#endif
               module procedure la_qorbdb1
#ifdef LA_EXTERNAL_LAPACK
               subroutine sorbdb1(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp),intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(sp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb1
#else
               module procedure la_sorbdb1
#endif
          end interface orbdb1

          !> ORBDB2: simultaneously bidiagonalizes the blocks of a tall and skinny
          !> matrix X with orthonomal columns:
          !> [ B11 ]
          !> [ X11 ]   [ P1 |    ] [  0  ]
          !> [-----] = [---------] [-----] Q1**T .
          !> [ X21 ]   [    | P2 ] [ B21 ]
          !> [  0  ]
          !> X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P,
          !> Q, or M-Q. Routines DORBDB1, DORBDB3, and DORBDB4 handle cases in
          !> which P is not the minimum dimension.
          !> The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !> and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !> Householder vectors.
          !> B11 and B12 are P-by-P bidiagonal matrices represented implicitly by
          !> angles THETA, PHI.
          interface orbdb2
#ifdef LA_EXTERNAL_LAPACK
               subroutine dorbdb2(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp),intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(dp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb2
#else
               module procedure la_dorbdb2
#endif
               module procedure la_qorbdb2
#ifdef LA_EXTERNAL_LAPACK
               subroutine sorbdb2(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp),intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(sp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb2
#else
               module procedure la_sorbdb2
#endif
          end interface orbdb2

          !> ORBDB3: simultaneously bidiagonalizes the blocks of a tall and skinny
          !> matrix X with orthonomal columns:
          !> [ B11 ]
          !> [ X11 ]   [ P1 |    ] [  0  ]
          !> [-----] = [---------] [-----] Q1**T .
          !> [ X21 ]   [    | P2 ] [ B21 ]
          !> [  0  ]
          !> X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P,
          !> Q, or M-Q. Routines DORBDB1, DORBDB2, and DORBDB4 handle cases in
          !> which M-P is not the minimum dimension.
          !> The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !> and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !> Householder vectors.
          !> B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented
          !> implicitly by angles THETA, PHI.
          interface orbdb3
#ifdef LA_EXTERNAL_LAPACK
               subroutine dorbdb3(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp),intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(dp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb3
#else
               module procedure la_dorbdb3
#endif
               module procedure la_qorbdb3
#ifdef LA_EXTERNAL_LAPACK
               subroutine sorbdb3(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp),intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(sp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb3
#else
               module procedure la_sorbdb3
#endif
          end interface orbdb3

          !> ORBDB4: simultaneously bidiagonalizes the blocks of a tall and skinny
          !> matrix X with orthonomal columns:
          !> [ B11 ]
          !> [ X11 ]   [ P1 |    ] [  0  ]
          !> [-----] = [---------] [-----] Q1**T .
          !> [ X21 ]   [    | P2 ] [ B21 ]
          !> [  0  ]
          !> X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P,
          !> M-P, or Q. Routines DORBDB1, DORBDB2, and DORBDB3 handle cases in
          !> which M-Q is not the minimum dimension.
          !> The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !> and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !> Householder vectors.
          !> B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented
          !> implicitly by angles THETA, PHI.
          interface orbdb4
#ifdef LA_EXTERNAL_LAPACK
               subroutine dorbdb4(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,phantom,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp),intent(out) :: phi(*),theta(*),phantom(*),taup1(*),taup2(*),tauq1(*) &
                              ,work(*)
                    real(dp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb4
#else
               module procedure la_dorbdb4
#endif
               module procedure la_qorbdb4
#ifdef LA_EXTERNAL_LAPACK
               subroutine sorbdb4(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,phantom,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp),intent(out) :: phi(*),theta(*),phantom(*),taup1(*),taup2(*),tauq1(*) &
                              ,work(*)
                    real(sp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb4
#else
               module procedure la_sorbdb4
#endif
          end interface orbdb4

          !> ORBDB5: orthogonalizes the column vector
          !> X = [ X1 ]
          !> [ X2 ]
          !> with respect to the columns of
          !> Q = [ Q1 ] .
          !> [ Q2 ]
          !> The columns of Q must be orthonormal.
          !> If the projection is zero according to Kahan's "twice is enough"
          !> criterion, then some other vector from the orthogonal complement
          !> is returned. This vector is chosen in an arbitrary but deterministic
          !> way.
          interface orbdb5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorbdb5(m1,m2,n,x1,incx1,x2,incx2,q1,ldq1,q2,ldq2,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(dp),intent(out) :: work(*)
                    real(dp),intent(inout) :: x1(*),x2(*)
               end subroutine dorbdb5
#else
               module procedure la_dorbdb5
#endif
               module procedure la_qorbdb5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorbdb5(m1,m2,n,x1,incx1,x2,incx2,q1,ldq1,q2,ldq2,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(sp),intent(out) :: work(*)
                    real(sp),intent(inout) :: x1(*),x2(*)
               end subroutine sorbdb5
#else
               module procedure la_sorbdb5
#endif
          end interface orbdb5

          !> ORBDB6: orthogonalizes the column vector
          !> X = [ X1 ]
          !> [ X2 ]
          !> with respect to the columns of
          !> Q = [ Q1 ] .
          !> [ Q2 ]
          !> The columns of Q must be orthonormal.
          !> If the projection is zero according to Kahan's "twice is enough"
          !> criterion, then the zero vector is returned.
          interface orbdb6
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorbdb6(m1,m2,n,x1,incx1,x2,incx2,q1,ldq1,q2,ldq2,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(dp),intent(out) :: work(*)
                    real(dp),intent(inout) :: x1(*),x2(*)
               end subroutine dorbdb6
#else
               module procedure la_dorbdb6
#endif
               module procedure la_qorbdb6
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorbdb6(m1,m2,n,x1,incx1,x2,incx2,q1,ldq1,q2,ldq2,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(sp),intent(out) :: work(*)
                    real(sp),intent(inout) :: x1(*),x2(*)
               end subroutine sorbdb6
#else
               module procedure la_sorbdb6
#endif
          end interface orbdb6

          !> ORCSD: computes the CS decomposition of an M-by-M partitioned
          !> orthogonal matrix X:
          !> [  I  0  0 |  0  0  0 ]
          !> [  0  C  0 |  0 -S  0 ]
          !> [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**T
          !> X = [-----------] = [---------] [---------------------] [---------]   .
          !> [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]
          !> [  0  S  0 |  0  C  0 ]
          !> [  0  0  I |  0  0  0 ]
          !> X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,
          !> (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
          !> R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
          !> which R = MIN(P,M-P,Q,M-Q).
          interface orcsd
#ifdef LA_EXTERNAL_LAPACK
               recursive subroutine dorcsd(jobu1,jobu2,jobv1t,jobv2t,trans,signs,m,p,q, &
               x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t, &
                         ldv1t,v2t,ldv2t,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22, &
                              lwork,m,p,q
                    real(dp),intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t( &
                              ldv2t,*),work(*)
                    real(dp),intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)
                              
               end subroutine dorcsd
#else
               module procedure la_dorcsd
#endif
               module procedure la_qorcsd
#ifdef LA_EXTERNAL_LAPACK
               recursive subroutine sorcsd(jobu1,jobu2,jobv1t,jobv2t,trans,signs,m,p,q, &
               x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t, &
                         ldv1t,v2t,ldv2t,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22, &
                              lwork,m,p,q
                    real(sp),intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t( &
                              ldv2t,*),work(*)
                    real(sp),intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)
                              
               end subroutine sorcsd
#else
               module procedure la_sorcsd
#endif
          end interface orcsd

          !> ORCSD2BY1: computes the CS decomposition of an M-by-Q matrix X with
          !> orthonormal columns that has been partitioned into a 2-by-1 block
          !> structure:
          !> [  I1 0  0 ]
          !> [  0  C  0 ]
          !> [ X11 ]   [ U1 |    ] [  0  0  0 ]
          !> X = [-----] = [---------] [----------] V1**T .
          !> [ X21 ]   [    | U2 ] [  0  0  0 ]
          !> [  0  S  0 ]
          !> [  0  0  I2]
          !> X11 is P-by-Q. The orthogonal matrices U1, U2, and V1 are P-by-P,
          !> (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R
          !> nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which
          !> R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a
          !> K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).
          interface orcsd2by1
#ifdef LA_EXTERNAL_LAPACK
               subroutine dorcsd2by1(jobu1,jobu2,jobv1t,m,p,q,x11,ldx11,x21,ldx21,theta, &
                          u1,ldu1,u2,ldu2,v1t,ldv1t,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q
                    real(dp),intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                              
                    real(dp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorcsd2by1
#else
               module procedure la_dorcsd2by1
#endif
               module procedure la_qorcsd2by1
#ifdef LA_EXTERNAL_LAPACK
               subroutine sorcsd2by1(jobu1,jobu2,jobv1t,m,p,q,x11,ldx11,x21,ldx21,theta, &
                          u1,ldu1,u2,ldu2,v1t,ldv1t,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q
                    real(sp),intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                              
                    real(sp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorcsd2by1
#else
               module procedure la_sorcsd2by1
#endif
          end interface orcsd2by1

          !> ORG2L: generates an m by n real matrix Q with orthonormal columns,
          !> which is defined as the last n columns of a product of k elementary
          !> reflectors of order m
          !> Q  =  H(k) . . . H(2) H(1)
          !> as returned by DGEQLF.
          interface org2l
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorg2l(m,n,k,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorg2l
#else
               module procedure la_dorg2l
#endif
               module procedure la_qorg2l
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorg2l(m,n,k,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorg2l
#else
               module procedure la_sorg2l
#endif
          end interface org2l

          !> ORG2R: generates an m by n real matrix Q with orthonormal columns,
          !> which is defined as the first n columns of a product of k elementary
          !> reflectors of order m
          !> Q  =  H(1) H(2) . . . H(k)
          !> as returned by DGEQRF.
          interface org2r
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorg2r(m,n,k,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorg2r
#else
               module procedure la_dorg2r
#endif
               module procedure la_qorg2r
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorg2r(m,n,k,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorg2r
#else
               module procedure la_sorg2r
#endif
          end interface org2r

          !> ORGBR: generates one of the real orthogonal matrices Q or P**T
          !> determined by DGEBRD when reducing a real matrix A to bidiagonal
          !> form: A = Q * B * P**T.  Q and P**T are defined as products of
          !> elementary reflectors H(i) or G(i) respectively.
          !> If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
          !> is of order M:
          !> if m >= k, Q = H(1) H(2) . . . H(k) and ORGBR returns the first n
          !> columns of Q, where m >= n >= k;
          !> if m < k, Q = H(1) H(2) . . . H(m-1) and ORGBR returns Q as an
          !> M-by-M matrix.
          !> If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
          !> is of order N:
          !> if k < n, P**T = G(k) . . . G(2) G(1) and ORGBR returns the first m
          !> rows of P**T, where n >= m >= k;
          !> if k >= n, P**T = G(n-1) . . . G(2) G(1) and ORGBR returns P**T as
          !> an N-by-N matrix.
          interface orgbr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorgbr(vect,m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorgbr
#else
               module procedure la_dorgbr
#endif
               module procedure la_qorgbr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorgbr(vect,m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorgbr
#else
               module procedure la_sorgbr
#endif
          end interface orgbr

          !> ORGHR: generates a real orthogonal matrix Q which is defined as the
          !> product of IHI-ILO elementary reflectors of order N, as returned by
          !> DGEHRD:
          !> Q = H(ilo) H(ilo+1) . . . H(ihi-1).
          interface orghr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorghr(n,ilo,ihi,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorghr
#else
               module procedure la_dorghr
#endif
               module procedure la_qorghr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorghr(n,ilo,ihi,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorghr
#else
               module procedure la_sorghr
#endif
          end interface orghr

          !> ORGLQ: generates an M-by-N real matrix Q with orthonormal rows,
          !> which is defined as the first M rows of a product of K elementary
          !> reflectors of order N
          !> Q  =  H(k) . . . H(2) H(1)
          !> as returned by DGELQF.
          interface orglq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorglq(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorglq
#else
               module procedure la_dorglq
#endif
               module procedure la_qorglq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorglq(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorglq
#else
               module procedure la_sorglq
#endif
          end interface orglq

          !> ORGQL: generates an M-by-N real matrix Q with orthonormal columns,
          !> which is defined as the last N columns of a product of K elementary
          !> reflectors of order M
          !> Q  =  H(k) . . . H(2) H(1)
          !> as returned by DGEQLF.
          interface orgql
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorgql(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorgql
#else
               module procedure la_dorgql
#endif
               module procedure la_qorgql
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorgql(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorgql
#else
               module procedure la_sorgql
#endif
          end interface orgql

          !> ORGQR: generates an M-by-N real matrix Q with orthonormal columns,
          !> which is defined as the first N columns of a product of K elementary
          !> reflectors of order M
          !> Q  =  H(1) H(2) . . . H(k)
          !> as returned by GEQRF.
          interface orgqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorgqr(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorgqr
#else
               module procedure la_dorgqr
#endif
               module procedure la_qorgqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorgqr(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorgqr
#else
               module procedure la_sorgqr
#endif
          end interface orgqr

          !> ORGRQ: generates an M-by-N real matrix Q with orthonormal rows,
          !> which is defined as the last M rows of a product of K elementary
          !> reflectors of order N
          !> Q  =  H(1) H(2) . . . H(k)
          !> as returned by DGERQF.
          interface orgrq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorgrq(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorgrq
#else
               module procedure la_dorgrq
#endif
               module procedure la_qorgrq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorgrq(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorgrq
#else
               module procedure la_sorgrq
#endif
          end interface orgrq

          !> ORGTR: generates a real orthogonal matrix Q which is defined as the
          !> product of n-1 elementary reflectors of order N, as returned by
          !> DSYTRD:
          !> if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !> if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
          interface orgtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorgtr(uplo,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorgtr
#else
               module procedure la_dorgtr
#endif
               module procedure la_qorgtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorgtr(uplo,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorgtr
#else
               module procedure la_sorgtr
#endif
          end interface orgtr

          !> ORGTSQR: generates an M-by-N real matrix Q_out with orthonormal columns,
          !> which are the first N columns of a product of real orthogonal
          !> matrices of order M which are returned by DLATSQR
          !> Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !> See the documentation for DLATSQR.
          interface orgtsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorgtsqr(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: t(ldt,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorgtsqr
#else
               module procedure la_dorgtsqr
#endif
               module procedure la_qorgtsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorgtsqr(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: t(ldt,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorgtsqr
#else
               module procedure la_sorgtsqr
#endif
          end interface orgtsqr

          !> ORGTSQR_ROW: generates an M-by-N real matrix Q_out with
          !> orthonormal columns from the output of DLATSQR. These N orthonormal
          !> columns are the first N columns of a product of complex unitary
          !> matrices Q(k)_in of order M, which are returned by DLATSQR in
          !> a special format.
          !> Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !> The input matrices Q(k)_in are stored in row and column blocks in A.
          !> See the documentation of DLATSQR for more details on the format of
          !> Q(k)_in, where each Q(k)_in is represented by block Householder
          !> transformations. This routine calls an auxiliary routine DLARFB_GETT,
          !> where the computation is performed on each individual block. The
          !> algorithm first sweeps NB-sized column blocks from the right to left
          !> starting in the bottom row block and continues to the top row block
          !> (hence _ROW in the routine name). This sweep is in reverse order of
          !> the order in which DLATSQR generates the output blocks.
          interface orgtsqr_row
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorgtsqr_row(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: t(ldt,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorgtsqr_row
#else
               module procedure la_dorgtsqr_row
#endif
               module procedure la_qorgtsqr_row
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorgtsqr_row(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: t(ldt,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorgtsqr_row
#else
               module procedure la_sorgtsqr_row
#endif
          end interface orgtsqr_row

          !> ORHR_COL: takes an M-by-N real matrix Q_in with orthonormal columns
          !> as input, stored in A, and performs Householder Reconstruction (HR),
          !> i.e. reconstructs Householder vectors V(i) implicitly representing
          !> another M-by-N matrix Q_out, with the property that Q_in = Q_out*S,
          !> where S is an N-by-N diagonal matrix with diagonal entries
          !> equal to +1 or -1. The Householder vectors (columns V(i) of V) are
          !> stored in A on output, and the diagonal entries of S are stored in D.
          !> Block reflectors are also returned in T
          !> (same output format as DGEQRT).
          interface orhr_col
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorhr_col(m,n,nb,a,lda,t,ldt,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,nb
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: d(*),t(ldt,*)
               end subroutine dorhr_col
#else
               module procedure la_dorhr_col
#endif
               module procedure la_qorhr_col
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorhr_col(m,n,nb,a,lda,t,ldt,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,nb
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: d(*),t(ldt,*)
               end subroutine sorhr_col
#else
               module procedure la_sorhr_col
#endif
          end interface orhr_col

          !> ORM2L: overwrites the general real m by n matrix C with
          !> Q * C  if SIDE = 'L' and TRANS = 'N', or
          !> Q**T * C  if SIDE = 'L' and TRANS = 'T', or
          !> C * Q  if SIDE = 'R' and TRANS = 'N', or
          !> C * Q**T if SIDE = 'R' and TRANS = 'T',
          !> where Q is a real orthogonal matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(k) . . . H(2) H(1)
          !> as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n
          !> if SIDE = 'R'.
          interface orm2l
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorm2l(side,trans,m,n,k,a,lda,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,m,n
                    real(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorm2l
#else
               module procedure la_dorm2l
#endif
               module procedure la_qorm2l
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorm2l(side,trans,m,n,k,a,lda,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,m,n
                    real(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorm2l
#else
               module procedure la_sorm2l
#endif
          end interface orm2l

          !> ORM2R: overwrites the general real m by n matrix C with
          !> Q * C  if SIDE = 'L' and TRANS = 'N', or
          !> Q**T* C  if SIDE = 'L' and TRANS = 'T', or
          !> C * Q  if SIDE = 'R' and TRANS = 'N', or
          !> C * Q**T if SIDE = 'R' and TRANS = 'T',
          !> where Q is a real orthogonal matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(1) H(2) . . . H(k)
          !> as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n
          !> if SIDE = 'R'.
          interface orm2r
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dorm2r(side,trans,m,n,k,a,lda,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,m,n
                    real(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dorm2r
#else
               module procedure la_dorm2r
#endif
               module procedure la_qorm2r
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sorm2r(side,trans,m,n,k,a,lda,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,m,n
                    real(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sorm2r
#else
               module procedure la_sorm2r
#endif
          end interface orm2r

          !> If VECT = 'Q', ORMBR: overwrites the general real M-by-N matrix C
          !> with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**T * C       C * Q**T
          !> If VECT = 'P', ORMBR overwrites the general real M-by-N matrix C
          !> with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      P * C          C * P
          !> TRANS = 'T':      P**T * C       C * P**T
          !> Here Q and P**T are the orthogonal matrices determined by DGEBRD when
          !> reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
          !> P**T are defined as products of elementary reflectors H(i) and G(i)
          !> respectively.
          !> Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
          !> order of the orthogonal matrix Q or P**T that is applied.
          !> If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
          !> if nq >= k, Q = H(1) H(2) . . . H(k);
          !> if nq < k, Q = H(1) H(2) . . . H(nq-1).
          !> If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
          !> if k < nq, P = G(1) G(2) . . . G(k);
          !> if k >= nq, P = G(1) G(2) . . . G(nq-1).
          interface ormbr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dormbr(vect,side,trans,m,n,k,a,lda,tau,c,ldc,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dormbr
#else
               module procedure la_dormbr
#endif
               module procedure la_qormbr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sormbr(vect,side,trans,m,n,k,a,lda,tau,c,ldc,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sormbr
#else
               module procedure la_sormbr
#endif
          end interface ormbr

          !> ORMHR: overwrites the general real M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**T * C       C * Q**T
          !> where Q is a real orthogonal matrix of order nq, with nq = m if
          !> SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !> IHI-ILO elementary reflectors, as returned by DGEHRD:
          !> Q = H(ilo) H(ilo+1) . . . H(ihi-1).
          interface ormhr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dormhr(side,trans,m,n,ilo,ihi,a,lda,tau,c,ldc,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dormhr
#else
               module procedure la_dormhr
#endif
               module procedure la_qormhr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sormhr(side,trans,m,n,ilo,ihi,a,lda,tau,c,ldc,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sormhr
#else
               module procedure la_sormhr
#endif
          end interface ormhr

          !> ORMLQ: overwrites the general real M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**T * C       C * Q**T
          !> where Q is a real orthogonal matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(k) . . . H(2) H(1)
          !> as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
          !> if SIDE = 'R'.
          interface ormlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dormlq(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dormlq
#else
               module procedure la_dormlq
#endif
               module procedure la_qormlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sormlq(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sormlq
#else
               module procedure la_sormlq
#endif
          end interface ormlq

          !> ORMQL: overwrites the general real M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**T * C       C * Q**T
          !> where Q is a real orthogonal matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(k) . . . H(2) H(1)
          !> as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
          !> if SIDE = 'R'.
          interface ormql
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dormql(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dormql
#else
               module procedure la_dormql
#endif
               module procedure la_qormql
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sormql(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sormql
#else
               module procedure la_sormql
#endif
          end interface ormql

          !> ORMQR: overwrites the general real M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**T * C       C * Q**T
          !> where Q is a real orthogonal matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(1) H(2) . . . H(k)
          !> as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
          !> if SIDE = 'R'.
          interface ormqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dormqr
#else
               module procedure la_dormqr
#endif
               module procedure la_qormqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sormqr
#else
               module procedure la_sormqr
#endif
          end interface ormqr

          !> ORMRQ: overwrites the general real M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**T * C       C * Q**T
          !> where Q is a real orthogonal matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(1) H(2) . . . H(k)
          !> as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
          !> if SIDE = 'R'.
          interface ormrq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dormrq(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dormrq
#else
               module procedure la_dormrq
#endif
               module procedure la_qormrq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sormrq(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sormrq
#else
               module procedure la_sormrq
#endif
          end interface ormrq

          !> ORMRZ: overwrites the general real M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**T * C       C * Q**T
          !> where Q is a real orthogonal matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(1) H(2) . . . H(k)
          !> as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N
          !> if SIDE = 'R'.
          interface ormrz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dormrz(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,l,lda,ldc,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dormrz
#else
               module procedure la_dormrz
#endif
               module procedure la_qormrz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sormrz(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,l,lda,ldc,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sormrz
#else
               module procedure la_sormrz
#endif
          end interface ormrz

          !> ORMTR: overwrites the general real M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'T':      Q**T * C       C * Q**T
          !> where Q is a real orthogonal matrix of order nq, with nq = m if
          !> SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !> nq-1 elementary reflectors, as returned by DSYTRD:
          !> if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !> if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
          interface ormtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dormtr(side,uplo,trans,m,n,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldc,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp),intent(in) :: tau(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dormtr
#else
               module procedure la_dormtr
#endif
               module procedure la_qormtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sormtr(side,uplo,trans,m,n,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldc,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp),intent(in) :: tau(*)
                    real(sp),intent(out) :: work(*)
               end subroutine sormtr
#else
               module procedure la_sormtr
#endif
          end interface ormtr

          !> PBCON: estimates the reciprocal of the condition number (in the
          !> 1-norm) of a complex Hermitian positive definite band matrix using
          !> the Cholesky factorization A = U**H*U or A = L*L**H computed by
          !> CPBTRF.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
          interface pbcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpbcon(uplo,n,kd,ab,ldab,anorm,rcond,work,rwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond,rwork(*)
                    complex(sp),intent(in) :: ab(ldab,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cpbcon
#else
               module procedure la_cpbcon
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpbcon(uplo,n,kd,ab,ldab,anorm,rcond,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(in) :: anorm,ab(ldab,*)
                    real(dp),intent(out) :: rcond,work(*)
               end subroutine dpbcon
#else
               module procedure la_dpbcon
#endif
               module procedure la_qpbcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spbcon(uplo,n,kd,ab,ldab,anorm,rcond,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(in) :: anorm,ab(ldab,*)
                    real(sp),intent(out) :: rcond,work(*)
               end subroutine spbcon
#else
               module procedure la_spbcon
#endif
               module procedure la_wpbcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpbcon(uplo,n,kd,ab,ldab,anorm,rcond,work,rwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond,rwork(*)
                    complex(dp),intent(in) :: ab(ldab,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zpbcon
#else
               module procedure la_zpbcon
#endif
          end interface pbcon

          !> PBEQU: computes row and column scalings intended to equilibrate a
          !> Hermitian positive definite band matrix A and reduce its condition
          !> number (with respect to the two-norm).  S contains the scale factors,
          !> S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
          !> elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
          !> choice of S puts the condition number of B within a factor N of the
          !> smallest possible condition number over all possible diagonal
          !> scalings.
          interface pbequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpbequ(uplo,n,kd,ab,ldab,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(out) :: amax,scond,s(*)
                    complex(sp),intent(in) :: ab(ldab,*)
               end subroutine cpbequ
#else
               module procedure la_cpbequ
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpbequ(uplo,n,kd,ab,ldab,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(out) :: amax,scond,s(*)
                    real(dp),intent(in) :: ab(ldab,*)
               end subroutine dpbequ
#else
               module procedure la_dpbequ
#endif
               module procedure la_qpbequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spbequ(uplo,n,kd,ab,ldab,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(out) :: amax,scond,s(*)
                    real(sp),intent(in) :: ab(ldab,*)
               end subroutine spbequ
#else
               module procedure la_spbequ
#endif
               module procedure la_wpbequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpbequ(uplo,n,kd,ab,ldab,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(out) :: amax,scond,s(*)
                    complex(dp),intent(in) :: ab(ldab,*)
               end subroutine zpbequ
#else
               module procedure la_zpbequ
#endif
          end interface pbequ

          !> PBRFS: improves the computed solution to a system of linear
          !> equations when the coefficient matrix is Hermitian positive definite
          !> and banded, and provides error bounds and backward error estimates
          !> for the solution.
          interface pbrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpbrfs(uplo,n,kd,nrhs,ab,ldab,afb,ldafb,b,ldb,x,ldx, &
                         ferr,berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine cpbrfs
#else
               module procedure la_cpbrfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpbrfs(uplo,n,kd,nrhs,ab,ldab,afb,ldafb,b,ldb,x,ldx, &
                         ferr,berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(dp),intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dpbrfs
#else
               module procedure la_dpbrfs
#endif
               module procedure la_qpbrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spbrfs(uplo,n,kd,nrhs,ab,ldab,afb,ldafb,b,ldb,x,ldx, &
                         ferr,berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(sp),intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine spbrfs
#else
               module procedure la_spbrfs
#endif
               module procedure la_wpbrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpbrfs(uplo,n,kd,nrhs,ab,ldab,afb,ldafb,b,ldb,x,ldx, &
                         ferr,berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zpbrfs
#else
               module procedure la_zpbrfs
#endif
          end interface pbrfs

          !> PBSTF: computes a split Cholesky factorization of a complex
          !> Hermitian positive definite band matrix A.
          !> This routine is designed to be used in conjunction with CHBGST.
          !> The factorization has the form  A = S**H*S  where S is a band matrix
          !> of the same bandwidth as A and the following structure:
          !> S = ( U    )
          !> ( M  L )
          !> where U is upper triangular of order m = (n+kd)/2, and L is lower
          !> triangular of order n-m.
          interface pbstf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpbstf(uplo,n,kd,ab,ldab,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    complex(sp),intent(inout) :: ab(ldab,*)
               end subroutine cpbstf
#else
               module procedure la_cpbstf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpbstf(uplo,n,kd,ab,ldab,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(inout) :: ab(ldab,*)
               end subroutine dpbstf
#else
               module procedure la_dpbstf
#endif
               module procedure la_qpbstf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spbstf(uplo,n,kd,ab,ldab,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(inout) :: ab(ldab,*)
               end subroutine spbstf
#else
               module procedure la_spbstf
#endif
               module procedure la_wpbstf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpbstf(uplo,n,kd,ab,ldab,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    complex(dp),intent(inout) :: ab(ldab,*)
               end subroutine zpbstf
#else
               module procedure la_zpbstf
#endif
          end interface pbstf

          !> PBSV: computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N Hermitian positive definite band matrix and X
          !> and B are N-by-NRHS matrices.
          !> The Cholesky decomposition is used to factor A as
          !> A = U**H * U,  if UPLO = 'U', or
          !> A = L * L**H,  if UPLO = 'L',
          !> where U is an upper triangular band matrix, and L is a lower
          !> triangular band matrix, with the same number of superdiagonals or
          !> subdiagonals as A.  The factored form of A is then used to solve the
          !> system of equations A * X = B.
          interface pbsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpbsv(uplo,n,kd,nrhs,ab,ldab,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp),intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine cpbsv
#else
               module procedure la_cpbsv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpbsv(uplo,n,kd,nrhs,ab,ldab,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp),intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine dpbsv
#else
               module procedure la_dpbsv
#endif
               module procedure la_qpbsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spbsv(uplo,n,kd,nrhs,ab,ldab,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp),intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine spbsv
#else
               module procedure la_spbsv
#endif
               module procedure la_wpbsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpbsv(uplo,n,kd,nrhs,ab,ldab,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp),intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine zpbsv
#else
               module procedure la_zpbsv
#endif
          end interface pbsv

          !> PBTRF: computes the Cholesky factorization of a complex Hermitian
          !> positive definite band matrix A.
          !> The factorization has the form
          !> A = U**H * U,  if UPLO = 'U', or
          !> A = L  * L**H,  if UPLO = 'L',
          !> where U is an upper triangular matrix and L is lower triangular.
          interface pbtrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpbtrf(uplo,n,kd,ab,ldab,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    complex(sp),intent(inout) :: ab(ldab,*)
               end subroutine cpbtrf
#else
               module procedure la_cpbtrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpbtrf(uplo,n,kd,ab,ldab,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(inout) :: ab(ldab,*)
               end subroutine dpbtrf
#else
               module procedure la_dpbtrf
#endif
               module procedure la_qpbtrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spbtrf(uplo,n,kd,ab,ldab,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(inout) :: ab(ldab,*)
               end subroutine spbtrf
#else
               module procedure la_spbtrf
#endif
               module procedure la_wpbtrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpbtrf(uplo,n,kd,ab,ldab,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    complex(dp),intent(inout) :: ab(ldab,*)
               end subroutine zpbtrf
#else
               module procedure la_zpbtrf
#endif
          end interface pbtrf

          !> PBTRS: solves a system of linear equations A*X = B with a Hermitian
          !> positive definite band matrix A using the Cholesky factorization
          !> A = U**H*U or A = L*L**H computed by CPBTRF.
          interface pbtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpbtrs(uplo,n,kd,nrhs,ab,ldab,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp),intent(in) :: ab(ldab,*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine cpbtrs
#else
               module procedure la_cpbtrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpbtrs(uplo,n,kd,nrhs,ab,ldab,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp),intent(in) :: ab(ldab,*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dpbtrs
#else
               module procedure la_dpbtrs
#endif
               module procedure la_qpbtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spbtrs(uplo,n,kd,nrhs,ab,ldab,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp),intent(in) :: ab(ldab,*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine spbtrs
#else
               module procedure la_spbtrs
#endif
               module procedure la_wpbtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpbtrs(uplo,n,kd,nrhs,ab,ldab,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp),intent(in) :: ab(ldab,*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zpbtrs
#else
               module procedure la_zpbtrs
#endif
          end interface pbtrs

          !> PFTRF: computes the Cholesky factorization of a complex Hermitian
          !> positive definite matrix A.
          !> The factorization has the form
          !> A = U**H * U,  if UPLO = 'U', or
          !> A = L  * L**H,  if UPLO = 'L',
          !> where U is an upper triangular matrix and L is lower triangular.
          !> This is the block version of the algorithm, calling Level 3 BLAS.
          interface pftrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpftrf(transr,uplo,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(in) :: n
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(inout) :: a(0:*)
               end subroutine cpftrf
#else
               module procedure la_cpftrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpftrf(transr,uplo,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(in) :: n
                    integer(ilp),intent(out) :: info
                    real(dp),intent(inout) :: a(0:*)
               end subroutine dpftrf
#else
               module procedure la_dpftrf
#endif
               module procedure la_qpftrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spftrf(transr,uplo,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(in) :: n
                    integer(ilp),intent(out) :: info
                    real(sp),intent(inout) :: a(0:*)
               end subroutine spftrf
#else
               module procedure la_spftrf
#endif
               module procedure la_wpftrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpftrf(transr,uplo,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(in) :: n
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(inout) :: a(0:*)
               end subroutine zpftrf
#else
               module procedure la_zpftrf
#endif
          end interface pftrf

          !> PFTRI: computes the inverse of a complex Hermitian positive definite
          !> matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
          !> computed by CPFTRF.
          interface pftri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpftri(transr,uplo,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(inout) :: a(0:*)
               end subroutine cpftri
#else
               module procedure la_cpftri
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpftri(transr,uplo,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: a(0:*)
               end subroutine dpftri
#else
               module procedure la_dpftri
#endif
               module procedure la_qpftri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spftri(transr,uplo,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: a(0:*)
               end subroutine spftri
#else
               module procedure la_spftri
#endif
               module procedure la_wpftri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpftri(transr,uplo,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(inout) :: a(0:*)
               end subroutine zpftri
#else
               module procedure la_zpftri
#endif
          end interface pftri

          !> PFTRS: solves a system of linear equations A*X = B with a Hermitian
          !> positive definite matrix A using the Cholesky factorization
          !> A = U**H*U or A = L*L**H computed by CPFTRF.
          interface pftrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpftrs(transr,uplo,n,nrhs,a,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(sp),intent(in) :: a(0:*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine cpftrs
#else
               module procedure la_cpftrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpftrs(transr,uplo,n,nrhs,a,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(dp),intent(in) :: a(0:*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dpftrs
#else
               module procedure la_dpftrs
#endif
               module procedure la_qpftrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spftrs(transr,uplo,n,nrhs,a,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(sp),intent(in) :: a(0:*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine spftrs
#else
               module procedure la_spftrs
#endif
               module procedure la_wpftrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpftrs(transr,uplo,n,nrhs,a,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(dp),intent(in) :: a(0:*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zpftrs
#else
               module procedure la_zpftrs
#endif
          end interface pftrs

          !> POCON: estimates the reciprocal of the condition number (in the
          !> 1-norm) of a complex Hermitian positive definite matrix using the
          !> Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
          interface pocon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpocon(uplo,n,a,lda,anorm,rcond,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond,rwork(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cpocon
#else
               module procedure la_cpocon
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpocon(uplo,n,a,lda,anorm,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond,work(*)
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dpocon
#else
               module procedure la_dpocon
#endif
               module procedure la_qpocon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spocon(uplo,n,a,lda,anorm,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond,work(*)
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine spocon
#else
               module procedure la_spocon
#endif
               module procedure la_wpocon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpocon(uplo,n,a,lda,anorm,rcond,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond,rwork(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zpocon
#else
               module procedure la_zpocon
#endif
          end interface pocon

          !> POEQU: computes row and column scalings intended to equilibrate a
          !> Hermitian positive definite matrix A and reduce its condition number
          !> (with respect to the two-norm).  S contains the scale factors,
          !> S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
          !> elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
          !> choice of S puts the condition number of B within a factor N of the
          !> smallest possible condition number over all possible diagonal
          !> scalings.
          interface poequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpoequ(n,a,lda,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: amax,scond,s(*)
                    complex(sp),intent(in) :: a(lda,*)
               end subroutine cpoequ
#else
               module procedure la_cpoequ
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpoequ(n,a,lda,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: amax,scond,s(*)
                    real(dp),intent(in) :: a(lda,*)
               end subroutine dpoequ
#else
               module procedure la_dpoequ
#endif
               module procedure la_qpoequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spoequ(n,a,lda,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: amax,scond,s(*)
                    real(sp),intent(in) :: a(lda,*)
               end subroutine spoequ
#else
               module procedure la_spoequ
#endif
               module procedure la_wpoequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpoequ(n,a,lda,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: amax,scond,s(*)
                    complex(dp),intent(in) :: a(lda,*)
               end subroutine zpoequ
#else
               module procedure la_zpoequ
#endif
          end interface poequ

          !> POEQUB: computes row and column scalings intended to equilibrate a
          !> Hermitian positive definite matrix A and reduce its condition number
          !> (with respect to the two-norm).  S contains the scale factors,
          !> S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
          !> elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
          !> choice of S puts the condition number of B within a factor N of the
          !> smallest possible condition number over all possible diagonal
          !> scalings.
          !> This routine differs from CPOEQU by restricting the scaling factors
          !> to a power of the radix.  Barring over- and underflow, scaling by
          !> these factors introduces no additional rounding errors.  However, the
          !> scaled diagonal entries are no longer approximately 1 but lie
          !> between sqrt(radix) and 1/sqrt(radix).
          interface poequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpoequb(n,a,lda,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: amax,scond,s(*)
                    complex(sp),intent(in) :: a(lda,*)
               end subroutine cpoequb
#else
               module procedure la_cpoequb
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpoequb(n,a,lda,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: amax,scond,s(*)
                    real(dp),intent(in) :: a(lda,*)
               end subroutine dpoequb
#else
               module procedure la_dpoequb
#endif
               module procedure la_qpoequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spoequb(n,a,lda,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: amax,scond,s(*)
                    real(sp),intent(in) :: a(lda,*)
               end subroutine spoequb
#else
               module procedure la_spoequb
#endif
               module procedure la_wpoequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpoequb(n,a,lda,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: amax,scond,s(*)
                    complex(dp),intent(in) :: a(lda,*)
               end subroutine zpoequb
#else
               module procedure la_zpoequb
#endif
          end interface poequb

          !> PORFS: improves the computed solution to a system of linear
          !> equations when the coefficient matrix is Hermitian positive definite,
          !> and provides error bounds and backward error estimates for the
          !> solution.
          interface porfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cporfs(uplo,n,nrhs,a,lda,af,ldaf,b,ldb,x,ldx,ferr,berr, &
                          work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine cporfs
#else
               module procedure la_cporfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dporfs(uplo,n,nrhs,a,lda,af,ldaf,b,ldb,x,ldx,ferr,berr, &
                          work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(dp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dporfs
#else
               module procedure la_dporfs
#endif
               module procedure la_qporfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sporfs(uplo,n,nrhs,a,lda,af,ldaf,b,ldb,x,ldx,ferr,berr, &
                          work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(sp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine sporfs
#else
               module procedure la_sporfs
#endif
               module procedure la_wporfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zporfs(uplo,n,nrhs,a,lda,af,ldaf,b,ldb,x,ldx,ferr,berr, &
                          work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zporfs
#else
               module procedure la_zporfs
#endif
          end interface porfs

          !> POSV: computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N Hermitian positive definite matrix and X and B
          !> are N-by-NRHS matrices.
          !> The Cholesky decomposition is used to factor A as
          !> A = U**H* U,  if UPLO = 'U', or
          !> A = L * L**H,  if UPLO = 'L',
          !> where U is an upper triangular matrix and  L is a lower triangular
          !> matrix.  The factored form of A is then used to solve the system of
          !> equations A * X = B.
          interface posv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cposv(uplo,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cposv
#else
               module procedure la_cposv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dposv(uplo,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine dposv
#else
               module procedure la_dposv
#endif
               module procedure la_qposv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sposv(uplo,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine sposv
#else
               module procedure la_sposv
#endif
               module procedure la_wposv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zposv(uplo,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zposv
#else
               module procedure la_zposv
#endif
          end interface posv

          !> POTRF: computes the Cholesky factorization of a complex Hermitian
          !> positive definite matrix A.
          !> The factorization has the form
          !> A = U**H * U,  if UPLO = 'U', or
          !> A = L  * L**H,  if UPLO = 'L',
          !> where U is an upper triangular matrix and L is lower triangular.
          !> This is the block version of the algorithm, calling Level 3 BLAS.
          interface potrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpotrf(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine cpotrf
#else
               module procedure la_cpotrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpotrf(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dpotrf
#else
               module procedure la_dpotrf
#endif
               module procedure la_qpotrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spotrf(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine spotrf
#else
               module procedure la_spotrf
#endif
               module procedure la_wpotrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpotrf(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zpotrf
#else
               module procedure la_zpotrf
#endif
          end interface potrf

          !> POTRF2: computes the Cholesky factorization of a Hermitian
          !> positive definite matrix A using the recursive algorithm.
          !> The factorization has the form
          !> A = U**H * U,  if UPLO = 'U', or
          !> A = L  * L**H,  if UPLO = 'L',
          !> where U is an upper triangular matrix and L is lower triangular.
          !> This is the recursive version of the algorithm. It divides
          !> the matrix into four submatrices:
          !> [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
          !> A = [ -----|----- ]  with n1 = n/2
          !> [  A21 | A22  ]       n2 = n-n1
          !> The subroutine calls itself to factor A11. Update and scale A21
          !> or A12, update A22 then calls itself to factor A22.
          interface potrf2
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine cpotrf2(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine cpotrf2
#else
               module procedure la_cpotrf2
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine dpotrf2(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dpotrf2
#else
               module procedure la_dpotrf2
#endif
               module procedure la_qpotrf2
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine spotrf2(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine spotrf2
#else
               module procedure la_spotrf2
#endif
               module procedure la_wpotrf2
#ifdef LA_EXTERNAL_LAPACK
               pure recursive subroutine zpotrf2(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zpotrf2
#else
               module procedure la_zpotrf2
#endif
          end interface potrf2

          !> POTRI: computes the inverse of a complex Hermitian positive definite
          !> matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
          !> computed by CPOTRF.
          interface potri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpotri(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine cpotri
#else
               module procedure la_cpotri
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpotri(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dpotri
#else
               module procedure la_dpotri
#endif
               module procedure la_qpotri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spotri(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine spotri
#else
               module procedure la_spotri
#endif
               module procedure la_wpotri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpotri(uplo,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zpotri
#else
               module procedure la_zpotri
#endif
          end interface potri

          !> POTRS: solves a system of linear equations A*X = B with a Hermitian
          !> positive definite matrix A using the Cholesky factorization
          !> A = U**H*U or A = L*L**H computed by CPOTRF.
          interface potrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpotrs(uplo,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine cpotrs
#else
               module procedure la_cpotrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpotrs(uplo,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dpotrs
#else
               module procedure la_dpotrs
#endif
               module procedure la_qpotrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spotrs(uplo,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine spotrs
#else
               module procedure la_spotrs
#endif
               module procedure la_wpotrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpotrs(uplo,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zpotrs
#else
               module procedure la_zpotrs
#endif
          end interface potrs

          !> PPCON: estimates the reciprocal of the condition number (in the
          !> 1-norm) of a complex Hermitian positive definite packed matrix using
          !> the Cholesky factorization A = U**H*U or A = L*L**H computed by
          !> CPPTRF.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
          interface ppcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cppcon(uplo,n,ap,anorm,rcond,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond,rwork(*)
                    complex(sp),intent(in) :: ap(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cppcon
#else
               module procedure la_cppcon
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dppcon(uplo,n,ap,anorm,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: anorm,ap(*)
                    real(dp),intent(out) :: rcond,work(*)
               end subroutine dppcon
#else
               module procedure la_dppcon
#endif
               module procedure la_qppcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sppcon(uplo,n,ap,anorm,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: anorm,ap(*)
                    real(sp),intent(out) :: rcond,work(*)
               end subroutine sppcon
#else
               module procedure la_sppcon
#endif
               module procedure la_wppcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zppcon(uplo,n,ap,anorm,rcond,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond,rwork(*)
                    complex(dp),intent(in) :: ap(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zppcon
#else
               module procedure la_zppcon
#endif
          end interface ppcon

          !> PPEQU: computes row and column scalings intended to equilibrate a
          !> Hermitian positive definite matrix A in packed storage and reduce
          !> its condition number (with respect to the two-norm).  S contains the
          !> scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
          !> B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
          !> This choice of S puts the condition number of B within a factor N of
          !> the smallest possible condition number over all possible diagonal
          !> scalings.
          interface ppequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cppequ(uplo,n,ap,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: amax,scond,s(*)
                    complex(sp),intent(in) :: ap(*)
               end subroutine cppequ
#else
               module procedure la_cppequ
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dppequ(uplo,n,ap,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: amax,scond,s(*)
                    real(dp),intent(in) :: ap(*)
               end subroutine dppequ
#else
               module procedure la_dppequ
#endif
               module procedure la_qppequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sppequ(uplo,n,ap,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: amax,scond,s(*)
                    real(sp),intent(in) :: ap(*)
               end subroutine sppequ
#else
               module procedure la_sppequ
#endif
               module procedure la_wppequ
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zppequ(uplo,n,ap,s,scond,amax,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: amax,scond,s(*)
                    complex(dp),intent(in) :: ap(*)
               end subroutine zppequ
#else
               module procedure la_zppequ
#endif
          end interface ppequ

          !> PPRFS: improves the computed solution to a system of linear
          !> equations when the coefficient matrix is Hermitian positive definite
          !> and packed, and provides error bounds and backward error estimates
          !> for the solution.
          interface pprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpprfs(uplo,n,nrhs,ap,afp,b,ldb,x,ldx,ferr,berr,work, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine cpprfs
#else
               module procedure la_cpprfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpprfs(uplo,n,nrhs,ap,afp,b,ldb,x,ldx,ferr,berr,work, &
                         iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(dp),intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dpprfs
#else
               module procedure la_dpprfs
#endif
               module procedure la_qpprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spprfs(uplo,n,nrhs,ap,afp,b,ldb,x,ldx,ferr,berr,work, &
                         iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(sp),intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine spprfs
#else
               module procedure la_spprfs
#endif
               module procedure la_wpprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpprfs(uplo,n,nrhs,ap,afp,b,ldb,x,ldx,ferr,berr,work, &
                         rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zpprfs
#else
               module procedure la_zpprfs
#endif
          end interface pprfs

          !> PPSV: computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N Hermitian positive definite matrix stored in
          !> packed format and X and B are N-by-NRHS matrices.
          !> The Cholesky decomposition is used to factor A as
          !> A = U**H * U,  if UPLO = 'U', or
          !> A = L * L**H,  if UPLO = 'L',
          !> where U is an upper triangular matrix and L is a lower triangular
          !> matrix.  The factored form of A is then used to solve the system of
          !> equations A * X = B.
          interface ppsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cppsv(uplo,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(sp),intent(inout) :: ap(*),b(ldb,*)
               end subroutine cppsv
#else
               module procedure la_cppsv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dppsv(uplo,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(dp),intent(inout) :: ap(*),b(ldb,*)
               end subroutine dppsv
#else
               module procedure la_dppsv
#endif
               module procedure la_qppsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sppsv(uplo,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(sp),intent(inout) :: ap(*),b(ldb,*)
               end subroutine sppsv
#else
               module procedure la_sppsv
#endif
               module procedure la_wppsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zppsv(uplo,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(dp),intent(inout) :: ap(*),b(ldb,*)
               end subroutine zppsv
#else
               module procedure la_zppsv
#endif
          end interface ppsv

          !> PPTRF: computes the Cholesky factorization of a complex Hermitian
          !> positive definite matrix A stored in packed format.
          !> The factorization has the form
          !> A = U**H * U,  if UPLO = 'U', or
          !> A = L  * L**H,  if UPLO = 'L',
          !> where U is an upper triangular matrix and L is lower triangular.
          interface pptrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpptrf(uplo,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(inout) :: ap(*)
               end subroutine cpptrf
#else
               module procedure la_cpptrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpptrf(uplo,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: ap(*)
               end subroutine dpptrf
#else
               module procedure la_dpptrf
#endif
               module procedure la_qpptrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spptrf(uplo,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: ap(*)
               end subroutine spptrf
#else
               module procedure la_spptrf
#endif
               module procedure la_wpptrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpptrf(uplo,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(inout) :: ap(*)
               end subroutine zpptrf
#else
               module procedure la_zpptrf
#endif
          end interface pptrf

          !> PPTRI: computes the inverse of a complex Hermitian positive definite
          !> matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
          !> computed by CPPTRF.
          interface pptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpptri(uplo,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(inout) :: ap(*)
               end subroutine cpptri
#else
               module procedure la_cpptri
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpptri(uplo,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: ap(*)
               end subroutine dpptri
#else
               module procedure la_dpptri
#endif
               module procedure la_qpptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spptri(uplo,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: ap(*)
               end subroutine spptri
#else
               module procedure la_spptri
#endif
               module procedure la_wpptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpptri(uplo,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(inout) :: ap(*)
               end subroutine zpptri
#else
               module procedure la_zpptri
#endif
          end interface pptri

          !> PPTRS: solves a system of linear equations A*X = B with a Hermitian
          !> positive definite matrix A in packed storage using the Cholesky
          !> factorization A = U**H*U or A = L*L**H computed by CPPTRF.
          interface pptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpptrs(uplo,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(sp),intent(in) :: ap(*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine cpptrs
#else
               module procedure la_cpptrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpptrs(uplo,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(dp),intent(in) :: ap(*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dpptrs
#else
               module procedure la_dpptrs
#endif
               module procedure la_qpptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spptrs(uplo,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(sp),intent(in) :: ap(*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine spptrs
#else
               module procedure la_spptrs
#endif
               module procedure la_wpptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpptrs(uplo,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(dp),intent(in) :: ap(*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zpptrs
#else
               module procedure la_zpptrs
#endif
          end interface pptrs

          !> PSTRF: computes the Cholesky factorization with complete
          !> pivoting of a complex Hermitian positive semidefinite matrix A.
          !> The factorization has the form
          !> P**T * A * P = U**H * U ,  if UPLO = 'U',
          !> P**T * A * P = L  * L**H,  if UPLO = 'L',
          !> where U is an upper triangular matrix and L is lower triangular, and
          !> P is stored as vector PIV.
          !> This algorithm does not attempt to check that A is positive
          !> semidefinite. This version of the algorithm calls level 3 BLAS.
          interface pstrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpstrf(uplo,n,a,lda,piv,rank,tol,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: tol
                    integer(ilp),intent(out) :: info,rank,piv(n)
                    integer(ilp),intent(in) :: lda,n
                    character,intent(in) :: uplo
                    complex(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: work(2*n)
               end subroutine cpstrf
#else
               module procedure la_cpstrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpstrf(uplo,n,a,lda,piv,rank,tol,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: tol
                    integer(ilp),intent(out) :: info,rank,piv(n)
                    integer(ilp),intent(in) :: lda,n
                    character,intent(in) :: uplo
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: work(2*n)
               end subroutine dpstrf
#else
               module procedure la_dpstrf
#endif
               module procedure la_qpstrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spstrf(uplo,n,a,lda,piv,rank,tol,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: tol
                    integer(ilp),intent(out) :: info,rank,piv(n)
                    integer(ilp),intent(in) :: lda,n
                    character,intent(in) :: uplo
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: work(2*n)
               end subroutine spstrf
#else
               module procedure la_spstrf
#endif
               module procedure la_wpstrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpstrf(uplo,n,a,lda,piv,rank,tol,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: tol
                    integer(ilp),intent(out) :: info,rank,piv(n)
                    integer(ilp),intent(in) :: lda,n
                    character,intent(in) :: uplo
                    complex(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: work(2*n)
               end subroutine zpstrf
#else
               module procedure la_zpstrf
#endif
          end interface pstrf

          !> PTCON: computes the reciprocal of the condition number (in the
          !> 1-norm) of a complex Hermitian positive definite tridiagonal matrix
          !> using the factorization A = L*D*L**H or A = U**H*D*U computed by
          !> CPTTRF.
          !> Norm(inv(A)) is computed by a direct method, and the reciprocal of
          !> the condition number is computed as
          !> RCOND = 1 / (ANORM * norm(inv(A))).
          interface ptcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cptcon(n,d,e,anorm,rcond,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: anorm,d(*)
                    real(sp),intent(out) :: rcond,rwork(*)
                    complex(sp),intent(in) :: e(*)
               end subroutine cptcon
#else
               module procedure la_cptcon
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dptcon(n,d,e,anorm,rcond,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: anorm,d(*),e(*)
                    real(dp),intent(out) :: rcond,work(*)
               end subroutine dptcon
#else
               module procedure la_dptcon
#endif
               module procedure la_qptcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sptcon(n,d,e,anorm,rcond,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: anorm,d(*),e(*)
                    real(sp),intent(out) :: rcond,work(*)
               end subroutine sptcon
#else
               module procedure la_sptcon
#endif
               module procedure la_wptcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zptcon(n,d,e,anorm,rcond,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: anorm,d(*)
                    real(dp),intent(out) :: rcond,rwork(*)
                    complex(dp),intent(in) :: e(*)
               end subroutine zptcon
#else
               module procedure la_zptcon
#endif
          end interface ptcon

          !> PTEQR: computes all eigenvalues and, optionally, eigenvectors of a
          !> symmetric positive definite tridiagonal matrix by first factoring the
          !> matrix using SPTTRF and then calling CBDSQR to compute the singular
          !> values of the bidiagonal factor.
          !> This routine computes the eigenvalues of the positive definite
          !> tridiagonal matrix to high relative accuracy.  This means that if the
          !> eigenvalues range over many orders of magnitude in size, then the
          !> small eigenvalues and corresponding eigenvectors will be computed
          !> more accurately than, for example, with the standard QR method.
          !> The eigenvectors of a full or band positive definite Hermitian matrix
          !> can also be found if CHETRD, CHPTRD, or CHBTRD has been used to
          !> reduce this matrix to tridiagonal form.  (The reduction to
          !> tridiagonal form, however, may preclude the possibility of obtaining
          !> high relative accuracy in the small eigenvalues of the original
          !> matrix, if these eigenvalues range over many orders of magnitude.)
          interface pteqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpteqr(compz,n,d,e,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: z(ldz,*)
               end subroutine cpteqr
#else
               module procedure la_cpteqr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpteqr(compz,n,d,e,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(dp),intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dpteqr
#else
               module procedure la_dpteqr
#endif
               module procedure la_qpteqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spteqr(compz,n,d,e,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(sp),intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp),intent(out) :: work(*)
               end subroutine spteqr
#else
               module procedure la_spteqr
#endif
               module procedure la_wpteqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpteqr(compz,n,d,e,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: z(ldz,*)
               end subroutine zpteqr
#else
               module procedure la_zpteqr
#endif
          end interface pteqr

          !> PTRFS: improves the computed solution to a system of linear
          !> equations when the coefficient matrix is Hermitian positive definite
          !> and tridiagonal, and provides error bounds and backward error
          !> estimates for the solution.
          interface ptrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cptrfs(uplo,n,nrhs,d,e,df,ef,b,ldb,x,ldx,ferr,berr, &
                         work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    real(sp),intent(in) :: d(*),df(*)
                    complex(sp),intent(in) :: b(ldb,*),e(*),ef(*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine cptrfs
#else
               module procedure la_cptrfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dptrfs(n,nrhs,d,e,df,ef,b,ldb,x,ldx,ferr,berr,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(dp),intent(in) :: b(ldb,*),d(*),df(*),e(*),ef(*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dptrfs
#else
               module procedure la_dptrfs
#endif
               module procedure la_qptrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sptrfs(n,nrhs,d,e,df,ef,b,ldb,x,ldx,ferr,berr,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(sp),intent(in) :: b(ldb,*),d(*),df(*),e(*),ef(*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine sptrfs
#else
               module procedure la_sptrfs
#endif
               module procedure la_wptrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zptrfs(uplo,n,nrhs,d,e,df,ef,b,ldb,x,ldx,ferr,berr, &
                         work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    real(dp),intent(in) :: d(*),df(*)
                    complex(dp),intent(in) :: b(ldb,*),e(*),ef(*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zptrfs
#else
               module procedure la_zptrfs
#endif
          end interface ptrfs

          !> PTSV: computes the solution to a complex system of linear equations
          !> A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
          !> matrix, and X and B are N-by-NRHS matrices.
          !> A is factored as A = L*D*L**H, and the factored form of A is then
          !> used to solve the system of equations.
          interface ptsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cptsv(n,nrhs,d,e,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(sp),intent(inout) :: d(*)
                    complex(sp),intent(inout) :: b(ldb,*),e(*)
               end subroutine cptsv
#else
               module procedure la_cptsv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dptsv(n,nrhs,d,e,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(dp),intent(inout) :: b(ldb,*),d(*),e(*)
               end subroutine dptsv
#else
               module procedure la_dptsv
#endif
               module procedure la_qptsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sptsv(n,nrhs,d,e,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(sp),intent(inout) :: b(ldb,*),d(*),e(*)
               end subroutine sptsv
#else
               module procedure la_sptsv
#endif
               module procedure la_wptsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zptsv(n,nrhs,d,e,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(dp),intent(inout) :: d(*)
                    complex(dp),intent(inout) :: b(ldb,*),e(*)
               end subroutine zptsv
#else
               module procedure la_zptsv
#endif
          end interface ptsv

          !> PTTRF: computes the L*D*L**H factorization of a complex Hermitian
          !> positive definite tridiagonal matrix A.  The factorization may also
          !> be regarded as having the form A = U**H *D*U.
          interface pttrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpttrf(n,d,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: d(*)
                    complex(sp),intent(inout) :: e(*)
               end subroutine cpttrf
#else
               module procedure la_cpttrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpttrf(n,d,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: d(*),e(*)
               end subroutine dpttrf
#else
               module procedure la_dpttrf
#endif
               module procedure la_qpttrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spttrf(n,d,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: d(*),e(*)
               end subroutine spttrf
#else
               module procedure la_spttrf
#endif
               module procedure la_wpttrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpttrf(n,d,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: d(*)
                    complex(dp),intent(inout) :: e(*)
               end subroutine zpttrf
#else
               module procedure la_zpttrf
#endif
          end interface pttrf

          !> PTTRS: solves a tridiagonal system of the form
          !> A * X = B
          !> using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF.
          !> D is a diagonal matrix specified in the vector D, U (or L) is a unit
          !> bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
          !> the vector E, and X and B are N by NRHS matrices.
          interface pttrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cpttrs(uplo,n,nrhs,d,e,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(sp),intent(in) :: d(*)
                    complex(sp),intent(inout) :: b(ldb,*)
                    complex(sp),intent(in) :: e(*)
               end subroutine cpttrs
#else
               module procedure la_cpttrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dpttrs(n,nrhs,d,e,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(dp),intent(inout) :: b(ldb,*)
                    real(dp),intent(in) :: d(*),e(*)
               end subroutine dpttrs
#else
               module procedure la_dpttrs
#endif
               module procedure la_qpttrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine spttrs(n,nrhs,d,e,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(sp),intent(inout) :: b(ldb,*)
                    real(sp),intent(in) :: d(*),e(*)
               end subroutine spttrs
#else
               module procedure la_spttrs
#endif
               module procedure la_wpttrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zpttrs(uplo,n,nrhs,d,e,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(dp),intent(in) :: d(*)
                    complex(dp),intent(inout) :: b(ldb,*)
                    complex(dp),intent(in) :: e(*)
               end subroutine zpttrs
#else
               module procedure la_zpttrs
#endif
          end interface pttrs

          !> ROT:   applies a plane rotation, where the cos (C) is real and the
          !> sin (S) is complex, and the vectors CX and CY are complex.
          interface rot
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine crot(n,cx,incx,cy,incy,c,s)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,incy,n
                    real(sp),intent(in) :: c
                    complex(sp),intent(in) :: s
                    complex(sp),intent(inout) :: cx(*),cy(*)
               end subroutine crot
#else
               module procedure la_crot
#endif
               module procedure la_wrot
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zrot(n,cx,incx,cy,incy,c,s)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,incy,n
                    real(dp),intent(in) :: c
                    complex(dp),intent(in) :: s
                    complex(dp),intent(inout) :: cx(*),cy(*)
               end subroutine zrot
#else
               module procedure la_zrot
#endif
          end interface rot

          !> RSCL: multiplies an n-element real vector x by the real scalar 1/a.
          !> This is done without overflow or underflow as long as
          !> the final result x/a does not overflow or underflow.
          interface rscl
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine drscl(n,sa,sx,incx)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    real(dp),intent(in) :: sa
                    real(dp),intent(inout) :: sx(*)
               end subroutine drscl
#else
               module procedure la_drscl
#endif
               module procedure la_qrscl
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine srscl(n,sa,sx,incx)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx,n
                    real(sp),intent(in) :: sa
                    real(sp),intent(inout) :: sx(*)
               end subroutine srscl
#else
               module procedure la_srscl
#endif
          end interface rscl

          !> SB2ST_KERNELS: is an internal routine used by the DSYTRD_SB2ST
          !> subroutine.
          interface sb2st_kernels
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsb2st_kernels(uplo,wantz,ttype,st,ed,sweep,n,nb,ib,a, &
                         lda,v,tau,ldvt,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    logical(lk),intent(in) :: wantz
                    integer(ilp),intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: v(*),tau(*),work(*)
               end subroutine dsb2st_kernels
#else
               module procedure la_dsb2st_kernels
#endif
               module procedure la_qsb2st_kernels
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssb2st_kernels(uplo,wantz,ttype,st,ed,sweep,n,nb,ib,a, &
                         lda,v,tau,ldvt,work)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    logical(lk),intent(in) :: wantz
                    integer(ilp),intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: v(*),tau(*),work(*)
               end subroutine ssb2st_kernels
#else
               module procedure la_ssb2st_kernels
#endif
          end interface sb2st_kernels

          !> SBEV: computes all the eigenvalues and, optionally, eigenvectors of
          !> a real symmetric band matrix A.
          interface sbev
#ifdef LA_EXTERNAL_LAPACK
               subroutine dsbev(jobz,uplo,n,kd,ab,ldab,w,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldz,n
                    real(dp),intent(inout) :: ab(ldab,*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbev
#else
               module procedure la_dsbev
#endif
               module procedure la_qsbev
#ifdef LA_EXTERNAL_LAPACK
               subroutine ssbev(jobz,uplo,n,kd,ab,ldab,w,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldz,n
                    real(sp),intent(inout) :: ab(ldab,*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbev
#else
               module procedure la_ssbev
#endif
          end interface sbev

          !> SBEVD: computes all the eigenvalues and, optionally, eigenvectors of
          !> a real symmetric band matrix A. If eigenvectors are desired, it uses
          !> a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface sbevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine dsbevd(jobz,uplo,n,kd,ab,ldab,w,z,ldz,work,lwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,ldz,liwork,lwork,n
                    real(dp),intent(inout) :: ab(ldab,*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbevd
#else
               module procedure la_dsbevd
#endif
               module procedure la_qsbevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine ssbevd(jobz,uplo,n,kd,ab,ldab,w,z,ldz,work,lwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,ldz,liwork,lwork,n
                    real(sp),intent(inout) :: ab(ldab,*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbevd
#else
               module procedure la_ssbevd
#endif
          end interface sbevd

          !> SBGST: reduces a real symmetric-definite banded generalized
          !> eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
          !> such that C has the same bandwidth as A.
          !> B must have been previously factorized as S**T*S by DPBSTF, using a
          !> split Cholesky factorization. A is overwritten by C = X**T*A*X, where
          !> X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
          !> bandwidth of A.
          interface sbgst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsbgst(vect,uplo,n,ka,kb,ab,ldab,bb,ldbb,x,ldx,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(dp),intent(inout) :: ab(ldab,*)
                    real(dp),intent(in) :: bb(ldbb,*)
                    real(dp),intent(out) :: work(*),x(ldx,*)
               end subroutine dsbgst
#else
               module procedure la_dsbgst
#endif
               module procedure la_qsbgst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssbgst(vect,uplo,n,ka,kb,ab,ldab,bb,ldbb,x,ldx,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(sp),intent(inout) :: ab(ldab,*)
                    real(sp),intent(in) :: bb(ldbb,*)
                    real(sp),intent(out) :: work(*),x(ldx,*)
               end subroutine ssbgst
#else
               module procedure la_ssbgst
#endif
          end interface sbgst

          !> SBGV: computes all the eigenvalues, and optionally, the eigenvectors
          !> of a real generalized symmetric-definite banded eigenproblem, of
          !> the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
          !> and banded, and B is also positive definite.
          interface sbgv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsbgv(jobz,uplo,n,ka,kb,ab,ldab,bb,ldbb,w,z,ldz,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(dp),intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbgv
#else
               module procedure la_dsbgv
#endif
               module procedure la_qsbgv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssbgv(jobz,uplo,n,ka,kb,ab,ldab,bb,ldbb,w,z,ldz,work, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(sp),intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbgv
#else
               module procedure la_ssbgv
#endif
          end interface sbgv

          !> SBGVD: computes all the eigenvalues, and optionally, the eigenvectors
          !> of a real generalized symmetric-definite banded eigenproblem, of the
          !> form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and
          !> banded, and B is also positive definite.  If eigenvectors are
          !> desired, it uses a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface sbgvd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsbgvd(jobz,uplo,n,ka,kb,ab,ldab,bb,ldbb,w,z,ldz,work, &
                         lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lwork,n
                    real(dp),intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbgvd
#else
               module procedure la_dsbgvd
#endif
               module procedure la_qsbgvd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssbgvd(jobz,uplo,n,ka,kb,ab,ldab,bb,ldbb,w,z,ldz,work, &
                         lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lwork,n
                    real(sp),intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbgvd
#else
               module procedure la_ssbgvd
#endif
          end interface sbgvd

          !> SBTRD: reduces a real symmetric band matrix A to symmetric
          !> tridiagonal form T by an orthogonal similarity transformation:
          !> Q**T * A * Q = T.
          interface sbtrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsbtrd(vect,uplo,n,kd,ab,ldab,d,e,q,ldq,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldq,n
                    real(dp),intent(inout) :: ab(ldab,*),q(ldq,*)
                    real(dp),intent(out) :: d(*),e(*),work(*)
               end subroutine dsbtrd
#else
               module procedure la_dsbtrd
#endif
               module procedure la_qsbtrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssbtrd(vect,uplo,n,kd,ab,ldab,d,e,q,ldq,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldq,n
                    real(sp),intent(inout) :: ab(ldab,*),q(ldq,*)
                    real(sp),intent(out) :: d(*),e(*),work(*)
               end subroutine ssbtrd
#else
               module procedure la_ssbtrd
#endif
          end interface sbtrd

          !> Level 3 BLAS like routine for C in RFP Format.
          !> SFRK: performs one of the symmetric rank--k operations
          !> C := alpha*A*A**T + beta*C,
          !> or
          !> C := alpha*A**T*A + beta*C,
          !> where alpha and beta are real scalars, C is an n--by--n symmetric
          !> matrix and A is an n--by--k matrix in the first case and a k--by--n
          !> matrix in the second case.
          interface sfrk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsfrk(transr,uplo,trans,n,k,alpha,a,lda,beta,c)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(dp),intent(in) :: alpha,beta,a(lda,*)
                    integer(ilp),intent(in) :: k,lda,n
                    character,intent(in) :: trans,transr,uplo
                    real(dp),intent(inout) :: c(*)
               end subroutine dsfrk
#else
               module procedure la_dsfrk
#endif
               module procedure la_qsfrk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssfrk(transr,uplo,trans,n,k,alpha,a,lda,beta,c)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    real(sp),intent(in) :: alpha,beta,a(lda,*)
                    integer(ilp),intent(in) :: k,lda,n
                    character,intent(in) :: trans,transr,uplo
                    real(sp),intent(inout) :: c(*)
               end subroutine ssfrk
#else
               module procedure la_ssfrk
#endif
          end interface sfrk

          !> SPCON: estimates the reciprocal of the condition number (in the
          !> 1-norm) of a complex symmetric packed matrix A using the
          !> factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
          interface spcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cspcon(uplo,n,ap,ipiv,anorm,rcond,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond
                    complex(sp),intent(in) :: ap(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cspcon
#else
               module procedure la_cspcon
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dspcon(uplo,n,ap,ipiv,anorm,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(dp),intent(in) :: anorm,ap(*)
                    real(dp),intent(out) :: rcond,work(*)
               end subroutine dspcon
#else
               module procedure la_dspcon
#endif
               module procedure la_qspcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sspcon(uplo,n,ap,ipiv,anorm,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(sp),intent(in) :: anorm,ap(*)
                    real(sp),intent(out) :: rcond,work(*)
               end subroutine sspcon
#else
               module procedure la_sspcon
#endif
               module procedure la_wspcon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zspcon(uplo,n,ap,ipiv,anorm,rcond,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond
                    complex(dp),intent(in) :: ap(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zspcon
#else
               module procedure la_zspcon
#endif
          end interface spcon

          !> SPEV: computes all the eigenvalues and, optionally, eigenvectors of a
          !> real symmetric matrix A in packed storage.
          interface spev
#ifdef LA_EXTERNAL_LAPACK
               subroutine dspev(jobz,uplo,n,ap,w,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(dp),intent(inout) :: ap(*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspev
#else
               module procedure la_dspev
#endif
               module procedure la_qspev
#ifdef LA_EXTERNAL_LAPACK
               subroutine sspev(jobz,uplo,n,ap,w,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(sp),intent(inout) :: ap(*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspev
#else
               module procedure la_sspev
#endif
          end interface spev

          !> SPEVD: computes all the eigenvalues and, optionally, eigenvectors
          !> of a real symmetric matrix A in packed storage. If eigenvectors are
          !> desired, it uses a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface spevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine dspevd(jobz,uplo,n,ap,w,z,ldz,work,lwork,iwork,liwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldz,liwork,lwork,n
                    real(dp),intent(inout) :: ap(*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspevd
#else
               module procedure la_dspevd
#endif
               module procedure la_qspevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine sspevd(jobz,uplo,n,ap,w,z,ldz,work,lwork,iwork,liwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldz,liwork,lwork,n
                    real(sp),intent(inout) :: ap(*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspevd
#else
               module procedure la_sspevd
#endif
          end interface spevd

          !> SPGST: reduces a real symmetric-definite generalized eigenproblem
          !> to standard form, using packed storage.
          !> If ITYPE = 1, the problem is A*x = lambda*B*x,
          !> and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
          !> If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !> B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
          !> B must have been previously factorized as U**T*U or L*L**T by DPPTRF.
          interface spgst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dspgst(itype,uplo,n,ap,bp,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,n
                    real(dp),intent(inout) :: ap(*)
                    real(dp),intent(in) :: bp(*)
               end subroutine dspgst
#else
               module procedure la_dspgst
#endif
               module procedure la_qspgst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sspgst(itype,uplo,n,ap,bp,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,n
                    real(sp),intent(inout) :: ap(*)
                    real(sp),intent(in) :: bp(*)
               end subroutine sspgst
#else
               module procedure la_sspgst
#endif
          end interface spgst

          !> SPGV: computes all the eigenvalues and, optionally, the eigenvectors
          !> of a real generalized symmetric-definite eigenproblem, of the form
          !> A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !> Here A and B are assumed to be symmetric, stored in packed format,
          !> and B is also positive definite.
          interface spgv
#ifdef LA_EXTERNAL_LAPACK
               subroutine dspgv(itype,jobz,uplo,n,ap,bp,w,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,ldz,n
                    real(dp),intent(inout) :: ap(*),bp(*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspgv
#else
               module procedure la_dspgv
#endif
               module procedure la_qspgv
#ifdef LA_EXTERNAL_LAPACK
               subroutine sspgv(itype,jobz,uplo,n,ap,bp,w,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,ldz,n
                    real(sp),intent(inout) :: ap(*),bp(*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspgv
#else
               module procedure la_sspgv
#endif
          end interface spgv

          !> SPGVD: computes all the eigenvalues, and optionally, the eigenvectors
          !> of a real generalized symmetric-definite eigenproblem, of the form
          !> A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !> B are assumed to be symmetric, stored in packed format, and B is also
          !> positive definite.
          !> If eigenvectors are desired, it uses a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface spgvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine dspgvd(itype,jobz,uplo,n,ap,bp,w,z,ldz,work,lwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: itype,ldz,liwork,lwork,n
                    real(dp),intent(inout) :: ap(*),bp(*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspgvd
#else
               module procedure la_dspgvd
#endif
               module procedure la_qspgvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine sspgvd(itype,jobz,uplo,n,ap,bp,w,z,ldz,work,lwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: itype,ldz,liwork,lwork,n
                    real(sp),intent(inout) :: ap(*),bp(*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspgvd
#else
               module procedure la_sspgvd
#endif
          end interface spgvd

          !> SPMV:  performs the matrix-vector operation
          !> y := alpha*A*x + beta*y,
          !> where alpha and beta are scalars, x and y are n element vectors and
          !> A is an n by n symmetric matrix, supplied in packed form.
          interface spmv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cspmv(uplo,n,alpha,ap,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incx,incy,n
                    complex(sp),intent(in) :: alpha,beta,ap(*),x(*)
                    complex(sp),intent(inout) :: y(*)
               end subroutine cspmv
#else
               module procedure la_cspmv
#endif
               module procedure la_wspmv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zspmv(uplo,n,alpha,ap,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incx,incy,n
                    complex(dp),intent(in) :: alpha,beta,ap(*),x(*)
                    complex(dp),intent(inout) :: y(*)
               end subroutine zspmv
#else
               module procedure la_zspmv
#endif
          end interface spmv

          !> SPR:    performs the symmetric rank 1 operation
          !> A := alpha*x*x**H + A,
          !> where alpha is a complex scalar, x is an n element vector and A is an
          !> n by n symmetric matrix, supplied in packed form.
          interface spr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cspr(uplo,n,alpha,x,incx,ap)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incx,n
                    complex(sp),intent(in) :: alpha,x(*)
                    complex(sp),intent(inout) :: ap(*)
               end subroutine cspr
#else
               module procedure la_cspr
#endif
               module procedure la_wspr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zspr(uplo,n,alpha,x,incx,ap)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incx,n
                    complex(dp),intent(in) :: alpha,x(*)
                    complex(dp),intent(inout) :: ap(*)
               end subroutine zspr
#else
               module procedure la_zspr
#endif
          end interface spr

          !> SPRFS: improves the computed solution to a system of linear
          !> equations when the coefficient matrix is symmetric indefinite
          !> and packed, and provides error bounds and backward error estimates
          !> for the solution.
          interface sprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csprfs(uplo,n,nrhs,ap,afp,ipiv,b,ldb,x,ldx,ferr,berr, &
                         work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine csprfs
#else
               module procedure la_csprfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsprfs(uplo,n,nrhs,ap,afp,ipiv,b,ldb,x,ldx,ferr,berr, &
                         work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dsprfs
#else
               module procedure la_dsprfs
#endif
               module procedure la_qsprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssprfs(uplo,n,nrhs,ap,afp,ipiv,b,ldb,x,ldx,ferr,berr, &
                         work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine ssprfs
#else
               module procedure la_ssprfs
#endif
               module procedure la_wsprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsprfs(uplo,n,nrhs,ap,afp,ipiv,b,ldb,x,ldx,ferr,berr, &
                         work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zsprfs
#else
               module procedure la_zsprfs
#endif
          end interface sprfs

          !> SPSV: computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N symmetric matrix stored in packed format and X
          !> and B are N-by-NRHS matrices.
          !> The diagonal pivoting method is used to factor A as
          !> A = U * D * U**T,  if UPLO = 'U', or
          !> A = L * D * L**T,  if UPLO = 'L',
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, D is symmetric and block diagonal with 1-by-1
          !> and 2-by-2 diagonal blocks.  The factored form of A is then used to
          !> solve the system of equations A * X = B.
          interface spsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cspsv(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(sp),intent(inout) :: ap(*),b(ldb,*)
               end subroutine cspsv
#else
               module procedure la_cspsv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dspsv(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(dp),intent(inout) :: ap(*),b(ldb,*)
               end subroutine dspsv
#else
               module procedure la_dspsv
#endif
               module procedure la_qspsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sspsv(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(sp),intent(inout) :: ap(*),b(ldb,*)
               end subroutine sspsv
#else
               module procedure la_sspsv
#endif
               module procedure la_wspsv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zspsv(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(dp),intent(inout) :: ap(*),b(ldb,*)
               end subroutine zspsv
#else
               module procedure la_zspsv
#endif
          end interface spsv

          !> SPTRD: reduces a real symmetric matrix A stored in packed form to
          !> symmetric tridiagonal form T by an orthogonal similarity
          !> transformation: Q**T * A * Q = T.
          interface sptrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsptrd(uplo,n,ap,d,e,tau,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: ap(*)
                    real(dp),intent(out) :: d(*),e(*),tau(*)
               end subroutine dsptrd
#else
               module procedure la_dsptrd
#endif
               module procedure la_qsptrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssptrd(uplo,n,ap,d,e,tau,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: ap(*)
                    real(sp),intent(out) :: d(*),e(*),tau(*)
               end subroutine ssptrd
#else
               module procedure la_ssptrd
#endif
          end interface sptrd

          !> SPTRF: computes the factorization of a complex symmetric matrix A
          !> stored in packed format using the Bunch-Kaufman diagonal pivoting
          !> method:
          !> A = U*D*U**T  or  A = L*D*L**T
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and D is symmetric and block diagonal with
          !> 1-by-1 and 2-by-2 diagonal blocks.
          interface sptrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csptrf(uplo,n,ap,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(inout) :: ap(*)
               end subroutine csptrf
#else
               module procedure la_csptrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsptrf(uplo,n,ap,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: ap(*)
               end subroutine dsptrf
#else
               module procedure la_dsptrf
#endif
               module procedure la_qsptrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssptrf(uplo,n,ap,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: ap(*)
               end subroutine ssptrf
#else
               module procedure la_ssptrf
#endif
               module procedure la_wsptrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsptrf(uplo,n,ap,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(inout) :: ap(*)
               end subroutine zsptrf
#else
               module procedure la_zsptrf
#endif
          end interface sptrf

          !> SPTRI: computes the inverse of a complex symmetric indefinite matrix
          !> A in packed storage using the factorization A = U*D*U**T or
          !> A = L*D*L**T computed by CSPTRF.
          interface sptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csptri(uplo,n,ap,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    complex(sp),intent(inout) :: ap(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csptri
#else
               module procedure la_csptri
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsptri(uplo,n,ap,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(dp),intent(inout) :: ap(*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsptri
#else
               module procedure la_dsptri
#endif
               module procedure la_qsptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssptri(uplo,n,ap,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    real(sp),intent(inout) :: ap(*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssptri
#else
               module procedure la_ssptri
#endif
               module procedure la_wsptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsptri(uplo,n,ap,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,ipiv(*)
                    complex(dp),intent(inout) :: ap(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsptri
#else
               module procedure la_zsptri
#endif
          end interface sptri

          !> SPTRS: solves a system of linear equations A*X = B with a complex
          !> symmetric matrix A stored in packed format using the factorization
          !> A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
          interface sptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csptrs(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(in) :: ap(*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine csptrs
#else
               module procedure la_csptrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsptrs(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: ap(*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dsptrs
#else
               module procedure la_dsptrs
#endif
               module procedure la_qsptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssptrs(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: ap(*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine ssptrs
#else
               module procedure la_ssptrs
#endif
               module procedure la_wsptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsptrs(uplo,n,nrhs,ap,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(in) :: ap(*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zsptrs
#else
               module procedure la_zsptrs
#endif
          end interface sptrs

          !> STEBZ: computes the eigenvalues of a symmetric tridiagonal
          !> matrix T.  The user may ask for all eigenvalues, all eigenvalues
          !> in the half-open interval (VL, VU], or the IL-th through IU-th
          !> eigenvalues.
          !> To avoid overflow, the matrix must be scaled so that its
          !> largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
          !> accuracy, it should not be much smaller than that.
          !> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !> Matrix", Report CS41, Computer Science Dept., Stanford
          !> University, July 21, 1966.
          interface stebz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dstebz(range,order,n,vl,vu,il,iu,abstol,d,e,m,nsplit,w, &
                          iblock,isplit,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: order,range
                    integer(ilp),intent(in) :: il,iu,n
                    integer(ilp),intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*)
                              
                    real(dp),intent(in) :: abstol,vl,vu,d(*),e(*)
                    real(dp),intent(out) :: w(*),work(*)
               end subroutine dstebz
#else
               module procedure la_dstebz
#endif
               module procedure la_qstebz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sstebz(range,order,n,vl,vu,il,iu,abstol,d,e,m,nsplit,w, &
                          iblock,isplit,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: order,range
                    integer(ilp),intent(in) :: il,iu,n
                    integer(ilp),intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*)
                              
                    real(sp),intent(in) :: abstol,vl,vu,d(*),e(*)
                    real(sp),intent(out) :: w(*),work(*)
               end subroutine sstebz
#else
               module procedure la_sstebz
#endif
          end interface stebz

          !> STEDC: computes all eigenvalues and, optionally, eigenvectors of a
          !> symmetric tridiagonal matrix using the divide and conquer method.
          !> The eigenvectors of a full or band complex Hermitian matrix can also
          !> be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
          !> matrix to tridiagonal form.
          !> This code makes very mild assumptions about floating point
          !> arithmetic. It will work on machines with a guard digit in
          !> add/subtract, or on those binary machines without guard digits
          !> which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
          !> It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.  See SLAED3 for details.
          interface stedc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cstedc(compz,n,d,e,z,ldz,work,lwork,rwork,lrwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: z(ldz,*)
               end subroutine cstedc
#else
               module procedure la_cstedc
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dstedc(compz,n,d,e,z,ldz,work,lwork,iwork,liwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldz,liwork,lwork,n
                    real(dp),intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dstedc
#else
               module procedure la_dstedc
#endif
               module procedure la_qstedc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sstedc(compz,n,d,e,z,ldz,work,lwork,iwork,liwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldz,liwork,lwork,n
                    real(sp),intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp),intent(out) :: work(*)
               end subroutine sstedc
#else
               module procedure la_sstedc
#endif
               module procedure la_wstedc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zstedc(compz,n,d,e,z,ldz,work,lwork,rwork,lrwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: z(ldz,*)
               end subroutine zstedc
#else
               module procedure la_zstedc
#endif
          end interface stedc

          !> STEGR: computes selected eigenvalues and, optionally, eigenvectors
          !> of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
          !> a well defined set of pairwise different real eigenvalues, the corresponding
          !> real eigenvectors are pairwise orthogonal.
          !> The spectrum may be computed either completely or partially by specifying
          !> either an interval (VL,VU] or a range of indices IL:IU for the desired
          !> eigenvalues.
          !> STEGR is a compatibility wrapper around the improved CSTEMR routine.
          !> See SSTEMR for further details.
          !> One important change is that the ABSTOL parameter no longer provides any
          !> benefit and hence is no longer used.
          !> Note : STEGR and CSTEMR work only on machines which follow
          !> IEEE-754 floating-point standard in their handling of infinities and
          !> NaNs.  Normal execution may create these exceptiona values and hence
          !> may abort due to a floating point exception in environments which
          !> do not conform to the IEEE-754 standard.
          interface stegr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cstegr(jobz,range,n,d,e,vl,vu,il,iu,abstol,m,w,z,ldz, &
                         isuppz,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range
                    integer(ilp),intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp),intent(in) :: abstol,vl,vu
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: w(*),work(*)
                    complex(sp),intent(out) :: z(ldz,*)
               end subroutine cstegr
#else
               module procedure la_cstegr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dstegr(jobz,range,n,d,e,vl,vu,il,iu,abstol,m,w,z,ldz, &
                         isuppz,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range
                    integer(ilp),intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp),intent(in) :: abstol,vl,vu
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstegr
#else
               module procedure la_dstegr
#endif
               module procedure la_qstegr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sstegr(jobz,range,n,d,e,vl,vu,il,iu,abstol,m,w,z,ldz, &
                         isuppz,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range
                    integer(ilp),intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp),intent(in) :: abstol,vl,vu
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstegr
#else
               module procedure la_sstegr
#endif
               module procedure la_wstegr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zstegr(jobz,range,n,d,e,vl,vu,il,iu,abstol,m,w,z,ldz, &
                         isuppz,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range
                    integer(ilp),intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp),intent(in) :: abstol,vl,vu
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: w(*),work(*)
                    complex(dp),intent(out) :: z(ldz,*)
               end subroutine zstegr
#else
               module procedure la_zstegr
#endif
          end interface stegr

          !> STEIN: computes the eigenvectors of a real symmetric tridiagonal
          !> matrix T corresponding to specified eigenvalues, using inverse
          !> iteration.
          !> The maximum number of iterations allowed for each eigenvector is
          !> specified by an internal parameter MAXITS (currently set to 5).
          !> Although the eigenvectors are real, they are stored in a complex
          !> array, which may be passed to CUNMTR or CUPMTR for back
          !> transformation to the eigenvectors of a complex Hermitian matrix
          !> which was reduced to tridiagonal form.
          interface stein
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cstein(n,d,e,m,w,iblock,isplit,z,ldz,work,iwork,ifail, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp),intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(sp),intent(in) :: d(*),e(*),w(*)
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(out) :: z(ldz,*)
               end subroutine cstein
#else
               module procedure la_cstein
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dstein(n,d,e,m,w,iblock,isplit,z,ldz,work,iwork,ifail, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp),intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(dp),intent(in) :: d(*),e(*),w(*)
                    real(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine dstein
#else
               module procedure la_dstein
#endif
               module procedure la_qstein
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sstein(n,d,e,m,w,iblock,isplit,z,ldz,work,iwork,ifail, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp),intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(sp),intent(in) :: d(*),e(*),w(*)
                    real(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine sstein
#else
               module procedure la_sstein
#endif
               module procedure la_wstein
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zstein(n,d,e,m,w,iblock,isplit,z,ldz,work,iwork,ifail, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp),intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(dp),intent(in) :: d(*),e(*),w(*)
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(out) :: z(ldz,*)
               end subroutine zstein
#else
               module procedure la_zstein
#endif
          end interface stein

          !> STEMR: computes selected eigenvalues and, optionally, eigenvectors
          !> of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
          !> a well defined set of pairwise different real eigenvalues, the corresponding
          !> real eigenvectors are pairwise orthogonal.
          !> The spectrum may be computed either completely or partially by specifying
          !> either an interval (VL,VU] or a range of indices IL:IU for the desired
          !> eigenvalues.
          !> Depending on the number of desired eigenvalues, these are computed either
          !> by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
          !> computed by the use of various suitable L D L^T factorizations near clusters
          !> of close eigenvalues (referred to as RRRs, Relatively Robust
          !> Representations). An informal sketch of the algorithm follows.
          !> For each unreduced block (submatrix) of T,
          !> (a) Compute T - sigma I  = L D L^T, so that L and D
          !> define all the wanted eigenvalues to high relative accuracy.
          !> This means that small relative changes in the entries of D and L
          !> cause only small relative changes in the eigenvalues and
          !> eigenvectors. The standard (unfactored) representation of the
          !> tridiagonal matrix T does not have this property in general.
          !> (b) Compute the eigenvalues to suitable accuracy.
          !> If the eigenvectors are desired, the algorithm attains full
          !> accuracy of the computed eigenvalues only right before
          !> the corresponding vectors have to be computed, see steps c) and d).
          !> (c) For each cluster of close eigenvalues, select a new
          !> shift close to the cluster, find a new factorization, and refine
          !> the shifted eigenvalues to suitable accuracy.
          !> (d) For each eigenvalue with a large enough relative separation compute
          !> the corresponding eigenvector by forming a rank revealing twisted
          !> factorization. Go back to (c) for any clusters that remain.
          !> For more details, see:
          !> - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
          !> to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
          !> Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
          !> - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
          !> Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
          !> 2004.  Also LAPACK Working Note 154.
          !> - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
          !> tridiagonal eigenvalue/eigenvector problem",
          !> Computer Science Division Technical Report No. UCB/CSD-97-971,
          !> UC Berkeley, May 1997.
          !> Further Details
          !> 1.STEMR works only on machines which follow IEEE-754
          !> floating-point standard in their handling of infinities and NaNs.
          !> This permits the use of efficient inner loops avoiding a check for
          !> zero divisors.
          !> 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
          !> real symmetric tridiagonal form.
          !> (Any complex Hermitean tridiagonal matrix has real values on its diagonal
          !> and potentially complex numbers on its off-diagonals. By applying a
          !> similarity transform with an appropriate diagonal matrix
          !> diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
          !> matrix can be transformed into a real symmetric matrix and complex
          !> arithmetic can be entirely avoided.)
          !> While the eigenvectors of the real symmetric tridiagonal matrix are real,
          !> the eigenvectors of original complex Hermitean matrix have complex entries
          !> in general.
          !> Since LAPACK drivers overwrite the matrix data with the eigenvectors,
          !> STEMR accepts complex workspace to facilitate interoperability
          !> with CUNMTR or CUPMTR.
          interface stemr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cstemr(jobz,range,n,d,e,vl,vu,il,iu,m,w,z,ldz,nzc, &
                         isuppz,tryrac,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range
                    logical(lk),intent(inout) :: tryrac
                    integer(ilp),intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp),intent(in) :: vl,vu
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: w(*),work(*)
                    complex(sp),intent(out) :: z(ldz,*)
               end subroutine cstemr
#else
               module procedure la_cstemr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dstemr(jobz,range,n,d,e,vl,vu,il,iu,m,w,z,ldz,nzc, &
                         isuppz,tryrac,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range
                    logical(lk),intent(inout) :: tryrac
                    integer(ilp),intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp),intent(in) :: vl,vu
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstemr
#else
               module procedure la_dstemr
#endif
               module procedure la_qstemr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sstemr(jobz,range,n,d,e,vl,vu,il,iu,m,w,z,ldz,nzc, &
                         isuppz,tryrac,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range
                    logical(lk),intent(inout) :: tryrac
                    integer(ilp),intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp),intent(in) :: vl,vu
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstemr
#else
               module procedure la_sstemr
#endif
               module procedure la_wstemr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zstemr(jobz,range,n,d,e,vl,vu,il,iu,m,w,z,ldz,nzc, &
                         isuppz,tryrac,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range
                    logical(lk),intent(inout) :: tryrac
                    integer(ilp),intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp),intent(in) :: vl,vu
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: w(*),work(*)
                    complex(dp),intent(out) :: z(ldz,*)
               end subroutine zstemr
#else
               module procedure la_zstemr
#endif
          end interface stemr

          !> STEQR: computes all eigenvalues and, optionally, eigenvectors of a
          !> symmetric tridiagonal matrix using the implicit QL or QR method.
          !> The eigenvectors of a full or band complex Hermitian matrix can also
          !> be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
          !> matrix to tridiagonal form.
          interface steqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csteqr(compz,n,d,e,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: z(ldz,*)
               end subroutine csteqr
#else
               module procedure la_csteqr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsteqr(compz,n,d,e,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(dp),intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsteqr
#else
               module procedure la_dsteqr
#endif
               module procedure la_qsteqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssteqr(compz,n,d,e,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(sp),intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssteqr
#else
               module procedure la_ssteqr
#endif
               module procedure la_wsteqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsteqr(compz,n,d,e,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compz
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: z(ldz,*)
               end subroutine zsteqr
#else
               module procedure la_zsteqr
#endif
          end interface steqr

          !> STERF: computes all eigenvalues of a symmetric tridiagonal matrix
          !> using the Pal-Walker-Kahan variant of the QL or QR algorithm.
          interface sterf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsterf(n,d,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: d(*),e(*)
               end subroutine dsterf
#else
               module procedure la_dsterf
#endif
               module procedure la_qsterf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssterf(n,d,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: d(*),e(*)
               end subroutine ssterf
#else
               module procedure la_ssterf
#endif
          end interface sterf

          !> STEV: computes all eigenvalues and, optionally, eigenvectors of a
          !> real symmetric tridiagonal matrix A.
          interface stev
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dstev(jobz,n,d,e,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine dstev
#else
               module procedure la_dstev
#endif
               module procedure la_qstev
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sstev(jobz,n,d,e,z,ldz,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldz,n
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine sstev
#else
               module procedure la_sstev
#endif
          end interface stev

          !> STEVD: computes all eigenvalues and, optionally, eigenvectors of a
          !> real symmetric tridiagonal matrix. If eigenvectors are desired, it
          !> uses a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface stevd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dstevd(jobz,n,d,e,z,ldz,work,lwork,iwork,liwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldz,liwork,lwork,n
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: work(*),z(ldz,*)
               end subroutine dstevd
#else
               module procedure la_dstevd
#endif
               module procedure la_qstevd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sstevd(jobz,n,d,e,z,ldz,work,lwork,iwork,liwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldz,liwork,lwork,n
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: work(*),z(ldz,*)
               end subroutine sstevd
#else
               module procedure la_sstevd
#endif
          end interface stevd

          !> STEVR: computes selected eigenvalues and, optionally, eigenvectors
          !> of a real symmetric tridiagonal matrix T.  Eigenvalues and
          !> eigenvectors can be selected by specifying either a range of values
          !> or a range of indices for the desired eigenvalues.
          !> Whenever possible, STEVR calls DSTEMR to compute the
          !> eigenspectrum using Relatively Robust Representations.  DSTEMR
          !> computes eigenvalues by the dqds algorithm, while orthogonal
          !> eigenvectors are computed from various "good" L D L^T representations
          !> (also known as Relatively Robust Representations). Gram-Schmidt
          !> orthogonalization is avoided as far as possible. More specifically,
          !> the various steps of the algorithm are as follows. For the i-th
          !> unreduced block of T,
          !> (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
          !> is a relatively robust representation,
          !> (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
          !> relative accuracy by the dqds algorithm,
          !> (c) If there is a cluster of close eigenvalues, "choose" sigma_i
          !> close to the cluster, and go to step (a),
          !> (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
          !> compute the corresponding eigenvector by forming a
          !> rank-revealing twisted factorization.
          !> The desired accuracy of the output can be specified by the input
          !> parameter ABSTOL.
          !> For more details, see "A new O(n^2) algorithm for the symmetric
          !> tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
          !> Computer Science Division Technical Report No. UCB//CSD-97-971,
          !> UC Berkeley, May 1997.
          !> Note 1 : STEVR calls DSTEMR when the full spectrum is requested
          !> on machines which conform to the ieee-754 floating point standard.
          !> STEVR calls DSTEBZ and DSTEIN on non-ieee machines and
          !> when partial spectrum requests are made.
          !> Normal execution of DSTEMR may create NaNs and infinities and
          !> hence may abort due to a floating point exception in environments
          !> which do not handle NaNs and infinities in the ieee standard default
          !> manner.
          interface stevr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dstevr(jobz,range,n,d,e,vl,vu,il,iu,abstol,m,w,z,ldz, &
                         isuppz,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range
                    integer(ilp),intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp),intent(in) :: abstol,vl,vu
                    real(dp),intent(inout) :: d(*),e(*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstevr
#else
               module procedure la_dstevr
#endif
               module procedure la_qstevr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine sstevr(jobz,range,n,d,e,vl,vu,il,iu,abstol,m,w,z,ldz, &
                         isuppz,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range
                    integer(ilp),intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp),intent(in) :: abstol,vl,vu
                    real(sp),intent(inout) :: d(*),e(*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstevr
#else
               module procedure la_sstevr
#endif
          end interface stevr

          !> SYCON: estimates the reciprocal of the condition number (in the
          !> 1-norm) of a complex symmetric matrix A using the factorization
          !> A = U*D*U**T or A = L*D*L**T computed by CSYTRF.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
          interface sycon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csycon(uplo,n,a,lda,ipiv,anorm,rcond,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csycon
#else
               module procedure la_csycon
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsycon(uplo,n,a,lda,ipiv,anorm,rcond,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(dp),intent(in) :: anorm,a(lda,*)
                    real(dp),intent(out) :: rcond,work(*)
               end subroutine dsycon
#else
               module procedure la_dsycon
#endif
               module procedure la_qsycon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssycon(uplo,n,a,lda,ipiv,anorm,rcond,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(sp),intent(in) :: anorm,a(lda,*)
                    real(sp),intent(out) :: rcond,work(*)
               end subroutine ssycon
#else
               module procedure la_ssycon
#endif
               module procedure la_wsycon
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsycon(uplo,n,a,lda,ipiv,anorm,rcond,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsycon
#else
               module procedure la_zsycon
#endif
          end interface sycon

          !> SYCON_ROOK: estimates the reciprocal of the condition number (in the
          !> 1-norm) of a complex symmetric matrix A using the factorization
          !> A = U*D*U**T or A = L*D*L**T computed by CSYTRF_ROOK.
          !> An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !> condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
          interface sycon_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csycon_rook(uplo,n,a,lda,ipiv,anorm,rcond,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(sp),intent(in) :: anorm
                    real(sp),intent(out) :: rcond
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csycon_rook
#else
               module procedure la_csycon_rook
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsycon_rook(uplo,n,a,lda,ipiv,anorm,rcond,work,iwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(dp),intent(in) :: anorm,a(lda,*)
                    real(dp),intent(out) :: rcond,work(*)
               end subroutine dsycon_rook
#else
               module procedure la_dsycon_rook
#endif
               module procedure la_qsycon_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssycon_rook(uplo,n,a,lda,ipiv,anorm,rcond,work,iwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(sp),intent(in) :: anorm,a(lda,*)
                    real(sp),intent(out) :: rcond,work(*)
               end subroutine ssycon_rook
#else
               module procedure la_ssycon_rook
#endif
               module procedure la_wsycon_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsycon_rook(uplo,n,a,lda,ipiv,anorm,rcond,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(dp),intent(in) :: anorm
                    real(dp),intent(out) :: rcond
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsycon_rook
#else
               module procedure la_zsycon_rook
#endif
          end interface sycon_rook

          !> SYCONV: convert A given by TRF into L and D and vice-versa.
          !> Get Non-diag elements of D (returned in workspace) and
          !> apply or reverse permutation done in TRF.
          interface syconv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csyconv(uplo,way,n,a,lda,ipiv,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: e(*)
               end subroutine csyconv
#else
               module procedure la_csyconv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsyconv(uplo,way,n,a,lda,ipiv,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: e(*)
               end subroutine dsyconv
#else
               module procedure la_dsyconv
#endif
               module procedure la_qsyconv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssyconv(uplo,way,n,a,lda,ipiv,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: e(*)
               end subroutine ssyconv
#else
               module procedure la_ssyconv
#endif
               module procedure la_wsyconv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsyconv(uplo,way,n,a,lda,ipiv,e,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: e(*)
               end subroutine zsyconv
#else
               module procedure la_zsyconv
#endif
          end interface syconv

          !> If parameter WAY = 'C':
          !> SYCONVF: converts the factorization output format used in
          !> CSYTRF provided on entry in parameter A into the factorization
          !> output format used in CSYTRF_RK (or CSYTRF_BK) that is stored
          !> on exit in parameters A and E. It also converts in place details of
          !> the intechanges stored in IPIV from the format used in CSYTRF into
          !> the format used in CSYTRF_RK (or CSYTRF_BK).
          !> If parameter WAY = 'R':
          !> SYCONVF performs the conversion in reverse direction, i.e.
          !> converts the factorization output format used in CSYTRF_RK
          !> (or CSYTRF_BK) provided on entry in parameters A and E into
          !> the factorization output format used in CSYTRF that is stored
          !> on exit in parameter A. It also converts in place details of
          !> the intechanges stored in IPIV from the format used in CSYTRF_RK
          !> (or CSYTRF_BK) into the format used in CSYTRF.
          !> SYCONVF can also convert in Hermitian matrix case, i.e. between
          !> formats used in CHETRF and CHETRF_RK (or CHETRF_BK).
          interface syconvf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csyconvf(uplo,way,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    integer(ilp),intent(inout) :: ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*),e(*)
               end subroutine csyconvf
#else
               module procedure la_csyconvf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsyconvf(uplo,way,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    integer(ilp),intent(inout) :: ipiv(*)
                    real(dp),intent(inout) :: a(lda,*),e(*)
               end subroutine dsyconvf
#else
               module procedure la_dsyconvf
#endif
               module procedure la_qsyconvf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssyconvf(uplo,way,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    integer(ilp),intent(inout) :: ipiv(*)
                    real(sp),intent(inout) :: a(lda,*),e(*)
               end subroutine ssyconvf
#else
               module procedure la_ssyconvf
#endif
               module procedure la_wsyconvf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsyconvf(uplo,way,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    integer(ilp),intent(inout) :: ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*),e(*)
               end subroutine zsyconvf
#else
               module procedure la_zsyconvf
#endif
          end interface syconvf

          !> If parameter WAY = 'C':
          !> SYCONVF_ROOK: converts the factorization output format used in
          !> CSYTRF_ROOK provided on entry in parameter A into the factorization
          !> output format used in CSYTRF_RK (or CSYTRF_BK) that is stored
          !> on exit in parameters A and E. IPIV format for CSYTRF_ROOK and
          !> CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.
          !> If parameter WAY = 'R':
          !> SYCONVF_ROOK performs the conversion in reverse direction, i.e.
          !> converts the factorization output format used in CSYTRF_RK
          !> (or CSYTRF_BK) provided on entry in parameters A and E into
          !> the factorization output format used in CSYTRF_ROOK that is stored
          !> on exit in parameter A. IPIV format for CSYTRF_ROOK and
          !> CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.
          !> SYCONVF_ROOK can also convert in Hermitian matrix case, i.e. between
          !> formats used in CHETRF_ROOK and CHETRF_RK (or CHETRF_BK).
          interface syconvf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csyconvf_rook(uplo,way,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*),e(*)
               end subroutine csyconvf_rook
#else
               module procedure la_csyconvf_rook
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsyconvf_rook(uplo,way,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(dp),intent(inout) :: a(lda,*),e(*)
               end subroutine dsyconvf_rook
#else
               module procedure la_dsyconvf_rook
#endif
               module procedure la_qsyconvf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssyconvf_rook(uplo,way,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(sp),intent(inout) :: a(lda,*),e(*)
               end subroutine ssyconvf_rook
#else
               module procedure la_ssyconvf_rook
#endif
               module procedure la_wsyconvf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsyconvf_rook(uplo,way,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo,way
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*),e(*)
               end subroutine zsyconvf_rook
#else
               module procedure la_zsyconvf_rook
#endif
          end interface syconvf_rook

          !> SYEQUB: computes row and column scalings intended to equilibrate a
          !> symmetric matrix A (with respect to the Euclidean norm) and reduce
          !> its condition number. The scale factors S are computed by the BIN
          !> algorithm (see references) so that the scaled matrix B with elements
          !> B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
          !> the smallest possible condition number over all possible diagonal
          !> scalings.
          interface syequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csyequb(uplo,n,a,lda,s,scond,amax,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: amax,scond,s(*)
                    character,intent(in) :: uplo
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csyequb
#else
               module procedure la_csyequb
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsyequb(uplo,n,a,lda,s,scond,amax,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: amax,scond,s(*),work(*)
                    character,intent(in) :: uplo
                    real(dp),intent(in) :: a(lda,*)
               end subroutine dsyequb
#else
               module procedure la_dsyequb
#endif
               module procedure la_qsyequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssyequb(uplo,n,a,lda,s,scond,amax,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: amax,scond,s(*),work(*)
                    character,intent(in) :: uplo
                    real(sp),intent(in) :: a(lda,*)
               end subroutine ssyequb
#else
               module procedure la_ssyequb
#endif
               module procedure la_wsyequb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsyequb(uplo,n,a,lda,s,scond,amax,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: amax,scond,s(*)
                    character,intent(in) :: uplo
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsyequb
#else
               module procedure la_zsyequb
#endif
          end interface syequb

          !> SYEV: computes all eigenvalues and, optionally, eigenvectors of a
          !> real symmetric matrix A.
          interface syev
#ifdef LA_EXTERNAL_LAPACK
               subroutine dsyev(jobz,uplo,n,a,lda,w,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: w(*),work(*)
               end subroutine dsyev
#else
               module procedure la_dsyev
#endif
               module procedure la_qsyev
#ifdef LA_EXTERNAL_LAPACK
               subroutine ssyev(jobz,uplo,n,a,lda,w,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: w(*),work(*)
               end subroutine ssyev
#else
               module procedure la_ssyev
#endif
          end interface syev

          !> SYEVD: computes all eigenvalues and, optionally, eigenvectors of a
          !> real symmetric matrix A. If eigenvectors are desired, it uses a
          !> divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          !> Because of large use of BLAS of level 3, SYEVD needs N**2 more
          !> workspace than DSYEVX.
          interface syevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine dsyevd(jobz,uplo,n,a,lda,w,work,lwork,iwork,liwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,liwork,lwork,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: w(*),work(*)
               end subroutine dsyevd
#else
               module procedure la_dsyevd
#endif
               module procedure la_qsyevd
#ifdef LA_EXTERNAL_LAPACK
               subroutine ssyevd(jobz,uplo,n,a,lda,w,work,lwork,iwork,liwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,liwork,lwork,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: w(*),work(*)
               end subroutine ssyevd
#else
               module procedure la_ssyevd
#endif
          end interface syevd

          !> SYEVR: computes selected eigenvalues and, optionally, eigenvectors
          !> of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
          !> selected by specifying either a range of values or a range of
          !> indices for the desired eigenvalues.
          !> SYEVR first reduces the matrix A to tridiagonal form T with a call
          !> to DSYTRD.  Then, whenever possible, SYEVR calls DSTEMR to compute
          !> the eigenspectrum using Relatively Robust Representations.  DSTEMR
          !> computes eigenvalues by the dqds algorithm, while orthogonal
          !> eigenvectors are computed from various "good" L D L^T representations
          !> (also known as Relatively Robust Representations). Gram-Schmidt
          !> orthogonalization is avoided as far as possible. More specifically,
          !> the various steps of the algorithm are as follows.
          !> For each unreduced block (submatrix) of T,
          !> (a) Compute T - sigma I  = L D L^T, so that L and D
          !> define all the wanted eigenvalues to high relative accuracy.
          !> This means that small relative changes in the entries of D and L
          !> cause only small relative changes in the eigenvalues and
          !> eigenvectors. The standard (unfactored) representation of the
          !> tridiagonal matrix T does not have this property in general.
          !> (b) Compute the eigenvalues to suitable accuracy.
          !> If the eigenvectors are desired, the algorithm attains full
          !> accuracy of the computed eigenvalues only right before
          !> the corresponding vectors have to be computed, see steps c) and d).
          !> (c) For each cluster of close eigenvalues, select a new
          !> shift close to the cluster, find a new factorization, and refine
          !> the shifted eigenvalues to suitable accuracy.
          !> (d) For each eigenvalue with a large enough relative separation compute
          !> the corresponding eigenvector by forming a rank revealing twisted
          !> factorization. Go back to (c) for any clusters that remain.
          !> The desired accuracy of the output can be specified by the input
          !> parameter ABSTOL.
          !> For more details, see DSTEMR's documentation and:
          !> - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
          !> to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
          !> Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
          !> - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
          !> Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
          !> 2004.  Also LAPACK Working Note 154.
          !> - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
          !> tridiagonal eigenvalue/eigenvector problem",
          !> Computer Science Division Technical Report No. UCB/CSD-97-971,
          !> UC Berkeley, May 1997.
          !> Note 1 : SYEVR calls DSTEMR when the full spectrum is requested
          !> on machines which conform to the ieee-754 floating point standard.
          !> SYEVR calls DSTEBZ and DSTEIN on non-ieee machines and
          !> when partial spectrum requests are made.
          !> Normal execution of DSTEMR may create NaNs and infinities and
          !> hence may abort due to a floating point exception in environments
          !> which do not handle NaNs and infinities in the ieee standard default
          !> manner.
          interface syevr
#ifdef LA_EXTERNAL_LAPACK
               subroutine dsyevr(jobz,range,uplo,n,a,lda,vl,vu,il,iu,abstol,m,w,z, &
                         ldz,isuppz,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range,uplo
                    integer(ilp),intent(in) :: il,iu,lda,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp),intent(in) :: abstol,vl,vu
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsyevr
#else
               module procedure la_dsyevr
#endif
               module procedure la_qsyevr
#ifdef LA_EXTERNAL_LAPACK
               subroutine ssyevr(jobz,range,uplo,n,a,lda,vl,vu,il,iu,abstol,m,w,z, &
                         ldz,isuppz,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,range,uplo
                    integer(ilp),intent(in) :: il,iu,lda,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp),intent(in) :: abstol,vl,vu
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssyevr
#else
               module procedure la_ssyevr
#endif
          end interface syevr

          !> SYGST: reduces a real symmetric-definite generalized eigenproblem
          !> to standard form.
          !> If ITYPE = 1, the problem is A*x = lambda*B*x,
          !> and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
          !> If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !> B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
          !> B must have been previously factorized as U**T*U or L*L**T by DPOTRF.
          interface sygst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsygst(itype,uplo,n,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,lda,ldb,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(in) :: b(ldb,*)
               end subroutine dsygst
#else
               module procedure la_dsygst
#endif
               module procedure la_qsygst
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssygst(itype,uplo,n,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,lda,ldb,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(in) :: b(ldb,*)
               end subroutine ssygst
#else
               module procedure la_ssygst
#endif
          end interface sygst

          !> SYGV: computes all the eigenvalues, and optionally, the eigenvectors
          !> of a real generalized symmetric-definite eigenproblem, of the form
          !> A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !> Here A and B are assumed to be symmetric and B is also
          !> positive definite.
          interface sygv
#ifdef LA_EXTERNAL_LAPACK
               subroutine dsygv(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,lda,ldb,lwork,n
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: w(*),work(*)
               end subroutine dsygv
#else
               module procedure la_dsygv
#endif
               module procedure la_qsygv
#ifdef LA_EXTERNAL_LAPACK
               subroutine ssygv(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: itype,lda,ldb,lwork,n
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: w(*),work(*)
               end subroutine ssygv
#else
               module procedure la_ssygv
#endif
          end interface sygv

          !> SYGVD: computes all the eigenvalues, and optionally, the eigenvectors
          !> of a real generalized symmetric-definite eigenproblem, of the form
          !> A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !> B are assumed to be symmetric and B is also positive definite.
          !> If eigenvectors are desired, it uses a divide and conquer algorithm.
          !> The divide and conquer algorithm makes very mild assumptions about
          !> floating point arithmetic. It will work on machines with a guard
          !> digit in add/subtract, or on those binary machines without guard
          !> digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !> Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !> without guard digits, but we know of none.
          interface sygvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine dsygvd(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: itype,lda,ldb,liwork,lwork,n
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: w(*),work(*)
               end subroutine dsygvd
#else
               module procedure la_dsygvd
#endif
               module procedure la_qsygvd
#ifdef LA_EXTERNAL_LAPACK
               subroutine ssygvd(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,iwork, &
                         liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobz,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: itype,lda,ldb,liwork,lwork,n
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: w(*),work(*)
               end subroutine ssygvd
#else
               module procedure la_ssygvd
#endif
          end interface sygvd

          !> SYMV:  performs the matrix-vector  operation
          !> y := alpha*A*x + beta*y,
          !> where alpha and beta are scalars, x and y are n element vectors and
          !> A is an n by n symmetric matrix.
          interface symv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csymv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incx,incy,lda,n
                    complex(sp),intent(in) :: alpha,beta,a(lda,*),x(*)
                    complex(sp),intent(inout) :: y(*)
               end subroutine csymv
#else
               module procedure la_csymv
#endif
               module procedure la_wsymv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsymv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incx,incy,lda,n
                    complex(dp),intent(in) :: alpha,beta,a(lda,*),x(*)
                    complex(dp),intent(inout) :: y(*)
               end subroutine zsymv
#else
               module procedure la_zsymv
#endif
          end interface symv

          !> SYR:   performs the symmetric rank 1 operation
          !> A := alpha*x*x**H + A,
          !> where alpha is a complex scalar, x is an n element vector and A is an
          !> n by n symmetric matrix.
          interface syr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csyr(uplo,n,alpha,x,incx,a,lda)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incx,lda,n
                    complex(sp),intent(in) :: alpha,x(*)
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine csyr
#else
               module procedure la_csyr
#endif
               module procedure la_wsyr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsyr(uplo,n,alpha,x,incx,a,lda)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: incx,lda,n
                    complex(dp),intent(in) :: alpha,x(*)
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zsyr
#else
               module procedure la_zsyr
#endif
          end interface syr

          !> SYRFS: improves the computed solution to a system of linear
          !> equations when the coefficient matrix is symmetric indefinite, and
          !> provides error bounds and backward error estimates for the solution.
          interface syrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csyrfs(uplo,n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,ferr, &
                          berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x(ldx,*)
               end subroutine csyrfs
#else
               module procedure la_csyrfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsyrfs(uplo,n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,ferr, &
                          berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
                    real(dp),intent(inout) :: x(ldx,*)
               end subroutine dsyrfs
#else
               module procedure la_dsyrfs
#endif
               module procedure la_qsyrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssyrfs(uplo,n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,ferr, &
                          berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
                    real(sp),intent(inout) :: x(ldx,*)
               end subroutine ssyrfs
#else
               module procedure la_ssyrfs
#endif
               module procedure la_wsyrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsyrfs(uplo,n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,ferr, &
                          berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x(ldx,*)
               end subroutine zsyrfs
#else
               module procedure la_zsyrfs
#endif
          end interface syrfs

          !> SYSV: computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
          !> matrices.
          !> The diagonal pivoting method is used to factor A as
          !> A = U * D * U**T,  if UPLO = 'U', or
          !> A = L * D * L**T,  if UPLO = 'L',
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and D is symmetric and block diagonal with
          !> 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
          !> used to solve the system of equations A * X = B.
          interface sysv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csysv(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csysv
#else
               module procedure la_csysv
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsysv(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsysv
#else
               module procedure la_dsysv
#endif
               module procedure la_qsysv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssysv(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssysv
#else
               module procedure la_ssysv
#endif
               module procedure la_wsysv
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsysv(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsysv
#else
               module procedure la_zsysv
#endif
          end interface sysv

          !> CSYSV computes the solution to a complex system of linear equations
          !> A * X = B,
          !> where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
          !> matrices.
          !> Aasen's algorithm is used to factor A as
          !> A = U**T * T * U,  if UPLO = 'U', or
          !> A = L * T * L**T,  if UPLO = 'L',
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and T is symmetric tridiagonal. The factored
          !> form of A is then used to solve the system of equations A * X = B.
          interface sysv_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csysv_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csysv_aa
#else
               module procedure la_csysv_aa
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsysv_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsysv_aa
#else
               module procedure la_dsysv_aa
#endif
               module procedure la_qsysv_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssysv_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssysv_aa
#else
               module procedure la_ssysv_aa
#endif
               module procedure la_wsysv_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsysv_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsysv_aa
#else
               module procedure la_zsysv_aa
#endif
          end interface sysv_aa

          !> SYSV_RK: computes the solution to a complex system of linear
          !> equations A * X = B, where A is an N-by-N symmetric matrix
          !> and X and B are N-by-NRHS matrices.
          !> The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
          !> to factor A as
          !> A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
          !> A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
          !> where U (or L) is unit upper (or lower) triangular matrix,
          !> U**T (or L**T) is the transpose of U (or L), P is a permutation
          !> matrix, P**T is the transpose of P, and D is symmetric and block
          !> diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !> CSYTRF_RK is called to compute the factorization of a complex
          !> symmetric matrix.  The factored form of A is then used to solve
          !> the system of equations A * X = B by calling BLAS3 routine CSYTRS_3.
          interface sysv_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csysv_rk(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: e(*),work(*)
               end subroutine csysv_rk
#else
               module procedure la_csysv_rk
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsysv_rk(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: e(*),work(*)
               end subroutine dsysv_rk
#else
               module procedure la_dsysv_rk
#endif
               module procedure la_qsysv_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssysv_rk(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: e(*),work(*)
               end subroutine ssysv_rk
#else
               module procedure la_ssysv_rk
#endif
               module procedure la_wsysv_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsysv_rk(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: e(*),work(*)
               end subroutine zsysv_rk
#else
               module procedure la_zsysv_rk
#endif
          end interface sysv_rk

          !> SYSV_ROOK: computes the solution to a complex system of linear
          !> equations
          !> A * X = B,
          !> where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
          !> matrices.
          !> The diagonal pivoting method is used to factor A as
          !> A = U * D * U**T,  if UPLO = 'U', or
          !> A = L * D * L**T,  if UPLO = 'L',
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and D is symmetric and block diagonal with
          !> 1-by-1 and 2-by-2 diagonal blocks.
          !> CSYTRF_ROOK is called to compute the factorization of a complex
          !> symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
          !> pivoting method.
          !> The factored form of A is then used to solve the system
          !> of equations A * X = B by calling CSYTRS_ROOK.
          interface sysv_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csysv_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csysv_rook
#else
               module procedure la_csysv_rook
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsysv_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsysv_rook
#else
               module procedure la_dsysv_rook
#endif
               module procedure la_qsysv_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssysv_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssysv_rook
#else
               module procedure la_ssysv_rook
#endif
               module procedure la_wsysv_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsysv_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsysv_rook
#else
               module procedure la_zsysv_rook
#endif
          end interface sysv_rook

          !> SYSWAPR: applies an elementary permutation on the rows and the columns of
          !> a symmetric matrix.
          interface syswapr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csyswapr(uplo,n,a,lda,i1,i2)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: i1,i2,lda,n
                    complex(sp),intent(inout) :: a(lda,n)
               end subroutine csyswapr
#else
               module procedure la_csyswapr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsyswapr(uplo,n,a,lda,i1,i2)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: i1,i2,lda,n
                    real(dp),intent(inout) :: a(lda,n)
               end subroutine dsyswapr
#else
               module procedure la_dsyswapr
#endif
               module procedure la_qsyswapr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssyswapr(uplo,n,a,lda,i1,i2)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: i1,i2,lda,n
                    real(sp),intent(inout) :: a(lda,n)
               end subroutine ssyswapr
#else
               module procedure la_ssyswapr
#endif
               module procedure la_wsyswapr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsyswapr(uplo,n,a,lda,i1,i2)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: i1,i2,lda,n
                    complex(dp),intent(inout) :: a(lda,n)
               end subroutine zsyswapr
#else
               module procedure la_zsyswapr
#endif
          end interface syswapr

          !> SYTF2_RK: computes the factorization of a complex symmetric matrix A
          !> using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !> A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
          !> where U (or L) is unit upper (or lower) triangular matrix,
          !> U**T (or L**T) is the transpose of U (or L), P is a permutation
          !> matrix, P**T is the transpose of P, and D is symmetric and block
          !> diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !> This is the unblocked version of the algorithm, calling Level 2 BLAS.
          !> For more information see Further Details section.
          interface sytf2_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytf2_rk(uplo,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: e(*)
               end subroutine csytf2_rk
#else
               module procedure la_csytf2_rk
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytf2_rk(uplo,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: e(*)
               end subroutine dsytf2_rk
#else
               module procedure la_dsytf2_rk
#endif
               module procedure la_qsytf2_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytf2_rk(uplo,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: e(*)
               end subroutine ssytf2_rk
#else
               module procedure la_ssytf2_rk
#endif
               module procedure la_wsytf2_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytf2_rk(uplo,n,a,lda,e,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: e(*)
               end subroutine zsytf2_rk
#else
               module procedure la_zsytf2_rk
#endif
          end interface sytf2_rk

          !> SYTF2_ROOK: computes the factorization of a complex symmetric matrix A
          !> using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
          !> A = U*D*U**T  or  A = L*D*L**T
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, U**T is the transpose of U, and D is symmetric and
          !> block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !> This is the unblocked version of the algorithm, calling Level 2 BLAS.
          interface sytf2_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytf2_rook(uplo,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine csytf2_rook
#else
               module procedure la_csytf2_rook
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytf2_rook(uplo,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dsytf2_rook
#else
               module procedure la_dsytf2_rook
#endif
               module procedure la_qsytf2_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytf2_rook(uplo,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine ssytf2_rook
#else
               module procedure la_ssytf2_rook
#endif
               module procedure la_wsytf2_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytf2_rook(uplo,n,a,lda,ipiv,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,n
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine zsytf2_rook
#else
               module procedure la_zsytf2_rook
#endif
          end interface sytf2_rook

          !> SYTRD: reduces a real symmetric matrix A to real symmetric
          !> tridiagonal form T by an orthogonal similarity transformation:
          !> Q**T * A * Q = T.
          interface sytrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrd(uplo,n,a,lda,d,e,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: d(*),e(*),tau(*),work(*)
               end subroutine dsytrd
#else
               module procedure la_dsytrd
#endif
               module procedure la_qsytrd
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrd(uplo,n,a,lda,d,e,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: d(*),e(*),tau(*),work(*)
               end subroutine ssytrd
#else
               module procedure la_ssytrd
#endif
          end interface sytrd

          !> SYTRD_SB2ST: reduces a real symmetric band matrix A to real symmetric
          !> tridiagonal form T by a orthogonal similarity transformation:
          !> Q**T * A * Q = T.
          interface sytrd_sb2st
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrd_sb2st(stage1,vect,uplo,n,kd,ab,ldab,d,e,hous, &
                         lhous,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: stage1,uplo,vect
                    integer(ilp),intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp),intent(out) :: info
                    real(dp),intent(out) :: d(*),e(*),hous(*),work(*)
                    real(dp),intent(inout) :: ab(ldab,*)
               end subroutine dsytrd_sb2st
#else
               module procedure la_dsytrd_sb2st
#endif
               module procedure la_qsytrd_sb2st
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrd_sb2st(stage1,vect,uplo,n,kd,ab,ldab,d,e,hous, &
                         lhous,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: stage1,uplo,vect
                    integer(ilp),intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp),intent(out) :: info
                    real(sp),intent(out) :: d(*),e(*),hous(*),work(*)
                    real(sp),intent(inout) :: ab(ldab,*)
               end subroutine ssytrd_sb2st
#else
               module procedure la_ssytrd_sb2st
#endif
          end interface sytrd_sb2st

          !> SYTRD_SY2SB: reduces a real symmetric matrix A to real symmetric
          !> band-diagonal form AB by a orthogonal similarity transformation:
          !> Q**T * A * Q = AB.
          interface sytrd_sy2sb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrd_sy2sb(uplo,n,kd,a,lda,ab,ldab,tau,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldab,lwork,n,kd
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine dsytrd_sy2sb
#else
               module procedure la_dsytrd_sy2sb
#endif
               module procedure la_qsytrd_sy2sb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrd_sy2sb(uplo,n,kd,a,lda,ab,ldab,tau,work,lwork,info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldab,lwork,n,kd
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine ssytrd_sy2sb
#else
               module procedure la_ssytrd_sy2sb
#endif
          end interface sytrd_sy2sb

          !> SYTRF: computes the factorization of a complex symmetric matrix A
          !> using the Bunch-Kaufman diagonal pivoting method.  The form of the
          !> factorization is
          !> A = U*D*U**T  or  A = L*D*L**T
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and D is symmetric and block diagonal with
          !> 1-by-1 and 2-by-2 diagonal blocks.
          !> This is the blocked version of the algorithm, calling Level 3 BLAS.
          interface sytrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytrf(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csytrf
#else
               module procedure la_csytrf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrf(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsytrf
#else
               module procedure la_dsytrf
#endif
               module procedure la_qsytrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrf(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssytrf
#else
               module procedure la_ssytrf
#endif
               module procedure la_wsytrf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytrf(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsytrf
#else
               module procedure la_zsytrf
#endif
          end interface sytrf

          !> SYTRF_AA: computes the factorization of a complex symmetric matrix A
          !> using the Aasen's algorithm.  The form of the factorization is
          !> A = U**T*T*U  or  A = L*T*L**T
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and T is a complex symmetric tridiagonal matrix.
          !> This is the blocked version of the algorithm, calling Level 3 BLAS.
          interface sytrf_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytrf_aa(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,lda,lwork
                    integer(ilp),intent(out) :: info,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csytrf_aa
#else
               module procedure la_csytrf_aa
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrf_aa(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,lda,lwork
                    integer(ilp),intent(out) :: info,ipiv(*)
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsytrf_aa
#else
               module procedure la_dsytrf_aa
#endif
               module procedure la_qsytrf_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrf_aa(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,lda,lwork
                    integer(ilp),intent(out) :: info,ipiv(*)
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssytrf_aa
#else
               module procedure la_ssytrf_aa
#endif
               module procedure la_wsytrf_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytrf_aa(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,lda,lwork
                    integer(ilp),intent(out) :: info,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsytrf_aa
#else
               module procedure la_zsytrf_aa
#endif
          end interface sytrf_aa

          !> SYTRF_RK: computes the factorization of a complex symmetric matrix A
          !> using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !> A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
          !> where U (or L) is unit upper (or lower) triangular matrix,
          !> U**T (or L**T) is the transpose of U (or L), P is a permutation
          !> matrix, P**T is the transpose of P, and D is symmetric and block
          !> diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !> This is the blocked version of the algorithm, calling Level 3 BLAS.
          !> For more information see Further Details section.
          interface sytrf_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytrf_rk(uplo,n,a,lda,e,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: e(*),work(*)
               end subroutine csytrf_rk
#else
               module procedure la_csytrf_rk
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrf_rk(uplo,n,a,lda,e,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: e(*),work(*)
               end subroutine dsytrf_rk
#else
               module procedure la_dsytrf_rk
#endif
               module procedure la_qsytrf_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrf_rk(uplo,n,a,lda,e,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: e(*),work(*)
               end subroutine ssytrf_rk
#else
               module procedure la_ssytrf_rk
#endif
               module procedure la_wsytrf_rk
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytrf_rk(uplo,n,a,lda,e,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: e(*),work(*)
               end subroutine zsytrf_rk
#else
               module procedure la_zsytrf_rk
#endif
          end interface sytrf_rk

          !> SYTRF_ROOK: computes the factorization of a complex symmetric matrix A
          !> using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
          !> The form of the factorization is
          !> A = U*D*U**T  or  A = L*D*L**T
          !> where U (or L) is a product of permutation and unit upper (lower)
          !> triangular matrices, and D is symmetric and block diagonal with
          !> 1-by-1 and 2-by-2 diagonal blocks.
          !> This is the blocked version of the algorithm, calling Level 3 BLAS.
          interface sytrf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytrf_rook(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csytrf_rook
#else
               module procedure la_csytrf_rook
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrf_rook(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsytrf_rook
#else
               module procedure la_dsytrf_rook
#endif
               module procedure la_qsytrf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrf_rook(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssytrf_rook
#else
               module procedure la_ssytrf_rook
#endif
               module procedure la_wsytrf_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytrf_rook(uplo,n,a,lda,ipiv,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info,ipiv(*)
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsytrf_rook
#else
               module procedure la_zsytrf_rook
#endif
          end interface sytrf_rook

          !> SYTRI: computes the inverse of a complex symmetric indefinite matrix
          !> A using the factorization A = U*D*U**T or A = L*D*L**T computed by
          !> CSYTRF.
          interface sytri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytri(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csytri
#else
               module procedure la_csytri
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytri(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsytri
#else
               module procedure la_dsytri
#endif
               module procedure la_qsytri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytri(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssytri
#else
               module procedure la_ssytri
#endif
               module procedure la_wsytri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytri(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsytri
#else
               module procedure la_zsytri
#endif
          end interface sytri

          !> SYTRI_ROOK: computes the inverse of a complex symmetric
          !> matrix A using the factorization A = U*D*U**T or A = L*D*L**T
          !> computed by CSYTRF_ROOK.
          interface sytri_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytri_rook(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csytri_rook
#else
               module procedure la_csytri_rook
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytri_rook(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsytri_rook
#else
               module procedure la_dsytri_rook
#endif
               module procedure la_qsytri_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytri_rook(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssytri_rook
#else
               module procedure la_ssytri_rook
#endif
               module procedure la_wsytri_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytri_rook(uplo,n,a,lda,ipiv,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsytri_rook
#else
               module procedure la_zsytri_rook
#endif
          end interface sytri_rook

          !> SYTRS: solves a system of linear equations A*X = B with a complex
          !> symmetric matrix A using the factorization A = U*D*U**T or
          !> A = L*D*L**T computed by CSYTRF.
          interface sytrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytrs(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine csytrs
#else
               module procedure la_csytrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrs(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dsytrs
#else
               module procedure la_dsytrs
#endif
               module procedure la_qsytrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrs(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine ssytrs
#else
               module procedure la_ssytrs
#endif
               module procedure la_wsytrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytrs(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zsytrs
#else
               module procedure la_zsytrs
#endif
          end interface sytrs

          !> SYTRS2: solves a system of linear equations A*X = B with a complex
          !> symmetric matrix A using the factorization A = U*D*U**T or
          !> A = L*D*L**T computed by CSYTRF and converted by CSYCONV.
          interface sytrs2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytrs2(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csytrs2
#else
               module procedure la_csytrs2
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrs2(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsytrs2
#else
               module procedure la_dsytrs2
#endif
               module procedure la_qsytrs2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrs2(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssytrs2
#else
               module procedure la_ssytrs2
#endif
               module procedure la_wsytrs2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytrs2(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsytrs2
#else
               module procedure la_zsytrs2
#endif
          end interface sytrs2

          !> SYTRS_3: solves a system of linear equations A * X = B with a complex
          !> symmetric matrix A using the factorization computed
          !> by CSYTRF_RK or CSYTRF_BK:
          !> A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
          !> where U (or L) is unit upper (or lower) triangular matrix,
          !> U**T (or L**T) is the transpose of U (or L), P is a permutation
          !> matrix, P**T is the transpose of P, and D is symmetric and block
          !> diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !> This algorithm is using Level 3 BLAS.
          interface sytrs_3
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytrs_3(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(in) :: a(lda,*),e(*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine csytrs_3
#else
               module procedure la_csytrs_3
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrs_3(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: a(lda,*),e(*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dsytrs_3
#else
               module procedure la_dsytrs_3
#endif
               module procedure la_qsytrs_3
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrs_3(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: a(lda,*),e(*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine ssytrs_3
#else
               module procedure la_ssytrs_3
#endif
               module procedure la_wsytrs_3
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytrs_3(uplo,n,nrhs,a,lda,e,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(in) :: a(lda,*),e(*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zsytrs_3
#else
               module procedure la_zsytrs_3
#endif
          end interface sytrs_3

          !> SYTRS_AA: solves a system of linear equations A*X = B with a complex
          !> symmetric matrix A using the factorization A = U**T*T*U or
          !> A = L*T*L**T computed by CSYTRF_AA.
          interface sytrs_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytrs_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine csytrs_aa
#else
               module procedure la_csytrs_aa
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrs_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp),intent(out) :: info
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(inout) :: b(ldb,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dsytrs_aa
#else
               module procedure la_dsytrs_aa
#endif
               module procedure la_qsytrs_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrs_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp),intent(out) :: info
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(inout) :: b(ldb,*)
                    real(sp),intent(out) :: work(*)
               end subroutine ssytrs_aa
#else
               module procedure la_ssytrs_aa
#endif
               module procedure la_wsytrs_aa
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytrs_aa(uplo,n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zsytrs_aa
#else
               module procedure la_zsytrs_aa
#endif
          end interface sytrs_aa

          !> SYTRS_ROOK: solves a system of linear equations A*X = B with
          !> a complex symmetric matrix A using the factorization A = U*D*U**T or
          !> A = L*D*L**T computed by CSYTRF_ROOK.
          interface sytrs_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine csytrs_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine csytrs_rook
#else
               module procedure la_csytrs_rook
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dsytrs_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dsytrs_rook
#else
               module procedure la_dsytrs_rook
#endif
               module procedure la_qsytrs_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ssytrs_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine ssytrs_rook
#else
               module procedure la_ssytrs_rook
#endif
               module procedure la_wsytrs_rook
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zsytrs_rook(uplo,n,nrhs,a,lda,ipiv,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine zsytrs_rook
#else
               module procedure la_zsytrs_rook
#endif
          end interface sytrs_rook

          !> TBCON: estimates the reciprocal of the condition number of a
          !> triangular band matrix A, in either the 1-norm or the infinity-norm.
          !> The norm of A is computed and an estimate is obtained for
          !> norm(inv(A)), then the reciprocal of the condition number is
          !> computed as
          !> RCOND = 1 / ( norm(A) * norm(inv(A)) ).
          interface tbcon
#ifdef LA_EXTERNAL_LAPACK
               subroutine ctbcon(norm,uplo,diag,n,kd,ab,ldab,rcond,work,rwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(out) :: rcond,rwork(*)
                    complex(sp),intent(in) :: ab(ldab,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctbcon
#else
               module procedure la_ctbcon
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dtbcon(norm,uplo,diag,n,kd,ab,ldab,rcond,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(out) :: rcond,work(*)
                    real(dp),intent(in) :: ab(ldab,*)
               end subroutine dtbcon
#else
               module procedure la_dtbcon
#endif
               module procedure la_qtbcon
#ifdef LA_EXTERNAL_LAPACK
               subroutine stbcon(norm,uplo,diag,n,kd,ab,ldab,rcond,work,iwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(sp),intent(out) :: rcond,work(*)
                    real(sp),intent(in) :: ab(ldab,*)
               end subroutine stbcon
#else
               module procedure la_stbcon
#endif
               module procedure la_wtbcon
#ifdef LA_EXTERNAL_LAPACK
               subroutine ztbcon(norm,uplo,diag,n,kd,ab,ldab,rcond,work,rwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,n
                    real(dp),intent(out) :: rcond,rwork(*)
                    complex(dp),intent(in) :: ab(ldab,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztbcon
#else
               module procedure la_ztbcon
#endif
          end interface tbcon

          !> TBRFS: provides error bounds and backward error estimates for the
          !> solution to a system of linear equations with a triangular band
          !> coefficient matrix.
          !> The solution matrix X must be computed by CTBTRS or some other
          !> means before entering this routine.  TBRFS does not do iterative
          !> refinement because doing so cannot improve the backward error.
          interface tbrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctbrfs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,x,ldx, &
                         ferr,berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctbrfs
#else
               module procedure la_ctbrfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtbrfs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,x,ldx, &
                         ferr,berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(dp),intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtbrfs
#else
               module procedure la_dtbrfs
#endif
               module procedure la_qtbrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stbrfs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,x,ldx, &
                         ferr,berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(sp),intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
               end subroutine stbrfs
#else
               module procedure la_stbrfs
#endif
               module procedure la_wtbrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztbrfs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,x,ldx, &
                         ferr,berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztbrfs
#else
               module procedure la_ztbrfs
#endif
          end interface tbrfs

          !> TBTRS: solves a triangular system of the form
          !> A * X = B,  A**T * X = B,  or  A**H * X = B,
          !> where A is a triangular band matrix of order N, and B is an
          !> N-by-NRHS matrix.  A check is made to verify that A is nonsingular.
          interface tbtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp),intent(in) :: ab(ldab,*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine ctbtrs
#else
               module procedure la_ctbtrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp),intent(in) :: ab(ldab,*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dtbtrs
#else
               module procedure la_dtbtrs
#endif
               module procedure la_qtbtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp),intent(in) :: ab(ldab,*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine stbtrs
#else
               module procedure la_stbtrs
#endif
               module procedure la_wtbtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp),intent(in) :: ab(ldab,*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine ztbtrs
#else
               module procedure la_ztbtrs
#endif
          end interface tbtrs

          !> Level 3 BLAS like routine for A in RFP Format.
          !> TFSM: solves the matrix equation
          !> op( A )*X = alpha*B  or  X*op( A ) = alpha*B
          !> where alpha is a scalar, X and B are m by n matrices, A is a unit, or
          !> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
          !> op( A ) = A   or   op( A ) = A**H.
          !> A is in Rectangular Full Packed (RFP) Format.
          !> The matrix X is overwritten on B.
          interface tfsm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctfsm(transr,side,uplo,trans,diag,m,n,alpha,a,b,ldb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp),intent(in) :: ldb,m,n
                    complex(sp),intent(in) :: alpha,a(0:*)
                    complex(sp),intent(inout) :: b(0:ldb - 1,0:*)
               end subroutine ctfsm
#else
               module procedure la_ctfsm
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtfsm(transr,side,uplo,trans,diag,m,n,alpha,a,b,ldb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp),intent(in) :: ldb,m,n
                    real(dp),intent(in) :: alpha,a(0:*)
                    real(dp),intent(inout) :: b(0:ldb - 1,0:*)
               end subroutine dtfsm
#else
               module procedure la_dtfsm
#endif
               module procedure la_qtfsm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stfsm(transr,side,uplo,trans,diag,m,n,alpha,a,b,ldb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp),intent(in) :: ldb,m,n
                    real(sp),intent(in) :: alpha,a(0:*)
                    real(sp),intent(inout) :: b(0:ldb - 1,0:*)
               end subroutine stfsm
#else
               module procedure la_stfsm
#endif
               module procedure la_wtfsm
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztfsm(transr,side,uplo,trans,diag,m,n,alpha,a,b,ldb)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp),intent(in) :: ldb,m,n
                    complex(dp),intent(in) :: alpha,a(0:*)
                    complex(dp),intent(inout) :: b(0:ldb - 1,0:*)
               end subroutine ztfsm
#else
               module procedure la_ztfsm
#endif
          end interface tfsm

          !> TFTRI: computes the inverse of a triangular matrix A stored in RFP
          !> format.
          !> This is a Level 3 BLAS version of the algorithm.
          interface tftri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctftri(transr,uplo,diag,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo,diag
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(inout) :: a(0:*)
               end subroutine ctftri
#else
               module procedure la_ctftri
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtftri(transr,uplo,diag,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo,diag
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: a(0:*)
               end subroutine dtftri
#else
               module procedure la_dtftri
#endif
               module procedure la_qtftri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stftri(transr,uplo,diag,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo,diag
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: a(0:*)
               end subroutine stftri
#else
               module procedure la_stftri
#endif
               module procedure la_wtftri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztftri(transr,uplo,diag,n,a,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo,diag
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(inout) :: a(0:*)
               end subroutine ztftri
#else
               module procedure la_ztftri
#endif
          end interface tftri

          !> TFTTP: copies a triangular matrix A from rectangular full packed
          !> format (TF) to standard packed format (TP).
          interface tfttp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctfttp(transr,uplo,n,arf,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(out) :: ap(0:*)
                    complex(sp),intent(in) :: arf(0:*)
               end subroutine ctfttp
#else
               module procedure la_ctfttp
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtfttp(transr,uplo,n,arf,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: ap(0:*)
                    real(dp),intent(in) :: arf(0:*)
               end subroutine dtfttp
#else
               module procedure la_dtfttp
#endif
               module procedure la_qtfttp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stfttp(transr,uplo,n,arf,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: ap(0:*)
                    real(sp),intent(in) :: arf(0:*)
               end subroutine stfttp
#else
               module procedure la_stfttp
#endif
               module procedure la_wtfttp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztfttp(transr,uplo,n,arf,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(out) :: ap(0:*)
                    complex(dp),intent(in) :: arf(0:*)
               end subroutine ztfttp
#else
               module procedure la_ztfttp
#endif
          end interface tfttp

          !> TFTTR: copies a triangular matrix A from rectangular full packed
          !> format (TF) to standard full format (TR).
          interface tfttr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctfttr(transr,uplo,n,arf,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    complex(sp),intent(out) :: a(0:lda - 1,0:*)
                    complex(sp),intent(in) :: arf(0:*)
               end subroutine ctfttr
#else
               module procedure la_ctfttr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtfttr(transr,uplo,n,arf,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    real(dp),intent(out) :: a(0:lda - 1,0:*)
                    real(dp),intent(in) :: arf(0:*)
               end subroutine dtfttr
#else
               module procedure la_dtfttr
#endif
               module procedure la_qtfttr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stfttr(transr,uplo,n,arf,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    real(sp),intent(out) :: a(0:lda - 1,0:*)
                    real(sp),intent(in) :: arf(0:*)
               end subroutine stfttr
#else
               module procedure la_stfttr
#endif
               module procedure la_wtfttr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztfttr(transr,uplo,n,arf,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    complex(dp),intent(out) :: a(0:lda - 1,0:*)
                    complex(dp),intent(in) :: arf(0:*)
               end subroutine ztfttr
#else
               module procedure la_ztfttr
#endif
          end interface tfttr

          !> TGEVC: computes some or all of the right and/or left eigenvectors of
          !> a pair of complex matrices (S,P), where S and P are upper triangular.
          !> Matrix pairs of this type are produced by the generalized Schur
          !> factorization of a complex matrix pair (A,B):
          !> A = Q*S*Z**H,  B = Q*P*Z**H
          !> as computed by CGGHRD + CHGEQZ.
          !> The right eigenvector x and the left eigenvector y of (S,P)
          !> corresponding to an eigenvalue w are defined by:
          !> S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
          !> where y**H denotes the conjugate tranpose of y.
          !> The eigenvalues are not input to this routine, but are computed
          !> directly from the diagonal elements of S and P.
          !> This routine returns the matrices X and/or Y of right and left
          !> eigenvectors of (S,P), or the products Z*X and/or Q*Y,
          !> where Z and Q are input matrices.
          !> If Q and Z are the unitary factors from the generalized Schur
          !> factorization of a matrix pair (A,B), then Z*X and Q*Y
          !> are the matrices of right and left eigenvectors of (A,B).
          interface tgevc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctgevc(side,howmny,select,n,s,lds,p,ldp,vl,ldvl,vr,ldvr, &
                          mm,m,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(in) :: p(ldp,*),s(lds,*)
                    complex(sp),intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctgevc
#else
               module procedure la_ctgevc
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtgevc(side,howmny,select,n,s,lds,p,ldp,vl,ldvl,vr,ldvr, &
                          mm,m,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(dp),intent(in) :: p(ldp,*),s(lds,*)
                    real(dp),intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dtgevc
#else
               module procedure la_dtgevc
#endif
               module procedure la_qtgevc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stgevc(side,howmny,select,n,s,lds,p,ldp,vl,ldvl,vr,ldvr, &
                          mm,m,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(sp),intent(in) :: p(ldp,*),s(lds,*)
                    real(sp),intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp),intent(out) :: work(*)
               end subroutine stgevc
#else
               module procedure la_stgevc
#endif
               module procedure la_wtgevc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztgevc(side,howmny,select,n,s,lds,p,ldp,vl,ldvl,vr,ldvr, &
                          mm,m,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(in) :: p(ldp,*),s(lds,*)
                    complex(dp),intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztgevc
#else
               module procedure la_ztgevc
#endif
          end interface tgevc

          !> TGEXC: reorders the generalized Schur decomposition of a complex
          !> matrix pair (A,B), using an unitary equivalence transformation
          !> (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
          !> row index IFST is moved to row ILST.
          !> (A, B) must be in generalized Schur canonical form, that is, A and
          !> B are both upper triangular.
          !> Optionally, the matrices Q and Z of generalized Schur vectors are
          !> updated.
          !> Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
          !> Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
          interface tgexc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctgexc(wantq,wantz,n,a,lda,b,ldb,q,ldq,z,ldz,ifst,ilst, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantq,wantz
                    integer(ilp),intent(in) :: ifst,lda,ldb,ldq,ldz,n
                    integer(ilp),intent(inout) :: ilst
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine ctgexc
#else
               module procedure la_ctgexc
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtgexc(wantq,wantz,n,a,lda,b,ldb,q,ldq,z,ldz,ifst,ilst, &
                          work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantq,wantz
                    integer(ilp),intent(inout) :: ifst,ilst
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldq,ldz,lwork,n
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dtgexc
#else
               module procedure la_dtgexc
#endif
               module procedure la_qtgexc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stgexc(wantq,wantz,n,a,lda,b,ldb,q,ldq,z,ldz,ifst,ilst, &
                          work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantq,wantz
                    integer(ilp),intent(inout) :: ifst,ilst
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldq,ldz,lwork,n
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(sp),intent(out) :: work(*)
               end subroutine stgexc
#else
               module procedure la_stgexc
#endif
               module procedure la_wtgexc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztgexc(wantq,wantz,n,a,lda,b,ldb,q,ldq,z,ldz,ifst,ilst, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantq,wantz
                    integer(ilp),intent(in) :: ifst,lda,ldb,ldq,ldz,n
                    integer(ilp),intent(inout) :: ilst
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine ztgexc
#else
               module procedure la_ztgexc
#endif
          end interface tgexc

          !> TGSEN: reorders the generalized Schur decomposition of a complex
          !> matrix pair (A, B) (in terms of an unitary equivalence trans-
          !> formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
          !> appears in the leading diagonal blocks of the pair (A,B). The leading
          !> columns of Q and Z form unitary bases of the corresponding left and
          !> right eigenspaces (deflating subspaces). (A, B) must be in
          !> generalized Schur canonical form, that is, A and B are both upper
          !> triangular.
          !> TGSEN also computes the generalized eigenvalues
          !> w(j)= ALPHA(j) / BETA(j)
          !> of the reordered matrix pair (A, B).
          !> Optionally, the routine computes estimates of reciprocal condition
          !> numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
          !> (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
          !> between the matrix pairs (A11, B11) and (A22,B22) that correspond to
          !> the selected cluster and the eigenvalues outside the cluster, resp.,
          !> and norms of "projections" onto left and right eigenspaces w.r.t.
          !> the selected cluster in the (1,1)-block.
          interface tgsen
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alpha,beta, &
                         q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantq,wantz,select(*)
                    integer(ilp),intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    real(sp),intent(out) :: pl,pr,dif(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(sp),intent(out) :: alpha(*),beta(*),work(*)
               end subroutine ctgsen
#else
               module procedure la_ctgsen
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alphar, &
               alphai,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantq,wantz,select(*)
                    integer(ilp),intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    real(dp),intent(out) :: pl,pr,alphai(*),alphar(*),beta(*),dif(*),work(*)
                              
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine dtgsen
#else
               module procedure la_dtgsen
#endif
               module procedure la_qtgsen
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alphar, &
               alphai,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantq,wantz,select(*)
                    integer(ilp),intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    real(sp),intent(out) :: pl,pr,alphai(*),alphar(*),beta(*),dif(*),work(*)
                              
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine stgsen
#else
               module procedure la_stgsen
#endif
               module procedure la_wtgsen
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alpha,beta, &
                         q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    logical(lk),intent(in) :: wantq,wantz,select(*)
                    integer(ilp),intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    real(dp),intent(out) :: pl,pr,dif(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(dp),intent(out) :: alpha(*),beta(*),work(*)
               end subroutine ztgsen
#else
               module procedure la_ztgsen
#endif
          end interface tgsen

          !> TGSJA: computes the generalized singular value decomposition (GSVD)
          !> of two complex upper triangular (or trapezoidal) matrices A and B.
          !> On entry, it is assumed that matrices A and B have the following
          !> forms, which may be obtained by the preprocessing subroutine CGGSVP
          !> from a general M-by-N matrix A and P-by-N matrix B:
          !> N-K-L  K    L
          !> A =    K ( 0    A12  A13 ) if M-K-L >= 0;
          !> L ( 0     0   A23 )
          !> M-K-L ( 0     0    0  )
          !> N-K-L  K    L
          !> A =  K ( 0    A12  A13 ) if M-K-L < 0;
          !> M-K ( 0     0   A23 )
          !> N-K-L  K    L
          !> B =  L ( 0     0   B13 )
          !> P-L ( 0     0    0  )
          !> where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
          !> upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
          !> otherwise A23 is (M-K)-by-L upper trapezoidal.
          !> On exit,
          !> U**H *A*Q = D1*( 0 R ),    V**H *B*Q = D2*( 0 R ),
          !> where U, V and Q are unitary matrices.
          !> R is a nonsingular upper triangular matrix, and D1
          !> and D2 are ``diagonal'' matrices, which are of the following
          !> structures:
          !> If M-K-L >= 0,
          !> K  L
          !> D1 =     K ( I  0 )
          !> L ( 0  C )
          !> M-K-L ( 0  0 )
          !> K  L
          !> D2 = L   ( 0  S )
          !> P-L ( 0  0 )
          !> N-K-L  K    L
          !> ( 0 R ) = K (  0   R11  R12 ) K
          !> L (  0    0   R22 ) L
          !> where
          !> C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
          !> S = diag( BETA(K+1),  ... , BETA(K+L) ),
          !> C**2 + S**2 = I.
          !> R is stored in A(1:K+L,N-K-L+1:N) on exit.
          !> If M-K-L < 0,
          !> K M-K K+L-M
          !> D1 =   K ( I  0    0   )
          !> M-K ( 0  C    0   )
          !> K M-K K+L-M
          !> D2 =   M-K ( 0  S    0   )
          !> K+L-M ( 0  0    I   )
          !> P-L ( 0  0    0   )
          !> N-K-L  K   M-K  K+L-M
          !> ( 0 R ) =    K ( 0    R11  R12  R13  )
          !> M-K ( 0     0   R22  R23  )
          !> K+L-M ( 0     0    0   R33  )
          !> where
          !> C = diag( ALPHA(K+1), ... , ALPHA(M) ),
          !> S = diag( BETA(K+1),  ... , BETA(M) ),
          !> C**2 + S**2 = I.
          !> R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
          !> (  0  R22 R23 )
          !> in B(M-K+1:L,N+M-K-L+1:N) on exit.
          !> The computation of the unitary transformation matrices U, V or Q
          !> is optional.  These matrices may either be formed explicitly, or they
          !> may be postmultiplied into input matrices U1, V1, or Q1.
          interface tgsja
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctgsja(jobu,jobv,jobq,m,p,n,k,l,a,lda,b,ldb,tola,tolb, &
                          alpha,beta,u,ldu,v,ldv,q,ldq,work,ncycle,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobq,jobu,jobv
                    integer(ilp),intent(out) :: info,ncycle
                    integer(ilp),intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(sp),intent(in) :: tola,tolb
                    real(sp),intent(out) :: alpha(*),beta(*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)
                              
                    complex(sp),intent(out) :: work(*)
               end subroutine ctgsja
#else
               module procedure la_ctgsja
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtgsja(jobu,jobv,jobq,m,p,n,k,l,a,lda,b,ldb,tola,tolb, &
                          alpha,beta,u,ldu,v,ldv,q,ldq,work,ncycle,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobq,jobu,jobv
                    integer(ilp),intent(out) :: info,ncycle
                    integer(ilp),intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(dp),intent(in) :: tola,tolb
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)
                              
                    real(dp),intent(out) :: alpha(*),beta(*),work(*)
               end subroutine dtgsja
#else
               module procedure la_dtgsja
#endif
               module procedure la_qtgsja
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stgsja(jobu,jobv,jobq,m,p,n,k,l,a,lda,b,ldb,tola,tolb, &
                          alpha,beta,u,ldu,v,ldv,q,ldq,work,ncycle,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobq,jobu,jobv
                    integer(ilp),intent(out) :: info,ncycle
                    integer(ilp),intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(sp),intent(in) :: tola,tolb
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)
                              
                    real(sp),intent(out) :: alpha(*),beta(*),work(*)
               end subroutine stgsja
#else
               module procedure la_stgsja
#endif
               module procedure la_wtgsja
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztgsja(jobu,jobv,jobq,m,p,n,k,l,a,lda,b,ldb,tola,tolb, &
                          alpha,beta,u,ldu,v,ldv,q,ldq,work,ncycle,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobq,jobu,jobv
                    integer(ilp),intent(out) :: info,ncycle
                    integer(ilp),intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(dp),intent(in) :: tola,tolb
                    real(dp),intent(out) :: alpha(*),beta(*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)
                              
                    complex(dp),intent(out) :: work(*)
               end subroutine ztgsja
#else
               module procedure la_ztgsja
#endif
          end interface tgsja

          !> TGSNA: estimates reciprocal condition numbers for specified
          !> eigenvalues and/or eigenvectors of a matrix pair (A, B).
          !> (A, B) must be in generalized Schur canonical form, that is, A and
          !> B are both upper triangular.
          interface tgsna
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctgsna(job,howmny,select,n,a,lda,b,ldb,vl,ldvl,vr,ldvr, &
                         s,dif,mm,m,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,job
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    integer(ilp),intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(sp),intent(out) :: dif(*),s(*)
                    complex(sp),intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctgsna
#else
               module procedure la_ctgsna
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtgsna(job,howmny,select,n,a,lda,b,ldb,vl,ldvl,vr,ldvr, &
                         s,dif,mm,m,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,job
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    integer(ilp),intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(dp),intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    real(dp),intent(out) :: dif(*),s(*),work(*)
               end subroutine dtgsna
#else
               module procedure la_dtgsna
#endif
               module procedure la_qtgsna
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stgsna(job,howmny,select,n,a,lda,b,ldb,vl,ldvl,vr,ldvr, &
                         s,dif,mm,m,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,job
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    integer(ilp),intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(sp),intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    real(sp),intent(out) :: dif(*),s(*),work(*)
               end subroutine stgsna
#else
               module procedure la_stgsna
#endif
               module procedure la_wtgsna
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztgsna(job,howmny,select,n,a,lda,b,ldb,vl,ldvl,vr,ldvr, &
                         s,dif,mm,m,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,job
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    integer(ilp),intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(dp),intent(out) :: dif(*),s(*)
                    complex(dp),intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztgsna
#else
               module procedure la_ztgsna
#endif
          end interface tgsna

          !> TGSYL: solves the generalized Sylvester equation:
          !> A * R - L * B = scale * C            (1)
          !> D * R - L * E = scale * F
          !> where R and L are unknown m-by-n matrices, (A, D), (B, E) and
          !> (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
          !> respectively, with complex entries. A, B, D and E are upper
          !> triangular (i.e., (A,D) and (B,E) in generalized Schur form).
          !> The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
          !> is an output scaling factor chosen to avoid overflow.
          !> In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
          !> is defined as
          !> Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)
          !> [ kron(In, D)  -kron(E**H, Im) ],
          !> Here Ix is the identity matrix of size x and X**H is the conjugate
          !> transpose of X. Kron(X, Y) is the Kronecker product between the
          !> matrices X and Y.
          !> If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
          !> is solved for, which is equivalent to solve for R and L in
          !> A**H * R + D**H * L = scale * C           (3)
          !> R * B**H + L * E**H = scale * -F
          !> This case (TRANS = 'C') is used to compute an one-norm-based estimate
          !> of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
          !> and (B,E), using CLACON.
          !> If IJOB >= 1, TGSYL computes a Frobenius norm-based estimate of
          !> Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
          !> reciprocal of the smallest singular value of Z.
          !> This is a level-3 BLAS algorithm.
          interface tgsyl
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctgsyl(trans,ijob,m,n,a,lda,b,ldb,c,ldc,d,ldd,e,lde, &
                         f,ldf,scale,dif,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(out) :: dif,scale
                    complex(sp),intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    complex(sp),intent(inout) :: c(ldc,*),f(ldf,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctgsyl
#else
               module procedure la_ctgsyl
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtgsyl(trans,ijob,m,n,a,lda,b,ldb,c,ldc,d,ldd,e,lde, &
                         f,ldf,scale,dif,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(out) :: dif,scale,work(*)
                    real(dp),intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    real(dp),intent(inout) :: c(ldc,*),f(ldf,*)
               end subroutine dtgsyl
#else
               module procedure la_dtgsyl
#endif
               module procedure la_qtgsyl
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stgsyl(trans,ijob,m,n,a,lda,b,ldb,c,ldc,d,ldd,e,lde, &
                         f,ldf,scale,dif,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(sp),intent(out) :: dif,scale,work(*)
                    real(sp),intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    real(sp),intent(inout) :: c(ldc,*),f(ldf,*)
               end subroutine stgsyl
#else
               module procedure la_stgsyl
#endif
               module procedure la_wtgsyl
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztgsyl(trans,ijob,m,n,a,lda,b,ldb,c,ldc,d,ldd,e,lde, &
                         f,ldf,scale,dif,work,lwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trans
                    integer(ilp),intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp),intent(out) :: info,iwork(*)
                    real(dp),intent(out) :: dif,scale
                    complex(dp),intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    complex(dp),intent(inout) :: c(ldc,*),f(ldf,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztgsyl
#else
               module procedure la_ztgsyl
#endif
          end interface tgsyl

          !> TPCON: estimates the reciprocal of the condition number of a packed
          !> triangular matrix A, in either the 1-norm or the infinity-norm.
          !> The norm of A is computed and an estimate is obtained for
          !> norm(inv(A)), then the reciprocal of the condition number is
          !> computed as
          !> RCOND = 1 / ( norm(A) * norm(inv(A)) ).
          interface tpcon
#ifdef LA_EXTERNAL_LAPACK
               subroutine ctpcon(norm,uplo,diag,n,ap,rcond,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: rcond,rwork(*)
                    complex(sp),intent(in) :: ap(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctpcon
#else
               module procedure la_ctpcon
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dtpcon(norm,uplo,diag,n,ap,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: rcond,work(*)
                    real(dp),intent(in) :: ap(*)
               end subroutine dtpcon
#else
               module procedure la_dtpcon
#endif
               module procedure la_qtpcon
#ifdef LA_EXTERNAL_LAPACK
               subroutine stpcon(norm,uplo,diag,n,ap,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: n
                    real(sp),intent(out) :: rcond,work(*)
                    real(sp),intent(in) :: ap(*)
               end subroutine stpcon
#else
               module procedure la_stpcon
#endif
               module procedure la_wtpcon
#ifdef LA_EXTERNAL_LAPACK
               subroutine ztpcon(norm,uplo,diag,n,ap,rcond,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(out) :: rcond,rwork(*)
                    complex(dp),intent(in) :: ap(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztpcon
#else
               module procedure la_ztpcon
#endif
          end interface tpcon

          !> TPLQT: computes a blocked LQ factorization of a complex
          !> "triangular-pentagonal" matrix C, which is composed of a
          !> triangular block A and pentagonal block B, using the compact
          !> WY representation for Q.
          interface tplqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctplqt(m,n,l,mb,a,lda,b,ldb,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l,mb
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: t(ldt,*),work(*)
               end subroutine ctplqt
#else
               module procedure la_ctplqt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtplqt(m,n,l,mb,a,lda,b,ldb,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l,mb
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: t(ldt,*),work(*)
               end subroutine dtplqt
#else
               module procedure la_dtplqt
#endif
               module procedure la_qtplqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stplqt(m,n,l,mb,a,lda,b,ldb,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l,mb
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: t(ldt,*),work(*)
               end subroutine stplqt
#else
               module procedure la_stplqt
#endif
               module procedure la_wtplqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztplqt(m,n,l,mb,a,lda,b,ldb,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l,mb
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: t(ldt,*),work(*)
               end subroutine ztplqt
#else
               module procedure la_ztplqt
#endif
          end interface tplqt

          !> TPLQT2: computes a LQ a factorization of a complex "triangular-pentagonal"
          !> matrix C, which is composed of a triangular block A and pentagonal block B,
          !> using the compact WY representation for Q.
          interface tplqt2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctplqt2(m,n,l,a,lda,b,ldb,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: t(ldt,*)
               end subroutine ctplqt2
#else
               module procedure la_ctplqt2
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtplqt2(m,n,l,a,lda,b,ldb,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: t(ldt,*)
               end subroutine dtplqt2
#else
               module procedure la_dtplqt2
#endif
               module procedure la_qtplqt2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stplqt2(m,n,l,a,lda,b,ldb,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: t(ldt,*)
               end subroutine stplqt2
#else
               module procedure la_stplqt2
#endif
               module procedure la_wtplqt2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztplqt2(m,n,l,a,lda,b,ldb,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: t(ldt,*)
               end subroutine ztplqt2
#else
               module procedure la_ztplqt2
#endif
          end interface tplqt2

          !> TPMLQT: applies a complex unitary matrix Q obtained from a
          !> "triangular-pentagonal" complex block reflector H to a general
          !> complex matrix C, which consists of two blocks A and B.
          interface tpmlqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctpmlqt(side,trans,m,n,k,l,mb,v,ldv,t,ldt,a,lda,b, &
                         ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    complex(sp),intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctpmlqt
#else
               module procedure la_ctpmlqt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtpmlqt(side,trans,m,n,k,l,mb,v,ldv,t,ldt,a,lda,b, &
                         ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    real(dp),intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dtpmlqt
#else
               module procedure la_dtpmlqt
#endif
               module procedure la_qtpmlqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stpmlqt(side,trans,m,n,k,l,mb,v,ldv,t,ldt,a,lda,b, &
                         ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    real(sp),intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: work(*)
               end subroutine stpmlqt
#else
               module procedure la_stpmlqt
#endif
               module procedure la_wtpmlqt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztpmlqt(side,trans,m,n,k,l,mb,v,ldv,t,ldt,a,lda,b, &
                         ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    complex(dp),intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztpmlqt
#else
               module procedure la_ztpmlqt
#endif
          end interface tpmlqt

          !> TPMQRT: applies a complex orthogonal matrix Q obtained from a
          !> "triangular-pentagonal" complex block reflector H to a general
          !> complex matrix C, which consists of two blocks A and B.
          interface tpmqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b, &
                         ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    complex(sp),intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctpmqrt
#else
               module procedure la_ctpmqrt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b, &
                         ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    real(dp),intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dtpmqrt
#else
               module procedure la_dtpmqrt
#endif
               module procedure la_qtpmqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b, &
                         ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    real(sp),intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: work(*)
               end subroutine stpmqrt
#else
               module procedure la_stpmqrt
#endif
               module procedure la_wtpmqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b, &
                         ldb,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    complex(dp),intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztpmqrt
#else
               module procedure la_ztpmqrt
#endif
          end interface tpmqrt

          !> TPQRT: computes a blocked QR factorization of a complex
          !> "triangular-pentagonal" matrix C, which is composed of a
          !> triangular block A and pentagonal block B, using the compact
          !> WY representation for Q.
          interface tpqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctpqrt(m,n,l,nb,a,lda,b,ldb,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l,nb
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: t(ldt,*),work(*)
               end subroutine ctpqrt
#else
               module procedure la_ctpqrt
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtpqrt(m,n,l,nb,a,lda,b,ldb,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l,nb
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: t(ldt,*),work(*)
               end subroutine dtpqrt
#else
               module procedure la_dtpqrt
#endif
               module procedure la_qtpqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stpqrt(m,n,l,nb,a,lda,b,ldb,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l,nb
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: t(ldt,*),work(*)
               end subroutine stpqrt
#else
               module procedure la_stpqrt
#endif
               module procedure la_wtpqrt
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztpqrt(m,n,l,nb,a,lda,b,ldb,t,ldt,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l,nb
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: t(ldt,*),work(*)
               end subroutine ztpqrt
#else
               module procedure la_ztpqrt
#endif
          end interface tpqrt

          !> TPQRT2: computes a QR factorization of a complex "triangular-pentagonal"
          !> matrix C, which is composed of a triangular block A and pentagonal block B,
          !> using the compact WY representation for Q.
          interface tpqrt2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctpqrt2(m,n,l,a,lda,b,ldb,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(out) :: t(ldt,*)
               end subroutine ctpqrt2
#else
               module procedure la_ctpqrt2
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtpqrt2(m,n,l,a,lda,b,ldb,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(out) :: t(ldt,*)
               end subroutine dtpqrt2
#else
               module procedure la_dtpqrt2
#endif
               module procedure la_qtpqrt2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stpqrt2(m,n,l,a,lda,b,ldb,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(out) :: t(ldt,*)
               end subroutine stpqrt2
#else
               module procedure la_stpqrt2
#endif
               module procedure la_wtpqrt2
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztpqrt2(m,n,l,a,lda,b,ldb,t,ldt,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldt,n,m,l
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(out) :: t(ldt,*)
               end subroutine ztpqrt2
#else
               module procedure la_ztpqrt2
#endif
          end interface tpqrt2

          !> TPRFB: applies a complex "triangular-pentagonal" block reflector H or its
          !> conjugate transpose H**H to a complex matrix C, which is composed of two
          !> blocks A and B, either from the left or right.
          interface tprfb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctprfb(side,trans,direct,storev,m,n,k,l,v,ldv,t,ldt,a, &
                         lda,b,ldb,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    complex(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(in) :: t(ldt,*),v(ldv,*)
                    complex(sp),intent(out) :: work(ldwork,*)
               end subroutine ctprfb
#else
               module procedure la_ctprfb
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtprfb(side,trans,direct,storev,m,n,k,l,v,ldv,t,ldt,a, &
                         lda,b,ldb,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    real(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp),intent(in) :: t(ldt,*),v(ldv,*)
                    real(dp),intent(out) :: work(ldwork,*)
               end subroutine dtprfb
#else
               module procedure la_dtprfb
#endif
               module procedure la_qtprfb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stprfb(side,trans,direct,storev,m,n,k,l,v,ldv,t,ldt,a, &
                         lda,b,ldb,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    real(sp),intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp),intent(in) :: t(ldt,*),v(ldv,*)
                    real(sp),intent(out) :: work(ldwork,*)
               end subroutine stprfb
#else
               module procedure la_stprfb
#endif
               module procedure la_wtprfb
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztprfb(side,trans,direct,storev,m,n,k,l,v,ldv,t,ldt,a, &
                         lda,b,ldb,work,ldwork)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: direct,side,storev,trans
                    integer(ilp),intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    complex(dp),intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(in) :: t(ldt,*),v(ldv,*)
                    complex(dp),intent(out) :: work(ldwork,*)
               end subroutine ztprfb
#else
               module procedure la_ztprfb
#endif
          end interface tprfb

          !> TPRFS: provides error bounds and backward error estimates for the
          !> solution to a system of linear equations with a triangular packed
          !> coefficient matrix.
          !> The solution matrix X must be computed by CTPTRS or some other
          !> means before entering this routine.  TPRFS does not do iterative
          !> refinement because doing so cannot improve the backward error.
          interface tprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctprfs(uplo,trans,diag,n,nrhs,ap,b,ldb,x,ldx,ferr,berr, &
                         work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctprfs
#else
               module procedure la_ctprfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtprfs(uplo,trans,diag,n,nrhs,ap,b,ldb,x,ldx,ferr,berr, &
                         work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(dp),intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtprfs
#else
               module procedure la_dtprfs
#endif
               module procedure la_qtprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stprfs(uplo,trans,diag,n,nrhs,ap,b,ldb,x,ldx,ferr,berr, &
                         work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(sp),intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
               end subroutine stprfs
#else
               module procedure la_stprfs
#endif
               module procedure la_wtprfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztprfs(uplo,trans,diag,n,nrhs,ap,b,ldb,x,ldx,ferr,berr, &
                         work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,ldx,n,nrhs
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztprfs
#else
               module procedure la_ztprfs
#endif
          end interface tprfs

          !> TPTRI: computes the inverse of a complex upper or lower triangular
          !> matrix A stored in packed format.
          interface tptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctptri(uplo,diag,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(inout) :: ap(*)
               end subroutine ctptri
#else
               module procedure la_ctptri
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtptri(uplo,diag,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(inout) :: ap(*)
               end subroutine dtptri
#else
               module procedure la_dtptri
#endif
               module procedure la_qtptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stptri(uplo,diag,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(inout) :: ap(*)
               end subroutine stptri
#else
               module procedure la_stptri
#endif
               module procedure la_wtptri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztptri(uplo,diag,n,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(inout) :: ap(*)
               end subroutine ztptri
#else
               module procedure la_ztptri
#endif
          end interface tptri

          !> TPTRS: solves a triangular system of the form
          !> A * X = B,  A**T * X = B,  or  A**H * X = B,
          !> where A is a triangular matrix of order N stored in packed format,
          !> and B is an N-by-NRHS matrix.  A check is made to verify that A is
          !> nonsingular.
          interface tptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctptrs(uplo,trans,diag,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(sp),intent(in) :: ap(*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine ctptrs
#else
               module procedure la_ctptrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtptrs(uplo,trans,diag,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(dp),intent(in) :: ap(*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dtptrs
#else
               module procedure la_dtptrs
#endif
               module procedure la_qtptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stptrs(uplo,trans,diag,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    real(sp),intent(in) :: ap(*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine stptrs
#else
               module procedure la_stptrs
#endif
               module procedure la_wtptrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztptrs(uplo,trans,diag,n,nrhs,ap,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldb,n,nrhs
                    complex(dp),intent(in) :: ap(*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine ztptrs
#else
               module procedure la_ztptrs
#endif
          end interface tptrs

          !> TPTTF: copies a triangular matrix A from standard packed format (TP)
          !> to rectangular full packed format (TF).
          interface tpttf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctpttf(transr,uplo,n,ap,arf,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(sp),intent(in) :: ap(0:*)
                    complex(sp),intent(out) :: arf(0:*)
               end subroutine ctpttf
#else
               module procedure la_ctpttf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtpttf(transr,uplo,n,ap,arf,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(dp),intent(in) :: ap(0:*)
                    real(dp),intent(out) :: arf(0:*)
               end subroutine dtpttf
#else
               module procedure la_dtpttf
#endif
               module procedure la_qtpttf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stpttf(transr,uplo,n,ap,arf,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    real(sp),intent(in) :: ap(0:*)
                    real(sp),intent(out) :: arf(0:*)
               end subroutine stpttf
#else
               module procedure la_stpttf
#endif
               module procedure la_wtpttf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztpttf(transr,uplo,n,ap,arf,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n
                    complex(dp),intent(in) :: ap(0:*)
                    complex(dp),intent(out) :: arf(0:*)
               end subroutine ztpttf
#else
               module procedure la_ztpttf
#endif
          end interface tpttf

          !> TPTTR: copies a triangular matrix A from standard packed format (TP)
          !> to standard full format (TR).
          interface tpttr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctpttr(uplo,n,ap,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    complex(sp),intent(out) :: a(lda,*)
                    complex(sp),intent(in) :: ap(*)
               end subroutine ctpttr
#else
               module procedure la_ctpttr
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtpttr(uplo,n,ap,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    real(dp),intent(out) :: a(lda,*)
                    real(dp),intent(in) :: ap(*)
               end subroutine dtpttr
#else
               module procedure la_dtpttr
#endif
               module procedure la_qtpttr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stpttr(uplo,n,ap,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    real(sp),intent(out) :: a(lda,*)
                    real(sp),intent(in) :: ap(*)
               end subroutine stpttr
#else
               module procedure la_stpttr
#endif
               module procedure la_wtpttr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztpttr(uplo,n,ap,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    complex(dp),intent(out) :: a(lda,*)
                    complex(dp),intent(in) :: ap(*)
               end subroutine ztpttr
#else
               module procedure la_ztpttr
#endif
          end interface tpttr

          !> TRCON: estimates the reciprocal of the condition number of a
          !> triangular matrix A, in either the 1-norm or the infinity-norm.
          !> The norm of A is computed and an estimate is obtained for
          !> norm(inv(A)), then the reciprocal of the condition number is
          !> computed as
          !> RCOND = 1 / ( norm(A) * norm(inv(A)) ).
          interface trcon
#ifdef LA_EXTERNAL_LAPACK
               subroutine ctrcon(norm,uplo,diag,n,a,lda,rcond,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: rcond,rwork(*)
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctrcon
#else
               module procedure la_ctrcon
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dtrcon(norm,uplo,diag,n,a,lda,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: rcond,work(*)
                    real(dp),intent(in) :: a(lda,*)
               end subroutine dtrcon
#else
               module procedure la_dtrcon
#endif
               module procedure la_qtrcon
#ifdef LA_EXTERNAL_LAPACK
               subroutine strcon(norm,uplo,diag,n,a,lda,rcond,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(out) :: rcond,work(*)
                    real(sp),intent(in) :: a(lda,*)
               end subroutine strcon
#else
               module procedure la_strcon
#endif
               module procedure la_wtrcon
#ifdef LA_EXTERNAL_LAPACK
               subroutine ztrcon(norm,uplo,diag,n,a,lda,rcond,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,norm,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(out) :: rcond,rwork(*)
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztrcon
#else
               module procedure la_ztrcon
#endif
          end interface trcon

          !> TREVC: computes some or all of the right and/or left eigenvectors of
          !> a complex upper triangular matrix T.
          !> Matrices of this type are produced by the Schur factorization of
          !> a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
          !> The right eigenvector x and the left eigenvector y of T corresponding
          !> to an eigenvalue w are defined by:
          !> T*x = w*x,     (y**H)*T = w*(y**H)
          !> where y**H denotes the conjugate transpose of the vector y.
          !> The eigenvalues are not input to this routine, but are read directly
          !> from the diagonal of T.
          !> This routine returns the matrices X and/or Y of right and left
          !> eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
          !> input matrix.  If Q is the unitary factor that reduces a matrix A to
          !> Schur form T, then Q*X and Q*Y are the matrices of right and left
          !> eigenvectors of A.
          interface trevc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctrevc(side,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,mm,m, &
                         work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctrevc
#else
               module procedure la_ctrevc
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtrevc(side,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,mm,m, &
                         work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk),intent(inout) :: select(*)
                    real(dp),intent(in) :: t(ldt,*)
                    real(dp),intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dtrevc
#else
               module procedure la_dtrevc
#endif
               module procedure la_qtrevc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine strevc(side,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,mm,m, &
                         work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk),intent(inout) :: select(*)
                    real(sp),intent(in) :: t(ldt,*)
                    real(sp),intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp),intent(out) :: work(*)
               end subroutine strevc
#else
               module procedure la_strevc
#endif
               module procedure la_wtrevc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztrevc(side,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,mm,m, &
                         work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztrevc
#else
               module procedure la_ztrevc
#endif
          end interface trevc

          !> TREVC3: computes some or all of the right and/or left eigenvectors of
          !> a complex upper triangular matrix T.
          !> Matrices of this type are produced by the Schur factorization of
          !> a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
          !> The right eigenvector x and the left eigenvector y of T corresponding
          !> to an eigenvalue w are defined by:
          !> T*x = w*x,     (y**H)*T = w*(y**H)
          !> where y**H denotes the conjugate transpose of the vector y.
          !> The eigenvalues are not input to this routine, but are read directly
          !> from the diagonal of T.
          !> This routine returns the matrices X and/or Y of right and left
          !> eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
          !> input matrix. If Q is the unitary factor that reduces a matrix A to
          !> Schur form T, then Q*X and Q*Y are the matrices of right and left
          !> eigenvectors of A.
          !> This uses a Level 3 BLAS version of the back transformation.
          interface trevc3
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctrevc3(side,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,mm,m, &
                          work,lwork,rwork,lrwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,lwork,lrwork,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(sp),intent(out) :: rwork(*)
                    complex(sp),intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctrevc3
#else
               module procedure la_ctrevc3
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtrevc3(side,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,mm,m, &
                          work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,lwork,mm,n
                    logical(lk),intent(inout) :: select(*)
                    real(dp),intent(in) :: t(ldt,*)
                    real(dp),intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dtrevc3
#else
               module procedure la_dtrevc3
#endif
               module procedure la_qtrevc3
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine strevc3(side,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,mm,m, &
                          work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,lwork,mm,n
                    logical(lk),intent(inout) :: select(*)
                    real(sp),intent(in) :: t(ldt,*)
                    real(sp),intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp),intent(out) :: work(*)
               end subroutine strevc3
#else
               module procedure la_strevc3
#endif
               module procedure la_wtrevc3
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztrevc3(side,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,mm,m, &
                          work,lwork,rwork,lrwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,side
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,lwork,lrwork,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(dp),intent(out) :: rwork(*)
                    complex(dp),intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztrevc3
#else
               module procedure la_ztrevc3
#endif
          end interface trevc3

          !> TREXC: reorders the Schur factorization of a complex matrix
          !> A = Q*T*Q**H, so that the diagonal element of T with row index IFST
          !> is moved to row ILST.
          !> The Schur form T is reordered by a unitary similarity transformation
          !> Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
          !> postmultplying it with Z.
          interface trexc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctrexc(compq,n,t,ldt,q,ldq,ifst,ilst,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq
                    integer(ilp),intent(in) :: ifst,ilst,ldq,ldt,n
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine ctrexc
#else
               module procedure la_ctrexc
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dtrexc(compq,n,t,ldt,q,ldq,ifst,ilst,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq
                    integer(ilp),intent(inout) :: ifst,ilst
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldq,ldt,n
                    real(dp),intent(inout) :: q(ldq,*),t(ldt,*)
                    real(dp),intent(out) :: work(*)
               end subroutine dtrexc
#else
               module procedure la_dtrexc
#endif
               module procedure la_qtrexc
#ifdef LA_EXTERNAL_LAPACK
               subroutine strexc(compq,n,t,ldt,q,ldq,ifst,ilst,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq
                    integer(ilp),intent(inout) :: ifst,ilst
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldq,ldt,n
                    real(sp),intent(inout) :: q(ldq,*),t(ldt,*)
                    real(sp),intent(out) :: work(*)
               end subroutine strexc
#else
               module procedure la_strexc
#endif
               module procedure la_wtrexc
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztrexc(compq,n,t,ldt,q,ldq,ifst,ilst,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq
                    integer(ilp),intent(in) :: ifst,ilst,ldq,ldt,n
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine ztrexc
#else
               module procedure la_ztrexc
#endif
          end interface trexc

          !> TRRFS: provides error bounds and backward error estimates for the
          !> solution to a system of linear equations with a triangular
          !> coefficient matrix.
          !> The solution matrix X must be computed by CTRTRS or some other
          !> means before entering this routine.  TRRFS does not do iterative
          !> refinement because doing so cannot improve the backward error.
          interface trrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctrrfs(uplo,trans,diag,n,nrhs,a,lda,b,ldb,x,ldx,ferr, &
                         berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldx,n,nrhs
                    real(sp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp),intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine ctrrfs
#else
               module procedure la_ctrrfs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtrrfs(uplo,trans,diag,n,nrhs,a,lda,b,ldb,x,ldx,ferr, &
                         berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldb,ldx,n,nrhs
                    real(dp),intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    real(dp),intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtrrfs
#else
               module procedure la_dtrrfs
#endif
               module procedure la_qtrrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine strrfs(uplo,trans,diag,n,nrhs,a,lda,b,ldb,x,ldx,ferr, &
                         berr,work,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: lda,ldb,ldx,n,nrhs
                    real(sp),intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    real(sp),intent(out) :: berr(*),ferr(*),work(*)
               end subroutine strrfs
#else
               module procedure la_strrfs
#endif
               module procedure la_wtrrfs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztrrfs(uplo,trans,diag,n,nrhs,a,lda,b,ldb,x,ldx,ferr, &
                         berr,work,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,ldx,n,nrhs
                    real(dp),intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp),intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine ztrrfs
#else
               module procedure la_ztrrfs
#endif
          end interface trrfs

          !> TRSEN: reorders the Schur factorization of a complex matrix
          !> A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
          !> the leading positions on the diagonal of the upper triangular matrix
          !> T, and the leading columns of Q form an orthonormal basis of the
          !> corresponding right invariant subspace.
          !> Optionally the routine computes the reciprocal condition numbers of
          !> the cluster of eigenvalues and/or the invariant subspace.
          interface trsen
#ifdef LA_EXTERNAL_LAPACK
               subroutine ctrsen(job,compq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,job
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldq,ldt,lwork,n
                    real(sp),intent(out) :: s,sep
                    logical(lk),intent(in) :: select(*)
                    complex(sp),intent(inout) :: q(ldq,*),t(ldt,*)
                    complex(sp),intent(out) :: w(*),work(*)
               end subroutine ctrsen
#else
               module procedure la_ctrsen
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dtrsen(job,compq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work, &
                         lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,job
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    integer(ilp),intent(in) :: ldq,ldt,liwork,lwork,n
                    real(dp),intent(out) :: s,sep,wi(*),work(*),wr(*)
                    logical(lk),intent(in) :: select(*)
                    real(dp),intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine dtrsen
#else
               module procedure la_dtrsen
#endif
               module procedure la_qtrsen
#ifdef LA_EXTERNAL_LAPACK
               subroutine strsen(job,compq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work, &
                         lwork,iwork,liwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,job
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    integer(ilp),intent(in) :: ldq,ldt,liwork,lwork,n
                    real(sp),intent(out) :: s,sep,wi(*),work(*),wr(*)
                    logical(lk),intent(in) :: select(*)
                    real(sp),intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine strsen
#else
               module procedure la_strsen
#endif
               module procedure la_wtrsen
#ifdef LA_EXTERNAL_LAPACK
               subroutine ztrsen(job,compq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork, &
                          info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: compq,job
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldq,ldt,lwork,n
                    real(dp),intent(out) :: s,sep
                    logical(lk),intent(in) :: select(*)
                    complex(dp),intent(inout) :: q(ldq,*),t(ldt,*)
                    complex(dp),intent(out) :: w(*),work(*)
               end subroutine ztrsen
#else
               module procedure la_ztrsen
#endif
          end interface trsen

          !> TRSNA: estimates reciprocal condition numbers for specified
          !> eigenvalues and/or right eigenvectors of a complex upper triangular
          !> matrix T (or of any matrix Q*T*Q**H with Q unitary).
          interface trsna
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctrsna(job,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,s,sep, &
                         mm,m,work,ldwork,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,job
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(sp),intent(out) :: rwork(*),s(*),sep(*)
                    complex(sp),intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp),intent(out) :: work(ldwork,*)
               end subroutine ctrsna
#else
               module procedure la_ctrsna
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dtrsna(job,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,s,sep,mm, &
                         m,work,ldwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,job
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(dp),intent(out) :: s(*),sep(*),work(ldwork,*)
                    real(dp),intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
               end subroutine dtrsna
#else
               module procedure la_dtrsna
#endif
               module procedure la_qtrsna
#ifdef LA_EXTERNAL_LAPACK
               subroutine strsna(job,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,s,sep,mm, &
                         m,work,ldwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,job
                    integer(ilp),intent(out) :: info,m,iwork(*)
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(sp),intent(out) :: s(*),sep(*),work(ldwork,*)
                    real(sp),intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
               end subroutine strsna
#else
               module procedure la_strsna
#endif
               module procedure la_wtrsna
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztrsna(job,howmny,select,n,t,ldt,vl,ldvl,vr,ldvr,s,sep, &
                         mm,m,work,ldwork,rwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: howmny,job
                    integer(ilp),intent(out) :: info,m
                    integer(ilp),intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk),intent(in) :: select(*)
                    real(dp),intent(out) :: rwork(*),s(*),sep(*)
                    complex(dp),intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp),intent(out) :: work(ldwork,*)
               end subroutine ztrsna
#else
               module procedure la_ztrsna
#endif
          end interface trsna

          !> TRSYL: solves the complex Sylvester matrix equation:
          !> op(A)*X + X*op(B) = scale*C or
          !> op(A)*X - X*op(B) = scale*C,
          !> where op(A) = A or A**H, and A and B are both upper triangular. A is
          !> M-by-M and B is N-by-N; the right hand side C and the solution X are
          !> M-by-N; and scale is an output scale factor, set <= 1 to avoid
          !> overflow in X.
          interface trsyl
#ifdef LA_EXTERNAL_LAPACK
               subroutine ctrsyl(trana,tranb,isgn,m,n,a,lda,b,ldb,c,ldc,scale,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trana,tranb
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(sp),intent(out) :: scale
                    complex(sp),intent(in) :: a(lda,*),b(ldb,*)
                    complex(sp),intent(inout) :: c(ldc,*)
               end subroutine ctrsyl
#else
               module procedure la_ctrsyl
#endif
#ifdef LA_EXTERNAL_LAPACK
               subroutine dtrsyl(trana,tranb,isgn,m,n,a,lda,b,ldb,c,ldc,scale,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trana,tranb
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(dp),intent(out) :: scale
                    real(dp),intent(in) :: a(lda,*),b(ldb,*)
                    real(dp),intent(inout) :: c(ldc,*)
               end subroutine dtrsyl
#else
               module procedure la_dtrsyl
#endif
               module procedure la_qtrsyl
#ifdef LA_EXTERNAL_LAPACK
               subroutine strsyl(trana,tranb,isgn,m,n,a,lda,b,ldb,c,ldc,scale,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trana,tranb
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(sp),intent(out) :: scale
                    real(sp),intent(in) :: a(lda,*),b(ldb,*)
                    real(sp),intent(inout) :: c(ldc,*)
               end subroutine strsyl
#else
               module procedure la_strsyl
#endif
               module procedure la_wtrsyl
#ifdef LA_EXTERNAL_LAPACK
               subroutine ztrsyl(trana,tranb,isgn,m,n,a,lda,b,ldb,c,ldc,scale,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: trana,tranb
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(dp),intent(out) :: scale
                    complex(dp),intent(in) :: a(lda,*),b(ldb,*)
                    complex(dp),intent(inout) :: c(ldc,*)
               end subroutine ztrsyl
#else
               module procedure la_ztrsyl
#endif
          end interface trsyl

          !> TRTRI: computes the inverse of a complex upper or lower triangular
          !> matrix A.
          !> This is the Level 3 BLAS version of the algorithm.
          interface trtri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctrtri(uplo,diag,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    complex(sp),intent(inout) :: a(lda,*)
               end subroutine ctrtri
#else
               module procedure la_ctrtri
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtrtri(uplo,diag,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(dp),intent(inout) :: a(lda,*)
               end subroutine dtrtri
#else
               module procedure la_dtrtri
#endif
               module procedure la_qtrtri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine strtri(uplo,diag,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    real(sp),intent(inout) :: a(lda,*)
               end subroutine strtri
#else
               module procedure la_strtri
#endif
               module procedure la_wtrtri
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztrtri(uplo,diag,n,a,lda,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,n
                    complex(dp),intent(inout) :: a(lda,*)
               end subroutine ztrtri
#else
               module procedure la_ztrtri
#endif
          end interface trtri

          !> TRTRS: solves a triangular system of the form
          !> A * X = B,  A**T * X = B,  or  A**H * X = B,
          !> where A is a triangular matrix of order N, and B is an N-by-NRHS
          !> matrix.  A check is made to verify that A is nonsingular.
          interface trtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctrtrs(uplo,trans,diag,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(inout) :: b(ldb,*)
               end subroutine ctrtrs
#else
               module procedure la_ctrtrs
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtrtrs(uplo,trans,diag,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(inout) :: b(ldb,*)
               end subroutine dtrtrs
#else
               module procedure la_dtrtrs
#endif
               module procedure la_qtrtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine strtrs(uplo,trans,diag,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(inout) :: b(ldb,*)
               end subroutine strtrs
#else
               module procedure la_strtrs
#endif
               module procedure la_wtrtrs
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztrtrs(uplo,trans,diag,n,nrhs,a,lda,b,ldb,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: diag,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldb,n,nrhs
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(inout) :: b(ldb,*)
               end subroutine ztrtrs
#else
               module procedure la_ztrtrs
#endif
          end interface trtrs

          !> TRTTF: copies a triangular matrix A from standard full format (TR)
          !> to rectangular full packed format (TF) .
          interface trttf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctrttf(transr,uplo,n,a,lda,arf,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    complex(sp),intent(in) :: a(0:lda - 1,0:*)
                    complex(sp),intent(out) :: arf(0:*)
               end subroutine ctrttf
#else
               module procedure la_ctrttf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtrttf(transr,uplo,n,a,lda,arf,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    real(dp),intent(in) :: a(0:lda - 1,0:*)
                    real(dp),intent(out) :: arf(0:*)
               end subroutine dtrttf
#else
               module procedure la_dtrttf
#endif
               module procedure la_qtrttf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine strttf(transr,uplo,n,a,lda,arf,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    real(sp),intent(in) :: a(0:lda - 1,0:*)
                    real(sp),intent(out) :: arf(0:*)
               end subroutine strttf
#else
               module procedure la_strttf
#endif
               module procedure la_wtrttf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztrttf(transr,uplo,n,a,lda,arf,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: transr,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    complex(dp),intent(in) :: a(0:lda - 1,0:*)
                    complex(dp),intent(out) :: arf(0:*)
               end subroutine ztrttf
#else
               module procedure la_ztrttf
#endif
          end interface trttf

          !> TRTTP: copies a triangular matrix A from full format (TR) to standard
          !> packed format (TP).
          interface trttp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctrttp(uplo,n,a,lda,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    complex(sp),intent(in) :: a(lda,*)
                    complex(sp),intent(out) :: ap(*)
               end subroutine ctrttp
#else
               module procedure la_ctrttp
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtrttp(uplo,n,a,lda,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    real(dp),intent(in) :: a(lda,*)
                    real(dp),intent(out) :: ap(*)
               end subroutine dtrttp
#else
               module procedure la_dtrttp
#endif
               module procedure la_qtrttp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine strttp(uplo,n,a,lda,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    real(sp),intent(in) :: a(lda,*)
                    real(sp),intent(out) :: ap(*)
               end subroutine strttp
#else
               module procedure la_strttp
#endif
               module procedure la_wtrttp
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztrttp(uplo,n,a,lda,ap,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: n,lda
                    complex(dp),intent(in) :: a(lda,*)
                    complex(dp),intent(out) :: ap(*)
               end subroutine ztrttp
#else
               module procedure la_ztrttp
#endif
          end interface trttp

          !> TZRZF: reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
          !> to upper triangular form by means of unitary transformations.
          !> The upper trapezoidal matrix A is factored as
          !> A = ( R  0 ) * Z,
          !> where Z is an N-by-N unitary matrix and R is an M-by-M upper
          !> triangular matrix.
          interface tzrzf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ctzrzf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: tau(*),work(*)
               end subroutine ctzrzf
#else
               module procedure la_ctzrzf
#endif
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine dtzrzf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(dp),intent(inout) :: a(lda,*)
                    real(dp),intent(out) :: tau(*),work(*)
               end subroutine dtzrzf
#else
               module procedure la_dtzrzf
#endif
               module procedure la_qtzrzf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine stzrzf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    real(sp),intent(inout) :: a(lda,*)
                    real(sp),intent(out) :: tau(*),work(*)
               end subroutine stzrzf
#else
               module procedure la_stzrzf
#endif
               module procedure la_wtzrzf
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine ztzrzf(m,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: tau(*),work(*)
               end subroutine ztzrzf
#else
               module procedure la_ztzrzf
#endif
          end interface tzrzf

          !> UNBDB: simultaneously bidiagonalizes the blocks of an M-by-M
          !> partitioned unitary matrix X:
          !> [ B11 | B12 0  0 ]
          !> [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**H
          !> X = [-----------] = [---------] [----------------] [---------]   .
          !> [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]
          !> [  0  |  0  0  I ]
          !> X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
          !> not the case, then X must be transposed and/or permuted. This can be
          !> done in constant time using the TRANS and SIGNS options. See CUNCSD
          !> for details.)
          !> The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
          !> (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
          !> represented implicitly by Householder vectors.
          !> B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
          !> implicitly by angles THETA, PHI.
          interface unbdb
#ifdef LA_EXTERNAL_LAPACK
               subroutine cunbdb(trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22, &
                         ldx22,theta,phi,taup1,taup2,tauq1,tauq2,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: signs,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(sp),intent(out) :: phi(*),theta(*)
                    complex(sp),intent(out) :: taup1(*),taup2(*),tauq1(*),tauq2(*),work(*)
                              
                    complex(sp),intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22( &
                              ldx22,*)
               end subroutine cunbdb
#else
               module procedure la_cunbdb
#endif
               module procedure la_wunbdb
#ifdef LA_EXTERNAL_LAPACK
               subroutine zunbdb(trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22, &
                         ldx22,theta,phi,taup1,taup2,tauq1,tauq2,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: signs,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(dp),intent(out) :: phi(*),theta(*)
                    complex(dp),intent(out) :: taup1(*),taup2(*),tauq1(*),tauq2(*),work(*)
                              
                    complex(dp),intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22( &
                              ldx22,*)
               end subroutine zunbdb
#else
               module procedure la_zunbdb
#endif
          end interface unbdb

          !> UNBDB1: simultaneously bidiagonalizes the blocks of a tall and skinny
          !> matrix X with orthonomal columns:
          !> [ B11 ]
          !> [ X11 ]   [ P1 |    ] [  0  ]
          !> [-----] = [---------] [-----] Q1**T .
          !> [ X21 ]   [    | P2 ] [ B21 ]
          !> [  0  ]
          !> X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P,
          !> M-P, or M-Q. Routines CUNBDB2, CUNBDB3, and CUNBDB4 handle cases in
          !> which Q is not the minimum dimension.
          !> The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !> and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !> Householder vectors.
          !> B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by
          !> angles THETA, PHI.
          interface unbdb1
#ifdef LA_EXTERNAL_LAPACK
               subroutine cunbdb1(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp),intent(out) :: phi(*),theta(*)
                    complex(sp),intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb1
#else
               module procedure la_cunbdb1
#endif
               module procedure la_wunbdb1
#ifdef LA_EXTERNAL_LAPACK
               subroutine zunbdb1(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp),intent(out) :: phi(*),theta(*)
                    complex(dp),intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb1
#else
               module procedure la_zunbdb1
#endif
          end interface unbdb1

          !> UNBDB2: simultaneously bidiagonalizes the blocks of a tall and skinny
          !> matrix X with orthonomal columns:
          !> [ B11 ]
          !> [ X11 ]   [ P1 |    ] [  0  ]
          !> [-----] = [---------] [-----] Q1**T .
          !> [ X21 ]   [    | P2 ] [ B21 ]
          !> [  0  ]
          !> X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P,
          !> Q, or M-Q. Routines CUNBDB1, CUNBDB3, and CUNBDB4 handle cases in
          !> which P is not the minimum dimension.
          !> The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !> and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !> Householder vectors.
          !> B11 and B12 are P-by-P bidiagonal matrices represented implicitly by
          !> angles THETA, PHI.
          interface unbdb2
#ifdef LA_EXTERNAL_LAPACK
               subroutine cunbdb2(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp),intent(out) :: phi(*),theta(*)
                    complex(sp),intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb2
#else
               module procedure la_cunbdb2
#endif
               module procedure la_wunbdb2
#ifdef LA_EXTERNAL_LAPACK
               subroutine zunbdb2(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp),intent(out) :: phi(*),theta(*)
                    complex(dp),intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb2
#else
               module procedure la_zunbdb2
#endif
          end interface unbdb2

          !> UNBDB3: simultaneously bidiagonalizes the blocks of a tall and skinny
          !> matrix X with orthonomal columns:
          !> [ B11 ]
          !> [ X11 ]   [ P1 |    ] [  0  ]
          !> [-----] = [---------] [-----] Q1**T .
          !> [ X21 ]   [    | P2 ] [ B21 ]
          !> [  0  ]
          !> X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P,
          !> Q, or M-Q. Routines CUNBDB1, CUNBDB2, and CUNBDB4 handle cases in
          !> which M-P is not the minimum dimension.
          !> The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !> and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !> Householder vectors.
          !> B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented
          !> implicitly by angles THETA, PHI.
          interface unbdb3
#ifdef LA_EXTERNAL_LAPACK
               subroutine cunbdb3(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp),intent(out) :: phi(*),theta(*)
                    complex(sp),intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb3
#else
               module procedure la_cunbdb3
#endif
               module procedure la_wunbdb3
#ifdef LA_EXTERNAL_LAPACK
               subroutine zunbdb3(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp),intent(out) :: phi(*),theta(*)
                    complex(dp),intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb3
#else
               module procedure la_zunbdb3
#endif
          end interface unbdb3

          !> UNBDB4: simultaneously bidiagonalizes the blocks of a tall and skinny
          !> matrix X with orthonomal columns:
          !> [ B11 ]
          !> [ X11 ]   [ P1 |    ] [  0  ]
          !> [-----] = [---------] [-----] Q1**T .
          !> [ X21 ]   [    | P2 ] [ B21 ]
          !> [  0  ]
          !> X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P,
          !> M-P, or Q. Routines CUNBDB1, CUNBDB2, and CUNBDB3 handle cases in
          !> which M-Q is not the minimum dimension.
          !> The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !> and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !> Householder vectors.
          !> B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented
          !> implicitly by angles THETA, PHI.
          interface unbdb4
#ifdef LA_EXTERNAL_LAPACK
               subroutine cunbdb4(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,phantom,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp),intent(out) :: phi(*),theta(*)
                    complex(sp),intent(out) :: phantom(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    complex(sp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb4
#else
               module procedure la_cunbdb4
#endif
               module procedure la_wunbdb4
#ifdef LA_EXTERNAL_LAPACK
               subroutine zunbdb4(m,p,q,x11,ldx11,x21,ldx21,theta,phi,taup1,taup2, &
                         tauq1,phantom,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp),intent(out) :: phi(*),theta(*)
                    complex(dp),intent(out) :: phantom(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    complex(dp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb4
#else
               module procedure la_zunbdb4
#endif
          end interface unbdb4

          !> UNBDB5: orthogonalizes the column vector
          !> X = [ X1 ]
          !> [ X2 ]
          !> with respect to the columns of
          !> Q = [ Q1 ] .
          !> [ Q2 ]
          !> The columns of Q must be orthonormal.
          !> If the projection is zero according to Kahan's "twice is enough"
          !> criterion, then some other vector from the orthogonal complement
          !> is returned. This vector is chosen in an arbitrary but deterministic
          !> way.
          interface unbdb5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunbdb5(m1,m2,n,x1,incx1,x2,incx2,q1,ldq1,q2,ldq2,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x1(*),x2(*)
               end subroutine cunbdb5
#else
               module procedure la_cunbdb5
#endif
               module procedure la_wunbdb5
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunbdb5(m1,m2,n,x1,incx1,x2,incx2,q1,ldq1,q2,ldq2,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x1(*),x2(*)
               end subroutine zunbdb5
#else
               module procedure la_zunbdb5
#endif
          end interface unbdb5

          !> UNBDB6: orthogonalizes the column vector
          !> X = [ X1 ]
          !> [ X2 ]
          !> with respect to the columns of
          !> Q = [ Q1 ] .
          !> [ Q2 ]
          !> The columns of Q must be orthonormal.
          !> If the projection is zero according to Kahan's "twice is enough"
          !> criterion, then the zero vector is returned.
          interface unbdb6
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunbdb6(m1,m2,n,x1,incx1,x2,incx2,q1,ldq1,q2,ldq2,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(sp),intent(out) :: work(*)
                    complex(sp),intent(inout) :: x1(*),x2(*)
               end subroutine cunbdb6
#else
               module procedure la_cunbdb6
#endif
               module procedure la_wunbdb6
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunbdb6(m1,m2,n,x1,incx1,x2,incx2,q1,ldq1,q2,ldq2,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(dp),intent(out) :: work(*)
                    complex(dp),intent(inout) :: x1(*),x2(*)
               end subroutine zunbdb6
#else
               module procedure la_zunbdb6
#endif
          end interface unbdb6

          !> UNCSD: computes the CS decomposition of an M-by-M partitioned
          !> unitary matrix X:
          !> [  I  0  0 |  0  0  0 ]
          !> [  0  C  0 |  0 -S  0 ]
          !> [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**H
          !> X = [-----------] = [---------] [---------------------] [---------]   .
          !> [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]
          !> [  0  S  0 |  0  C  0 ]
          !> [  0  0  I |  0  0  0 ]
          !> X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,
          !> (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
          !> R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
          !> which R = MIN(P,M-P,Q,M-Q).
          interface uncsd
#ifdef LA_EXTERNAL_LAPACK
               recursive subroutine cuncsd(jobu1,jobu2,jobv1t,jobv2t,trans,signs,m,p,q, &
               x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t, &
                         ldv1t,v2t,ldv2t,work,lwork,rwork,lrwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22, &
                              lrwork,lwork,m,p,q
                    real(sp),intent(out) :: theta(*),rwork(*)
                    complex(sp),intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*), &
                              work(*)
                    complex(sp),intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22( &
                              ldx22,*)
               end subroutine cuncsd
#else
               module procedure la_cuncsd
#endif
               module procedure la_wuncsd
#ifdef LA_EXTERNAL_LAPACK
               recursive subroutine zuncsd(jobu1,jobu2,jobv1t,jobv2t,trans,signs,m,p,q, &
               x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t, &
                         ldv1t,v2t,ldv2t,work,lwork,rwork,lrwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22, &
                              lrwork,lwork,m,p,q
                    real(dp),intent(out) :: theta(*),rwork(*)
                    complex(dp),intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*), &
                              work(*)
                    complex(dp),intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22( &
                              ldx22,*)
               end subroutine zuncsd
#else
               module procedure la_zuncsd
#endif
          end interface uncsd

          !> UNCSD2BY1: computes the CS decomposition of an M-by-Q matrix X with
          !> orthonormal columns that has been partitioned into a 2-by-1 block
          !> structure:
          !> [  I1 0  0 ]
          !> [  0  C  0 ]
          !> [ X11 ]   [ U1 |    ] [  0  0  0 ]
          !> X = [-----] = [---------] [----------] V1**T .
          !> [ X21 ]   [    | U2 ] [  0  0  0 ]
          !> [  0  S  0 ]
          !> [  0  0  I2]
          !> X11 is P-by-Q. The unitary matrices U1, U2, and V1 are P-by-P,
          !> (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R
          !> nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which
          !> R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a
          !> K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).
          interface uncsd2by1
#ifdef LA_EXTERNAL_LAPACK
               subroutine cuncsd2by1(jobu1,jobu2,jobv1t,m,p,q,x11,ldx11,x21,ldx21,theta, &
                          u1,ldu1,u2,ldu2,v1t,ldv1t,work,lwork,rwork,lrwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q, &
                              lrwork
                    real(sp),intent(out) :: rwork(*),theta(*)
                    complex(sp),intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                    complex(sp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cuncsd2by1
#else
               module procedure la_cuncsd2by1
#endif
               module procedure la_wuncsd2by1
#ifdef LA_EXTERNAL_LAPACK
               subroutine zuncsd2by1(jobu1,jobu2,jobv1t,m,p,q,x11,ldx11,x21,ldx21,theta, &
                          u1,ldu1,u2,ldu2,v1t,ldv1t,work,lwork,rwork,lrwork,iwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp),intent(out) :: info,iwork(*)
                    integer(ilp),intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q, &
                              lrwork
                    real(dp),intent(out) :: rwork(*),theta(*)
                    complex(dp),intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                    complex(dp),intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zuncsd2by1
#else
               module procedure la_zuncsd2by1
#endif
          end interface uncsd2by1

          !> UNG2L: generates an m by n complex matrix Q with orthonormal columns,
          !> which is defined as the last n columns of a product of k elementary
          !> reflectors of order m
          !> Q  =  H(k) . . . H(2) H(1)
          !> as returned by CGEQLF.
          interface ung2l
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cung2l(m,n,k,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cung2l
#else
               module procedure la_cung2l
#endif
               module procedure la_wung2l
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zung2l(m,n,k,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zung2l
#else
               module procedure la_zung2l
#endif
          end interface ung2l

          !> UNG2R: generates an m by n complex matrix Q with orthonormal columns,
          !> which is defined as the first n columns of a product of k elementary
          !> reflectors of order m
          !> Q  =  H(1) H(2) . . . H(k)
          !> as returned by CGEQRF.
          interface ung2r
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cung2r(m,n,k,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cung2r
#else
               module procedure la_cung2r
#endif
               module procedure la_wung2r
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zung2r(m,n,k,a,lda,tau,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zung2r
#else
               module procedure la_zung2r
#endif
          end interface ung2r

          !> UNGBR: generates one of the complex unitary matrices Q or P**H
          !> determined by CGEBRD when reducing a complex matrix A to bidiagonal
          !> form: A = Q * B * P**H.  Q and P**H are defined as products of
          !> elementary reflectors H(i) or G(i) respectively.
          !> If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
          !> is of order M:
          !> if m >= k, Q = H(1) H(2) . . . H(k) and UNGBR returns the first n
          !> columns of Q, where m >= n >= k;
          !> if m < k, Q = H(1) H(2) . . . H(m-1) and UNGBR returns Q as an
          !> M-by-M matrix.
          !> If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
          !> is of order N:
          !> if k < n, P**H = G(k) . . . G(2) G(1) and UNGBR returns the first m
          !> rows of P**H, where n >= m >= k;
          !> if k >= n, P**H = G(n-1) . . . G(2) G(1) and UNGBR returns P**H as
          !> an N-by-N matrix.
          interface ungbr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cungbr(vect,m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cungbr
#else
               module procedure la_cungbr
#endif
               module procedure la_wungbr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zungbr(vect,m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zungbr
#else
               module procedure la_zungbr
#endif
          end interface ungbr

          !> UNGHR: generates a complex unitary matrix Q which is defined as the
          !> product of IHI-ILO elementary reflectors of order N, as returned by
          !> CGEHRD:
          !> Q = H(ilo) H(ilo+1) . . . H(ihi-1).
          interface unghr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunghr(n,ilo,ihi,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunghr
#else
               module procedure la_cunghr
#endif
               module procedure la_wunghr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunghr(n,ilo,ihi,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunghr
#else
               module procedure la_zunghr
#endif
          end interface unghr

          !> UNGLQ: generates an M-by-N complex matrix Q with orthonormal rows,
          !> which is defined as the first M rows of a product of K elementary
          !> reflectors of order N
          !> Q  =  H(k)**H . . . H(2)**H H(1)**H
          !> as returned by CGELQF.
          interface unglq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunglq(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunglq
#else
               module procedure la_cunglq
#endif
               module procedure la_wunglq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunglq(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunglq
#else
               module procedure la_zunglq
#endif
          end interface unglq

          !> UNGQL: generates an M-by-N complex matrix Q with orthonormal columns,
          !> which is defined as the last N columns of a product of K elementary
          !> reflectors of order M
          !> Q  =  H(k) . . . H(2) H(1)
          !> as returned by CGEQLF.
          interface ungql
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cungql(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cungql
#else
               module procedure la_cungql
#endif
               module procedure la_wungql
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zungql(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zungql
#else
               module procedure la_zungql
#endif
          end interface ungql

          !> UNGQR: generates an M-by-N complex matrix Q with orthonormal columns,
          !> which is defined as the first N columns of a product of K elementary
          !> reflectors of order M
          !> Q  =  H(1) H(2) . . . H(k)
          !> as returned by CGEQRF.
          interface ungqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cungqr(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cungqr
#else
               module procedure la_cungqr
#endif
               module procedure la_wungqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zungqr(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zungqr
#else
               module procedure la_zungqr
#endif
          end interface ungqr

          !> UNGRQ: generates an M-by-N complex matrix Q with orthonormal rows,
          !> which is defined as the last M rows of a product of K elementary
          !> reflectors of order N
          !> Q  =  H(1)**H H(2)**H . . . H(k)**H
          !> as returned by CGERQF.
          interface ungrq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cungrq(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cungrq
#else
               module procedure la_cungrq
#endif
               module procedure la_wungrq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zungrq(m,n,k,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zungrq
#else
               module procedure la_zungrq
#endif
          end interface ungrq

          !> UNGTR: generates a complex unitary matrix Q which is defined as the
          !> product of n-1 elementary reflectors of order N, as returned by
          !> CHETRD:
          !> if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !> if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
          interface ungtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cungtr(uplo,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cungtr
#else
               module procedure la_cungtr
#endif
               module procedure la_wungtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zungtr(uplo,n,a,lda,tau,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,lwork,n
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zungtr
#else
               module procedure la_zungtr
#endif
          end interface ungtr

          !> UNGTSQR: generates an M-by-N complex matrix Q_out with orthonormal
          !> columns, which are the first N columns of a product of comlpex unitary
          !> matrices of order M which are returned by CLATSQR
          !> Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !> See the documentation for CLATSQR.
          interface ungtsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cungtsqr(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: t(ldt,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cungtsqr
#else
               module procedure la_cungtsqr
#endif
               module procedure la_wungtsqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zungtsqr(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: t(ldt,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zungtsqr
#else
               module procedure la_zungtsqr
#endif
          end interface ungtsqr

          !> UNGTSQR_ROW: generates an M-by-N complex matrix Q_out with
          !> orthonormal columns from the output of CLATSQR. These N orthonormal
          !> columns are the first N columns of a product of complex unitary
          !> matrices Q(k)_in of order M, which are returned by CLATSQR in
          !> a special format.
          !> Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !> The input matrices Q(k)_in are stored in row and column blocks in A.
          !> See the documentation of CLATSQR for more details on the format of
          !> Q(k)_in, where each Q(k)_in is represented by block Householder
          !> transformations. This routine calls an auxiliary routine CLARFB_GETT,
          !> where the computation is performed on each individual block. The
          !> algorithm first sweeps NB-sized column blocks from the right to left
          !> starting in the bottom row block and continues to the top row block
          !> (hence _ROW in the routine name). This sweep is in reverse order of
          !> the order in which CLATSQR generates the output blocks.
          interface ungtsqr_row
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cungtsqr_row(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(in) :: t(ldt,*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cungtsqr_row
#else
               module procedure la_cungtsqr_row
#endif
               module procedure la_wungtsqr_row
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zungtsqr_row(m,n,mb,nb,a,lda,t,ldt,work,lwork,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(in) :: t(ldt,*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zungtsqr_row
#else
               module procedure la_zungtsqr_row
#endif
          end interface ungtsqr_row

          !> UNHR_COL: takes an M-by-N complex matrix Q_in with orthonormal columns
          !> as input, stored in A, and performs Householder Reconstruction (HR),
          !> i.e. reconstructs Householder vectors V(i) implicitly representing
          !> another M-by-N matrix Q_out, with the property that Q_in = Q_out*S,
          !> where S is an N-by-N diagonal matrix with diagonal entries
          !> equal to +1 or -1. The Householder vectors (columns V(i) of V) are
          !> stored in A on output, and the diagonal entries of S are stored in D.
          !> Block reflectors are also returned in T
          !> (same output format as CGEQRT).
          interface unhr_col
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunhr_col(m,n,nb,a,lda,t,ldt,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,nb
                    complex(sp),intent(inout) :: a(lda,*)
                    complex(sp),intent(out) :: d(*),t(ldt,*)
               end subroutine cunhr_col
#else
               module procedure la_cunhr_col
#endif
               module procedure la_wunhr_col
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunhr_col(m,n,nb,a,lda,t,ldt,d,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldt,m,n,nb
                    complex(dp),intent(inout) :: a(lda,*)
                    complex(dp),intent(out) :: d(*),t(ldt,*)
               end subroutine zunhr_col
#else
               module procedure la_zunhr_col
#endif
          end interface unhr_col

          !> UNM2L: overwrites the general complex m-by-n matrix C with
          !> Q * C  if SIDE = 'L' and TRANS = 'N', or
          !> Q**H* C  if SIDE = 'L' and TRANS = 'C', or
          !> C * Q  if SIDE = 'R' and TRANS = 'N', or
          !> C * Q**H if SIDE = 'R' and TRANS = 'C',
          !> where Q is a complex unitary matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(k) . . . H(2) H(1)
          !> as returned by CGEQLF. Q is of order m if SIDE = 'L' and of order n
          !> if SIDE = 'R'.
          interface unm2l
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunm2l(side,trans,m,n,k,a,lda,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,m,n
                    complex(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunm2l
#else
               module procedure la_cunm2l
#endif
               module procedure la_wunm2l
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunm2l(side,trans,m,n,k,a,lda,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,m,n
                    complex(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunm2l
#else
               module procedure la_zunm2l
#endif
          end interface unm2l

          !> UNM2R: overwrites the general complex m-by-n matrix C with
          !> Q * C  if SIDE = 'L' and TRANS = 'N', or
          !> Q**H* C  if SIDE = 'L' and TRANS = 'C', or
          !> C * Q  if SIDE = 'R' and TRANS = 'N', or
          !> C * Q**H if SIDE = 'R' and TRANS = 'C',
          !> where Q is a complex unitary matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(1) H(2) . . . H(k)
          !> as returned by CGEQRF. Q is of order m if SIDE = 'L' and of order n
          !> if SIDE = 'R'.
          interface unm2r
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunm2r(side,trans,m,n,k,a,lda,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,m,n
                    complex(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunm2r
#else
               module procedure la_cunm2r
#endif
               module procedure la_wunm2r
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunm2r(side,trans,m,n,k,a,lda,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,m,n
                    complex(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunm2r
#else
               module procedure la_zunm2r
#endif
          end interface unm2r

          !> If VECT = 'Q', UNMBR: overwrites the general complex M-by-N matrix C
          !> with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> If VECT = 'P', UNMBR overwrites the general complex M-by-N matrix C
          !> with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      P * C          C * P
          !> TRANS = 'C':      P**H * C       C * P**H
          !> Here Q and P**H are the unitary matrices determined by CGEBRD when
          !> reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
          !> and P**H are defined as products of elementary reflectors H(i) and
          !> G(i) respectively.
          !> Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
          !> order of the unitary matrix Q or P**H that is applied.
          !> If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
          !> if nq >= k, Q = H(1) H(2) . . . H(k);
          !> if nq < k, Q = H(1) H(2) . . . H(nq-1).
          !> If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
          !> if k < nq, P = G(1) G(2) . . . G(k);
          !> if k >= nq, P = G(1) G(2) . . . G(nq-1).
          interface unmbr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunmbr(vect,side,trans,m,n,k,a,lda,tau,c,ldc,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunmbr
#else
               module procedure la_cunmbr
#endif
               module procedure la_wunmbr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunmbr(vect,side,trans,m,n,k,a,lda,tau,c,ldc,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,vect
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunmbr
#else
               module procedure la_zunmbr
#endif
          end interface unmbr

          !> UNMHR: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix of order nq, with nq = m if
          !> SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !> IHI-ILO elementary reflectors, as returned by CGEHRD:
          !> Q = H(ilo) H(ilo+1) . . . H(ihi-1).
          interface unmhr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunmhr(side,trans,m,n,ilo,ihi,a,lda,tau,c,ldc,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp),intent(out) :: info
                    complex(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunmhr
#else
               module procedure la_cunmhr
#endif
               module procedure la_wunmhr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunmhr(side,trans,m,n,ilo,ihi,a,lda,tau,c,ldc,work, &
                         lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp),intent(out) :: info
                    complex(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunmhr
#else
               module procedure la_zunmhr
#endif
          end interface unmhr

          !> UNMLQ: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(k)**H . . . H(2)**H H(1)**H
          !> as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
          !> if SIDE = 'R'.
          interface unmlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunmlq(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunmlq
#else
               module procedure la_cunmlq
#endif
               module procedure la_wunmlq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunmlq(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunmlq
#else
               module procedure la_zunmlq
#endif
          end interface unmlq

          !> UNMQL: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(k) . . . H(2) H(1)
          !> as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N
          !> if SIDE = 'R'.
          interface unmql
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunmql(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunmql
#else
               module procedure la_cunmql
#endif
               module procedure la_wunmql
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunmql(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunmql
#else
               module procedure la_zunmql
#endif
          end interface unmql

          !> UNMQR: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(1) H(2) . . . H(k)
          !> as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
          !> if SIDE = 'R'.
          interface unmqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunmqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunmqr
#else
               module procedure la_cunmqr
#endif
               module procedure la_wunmqr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunmqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunmqr
#else
               module procedure la_zunmqr
#endif
          end interface unmqr

          !> UNMRQ: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(1)**H H(2)**H . . . H(k)**H
          !> as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N
          !> if SIDE = 'R'.
          interface unmrq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunmrq(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunmrq
#else
               module procedure la_cunmrq
#endif
               module procedure la_wunmrq
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunmrq(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunmrq
#else
               module procedure la_zunmrq
#endif
          end interface unmrq

          !> UNMRZ: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix defined as the product of k
          !> elementary reflectors
          !> Q = H(1) H(2) . . . H(k)
          !> as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N
          !> if SIDE = 'R'.
          interface unmrz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunmrz(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,l,lda,ldc,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunmrz
#else
               module procedure la_cunmrz
#endif
               module procedure la_wunmrz
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunmrz(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: k,l,lda,ldc,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunmrz
#else
               module procedure la_zunmrz
#endif
          end interface unmrz

          !> UNMTR: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix of order nq, with nq = m if
          !> SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !> nq-1 elementary reflectors, as returned by CHETRD:
          !> if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !> if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
          interface unmtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cunmtr(side,uplo,trans,m,n,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldc,lwork,m,n
                    complex(sp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cunmtr
#else
               module procedure la_cunmtr
#endif
               module procedure la_wunmtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zunmtr(side,uplo,trans,m,n,a,lda,tau,c,ldc,work,lwork, &
                         info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: lda,ldc,lwork,m,n
                    complex(dp),intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zunmtr
#else
               module procedure la_zunmtr
#endif
          end interface unmtr

          !> UPGTR: generates a complex unitary matrix Q which is defined as the
          !> product of n-1 elementary reflectors H(i) of order n, as returned by
          !> CHPTRD using packed storage:
          !> if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !> if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
          interface upgtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cupgtr(uplo,n,ap,tau,q,ldq,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldq,n
                    complex(sp),intent(in) :: ap(*),tau(*)
                    complex(sp),intent(out) :: q(ldq,*),work(*)
               end subroutine cupgtr
#else
               module procedure la_cupgtr
#endif
               module procedure la_wupgtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zupgtr(uplo,n,ap,tau,q,ldq,work,info)
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldq,n
                    complex(dp),intent(in) :: ap(*),tau(*)
                    complex(dp),intent(out) :: q(ldq,*),work(*)
               end subroutine zupgtr
#else
               module procedure la_zupgtr
#endif
          end interface upgtr

          !> UPMTR: overwrites the general complex M-by-N matrix C with
          !> SIDE = 'L'     SIDE = 'R'
          !> TRANS = 'N':      Q * C          C * Q
          !> TRANS = 'C':      Q**H * C       C * Q**H
          !> where Q is a complex unitary matrix of order nq, with nq = m if
          !> SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !> nq-1 elementary reflectors, as returned by CHPTRD using packed
          !> storage:
          !> if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !> if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
          interface upmtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine cupmtr(side,uplo,trans,m,n,ap,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldc,m,n
                    complex(sp),intent(inout) :: ap(*),c(ldc,*)
                    complex(sp),intent(in) :: tau(*)
                    complex(sp),intent(out) :: work(*)
               end subroutine cupmtr
#else
               module procedure la_cupmtr
#endif
               module procedure la_wupmtr
#ifdef LA_EXTERNAL_LAPACK
               pure subroutine zupmtr(side,uplo,trans,m,n,ap,tau,c,ldc,work,info)
                         
                    import sp,dp,qp,ilp,lk
                    implicit none(type,external)
                    character,intent(in) :: side,trans,uplo
                    integer(ilp),intent(out) :: info
                    integer(ilp),intent(in) :: ldc,m,n
                    complex(dp),intent(inout) :: ap(*),c(ldc,*)
                    complex(dp),intent(in) :: tau(*)
                    complex(dp),intent(out) :: work(*)
               end subroutine zupmtr
#else
               module procedure la_zupmtr
#endif
          end interface upmtr

end module la_lapack
