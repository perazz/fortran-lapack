<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fortran-lapack: fortran-lapack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init()
        </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fortran-lapack
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">fortran-lapack </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2fortran-lapack_2fortran-lapack_2_r_e_a_d_m_e"></a></p>
<p>This package provides precision-agnostic, high-level linear algebra APIs for <code>real</code> and <code>complex</code> arguments in Modern Fortran. The APIs are similar to NumPy/SciPy operations, and leverage a Modern Fortran implementation of the <a href="http://github.com/reference-LAPACK">Reference-LAPACK</a> library.</p>
<p>A full and standardized implementation of the present library has been integrated into the <a href="http://stdlib.fortran-lang.org/">Fortran Standard Library</a>, and as such, most users should seek to access the functionality from <code>stdlib</code>. The present library is kept in place for those who seek a compact implementation of it.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Browse API</h1>
<p>All procedures work with all types (<code>real</code>, <code>complex</code>) and kinds (32, 64, 128-bit floats).</p>
<h2><a class="anchor" id="autotoc_md6"></a>
<a class="el" href="interfacela__solve_1_1solve.html">solve</a> - Solve a linear matrix equation or a linear system of equations.</h2>
<h3><a class="anchor" id="autotoc_md7"></a>
Syntax</h3>
<p><code>x = solve(a, b [, overwrite_a] [, err])</code> <br  />
</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Description</h3>
<p>Solve linear systems - one (<code>b(:)</code>) or many (<code>b(:,:)</code>). <br  />
</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> or <code>complex</code> coefficient matrix. If <code>overwrite_a=.true.</code>, it is destroyed by the call.</li>
<li><code>b</code>: A rank-1 (one system) or rank-2 (many systems) array of the same kind as <code>a</code>, containing the right-hand-side vector(s).</li>
<li><code>overwrite_a</code> (optional, default = <code>.false.</code>): If <code>.true.</code>, input matrix <code>a</code> will be used as temporary storage and overwritten, to avoid internal data allocation.</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html">type(la_state)</a> variable.</li>
</ul>
<h3><a class="anchor" id="autotoc_md10"></a>
Return value</h3>
<p>For a full-rank matrix, returns an array value that represents the solution to the linear system of equations.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d">LINALG_ERROR</a> if the matrix is singular to working precision.</li>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903">LINALG_VALUE_ERROR</a> if the matrix and rhs vectors have invalid/incompatible sizes.</li>
<li>If <code>err</code> is not present, exceptions trigger an <code>error stop</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
<a class="el" href="interfacela__least__squares_1_1lstsq.html">lstsq</a> - Compute a least squares solution to a system of linear equations.</h2>
<h3><a class="anchor" id="autotoc_md13"></a>
Syntax</h3>
<p><code>x = lstsq(a, b [, cond] [, overwrite_a] [, rank] [, err])</code></p>
<h3><a class="anchor" id="autotoc_md14"></a>
Description</h3>
<p>Solves the least-squares problem for the system \( A \cdot x = b \), where \( A \) is a square matrix of size \( n \times n \) and \( b \) is either a vector of size \( n \) or a matrix of size \( n \times nrhs \). The function minimizes the 2-norm \( \|b - A \cdot x\| \) by solving for \( x \).</p>
<p>The result \( x \) is returned as an allocatable array, and it is either a vector (for a single right-hand side) or a matrix (for multiple right-hand sides).</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> matrix of size \( n \times n \) representing the coefficient matrix. If <code>overwrite_a = .true.</code>, the contents of <code>a</code> may be modified during the computation.</li>
<li><code>b</code>: A <code>real</code> vector or matrix representing the right-hand side. The size should be \( n \) (for a single right-hand side) or \( n \times nrhs \) (for multiple right-hand sides).</li>
<li><code>cond</code> (optional): A cutoff for rank evaluation. Singular values \( s(i) \) such that \( s(i) \leq \text{cond} \cdot \max(s) \) are considered zero.</li>
<li><code>overwrite_a</code> (optional, default = <code>.false.</code>): If <code>.true.</code>, both <code>a</code> and <code>b</code> may be overwritten and destroyed during computation.</li>
<li><code>rank</code> (optional): An integer variable that returns the rank of the matrix \( A \).</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html">type(la_state)</a> variable that returns the error state. If <code>err</code> is not provided, the function will stop execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md16"></a>
Return value</h3>
<p>Returns the solution array \( x \) with size \( n \) (for a single right-hand side) or \( n \times nrhs \) (for multiple right-hand sides).</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d">LINALG_ERROR</a> if the matrix \( A \) is singular to working precision.</li>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903">LINALG_VALUE_ERROR</a> if the matrix <code>a</code> and the right-hand side <code>b</code> have incompatible sizes.</li>
<li>If <code>err</code> is not provided, the function stops execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md18"></a>
Notes</h3>
<ul>
<li>This function relies on LAPACK's least-squares solvers, such as <a class="el" href="interfacela__lapack_1_1gelss.html">GELSS</a>.</li>
<li>If <code>overwrite_a</code> is enabled, the original contents of <code>a</code> and <code>b</code> may be lost.</li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
<a class="el" href="interfacela__determinant_1_1det.html">det</a> - Determinant of a scalar or rectangular matrix.</h2>
<h3><a class="anchor" id="autotoc_md20"></a>
Syntax</h3>
<p><code>d = det(a [, overwrite_a] [, err])</code></p>
<h3><a class="anchor" id="autotoc_md21"></a>
Description</h3>
<p>This function computes the determinant of a square matrix \( A \). The matrix must be a real matrix of size \( [m, n] \), and the determinant is computed using an efficient factorization method (e.g., LU decomposition).</p>
<h3><a class="anchor" id="autotoc_md22"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A real matrix of size \( [m, n] \), representing the rectangular matrix for which the determinant is calculated. If <code>overwrite_a</code>, it is an <code>inout</code> argument and may be modified during computation.</li>
<li><code>overwrite_a</code> (optional, default = <code>.false.</code>): A logical flag that determines whether the input matrix <code>a</code> can be overwritten. If <code>.true.</code>, the matrix <code>a</code> may be destroyed and modified in place to save memory.</li>
<li><code>err</code> (optional): A state return flag of <a class="el" href="structla__state__type_1_1la__state.html">type(la_state)</a>. If an error occurs and <code>err</code> is not provided, the function will stop execution.</li>
</ul>
<h3><a class="anchor" id="autotoc_md23"></a>
Return value</h3>
<p>The function returns a <code>real</code> scalar value representing the determinant of the input matrix \( A \), with the same kind as \( A \).</p>
<h3><a class="anchor" id="autotoc_md24"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903">LINALG_VALUE_ERROR</a> if the matrix <code>a</code> is not square.</li>
<li>If <code>err</code> is not provided, the function will stop execution on errors.</li>
</ul>
<h3><a class="anchor" id="autotoc_md25"></a>
Notes</h3>
<ul>
<li>The determinant of the matrix is computed using the LAPACK <a class="el" href="interfacela__lapack_1_1getrf.html">getrf</a> backend.</li>
<li>If <code>overwrite_a</code> is enabled, the input matrix <code>a</code> will be destroyed during the computation process.</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
<a class="el" href="interfacela__inverse_1_1inv.html">inv</a> - Inverse of a square matrix.</h2>
<h3><a class="anchor" id="autotoc_md27"></a>
Syntax</h3>
<p><code>inv_a = inv(a [, err])</code></p>
<h3><a class="anchor" id="autotoc_md28"></a>
Description</h3>
<p>This function computes the inverse \( A^{-1} \) of a real or complex square matrix \( A \), provided that \( A \) is non-singular. The inverse of a matrix is defined as:</p>
<p class="formulaDsp">
\[A A^{-1} = A^{-1} A = I
\]
</p>
<p>where \( I \) is the identity matrix of the same size as \( A \). The inverse exists only if \( A \) is square and has full rank (i.e., all its singular values are nonzero).</p>
<p>The computation is performed using LU decomposition.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> or <code>complex</code> square matrix of size \( [n,n] \), representing the matrix to be inverted.</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html">type(la_state)</a> variable that returns the error state. If not provided, the function will stop execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md30"></a>
Return value</h3>
<ul>
<li><code>inv_a</code>: A <code>real</code> or <code>complex</code> square matrix of size \( [n,n] \), representing the inverse of <code>a</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md31"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903">LINALG_VALUE_ERROR</a> if <code>a</code> is singular or has invalid size.</li>
<li>If <code>err</code> is not provided, exceptions will trigger an <code>error stop</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md32"></a>
Notes</h3>
<ul>
<li>This function computes the inverse using LAPACK's LU decomposition routine <a class="el" href="interfacela__lapack_1_1getrf.html">GETRF</a> followed by <a class="el" href="interfacela__lapack_1_1getri.html">GETRI</a>.</li>
<li>The inverse should be used with caution in numerical computations. For solving linear systems, using <a class="el" href="interfacela__solve_1_1solve.html">solve</a> is usually more stable and efficient than explicitly computing the inverse.</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
<a class="el" href="interfacela__inverse_1_1invert.html">invert</a> - In-place matrix inversion</h2>
<h3><a class="anchor" id="autotoc_md34"></a>
Syntax</h3>
<p><code>call invert(a [, err])</code></p>
<h3><a class="anchor" id="autotoc_md35"></a>
Description</h3>
<p>This subroutine computes the inverse \( A^{-1} \) of a real or complex square matrix \( A \) <b>in-place</b>, modifying <code>a</code> directly. It uses the LU decomposition method via LAPACK's <a class="el" href="interfacela__lapack_1_1getrf.html">GETRF</a> and <a class="el" href="interfacela__lapack_1_1getri.html">GETRI</a> routines.</p>
<p>Given a square matrix \( A \), the LU decomposition factorizes it as:</p>
<p class="formulaDsp">
\[A = P L U
\]
</p>
<p>where:</p><ul>
<li>\( P \) is a permutation matrix,</li>
<li>\( L \) is a lower triangular matrix with unit diagonal,</li>
<li>\( U \) is an upper triangular matrix.</li>
</ul>
<p>The inverse is then obtained by solving \( A X = I \) using the LU factors.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> or <code>complex</code> square matrix of size \( [n,n] \). On output, it is replaced with its inverse \( A^{-1} \).</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html">type(la_state)</a> variable that returns the error state. If not provided, the function will stop execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md37"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d">LINALG_ERROR</a> if the matrix is singular.</li>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903">LINALG_VALUE_ERROR</a> if <code>a</code> has invalid size.</li>
<li>If <code>err</code> is not provided, exceptions will trigger an <code>error stop</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md38"></a>
Notes</h3>
<ul>
<li>This subroutine modifies <code>a</code> in-place. If the original matrix needs to be preserved, use <a class="el" href="interfacela__inverse_1_1inv.html">inv</a> instead.</li>
<li>The determinant of <code>a</code> can be computed before inversion using <a class="el" href="interfacela__determinant_1_1det.html">det</a> to check for singularity.</li>
<li>The computational complexity is \( O(n^3) \), making it expensive for large matrices.</li>
<li>It is recommended to use matrix factorizations (e.g., LU or QR) for solving linear systems instead of computing the inverse explicitly, as it is numerically more stable and efficient.</li>
</ul>
<h2><a class="anchor" id="autotoc_md39"></a>
la_inverse::operator(.inv.) "operator(.inv.)" - Compute the inverse of a square matrix.</h2>
<h3><a class="anchor" id="autotoc_md40"></a>
Syntax</h3>
<div class="fragment"><div class="line">inva = .inv. a</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md41"></a>
Description</h3>
<p>This operator computes the inverse \( A^{-1} \) of a square, non-singular real or complex matrix \( A \) using an LU decomposition. The inversion satisfies:</p>
<p class="formulaDsp">
\[A A^{-1} = I
\]
</p>
<p>where \( I \) is the identity matrix of appropriate size.</p>
<p>This operator is functionally equivalent to <a class="el" href="interfacela__inverse_1_1inv.html">inv</a> but provides a more convenient syntax. It supports operator chaining, allowing multiple inversions within expressions:</p>
<h3><a class="anchor" id="autotoc_md42"></a>
Arguments</h3>
<ul>
<li><code>A</code>: A <code>real</code> or <code>complex</code> square matrix of size \( [n,n] \), representing the input matrix to be inverted.</li>
</ul>
<h3><a class="anchor" id="autotoc_md43"></a>
Return value</h3>
<ul>
<li><code>invA</code>: A <code>real</code> or <code>complex</code> square matrix of size \( [n,n] \), and same kind as <code>A</code> representing its inverse. <br  />
</li>
<li>If <code>A</code> is singular or the inversion fails, an <b>empty matrix</b> (size \( [0,0] \)) is returned instead of raising an error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md44"></a>
Errors</h3>
<ul>
<li>Unlike <a class="el" href="interfacela__inverse_1_1inv.html">inv</a>, this operator <b>does not provide explicit error handling</b>.</li>
<li>If <code>A</code> is singular or an error occurs during inversion, the function <b>returns an empty matrix</b> (size \( [0,0] \)) instead of raising an exception.</li>
<li>The caller should check the size of the returned matrix to determine if inversion was successful.</li>
</ul>
<h3><a class="anchor" id="autotoc_md45"></a>
Notes</h3>
<ul>
<li>This operator internally calls LAPACK's LU decomposition routine <a class="el" href="interfacela__lapack_1_1getrf.html">GETRF</a> followed by <a class="el" href="interfacela__lapack_1_1getri.html">GETRI</a>.</li>
<li>The chaining property allows for concise expressions but requires caution: if any intermediate inversion fails, subsequent operations may propagate errors due to empty matrix results.</li>
<li>If strict error handling is required, use <a class="el" href="interfacela__inverse_1_1inv.html">inv</a> instead.</li>
</ul>
<h2><a class="anchor" id="autotoc_md46"></a>
<a class="el" href="interfacela__pseudoinverse_1_1pinv.html">pinv</a> - Moore-Penrose pseudo-inverse of a matrix (function).</h2>
<h3><a class="anchor" id="autotoc_md47"></a>
Syntax</h3>
<p><code>pinva = pinv(a [, rtol] [, err])</code></p>
<h3><a class="anchor" id="autotoc_md48"></a>
Description</h3>
<p>This function computes the Moore-Penrose pseudo-inverse \( A^+ \) of a real or complex matrix \( A \) using Singular Value Decomposition (SVD). The pseudo-inverse provides a generalization of the inverse for non-square and singular matrices, making it useful for solving least-squares problems and underdetermined systems.</p>
<p>The computation is based on the singular value decomposition (SVD):</p>
<p class="formulaDsp">
\[A = U \Sigma V^T
\]
</p>
<p>where \( U \) and \( V \) are orthogonal matrices, and \( \Sigma \) is a diagonal matrix containing the singular values. The pseudo-inverse is computed as:</p>
<p class="formulaDsp">
\[A^+ = V \Sigma^+ U^T
\]
</p>
<p>where \( \Sigma^+ \) is obtained by inverting the nonzero singular values.</p>
<h3><a class="anchor" id="autotoc_md49"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> or <code>complex</code> matrix of size \( [m,n] \), representing the input matrix to be inverted.</li>
<li><code>rtol</code> (optional): A real scalar specifying the relative tolerance for singular value truncation. Singular values smaller than <code>rtol * max(singular_values(A))</code> are set to zero. If not provided, a default machine-precision-based tolerance is used.</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html">type(la_state)</a> variable that returns the error state. If not provided, the function will stop execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md50"></a>
Return value</h3>
<ul>
<li><code>pinva</code>: A <code>real</code> or <code>complex</code> matrix of size \( [n,m] \), representing the pseudo-inverse of <code>a</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md51"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903">LINALG_VALUE_ERROR</a> if the SVD decomposition fails or the input matrix has invalid dimensions.</li>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d">LINALG_ERROR</a> if numerical instability prevents inversion.</li>
<li>If <code>err</code> is not provided, exceptions will trigger an <code>error stop</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md52"></a>
Notes</h3>
<ul>
<li>This function computes the pseudo-inverse using LAPACK's SVD decomposition routine <a class="el" href="interfacela__lapack_1_1gesvd.html"><code>*GESVD</code></a>.</li>
<li>The choice of <code>rtol</code> affects numerical stability and rank estimation: setting it too high may result in an inaccurate inverse, while setting it too low may amplify numerical noise.</li>
<li>This function returns a newly allocated matrix. For an in-place version, use <a class="el" href="interfacela__pseudoinverse_1_1pseudoinvert.html"><code>pseudoinvert</code></a>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md53"></a>
la_pseudoinverse::operator(.pinv.) "operator(.pinv.)" - Compute the Moore-Penrose pseudo-inverse of a matrix.</h2>
<h3><a class="anchor" id="autotoc_md54"></a>
Syntax</h3>
<p><code>pinva = .pinv. a</code></p>
<h3><a class="anchor" id="autotoc_md55"></a>
Description</h3>
<p>This operator computes the Moore-Penrose pseudo-inverse \( A^+ \) of a real or complex matrix \( A \) using Singular Value Decomposition (SVD). The pseudo-inverse is useful for solving least-squares problems and handling singular or underdetermined systems.</p>
<p>Given the singular value decomposition (SVD):</p>
<p class="formulaDsp">
\[A = U \Sigma V^T
\]
</p>
<p>the pseudo-inverse is computed as:</p>
<p class="formulaDsp">
\[A^+ = V \Sigma^+ U^T
\]
</p>
<p>where \( \Sigma^+ \) is the inverse of the nonzero singular values in \( \Sigma \).</p>
<h3><a class="anchor" id="autotoc_md56"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> or <code>complex</code> matrix of size \( [m,n] \), representing the input matrix to be inverted.</li>
</ul>
<h3><a class="anchor" id="autotoc_md57"></a>
Return value</h3>
<ul>
<li><code>pinva</code>: A <code>real</code> or <code>complex</code> matrix of size \( [n,m] \), representing the pseudo-inverse of <code>a</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md58"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903">LINALG_VALUE_ERROR</a> if the SVD decomposition fails or the input matrix has invalid dimensions.</li>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d">LINALG_ERROR</a> if numerical instability prevents inversion.</li>
<li>If an error occurs, execution will stop.</li>
</ul>
<h3><a class="anchor" id="autotoc_md59"></a>
Notes</h3>
<ul>
<li>This operator internally calls <a class="el" href="interfacela__pseudoinverse_1_1pinv.html">pinv</a> and behaves identically.</li>
<li>The pseudo-inverse is computed using LAPACK's SVD decomposition routine <a class="el" href="interfacela__lapack_1_1gesvd.html">GESVD</a>.</li>
<li>This operator is a convenient shorthand for calling the functional interface <code>pinv(a)</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md60"></a>
<code>svd(A)</code></h2>
<p><b>Type</b>: Subroutine <br  />
 <b>Description</b>: Singular value decomposition of $A = U S V^t$. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>s</code>: Singular values. <br  />
</li>
<li><code>u</code>: Left singular vectors. <br  />
</li>
<li><code>vt</code>: Right singular vectors. <br  />
</li>
<li><code>full_matrices</code>: Defaults to <code>.false.</code>. <br  />
</li>
<li><code>err</code>: State handler. <br  />
</li>
</ul>
<p><b>Usage</b>: <code>call svd(A, s, u, vt, full_matrices=.false., err=state)</code>.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
<code>svdvals(A)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Singular values $S$ from $A = U S V^t$. <br  />
 <b>Usage</b>: <code>s = svdvals(A)</code> where <code>s</code> is a real array with the same precision as <code>A</code>.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
<code>eye(m)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Identity matrix of size <code>m</code>. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>n</code>: Optional column size. <br  />
</li>
<li><code>mold</code>: Optional datatype (default: real64). <br  />
</li>
<li><code>err</code>: Error handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md63"></a>
<code>eigvals(A)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Eigenvalues of matrix $A$. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>err</code>: State handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md64"></a>
<code>eig(A, lambda)</code></h2>
<p><b>Type</b>: Subroutine <br  />
 <b>Description</b>: Eigenproblem of matrix $A<code>. \ilinebr&lt;br&gt; **Optional arguments**: \ilinebr&lt;br&gt; -</code>left<code>: Output left eigenvector matrix. \ilinebr&lt;br&gt; -</code>right<code>: Output right eigenvector matrix. \ilinebr&lt;br&gt; -</code>overwrite_a<code>: Option to let A be destroyed. \ilinebr&lt;br&gt; -</code>err`: Return state handler.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
<code>eigvalsh(A)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Eigenvalues of symmetric or Hermitian matrix $A$. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>upper_a</code>: Choose to use upper or lower triangle. <br  />
</li>
<li><code>err</code>: State handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md66"></a>
<code>eigh(A, lambda)</code></h2>
<p><b>Type</b>: Subroutine <br  />
 <b>Description</b>: Eigenproblem of symmetric or Hermitian matrix $A<code>. \ilinebr&lt;br&gt; **Optional arguments**: \ilinebr&lt;br&gt; -</code>vector<code>: Output eigenvectors. \ilinebr&lt;br&gt; -</code>upper_a<code>: Choose to use upper or lower triangle. \ilinebr&lt;br&gt; -</code>overwrite_a<code>: Option to let A be destroyed. \ilinebr&lt;br&gt; -</code>err`: Return state handler.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
<code>diag(n, source)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Diagonal matrix from scalar input value. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>err</code>: Error handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md68"></a>
<code>diag(source)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Diagonal matrix from array input values. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>err</code>: Error handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md69"></a>
<a class="el" href="interfacela__qr_1_1qr.html">qr</a> - Compute the QR factorization of a matrix.</h2>
<h3><a class="anchor" id="autotoc_md70"></a>
Syntax</h3>
<p><code>call qr(a, q, r [, overwrite_a] [, storage] [, err])</code></p>
<h3><a class="anchor" id="autotoc_md71"></a>
Description</h3>
<p>This subroutine computes the QR factorization of a <code>real</code> or <code>complex</code> matrix \( A = Q \cdot R \), where \( Q \) is orthonormal and \( R \) is upper-triangular. The matrix \( A \) has size \( [m,n] \) with \( m \ge n \). The result is returned in the output matrices \( Q \) and \( R \), which have the same type and kind as \( A \).</p>
<p>Given \( k = \min(m, n) \), the matrix \( A \) can be written as:</p>
<p class="formulaDsp">
\[A = \left( \begin{array}{cc} Q_1 &amp; Q_2 \end{array} \right) \cdot \left( \begin{array}{cc} R_1 &amp; 0 \end{array} \right)
\]
</p>
<p>Because the lower rows of \( R \) are zeros, a reduced problem \( A = Q_1 R_1 \) can be solved. The size of the input matrices determines which problem is solved:</p><ul>
<li>For full matrices (<code>shape(Q) == [m,m]</code>, <code>shape(R) == [m,n]</code>), the full problem is solved.</li>
<li>For reduced matrices (<code>shape(Q) == [m,k]</code>, <code>shape(R) == [k,n]</code>), the reduced problem is solved.</li>
</ul>
<h3><a class="anchor" id="autotoc_md72"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> or <code>complex</code> matrix of size \( [m,n] \), representing the coefficient matrix. If <code>overwrite_a = .false.</code>, this is an input argument. If <code>overwrite_a = .true.</code>, it is an <code>inout</code> argument and is overwritten upon return.</li>
<li><code>q</code>: A rank-2 array of the same type and kind as <code>a</code>, representing the orthonormal matrix \( Q \). This is an output argument with shape \( [m,m] \) (for the full problem) or \( [m,k] \) (for the reduced problem).</li>
<li><code>r</code>: A rank-2 array of the same type and kind as <code>a</code>, representing the upper-triangular matrix \( R \). This is an output argument with shape \( [m,n] \) (for the full problem) or \( [k,n] \) (for the reduced problem).</li>
<li><code>storage</code> (optional): A rank-1 array of the same type and kind as <code>a</code>, providing working storage for the solver. Its minimum size can be determined by a call to <a class="el" href="interfacela__qr_1_1qr__space.html">qr_space</a>. This is an output argument.</li>
<li><code>overwrite_a</code> (optional, default = <code>.false.</code>): A logical flag that determines whether the input matrix <code>a</code> can be overwritten. If <code>.true.</code>, the matrix <code>a</code> is used as temporary storage and overwritten to avoid internal memory allocation. This is an input argument.</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html">type(la_state)</a> variable that returns the error state. If not provided, the function will stop execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md73"></a>
Return value</h3>
<p>The QR factorization matrices \( Q \) and \( R \) are returned in the corresponding arguments.</p>
<h3><a class="anchor" id="autotoc_md74"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903">LINALG_VALUE_ERROR</a> if the sizes of the matrices are incompatible with the full/reduced problem.</li>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d">LINALG_ERROR</a> if there is insufficient storage space.</li>
<li>If <code>err</code> is not provided, exceptions will trigger an <code>error stop</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md75"></a>
Notes</h3>
<ul>
<li>This subroutine computes the QR factorization using LAPACK's QR decomposition algorithm <a class="el" href="interfacela__lapack_1_1geqrf.html"><code>*GEQRF</code></a>.</li>
<li>If <code>overwrite_a</code> is enabled, the input matrix <code>a</code> will be modified during computation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md76"></a>
<a class="el" href="interfacela__qr_1_1qr__space.html">qr_space</a> - Workspace size for QR operations.</h2>
<h3><a class="anchor" id="autotoc_md77"></a>
Syntax</h3>
<p><code>call qr_space(a, lwork [, err])</code></p>
<h3><a class="anchor" id="autotoc_md78"></a>
Description</h3>
<p>This subroutine computes the minimum workspace size required for performing QR factorization. The size of the workspace array needed for both QR factorization and solving the reduced problem is determined based on the input matrix \( A \).</p>
<p>The input matrix \( A \) has size \( [m,n] \), and the output value \( lwork \) represents the minimum size of the workspace array that should be allocated for QR operations.</p>
<h3><a class="anchor" id="autotoc_md79"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> or <code>complex</code> matrix of size \( [m,n] \), representing the input matrix used to determine the required workspace size.</li>
<li><code>lwork</code>: An integer variable that will return the minimum workspace size required for QR factorization.</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html">type(la_state)</a> variable that returns the error state. If not provided, the function will stop execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md80"></a>
Return value</h3>
<p>The workspace size \( lwork \) that should be allocated before calling the QR factorization routine is returned.</p>
<h3><a class="anchor" id="autotoc_md81"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d">LINALG_ERROR</a> if there is an issue determining the required workspace size.</li>
<li>If <code>err</code> is not provided, exceptions will trigger an <code>error stop</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md82"></a>
Notes</h3>
<ul>
<li>This subroutine is useful for preallocating memory for QR factorization in large systems.</li>
<li>It is important to ensure that the workspace size is correctly allocated before proceeding with QR factorization to avoid memory issues.</li>
</ul>
<h1><a class="anchor" id="autotoc_md83"></a>
BLAS, LAPACK</h1>
<p>Modern Fortran modules with full explicit typing features are available as modules <code><a class="el" href="namespacela__blas.html" title="Precision-agnostic BLAS interface.">la_blas</a></code> and <code><a class="el" href="namespacela__lapack.html">la_lapack</a></code>. The reference Fortran-77 library, forked from Release 3.10.1, was automatically processed and modernized. The following refactorings are applied:</p><ul>
<li>All datatypes and accuracy constants standardized into a module (<code>stdlib</code>-compatible names)</li>
<li>Both libraries available for 32, 64 and 128-bit floats</li>
<li>Free format, lower-case style</li>
<li><code>implicit none(type, external)</code> everywhere</li>
<li>all <code>pure</code> procedures where possible</li>
<li><code>intent</code> added to all procedure arguments</li>
<li>Removed <code>DO 10 .... 10 CONTINUE</code>, replaced with <code>do..end do</code> loops or labelled <code>loop_10: do ... cycle loop_10 ... end do loop_10</code> in case control statements are present</li>
<li>BLAS modularized into a single-file module</li>
<li>LAPACK modularized into a single-file module</li>
<li>All procedures prefixed (with <code>stdlib_</code>, currently).</li>
<li>F77-style <code>parameter</code>s removed, and numeric constants moved to the top of each module.</li>
<li>Ambiguity in single vs. double precision constants (<code>0.0</code>, <code>0.d0</code>, <code>(1.0,0.0)</code>) removed</li>
<li>preprocessor-based OpenMP directives retained.</li>
</ul>
<p>The single-source module structure hopefully allows for cross-procedural inlining which is otherwise impossible without link-time optimization.</p>
<h1><a class="anchor" id="autotoc_md84"></a>
Building</h1>
<p>An automated build is currently available via the <a href="https://fpm.fortran-lang.org">Fortran Package Manager</a>. To add fortran-lapack to your project, simply add it as a dependency:</p>
<div class="fragment"><div class="line">[dependencies]</div>
<div class="line">fortran-lapack = { git=&quot;https://github.com/perazz/fortran-lapack.git&quot; }</div>
</div><!-- fragment --><p><code>fortran-lapack</code> is compatible with the LAPACK API. If high-performance external BLAS/LAPACK libraries are available, it is sufficient to define macros</p>
<div class="fragment"><div class="line">[dependencies]</div>
<div class="line">fortran-lapack = { git=&quot;https://github.com/perazz/fortran-lapack.git&quot;, preprocess.cpp.macros=[&quot;LA_EXTERNAL_BLAS&quot;, &quot;LA_EXTERNAL_LAPACK&quot;] }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md85"></a>
Extension to external BLAS/LAPACK libraries</h1>
<p>Generic interfaces to most BLAS/LAPACK functions are exposed to modules <code><a class="el" href="namespacela__blas.html" title="Precision-agnostic BLAS interface.">la_blas</a></code> and <code><a class="el" href="namespacela__lapack.html">la_lapack</a></code>. These interfaces drop the initial letter to wrap a precision-agnostic version. For example, <code>axpy</code> is a precision-agnostic interface to <code>saxpy</code>, <code>daxpy</code>, <code>caxpy</code>, <code>zaxpy</code>, <code>qaxpy</code>, <code>waxpy</code>. The naming convention is:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">32-bit   </th><th class="markdownTableHeadNone">64-bit   </th><th class="markdownTableHeadNone">128-bit    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">real   </td><td class="markdownTableBodyNone"><code>s</code>   </td><td class="markdownTableBodyNone"><code>d</code>   </td><td class="markdownTableBodyNone"><code>q</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">complex   </td><td class="markdownTableBodyNone"><code>c</code>   </td><td class="markdownTableBodyNone"><code>z</code>   </td><td class="markdownTableBodyNone"><code>w</code>   </td></tr>
</table>
<p>All public interfaces in <code><a class="el" href="namespacela__blas.html" title="Precision-agnostic BLAS interface.">la_blas</a></code> and <code><a class="el" href="namespacela__lapack.html">la_lapack</a></code> allow seamless linking against external libraries via a simple pre-processor flag. When an external library is available, just define macros <code>LA_EXTERNAL_BLAS</code> and <code>LA_EXTERNAL_LAPACK</code>. The kind-agnostic interface will just point to the external function. All such interfaces follow this template: <br  />
</p>
<div class="fragment"><div class="line"><span class="keyword">interface</span> axpy</div>
<div class="line"><span class="preprocessor">#ifdef LA_EXTERNAL_BLAS</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">! Use external library</span></div>
<div class="line">    <span class="keywordtype">pure</span> <span class="keyword">subroutine </span>saxpy(n, a, x, incx, y, incy)</div>
<div class="line">      <span class="keywordtype">import </span>:: ik, sp</div>
<div class="line">      <span class="keywordtype">integer</span>, <span class="keywordtype">parameter</span> :: wp = sp</div>
<div class="line">      <span class="keywordtype">integer(ik)</span>, <span class="keywordtype">intent(in)</span> :: n</div>
<div class="line"><span class="keywordtype">      real</span>(wp), <span class="keywordtype">intent(in)</span> :: a</div>
<div class="line"><span class="keywordtype">      real</span>(wp), <span class="keywordtype">intent(in)</span> :: x(*)</div>
<div class="line">      <span class="keywordtype">integer(ik)</span>, <span class="keywordtype">intent(in)</span> :: incx</div>
<div class="line"><span class="keywordtype">      real</span>(wp), <span class="keywordtype">intent(inout)</span> :: y(*)</div>
<div class="line">      <span class="keywordtype">integer(ik)</span>, <span class="keywordtype">intent(in)</span> :: incy</div>
<div class="line">    <span class="keyword">end subroutine </span>saxpy</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">! Use internal implementation</span></div>
<div class="line">    <span class="keyword">module procedure</span> la_saxpy</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">end interface</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md86"></a>
Licensing</h1>
<p>LAPACK is a freely-available software package. It is available from <a href="https://www.netlib.org/lapack/">netlib</a> via anonymous ftp and the World Wide Web. Thus, it can be included in commercial software packages (and has been). Credit for the library should be given to the <a href="https://www.netlib.org/lapack/contributor-list.html">LAPACK authors</a>. The license used for the software is the <a href="https://www.netlib.org/lapack/LICENSE.txt">modified BSD license</a>. According to the original license, we changed the name of the routines and commented the changes made to the original.</p>
<h1><a class="anchor" id="autotoc_md87"></a>
Acknowledgments</h1>
<p>Part of this work was supported by the <a href="https://www.sovereigntechfund.de">Sovereign Tech Fund</a>. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
