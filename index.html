<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fortran-lapack: fortran-lapack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init()
        </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fortran-lapack
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">fortran-lapack </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2fortran-lapack_2fortran-lapack_2_r_e_a_d_m_e"></a></p>
<p>This package provides precision-agnostic, high-level linear algebra APIs for <code>real</code> and <code>complex</code> arguments in Modern Fortran. The APIs are similar to NumPy/SciPy operations, and leverage a Modern Fortran implementation of the <a href="http://github.com/reference-LAPACK">Reference-LAPACK</a> library.</p>
<p>A full and standardized implementation of the present library has been integrated into the <a href="http://stdlib.fortran-lang.org/">Fortran Standard Library</a>, and as such, most users should seek to access the functionality from <code>stdlib</code>. The present library is kept in place for those who seek a compact implementation of it.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Browse API</h1>
<p>All procedures work with all types (<code>real</code>, <code>complex</code>) and kinds (32, 64, 128-bit floats).</p>
<h2><a class="anchor" id="autotoc_md6"></a>
<a class="el" href="interfacela__solve_1_1solve.html">solve</a> - Solve a linear matrix equation or a linear system of equations.</h2>
<h3><a class="anchor" id="autotoc_md7"></a>
Syntax</h3>
<p><code>x = solve(a, b [, overwrite_a] [, err])</code> <br  />
</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Description</h3>
<p>Solve linear systems - one (<code>b(:)</code>) or many (<code>b(:,:)</code>). <br  />
</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> or <code>complex</code> coefficient matrix. If <code>overwrite_a=.true.</code>, it is destroyed by the call.</li>
<li><code>b</code>: A rank-1 (one system) or rank-2 (many systems) array of the same kind as <code>a</code>, containing the right-hand-side vector(s).</li>
<li><code>overwrite_a</code> (optional, default = <code>.false.</code>): If <code>.true.</code>, input matrix <code>a</code> will be used as temporary storage and overwritten, to avoid internal data allocation.</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html"><code>type(la_state)</code></a> variable.</li>
</ul>
<h3><a class="anchor" id="autotoc_md10"></a>
Return value</h3>
<p>For a full-rank matrix, returns an array value that represents the solution to the linear system of equations.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d"><code>LINALG_ERROR</code></a> if the matrix is singular to working precision.</li>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903"><code>LINALG_VALUE_ERROR</code></a> if the matrix and rhs vectors have invalid/incompatible sizes.</li>
<li>If <code>err</code> is not present, exceptions trigger an <code>error stop</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
<a class="el" href="interfacela__least__squares_1_1lstsq.html">lstsq</a> - Compute a least squares solution to a system of linear equations.</h2>
<h3><a class="anchor" id="autotoc_md13"></a>
Syntax</h3>
<p><code>x = lstsq(a, b [, cond] [, overwrite_a] [, rank] [, err])</code></p>
<h3><a class="anchor" id="autotoc_md14"></a>
Description</h3>
<p>Solves the least-squares problem for the system \( A \cdot x = b \), where \( A \) is a square matrix of size \( n \times n \) and \( b \) is either a vector of size \( n \) or a matrix of size \( n \times nrhs \). The function minimizes the 2-norm \( \|b - A \cdot x\| \) by solving for \( x \).</p>
<p>The result \( x \) is returned as an allocatable array, and it is either a vector (for a single right-hand side) or a matrix (for multiple right-hand sides).</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> matrix of size \( n \times n \) representing the coefficient matrix. If <code>overwrite_a = .true.</code>, the contents of <code>a</code> may be modified during the computation.</li>
<li><code>b</code>: A <code>real</code> vector or matrix representing the right-hand side. The size should be \( n \) (for a single right-hand side) or \( n \times nrhs \) (for multiple right-hand sides).</li>
<li><code>cond</code> (optional): A cutoff for rank evaluation. Singular values \( s(i) \) such that \( s(i) \leq \text{cond} \cdot \max(s) \) are considered zero.</li>
<li><code>overwrite_a</code> (optional, default = <code>.false.</code>): If <code>.true.</code>, both <code>a</code> and <code>b</code> may be overwritten and destroyed during computation.</li>
<li><code>rank</code> (optional): An integer variable that returns the rank of the matrix \( A \).</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html"><code>type(la_state)</code></a> variable that returns the error state. If <code>err</code> is not provided, the function will stop execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md16"></a>
Return value</h3>
<p>Returns the solution array \( x \) with size \( n \) (for a single right-hand side) or \( n \times nrhs \) (for multiple right-hand sides).</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d"><code>LINALG_ERROR</code></a> if the matrix \( A \) is singular to working precision.</li>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903"><code>LINALG_VALUE_ERROR</code></a> if the matrix <code>a</code> and the right-hand side <code>b</code> have incompatible sizes.</li>
<li>If <code>err</code> is not provided, the function stops execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md18"></a>
Notes</h3>
<ul>
<li>This function relies on LAPACK's least-squares solvers, such as <a class="el" href="interfacela__lapack_1_1gelss.html"><code>*GELSS</code></a>.</li>
<li>If <code>overwrite_a</code> is enabled, the original contents of <code>a</code> and <code>b</code> may be lost.</li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
<code>det(A)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Determinant of a scalar or square matrix. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>overwrite_a</code>: Option to let A be destroyed. <br  />
</li>
<li><code>err</code>: Return state handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md20"></a>
<code>inv(A)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Inverse of a scalar or square matrix. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>err</code>: Return state handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md21"></a>
<code>pinv(A)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Moore-Penrose Pseudo-Inverse of a matrix. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>rtol</code>: Optional singular value threshold. <br  />
</li>
<li><code>err</code>: Return state handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md22"></a>
<code>invert(A)</code></h2>
<p><b>Type</b>: Subroutine <br  />
 <b>Description</b>: In-place inverse of a scalar or square matrix. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>err</code>: Return state handler. <br  />
</li>
</ul>
<p><b>Usage</b>: <code>call invert(A, err=err)</code> where <code>A</code> is replaced with $A^{-1}$.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
<code>.inv.A</code></h2>
<p><b>Type</b>: Operator <br  />
 <b>Description</b>: Inverse of a scalar or square matrix. <br  />
</p>
<p><b>Effect</b>: <code>A</code> is replaced with $A^{-1}$.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
<code>.pinv.A</code></h2>
<p><b>Type</b>: Operator <br  />
 <b>Description</b>: Moore-Penrose Pseudo-Inverse. <br  />
</p>
<p><b>Effect</b>: <code>A</code> is replaced with $A^{-1}$.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
<code>svd(A)</code></h2>
<p><b>Type</b>: Subroutine <br  />
 <b>Description</b>: Singular value decomposition of $A = U S V^t$. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>s</code>: Singular values. <br  />
</li>
<li><code>u</code>: Left singular vectors. <br  />
</li>
<li><code>vt</code>: Right singular vectors. <br  />
</li>
<li><code>full_matrices</code>: Defaults to <code>.false.</code>. <br  />
</li>
<li><code>err</code>: State handler. <br  />
</li>
</ul>
<p><b>Usage</b>: <code>call svd(A, s, u, vt, full_matrices=.false., err=state)</code>.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
<code>svdvals(A)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Singular values $S$ from $A = U S V^t$. <br  />
 <b>Usage</b>: <code>s = svdvals(A)</code> where <code>s</code> is a real array with the same precision as <code>A</code>.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
<code>eye(m)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Identity matrix of size <code>m</code>. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>n</code>: Optional column size. <br  />
</li>
<li><code>mold</code>: Optional datatype (default: real64). <br  />
</li>
<li><code>err</code>: Error handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
<code>eigvals(A)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Eigenvalues of matrix $A$. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>err</code>: State handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
<code>eig(A, lambda)</code></h2>
<p><b>Type</b>: Subroutine <br  />
 <b>Description</b>: Eigenproblem of matrix $A<code>. \ilinebr&lt;br&gt; **Optional arguments**: \ilinebr&lt;br&gt; -</code>left<code>: Output left eigenvector matrix. \ilinebr&lt;br&gt; -</code>right<code>: Output right eigenvector matrix. \ilinebr&lt;br&gt; -</code>overwrite_a<code>: Option to let A be destroyed. \ilinebr&lt;br&gt; -</code>err`: Return state handler.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
<code>eigvalsh(A)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Eigenvalues of symmetric or Hermitian matrix $A$. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>upper_a</code>: Choose to use upper or lower triangle. <br  />
</li>
<li><code>err</code>: State handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md31"></a>
<code>eigh(A, lambda)</code></h2>
<p><b>Type</b>: Subroutine <br  />
 <b>Description</b>: Eigenproblem of symmetric or Hermitian matrix $A<code>. \ilinebr&lt;br&gt; **Optional arguments**: \ilinebr&lt;br&gt; -</code>vector<code>: Output eigenvectors. \ilinebr&lt;br&gt; -</code>upper_a<code>: Choose to use upper or lower triangle. \ilinebr&lt;br&gt; -</code>overwrite_a<code>: Option to let A be destroyed. \ilinebr&lt;br&gt; -</code>err`: Return state handler.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
<code>diag(n, source)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Diagonal matrix from scalar input value. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>err</code>: Error handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
<code>diag(source)</code></h2>
<p><b>Type</b>: Function <br  />
 <b>Description</b>: Diagonal matrix from array input values. <br  />
 <b>Optional arguments</b>: <br  />
</p><ul>
<li><code>err</code>: Error handler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md34"></a>
<a class="el" href="interfacela__qr_1_1qr.html">qr</a> - Compute the QR factorization of a matrix.</h2>
<h3><a class="anchor" id="autotoc_md35"></a>
Syntax</h3>
<p><code>call qr(a, q, r [, overwrite_a] [, storage] [, err])</code></p>
<h3><a class="anchor" id="autotoc_md36"></a>
Description</h3>
<p>This subroutine computes the QR factorization of a <code>real</code> or <code>complex</code> matrix \( A = Q \cdot R \), where \( Q \) is orthonormal and \( R \) is upper-triangular. The matrix \( A \) has size \( [m,n] \) with \( m \ge n \). The result is returned in the output matrices \( Q \) and \( R \), which have the same type and kind as \( A \).</p>
<p>Given \( k = \min(m, n) \), the matrix \( A \) can be written as:</p>
<p class="formulaDsp">
\[A = \left( \begin{array}{cc} Q_1 &amp; Q_2 \end{array} \right) \cdot \left( \begin{array}{cc} R_1 &amp; 0 \end{array} \right)
\]
</p>
<p>Because the lower rows of \( R \) are zeros, a reduced problem \( A = Q_1 R_1 \) can be solved. The size of the input matrices determines which problem is solved:</p><ul>
<li>For full matrices (<code>shape(Q) == [m,m]</code>, <code>shape(R) == [m,n]</code>), the full problem is solved.</li>
<li>For reduced matrices (<code>shape(Q) == [m,k]</code>, <code>shape(R) == [k,n]</code>), the reduced problem is solved.</li>
</ul>
<h3><a class="anchor" id="autotoc_md37"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> or <code>complex</code> matrix of size \( [m,n] \), representing the coefficient matrix. If <code>overwrite_a = .false.</code>, this is an input argument. If <code>overwrite_a = .true.</code>, it is an <code>inout</code> argument and is overwritten upon return.</li>
<li><code>q</code>: A rank-2 array of the same type and kind as <code>a</code>, representing the orthonormal matrix \( Q \). This is an output argument with shape \( [m,m] \) (for the full problem) or \( [m,k] \) (for the reduced problem).</li>
<li><code>r</code>: A rank-2 array of the same type and kind as <code>a</code>, representing the upper-triangular matrix \( R \). This is an output argument with shape \( [m,n] \) (for the full problem) or \( [k,n] \) (for the reduced problem).</li>
<li><code>storage</code> (optional): A rank-1 array of the same type and kind as <code>a</code>, providing working storage for the solver. Its minimum size can be determined by a call to <a class="el" href="interfacela__qr_1_1qr__space.html"><code>qr_space</code></a>. This is an output argument.</li>
<li><code>overwrite_a</code> (optional, default = <code>.false.</code>): A logical flag that determines whether the input matrix <code>a</code> can be overwritten. If <code>.true.</code>, the matrix <code>a</code> is used as temporary storage and overwritten to avoid internal memory allocation. This is an input argument.</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html"><code>type(la_state)</code></a> variable that returns the error state. If not provided, the function will stop execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md38"></a>
Return value</h3>
<p>The QR factorization matrices \( Q \) and \( R \) are returned in the corresponding arguments.</p>
<h3><a class="anchor" id="autotoc_md39"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#ad9888f2f7d4e692e7d3b8fd532baa903"><code>LINALG_VALUE_ERROR</code></a> if the sizes of the matrices are incompatible with the full/reduced problem.</li>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d"><code>LINALG_ERROR</code></a> if there is insufficient storage space.</li>
<li>If <code>err</code> is not provided, exceptions will trigger an <code>error stop</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md40"></a>
Notes</h3>
<ul>
<li>This subroutine computes the QR factorization using LAPACK's QR decomposition algorithm <a class="el" href="interfacela__lapack_1_1geqrf.html"><code>*GEQRF</code></a>.</li>
<li>If <code>overwrite_a</code> is enabled, the input matrix <code>a</code> will be modified during computation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md41"></a>
<a class="el" href="interfacela__qr_1_1qr__space.html">qr_space</a> - Workspace size for QR operations.</h2>
<h3><a class="anchor" id="autotoc_md42"></a>
Syntax</h3>
<p><code>call qr_space(a, lwork [, err])</code></p>
<h3><a class="anchor" id="autotoc_md43"></a>
Description</h3>
<p>This subroutine computes the minimum workspace size required for performing QR factorization. The size of the workspace array needed for both QR factorization and solving the reduced problem is determined based on the input matrix \( A \).</p>
<p>The input matrix \( A \) has size \( [m,n] \), and the output value \( lwork \) represents the minimum size of the workspace array that should be allocated for QR operations.</p>
<h3><a class="anchor" id="autotoc_md44"></a>
Arguments</h3>
<ul>
<li><code>a</code>: A <code>real</code> or <code>complex</code> matrix of size \( [m,n] \), representing the input matrix used to determine the required workspace size.</li>
<li><code>lwork</code>: An integer variable that will return the minimum workspace size required for QR factorization.</li>
<li><code>err</code> (optional): A <a class="el" href="structla__state__type_1_1la__state.html"><code>type(la_state)</code></a> variable that returns the error state. If not provided, the function will stop execution on error.</li>
</ul>
<h3><a class="anchor" id="autotoc_md45"></a>
Return value</h3>
<p>The workspace size \( lwork \) that should be allocated before calling the QR factorization routine is returned.</p>
<h3><a class="anchor" id="autotoc_md46"></a>
Errors</h3>
<ul>
<li>Raises <a class="el" href="namespacela__state__type.html#af5b55841ca3045c3345d9ab019e0797d"><code>LINALG_ERROR</code></a> if there is an issue determining the required workspace size.</li>
<li>If <code>err</code> is not provided, exceptions will trigger an <code>error stop</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md47"></a>
Notes</h3>
<ul>
<li>This subroutine is useful for preallocating memory for QR factorization in large systems.</li>
<li>It is important to ensure that the workspace size is correctly allocated before proceeding with QR factorization to avoid memory issues.</li>
</ul>
<h1><a class="anchor" id="autotoc_md48"></a>
BLAS, LAPACK</h1>
<p>Modern Fortran modules with full explicit typing features are available as modules <code><a class="el" href="namespacela__blas.html" title="Precision-agnostic BLAS interface.">la_blas</a></code> and <code><a class="el" href="namespacela__lapack.html">la_lapack</a></code>. The reference Fortran-77 library, forked from Release 3.10.1, was automatically processed and modernized. The following refactorings are applied:</p><ul>
<li>All datatypes and accuracy constants standardized into a module (<code>stdlib</code>-compatible names)</li>
<li>Both libraries available for 32, 64 and 128-bit floats</li>
<li>Free format, lower-case style</li>
<li><code>implicit none(type, external)</code> everywhere</li>
<li>all <code>pure</code> procedures where possible</li>
<li><code>intent</code> added to all procedure arguments</li>
<li>Removed <code>DO 10 .... 10 CONTINUE</code>, replaced with <code>do..end do</code> loops or labelled <code>loop_10: do ... cycle loop_10 ... end do loop_10</code> in case control statements are present</li>
<li>BLAS modularized into a single-file module</li>
<li>LAPACK modularized into a single-file module</li>
<li>All procedures prefixed (with <code>stdlib_</code>, currently).</li>
<li>F77-style <code>parameter</code>s removed, and numeric constants moved to the top of each module.</li>
<li>Ambiguity in single vs. double precision constants (<code>0.0</code>, <code>0.d0</code>, <code>(1.0,0.0)</code>) removed</li>
<li>preprocessor-based OpenMP directives retained.</li>
</ul>
<p>The single-source module structure hopefully allows for cross-procedural inlining which is otherwise impossible without link-time optimization.</p>
<h1><a class="anchor" id="autotoc_md49"></a>
Building</h1>
<p>An automated build is currently available via the <a href="https://fpm.fortran-lang.org">Fortran Package Manager</a>. To add fortran-lapack to your project, simply add it as a dependency:</p>
<div class="fragment"><div class="line">[dependencies]</div>
<div class="line">fortran-lapack = { git=&quot;https://github.com/perazz/fortran-lapack.git&quot; }</div>
</div><!-- fragment --><p><code>fortran-lapack</code> is compatible with the LAPACK API. If high-performance external BLAS/LAPACK libraries are available, it is sufficient to define macros</p>
<div class="fragment"><div class="line">[dependencies]</div>
<div class="line">fortran-lapack = { git=&quot;https://github.com/perazz/fortran-lapack.git&quot;, preprocess.cpp.macros=[&quot;LA_EXTERNAL_BLAS&quot;, &quot;LA_EXTERNAL_LAPACK&quot;] }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md50"></a>
Extension to external BLAS/LAPACK libraries</h1>
<p>Generic interfaces to most BLAS/LAPACK functions are exposed to modules <code><a class="el" href="namespacela__blas.html" title="Precision-agnostic BLAS interface.">la_blas</a></code> and <code><a class="el" href="namespacela__lapack.html">la_lapack</a></code>. These interfaces drop the initial letter to wrap a precision-agnostic version. For example, <code>axpy</code> is a precision-agnostic interface to <code>saxpy</code>, <code>daxpy</code>, <code>caxpy</code>, <code>zaxpy</code>, <code>qaxpy</code>, <code>waxpy</code>. The naming convention is:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">32-bit   </th><th class="markdownTableHeadNone">64-bit   </th><th class="markdownTableHeadNone">128-bit    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">real   </td><td class="markdownTableBodyNone"><code>s</code>   </td><td class="markdownTableBodyNone"><code>d</code>   </td><td class="markdownTableBodyNone"><code>q</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">complex   </td><td class="markdownTableBodyNone"><code>c</code>   </td><td class="markdownTableBodyNone"><code>z</code>   </td><td class="markdownTableBodyNone"><code>w</code>   </td></tr>
</table>
<p>All public interfaces in <code><a class="el" href="namespacela__blas.html" title="Precision-agnostic BLAS interface.">la_blas</a></code> and <code><a class="el" href="namespacela__lapack.html">la_lapack</a></code> allow seamless linking against external libraries via a simple pre-processor flag. When an external library is available, just define macros <code>LA_EXTERNAL_BLAS</code> and <code>LA_EXTERNAL_LAPACK</code>. The kind-agnostic interface will just point to the external function. All such interfaces follow this template: <br  />
</p>
<div class="fragment"><div class="line"><span class="keyword">interface</span> axpy</div>
<div class="line"><span class="preprocessor">#ifdef LA_EXTERNAL_BLAS</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">! Use external library</span></div>
<div class="line">    <span class="keywordtype">pure</span> <span class="keyword">subroutine </span>saxpy(n, a, x, incx, y, incy)</div>
<div class="line">      <span class="keywordtype">import </span>:: ik, sp</div>
<div class="line">      <span class="keywordtype">integer</span>, <span class="keywordtype">parameter</span> :: wp = sp</div>
<div class="line">      <span class="keywordtype">integer(ik)</span>, <span class="keywordtype">intent(in)</span> :: n</div>
<div class="line"><span class="keywordtype">      real</span>(wp), <span class="keywordtype">intent(in)</span> :: a</div>
<div class="line"><span class="keywordtype">      real</span>(wp), <span class="keywordtype">intent(in)</span> :: x(*)</div>
<div class="line">      <span class="keywordtype">integer(ik)</span>, <span class="keywordtype">intent(in)</span> :: incx</div>
<div class="line"><span class="keywordtype">      real</span>(wp), <span class="keywordtype">intent(inout)</span> :: y(*)</div>
<div class="line">      <span class="keywordtype">integer(ik)</span>, <span class="keywordtype">intent(in)</span> :: incy</div>
<div class="line">    <span class="keyword">end subroutine </span>saxpy</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">! Use internal implementation</span></div>
<div class="line">    <span class="keyword">module procedure</span> la_saxpy</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">end interface</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md51"></a>
Licensing</h1>
<p>LAPACK is a freely-available software package. It is available from <a href="https://www.netlib.org/lapack/">netlib</a> via anonymous ftp and the World Wide Web. Thus, it can be included in commercial software packages (and has been). Credit for the library should be given to the <a href="https://www.netlib.org/lapack/contributor-list.html">LAPACK authors</a>. The license used for the software is the <a href="https://www.netlib.org/lapack/LICENSE.txt">modified BSD license</a>. According to the original license, we changed the name of the routines and commented the changes made to the original.</p>
<h1><a class="anchor" id="autotoc_md52"></a>
Acknowledgments</h1>
<p>Part of this work was supported by the <a href="https://www.sovereigntechfund.de">Sovereign Tech Fund</a>. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
