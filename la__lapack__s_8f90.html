<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fortran-lapack: la_lapack_s.f90 File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fortran-lapack
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('la__lapack__s_8f90.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Modules</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle"><div class="title">la_lapack_s.f90 File Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Modules</h2></td></tr>
<tr class="memitem:namespacela__lapack__s" id="r_namespacela__lapack__s"><td class="memItemLeft" align="right" valign="top">module &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html">la_lapack_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ae405d0f4abe27d86d8e5f79743ea46fa" id="r_ae405d0f4abe27d86d8e5f79743ea46fa"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ae405d0f4abe27d86d8e5f79743ea46fa">la_lapack_s::la_scsum1</a> (n, cx, incx)</td></tr>
<tr class="memdesc:ae405d0f4abe27d86d8e5f79743ea46fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCSUM1: takes the sum of the absolute values of a complex vector and returns a single precision result. Based on SCASUM from the Level 1 BLAS. The change is to use the 'genuine' absolute value.  <br /></td></tr>
<tr class="separator:ae405d0f4abe27d86d8e5f79743ea46fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a1b6dead03c04fe7e2cfc1f921876a" id="r_ac2a1b6dead03c04fe7e2cfc1f921876a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac2a1b6dead03c04fe7e2cfc1f921876a">la_lapack_s::la_sgbtf2</a> (m, n, kl, ku, ab, ldab, ipiv, info)</td></tr>
<tr class="memdesc:ac2a1b6dead03c04fe7e2cfc1f921876a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBTF2: computes an LU factorization of a real m-by-n band matrix A using partial pivoting with row interchanges. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:ac2a1b6dead03c04fe7e2cfc1f921876a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f617d917ac43140e6e413894e5d055" id="r_a30f617d917ac43140e6e413894e5d055"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a30f617d917ac43140e6e413894e5d055">la_lapack_s::la_sgbtrs</a> (trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a30f617d917ac43140e6e413894e5d055"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBTRS: solves a system of linear equations A * X = B or A**T * X = B with a general band matrix A using the LU factorization computed by SGBTRF.  <br /></td></tr>
<tr class="separator:a30f617d917ac43140e6e413894e5d055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af9b70c44c6230adc8ddc3159fcd235" id="r_a3af9b70c44c6230adc8ddc3159fcd235"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3af9b70c44c6230adc8ddc3159fcd235">la_lapack_s::la_sgebak</a> (job, side, n, ilo, ihi, scale, m, v, ldv, info)</td></tr>
<tr class="memdesc:a3af9b70c44c6230adc8ddc3159fcd235"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEBAK: forms the right or left eigenvectors of a real general matrix by backward transformation on the computed eigenvectors of the balanced matrix output by SGEBAL.  <br /></td></tr>
<tr class="separator:a3af9b70c44c6230adc8ddc3159fcd235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9604697725af46684b3719e32cc41c0" id="r_ae9604697725af46684b3719e32cc41c0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ae9604697725af46684b3719e32cc41c0">la_lapack_s::la_sggbak</a> (job, side, n, ilo, ihi, lscale, rscale, m, v, ldv, info)</td></tr>
<tr class="memdesc:ae9604697725af46684b3719e32cc41c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGBAK: forms the right or left eigenvectors of a real generalized eigenvalue problem A*x = lambda*B*x, by backward transformation on the computed eigenvectors of the balanced pair of matrices output by SGGBAL.  <br /></td></tr>
<tr class="separator:ae9604697725af46684b3719e32cc41c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786cb553ad22aed722de150137aa1469" id="r_a786cb553ad22aed722de150137aa1469"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a786cb553ad22aed722de150137aa1469">la_lapack_s::la_sgtsv</a> (n, nrhs, dl, d, du, b, ldb, info)</td></tr>
<tr class="memdesc:a786cb553ad22aed722de150137aa1469"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGTSV: solves the equation A*X = B, where A is an n by n tridiagonal matrix, by Gaussian elimination with partial pivoting. Note that the equation A**T*X = B may be solved by interchanging the order of the arguments DU and DL.  <br /></td></tr>
<tr class="separator:a786cb553ad22aed722de150137aa1469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e2c995bafe62a5c838c68c97d27ab0" id="r_a06e2c995bafe62a5c838c68c97d27ab0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a06e2c995bafe62a5c838c68c97d27ab0">la_lapack_s::la_sgttrf</a> (n, dl, d, du, du2, ipiv, info)</td></tr>
<tr class="memdesc:a06e2c995bafe62a5c838c68c97d27ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGTTRF: computes an LU factorization of a real tridiagonal matrix A using elimination with partial pivoting and row interchanges. The factorization has the form A = L * U where L is a product of permutation and unit lower bidiagonal matrices and U is upper triangular with nonzeros in only the main diagonal and first two superdiagonals.  <br /></td></tr>
<tr class="separator:a06e2c995bafe62a5c838c68c97d27ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580597865c1dd0decf74221c205778bc" id="r_a580597865c1dd0decf74221c205778bc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a580597865c1dd0decf74221c205778bc">la_lapack_s::la_sgtts2</a> (itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb)</td></tr>
<tr class="memdesc:a580597865c1dd0decf74221c205778bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGTTS2: solves one of the systems of equations A*X = B or A**T*X = B, with a tridiagonal matrix A using the LU factorization computed by SGTTRF.  <br /></td></tr>
<tr class="separator:a580597865c1dd0decf74221c205778bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df2ee0dcaed56f43442df463709086a" id="r_a7df2ee0dcaed56f43442df463709086a"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7df2ee0dcaed56f43442df463709086a">la_lapack_s::la_sla_gbrpvgrw</a> (n, kl, ku, ncols, ab, ldab, afb, ldafb)</td></tr>
<tr class="memdesc:a7df2ee0dcaed56f43442df463709086a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_GBRPVGRW: computes the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If this is much less than 1, the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, estimated condition numbers, and error bounds could be unreliable.  <br /></td></tr>
<tr class="separator:a7df2ee0dcaed56f43442df463709086a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056ee2e8518a23fac8dea75eb34190df" id="r_a056ee2e8518a23fac8dea75eb34190df"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a056ee2e8518a23fac8dea75eb34190df">la_lapack_s::la_sla_gerpvgrw</a> (n, ncols, a, lda, af, ldaf)</td></tr>
<tr class="memdesc:a056ee2e8518a23fac8dea75eb34190df"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_GERPVGRW: computes the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If this is much less than 1, the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, estimated condition numbers, and error bounds could be unreliable.  <br /></td></tr>
<tr class="separator:a056ee2e8518a23fac8dea75eb34190df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db8acf576d3aeb34dadef30710ddff6" id="r_a2db8acf576d3aeb34dadef30710ddff6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2db8acf576d3aeb34dadef30710ddff6">la_lapack_s::la_sla_wwaddw</a> (n, x, y, w)</td></tr>
<tr class="memdesc:a2db8acf576d3aeb34dadef30710ddff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_WWADDW: adds a vector W into a doubled-single vector (X, Y). This works for all extant IBM's hex and binary floating point arithmetic, but not for decimal.  <br /></td></tr>
<tr class="separator:a2db8acf576d3aeb34dadef30710ddff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c70bc25650d02927495d8a3635d03f8" id="r_a8c70bc25650d02927495d8a3635d03f8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8c70bc25650d02927495d8a3635d03f8">la_lapack_s::la_slabad</a> (small, large)</td></tr>
<tr class="memdesc:a8c70bc25650d02927495d8a3635d03f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLABAD: takes as input the values computed by SLAMCH for underflow and overflow, and returns the square root of each of these values if the log of LARGE is sufficiently large. This subroutine is intended to identify machines with a large exponent range, such as the Crays, and redefine the underflow and overflow limits to be the square roots of the values computed by SLAMCH. This subroutine is needed because SLAMCH does not compensate for poor arithmetic in the upper half of the exponent range, as is found on a Cray.  <br /></td></tr>
<tr class="separator:a8c70bc25650d02927495d8a3635d03f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5f2af31221a1cf8d74880aedc775ca" id="r_a7f5f2af31221a1cf8d74880aedc775ca"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7f5f2af31221a1cf8d74880aedc775ca">la_lapack_s::la_slacn2</a> (n, v, x, isgn, est, kase, isave)</td></tr>
<tr class="memdesc:a7f5f2af31221a1cf8d74880aedc775ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLACN2: estimates the 1-norm of a square, real matrix A. Reverse communication is used for evaluating matrix-vector products.  <br /></td></tr>
<tr class="separator:a7f5f2af31221a1cf8d74880aedc775ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f15136a389df955aa65c350a4abd54c" id="r_a8f15136a389df955aa65c350a4abd54c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8f15136a389df955aa65c350a4abd54c">la_lapack_s::la_slacon</a> (n, v, x, isgn, est, kase)</td></tr>
<tr class="memdesc:a8f15136a389df955aa65c350a4abd54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLACON: estimates the 1-norm of a square, real matrix A. Reverse communication is used for evaluating matrix-vector products.  <br /></td></tr>
<tr class="separator:a8f15136a389df955aa65c350a4abd54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1967e81244ac5e46fcdee355359852" id="r_aaf1967e81244ac5e46fcdee355359852"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aaf1967e81244ac5e46fcdee355359852">la_lapack_s::la_slacpy</a> (uplo, m, n, a, lda, b, ldb)</td></tr>
<tr class="memdesc:aaf1967e81244ac5e46fcdee355359852"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLACPY: copies all or part of a two-dimensional matrix A to another matrix B.  <br /></td></tr>
<tr class="separator:aaf1967e81244ac5e46fcdee355359852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17f6c0e0bd931bc884ab7f8a0648d74" id="r_ab17f6c0e0bd931bc884ab7f8a0648d74"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab17f6c0e0bd931bc884ab7f8a0648d74">la_lapack_s::la_sladiv2</a> (a, b, c, d, r, t)</td></tr>
<tr class="separator:ab17f6c0e0bd931bc884ab7f8a0648d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97354bef5f34975536b39d5e7438cf22" id="r_a97354bef5f34975536b39d5e7438cf22"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a97354bef5f34975536b39d5e7438cf22">la_lapack_s::la_slae2</a> (a, b, c, rt1, rt2)</td></tr>
<tr class="memdesc:a97354bef5f34975536b39d5e7438cf22"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAE2: computes the eigenvalues of a 2-by-2 symmetric matrix [ A B ] [ B C ]. On return, RT1 is the eigenvalue of larger absolute value, and RT2 is the eigenvalue of smaller absolute value.  <br /></td></tr>
<tr class="separator:a97354bef5f34975536b39d5e7438cf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab4a4740485276da029afc52e98c9e7" id="r_a5ab4a4740485276da029afc52e98c9e7"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a5ab4a4740485276da029afc52e98c9e7">la_lapack_s::la_slaebz</a> (ijob, nitmax, n, mmax, minp, nbmin, abstol, reltol, pivmin, d, e, e2, nval, ab, c, mout, nab, work, iwork, info)</td></tr>
<tr class="memdesc:a5ab4a4740485276da029afc52e98c9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAEBZ: contains the iteration loops which compute and use the function N(w), which is the count of eigenvalues of a symmetric tridiagonal matrix T less than or equal to its argument w. It performs a choice of two types of loops: IJOB=1, followed by IJOB=2: It takes as input a list of intervals and returns a list of sufficiently small intervals whose union contains the same eigenvalues as the union of the original intervals. The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP. The output interval (AB(j,1),AB(j,2)] will contain eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 &lt;= j &lt;= MOUT. IJOB=3: It performs a binary search in each input interval (AB(j,1),AB(j,2)] for a point w(j) such that N(w(j))=NVAL(j), and uses C(j) as the starting point of the search. If such a w(j) is found, then on output AB(j,1)=AB(j,2)=w. If no such w(j) is found, then on output (AB(j,1),AB(j,2)] will be a small interval containing the point where N(w) jumps through NVAL(j), unless that point lies outside the initial interval. Note that the intervals are in all cases half-open intervals, i.e., of the form (a,b] , which includes b but not a . To avoid underflow, the matrix should be scaled so that its largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value. To assure the most accurate computation of small eigenvalues, the matrix should be scaled to be not much smaller than that, either. See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford University, July 21, 1966 Note: the arguments are, in general, <em>not</em> checked for unreasonable values.  <br /></td></tr>
<tr class="separator:a5ab4a4740485276da029afc52e98c9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33476ec01694c0d71b16b52bfd7bd5e" id="r_ad33476ec01694c0d71b16b52bfd7bd5e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad33476ec01694c0d71b16b52bfd7bd5e">la_lapack_s::la_slaed5</a> (i, d, z, delta, rho, dlam)</td></tr>
<tr class="memdesc:ad33476ec01694c0d71b16b52bfd7bd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine computes the I-th eigenvalue of a symmetric rank-one modification of a 2-by-2 diagonal matrix diag( D ) + RHO * Z * transpose(Z) . The diagonal elements in the array D are assumed to satisfy D(i) &lt; D(j) for i &lt; j . We also assume RHO &gt; 0 and that the Euclidean norm of the vector Z is one.  <br /></td></tr>
<tr class="separator:ad33476ec01694c0d71b16b52bfd7bd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16d38efe5e49a6cfd9dc160dce90e61" id="r_ac16d38efe5e49a6cfd9dc160dce90e61"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac16d38efe5e49a6cfd9dc160dce90e61">la_lapack_s::la_slaeda</a> (n, tlvls, curlvl, curpbm, prmptr, perm, givptr, givcol, givnum, q, qptr, z, ztemp, info)</td></tr>
<tr class="memdesc:ac16d38efe5e49a6cfd9dc160dce90e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAEDA: computes the Z vector corresponding to the merge step in the CURLVLth step of the merge process with TLVLS steps for the CURPBMth problem.  <br /></td></tr>
<tr class="separator:ac16d38efe5e49a6cfd9dc160dce90e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b5963df7f28fc439de8f0c7f8a01fa" id="r_a72b5963df7f28fc439de8f0c7f8a01fa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a72b5963df7f28fc439de8f0c7f8a01fa">la_lapack_s::la_slaev2</a> (a, b, c, rt1, rt2, cs1, sn1)</td></tr>
<tr class="memdesc:a72b5963df7f28fc439de8f0c7f8a01fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAEV2: computes the eigendecomposition of a 2-by-2 symmetric matrix [ A B ] [ B C ]. On return, RT1 is the eigenvalue of larger absolute value, RT2 is the eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right eigenvector for RT1, giving the decomposition [ CS1 SN1 ] [ A B ] [ CS1 -SN1 ] = [ RT1 0 ] [-SN1 CS1 ] [ B C ] [ SN1 CS1 ] [ 0 RT2 ].  <br /></td></tr>
<tr class="separator:a72b5963df7f28fc439de8f0c7f8a01fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ccf62819d9fc0afba87dc2d05f6398" id="r_a96ccf62819d9fc0afba87dc2d05f6398"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a96ccf62819d9fc0afba87dc2d05f6398">la_lapack_s::la_slag2</a> (a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2, wi)</td></tr>
<tr class="memdesc:a96ccf62819d9fc0afba87dc2d05f6398"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAG2: computes the eigenvalues of a 2 x 2 generalized eigenvalue problem A - w B, with scaling as necessary to avoid over-/underflow. The scaling factor "s" results in a modified eigenvalue equation s A - w B where s is a non-negative scaling factor chosen so that w, w B, and s A do not overflow and, if possible, do not underflow, either.  <br /></td></tr>
<tr class="separator:a96ccf62819d9fc0afba87dc2d05f6398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d693cc41d07c6b1ffebf158d0b65e46" id="r_a3d693cc41d07c6b1ffebf158d0b65e46"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3d693cc41d07c6b1ffebf158d0b65e46">la_lapack_s::la_slag2d</a> (m, n, sa, ldsa, a, lda, info)</td></tr>
<tr class="memdesc:a3d693cc41d07c6b1ffebf158d0b65e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAG2D: converts a SINGLE PRECISION matrix, SA, to a DOUBLE PRECISION matrix, A. Note that while it is possible to overflow while converting from double to single, it is not possible to overflow when converting from single to double. This is an auxiliary routine so there is no argument checking.  <br /></td></tr>
<tr class="separator:a3d693cc41d07c6b1ffebf158d0b65e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1f5cf44ac54507afde1fe5fd0f3120" id="r_a4e1f5cf44ac54507afde1fe5fd0f3120"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4e1f5cf44ac54507afde1fe5fd0f3120">la_lapack_s::la_slagtm</a> (trans, n, nrhs, alpha, dl, d, du, x, ldx, beta, b, ldb)</td></tr>
<tr class="memdesc:a4e1f5cf44ac54507afde1fe5fd0f3120"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAGTM: performs a matrix-vector product of the form B := alpha * A * X + beta * B where A is a tridiagonal matrix of order N, B and X are N by NRHS matrices, and alpha and beta are real scalars, each of which may be 0., 1., or -1.  <br /></td></tr>
<tr class="separator:a4e1f5cf44ac54507afde1fe5fd0f3120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab716c1e999e316ce29c31703ef379eb1" id="r_ab716c1e999e316ce29c31703ef379eb1"><td class="memItemLeft" align="right" valign="top">pure logical(<a class="el" href="namespacela__constants.html#ab69b1529685742074aaa0fa65f97a084">lk</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab716c1e999e316ce29c31703ef379eb1">la_lapack_s::la_slaisnan</a> (sin1, sin2)</td></tr>
<tr class="memdesc:ab716c1e999e316ce29c31703ef379eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine is not for general use. It exists solely to avoid over-optimization in SISNAN. SLAISNAN: checks for NaNs by comparing its two arguments for inequality. NaN is the only floating-point value where NaN != NaN returns .TRUE. To check for NaNs, pass the same variable as both arguments. A compiler must assume that the two arguments are not the same variable, and the test will not be optimized away. Interprocedural or whole-program optimization may delete this test. The ISNAN functions will be replaced by the correct Fortran 03 intrinsic once the intrinsic is widely available.  <br /></td></tr>
<tr class="separator:ab716c1e999e316ce29c31703ef379eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe0ae24f069ddbf134ff3e404a19878" id="r_abbe0ae24f069ddbf134ff3e404a19878"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abbe0ae24f069ddbf134ff3e404a19878">la_lapack_s::la_slamch</a> (cmach)</td></tr>
<tr class="memdesc:abbe0ae24f069ddbf134ff3e404a19878"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAMCH: determines single precision machine parameters.  <br /></td></tr>
<tr class="separator:abbe0ae24f069ddbf134ff3e404a19878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c60e3c446767bce997fe321ee6ab2fb" id="r_a7c60e3c446767bce997fe321ee6ab2fb"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7c60e3c446767bce997fe321ee6ab2fb">la_lapack_s::la_slamc3</a> (a, b)</td></tr>
<tr class="separator:a7c60e3c446767bce997fe321ee6ab2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d05bb8d0ca029bcb1ef48d28af83cc" id="r_aa6d05bb8d0ca029bcb1ef48d28af83cc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa6d05bb8d0ca029bcb1ef48d28af83cc">la_lapack_s::la_slamrg</a> (n1, n2, a, strd1, strd2, index)</td></tr>
<tr class="memdesc:aa6d05bb8d0ca029bcb1ef48d28af83cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAMRG: will create a permutation list which will merge the elements of A (which is composed of two independently sorted sets) into a single set which is sorted in ascending order.  <br /></td></tr>
<tr class="separator:aa6d05bb8d0ca029bcb1ef48d28af83cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b36aefdcd735380a2912b047235df6d" id="r_a4b36aefdcd735380a2912b047235df6d"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4b36aefdcd735380a2912b047235df6d">la_lapack_s::la_slaorhr_col_getrfnp2</a> (m, n, a, lda, d, info)</td></tr>
<tr class="memdesc:a4b36aefdcd735380a2912b047235df6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAORHR_COL_GETRFNP2: computes the modified LU factorization without pivoting of a real general M-by-N matrix A. The factorization has the form: A - S = L * U, where: S is a m-by-n diagonal sign matrix with the diagonal D, so that D(i) = S(i,i), 1 &lt;= i &lt;= min(M,N). The diagonal D is constructed as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing i-1 steps of Gaussian elimination. This means that the diagonal element at each step of "modified" Gaussian elimination is at least one in absolute value (so that division-by-zero not possible during the division by the diagonal element); L is a M-by-N lower triangular matrix with unit diagonal elements (lower trapezoidal if M &gt; N); and U is a M-by-N upper triangular matrix (upper trapezoidal if M &lt; N). This routine is an auxiliary routine used in the Householder reconstruction routine SORHR_COL. In SORHR_COL, this routine is applied to an M-by-N matrix A with orthonormal columns, where each element is bounded by one in absolute value. With the choice of the matrix S above, one can show that the diagonal element at each step of Gaussian elimination is the largest (in absolute value) in the column on or below the diagonal, so that no pivoting is required for numerical stability [1]. For more details on the Householder reconstruction algorithm, including the modified LU factorization, see [1]. This is the recursive version of the LU factorization algorithm. Denote A - S by B. The algorithm divides the matrix B into four submatrices: [ B11 | B12 ] where B11 is n1 by n1, B = [ --&mdash;|--&mdash; ] B21 is (m-n1) by n1, [ B21 | B22 ] B12 is n1 by n2, B22 is (m-n1) by n2, with n1 = min(m,n)/2, n2 = n-n1. The subroutine calls itself to factor B11, solves for B21, solves for B12, updates B22, then calls itself to factor B22. For more details on the recursive LU algorithm, see [2]. SLAORHR_COL_GETRFNP2 is called to factorize a block by the blocked routine SLAORHR_COL_GETRFNP, which uses blocked code calling Level 3 BLAS to update the submatrix. However, SLAORHR_COL_GETRFNP2 is self-sufficient and can be used without SLAORHR_COL_GETRFNP. [1] "Reconstructing Householder vectors from tall-skinny QR", G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen, E. Solomonik, J. Parallel Distrib. Comput., vol. 85, pp. 3-31, 2015. [2] "Recursion leads to automatic variable blocking for dense linear
 algebra algorithms", F. Gustavson, IBM J. of Res. and Dev., vol. 41, no. 6, pp. 737-755, 1997.  <br /></td></tr>
<tr class="separator:a4b36aefdcd735380a2912b047235df6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c8005d8c8a1c262da728236379aaea" id="r_a25c8005d8c8a1c262da728236379aaea"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a25c8005d8c8a1c262da728236379aaea">la_lapack_s::la_slapmr</a> (forwrd, m, n, x, ldx, k)</td></tr>
<tr class="memdesc:a25c8005d8c8a1c262da728236379aaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAPMR: rearranges the rows of the M by N matrix X as specified by the permutation K(1),K(2),...,K(M) of the integers 1,...,M. If FORWRD = .TRUE., forward permutation: X(K(I),*) is moved X(I,*) for I = 1,2,...,M. If FORWRD = .FALSE., backward permutation: X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.  <br /></td></tr>
<tr class="separator:a25c8005d8c8a1c262da728236379aaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0004159f53124bf500f83ef8a1807b78" id="r_a0004159f53124bf500f83ef8a1807b78"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0004159f53124bf500f83ef8a1807b78">la_lapack_s::la_slapmt</a> (forwrd, m, n, x, ldx, k)</td></tr>
<tr class="memdesc:a0004159f53124bf500f83ef8a1807b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAPMT: rearranges the columns of the M by N matrix X as specified by the permutation K(1),K(2),...,K(N) of the integers 1,...,N. If FORWRD = .TRUE., forward permutation: X(*,K(J)) is moved X(*,J) for J = 1,2,...,N. If FORWRD = .FALSE., backward permutation: X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.  <br /></td></tr>
<tr class="separator:a0004159f53124bf500f83ef8a1807b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b575a6ebd1e3edcc83685b2fdf1122" id="r_a05b575a6ebd1e3edcc83685b2fdf1122"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a05b575a6ebd1e3edcc83685b2fdf1122">la_lapack_s::la_slapy3</a> (x, y, z)</td></tr>
<tr class="memdesc:a05b575a6ebd1e3edcc83685b2fdf1122"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAPY3: returns sqrt(x**2+y**2+z**2), taking care not to cause unnecessary overflow and unnecessary underflow.  <br /></td></tr>
<tr class="separator:a05b575a6ebd1e3edcc83685b2fdf1122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22040e5601b043326db071a8fc7fd445" id="r_a22040e5601b043326db071a8fc7fd445"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a22040e5601b043326db071a8fc7fd445">la_lapack_s::la_slaqgb</a> (m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, equed)</td></tr>
<tr class="memdesc:a22040e5601b043326db071a8fc7fd445"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQGB: equilibrates a general M by N band matrix A with KL subdiagonals and KU superdiagonals using the row and scaling factors in the vectors R and C.  <br /></td></tr>
<tr class="separator:a22040e5601b043326db071a8fc7fd445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8afd791784eb1faf83d690c1ebd827" id="r_a7e8afd791784eb1faf83d690c1ebd827"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7e8afd791784eb1faf83d690c1ebd827">la_lapack_s::la_slaqge</a> (m, n, a, lda, r, c, rowcnd, colcnd, amax, equed)</td></tr>
<tr class="memdesc:a7e8afd791784eb1faf83d690c1ebd827"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQGE: equilibrates a general M by N matrix A using the row and column scaling factors in the vectors R and C.  <br /></td></tr>
<tr class="separator:a7e8afd791784eb1faf83d690c1ebd827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa543e2b7d7f83c9d1ed2353ee1371fed" id="r_aa543e2b7d7f83c9d1ed2353ee1371fed"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa543e2b7d7f83c9d1ed2353ee1371fed">la_lapack_s::la_slaqr1</a> (n, h, ldh, sr1, si1, sr2, si2, v)</td></tr>
<tr class="memdesc:aa543e2b7d7f83c9d1ed2353ee1371fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a 2-by-2 or 3-by-3 matrix H, SLAQR1: sets v to a scalar multiple of the first column of the product (*) K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I) scaling to avoid overflows and most underflows. It is assumed that either 1) sr1 = sr2 and si1 = -si2 or 2) si1 = si2 = 0. This is useful for starting double implicit shift bulges in the QR algorithm.  <br /></td></tr>
<tr class="separator:aa543e2b7d7f83c9d1ed2353ee1371fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ae1145714e997688a00b60854e5c52" id="r_a16ae1145714e997688a00b60854e5c52"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a16ae1145714e997688a00b60854e5c52">la_lapack_s::la_slaqsb</a> (uplo, n, kd, ab, ldab, s, scond, amax, equed)</td></tr>
<tr class="memdesc:a16ae1145714e997688a00b60854e5c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQSB: equilibrates a symmetric band matrix A using the scaling factors in the vector S.  <br /></td></tr>
<tr class="separator:a16ae1145714e997688a00b60854e5c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c277f93eac102815803d813c75c80b5" id="r_a8c277f93eac102815803d813c75c80b5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8c277f93eac102815803d813c75c80b5">la_lapack_s::la_slaqsp</a> (uplo, n, ap, s, scond, amax, equed)</td></tr>
<tr class="memdesc:a8c277f93eac102815803d813c75c80b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQSP: equilibrates a symmetric matrix A using the scaling factors in the vector S.  <br /></td></tr>
<tr class="separator:a8c277f93eac102815803d813c75c80b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a62c94fb15a4ca454cccecc7d1adda" id="r_a75a62c94fb15a4ca454cccecc7d1adda"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a75a62c94fb15a4ca454cccecc7d1adda">la_lapack_s::la_slaqsy</a> (uplo, n, a, lda, s, scond, amax, equed)</td></tr>
<tr class="memdesc:a75a62c94fb15a4ca454cccecc7d1adda"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQSY: equilibrates a symmetric matrix A using the scaling factors in the vector S.  <br /></td></tr>
<tr class="separator:a75a62c94fb15a4ca454cccecc7d1adda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70949165fbe181dd558de03a8557e7aa" id="r_a70949165fbe181dd558de03a8557e7aa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a70949165fbe181dd558de03a8557e7aa">la_lapack_s::la_slar2v</a> (n, x, y, z, incx, c, s, incc)</td></tr>
<tr class="memdesc:a70949165fbe181dd558de03a8557e7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAR2V: applies a vector of real plane rotations from both sides to a sequence of 2-by-2 real symmetric matrices, defined by the elements of the vectors x, y and z. For i = 1,2,...,n ( x(i) z(i) ) := ( c(i) s(i) ) ( x(i) z(i) ) ( c(i) -s(i) ) ( z(i) y(i) ) ( -s(i) c(i) ) ( z(i) y(i) ) ( s(i) c(i) )  <br /></td></tr>
<tr class="separator:a70949165fbe181dd558de03a8557e7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe74baa9cec84eae9cb50ed04c85340c" id="r_afe74baa9cec84eae9cb50ed04c85340c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#afe74baa9cec84eae9cb50ed04c85340c">la_lapack_s::la_slarf</a> (side, m, n, v, incv, tau, c, ldc, work)</td></tr>
<tr class="memdesc:afe74baa9cec84eae9cb50ed04c85340c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARF: applies a real elementary reflector H to a real m by n matrix C, from either the left or the right. H is represented in the form H = I - tau * v * v**T where tau is a real scalar and v is a real vector. If tau = 0, then H is taken to be the unit matrix.  <br /></td></tr>
<tr class="separator:afe74baa9cec84eae9cb50ed04c85340c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f424ab78fa97dff58d431a8ab51b7c" id="r_a88f424ab78fa97dff58d431a8ab51b7c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a88f424ab78fa97dff58d431a8ab51b7c">la_lapack_s::la_slarfb</a> (side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork)</td></tr>
<tr class="memdesc:a88f424ab78fa97dff58d431a8ab51b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARFB: applies a real block reflector H or its transpose H**T to a real m by n matrix C, from either the left or the right.  <br /></td></tr>
<tr class="separator:a88f424ab78fa97dff58d431a8ab51b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ae9b0033e1bd16bad547d2c73e525a" id="r_ab4ae9b0033e1bd16bad547d2c73e525a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab4ae9b0033e1bd16bad547d2c73e525a">la_lapack_s::la_slarfb_gett</a> (ident, m, n, k, t, ldt, a, lda, b, ldb, work, ldwork)</td></tr>
<tr class="memdesc:ab4ae9b0033e1bd16bad547d2c73e525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARFB_GETT: applies a real Householder block reflector H from the left to a real (K+M)-by-N "triangular-pentagonal" matrix composed of two block matrices: an upper trapezoidal K-by-N matrix A stored in the array A, and a rectangular M-by-(N-K) matrix B, stored in the array B. The block reflector H is stored in a compact WY-representation, where the elementary reflectors are in the arrays A, B and T. See Further Details section.  <br /></td></tr>
<tr class="separator:ab4ae9b0033e1bd16bad547d2c73e525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b9ff2c43c13daa04cd1985c67d4216" id="r_a94b9ff2c43c13daa04cd1985c67d4216"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a94b9ff2c43c13daa04cd1985c67d4216">la_lapack_s::la_slarft</a> (direct, storev, n, k, v, ldv, tau, t, ldt)</td></tr>
<tr class="memdesc:a94b9ff2c43c13daa04cd1985c67d4216"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARFT: forms the triangular factor T of a real block reflector H of order n, which is defined as a product of k elementary reflectors. If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular; If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular. If STOREV = 'C', the vector which defines the elementary reflector H(i) is stored in the i-th column of the array V, and H = I - V * T * V**T If STOREV = 'R', the vector which defines the elementary reflector H(i) is stored in the i-th row of the array V, and H = I - V**T * T * V.  <br /></td></tr>
<tr class="separator:a94b9ff2c43c13daa04cd1985c67d4216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc192e2bc4ec8214dc94d7e793a1a59" id="r_aedc192e2bc4ec8214dc94d7e793a1a59"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aedc192e2bc4ec8214dc94d7e793a1a59">la_lapack_s::la_slarfx</a> (side, m, n, v, tau, c, ldc, work)</td></tr>
<tr class="memdesc:aedc192e2bc4ec8214dc94d7e793a1a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARFX: applies a real elementary reflector H to a real m by n matrix C, from either the left or the right. H is represented in the form H = I - tau * v * v**T where tau is a real scalar and v is a real vector. If tau = 0, then H is taken to be the unit matrix This version uses inline code if H has order &lt; 11.  <br /></td></tr>
<tr class="separator:aedc192e2bc4ec8214dc94d7e793a1a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec676c3c643164ef3da80603d9e3452" id="r_a5ec676c3c643164ef3da80603d9e3452"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a5ec676c3c643164ef3da80603d9e3452">la_lapack_s::la_slarfy</a> (uplo, n, v, incv, tau, c, ldc, work)</td></tr>
<tr class="memdesc:a5ec676c3c643164ef3da80603d9e3452"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARFY: applies an elementary reflector, or Householder matrix, H, to an n x n symmetric matrix C, from both the left and the right. H is represented in the form H = I - tau * v * v' where tau is a scalar and v is a vector. If tau is zero, then H is taken to be the unit matrix.  <br /></td></tr>
<tr class="separator:a5ec676c3c643164ef3da80603d9e3452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03705cc4581f4ed3a18e88ff00b9b0d1" id="r_a03705cc4581f4ed3a18e88ff00b9b0d1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a03705cc4581f4ed3a18e88ff00b9b0d1">la_lapack_s::la_slargv</a> (n, x, incx, y, incy, c, incc)</td></tr>
<tr class="memdesc:a03705cc4581f4ed3a18e88ff00b9b0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARGV: generates a vector of real plane rotations, determined by elements of the real vectors x and y. For i = 1,2,...,n ( c(i) s(i) ) ( x(i) ) = ( a(i) ) ( -s(i) c(i) ) ( y(i) ) = ( 0 )  <br /></td></tr>
<tr class="separator:a03705cc4581f4ed3a18e88ff00b9b0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8eacaceb11cbb3eb55b5b225120b99" id="r_abd8eacaceb11cbb3eb55b5b225120b99"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abd8eacaceb11cbb3eb55b5b225120b99">la_lapack_s::la_slarra</a> (n, d, e, e2, spltol, tnrm, nsplit, isplit, info)</td></tr>
<tr class="memdesc:abd8eacaceb11cbb3eb55b5b225120b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the splitting points with threshold SPLTOL. SLARRA: sets any "small" off-diagonal elements to zero.  <br /></td></tr>
<tr class="separator:abd8eacaceb11cbb3eb55b5b225120b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e22da93c392e8a03fe0808ea1f4219d" id="r_a2e22da93c392e8a03fe0808ea1f4219d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2e22da93c392e8a03fe0808ea1f4219d">la_lapack_s::la_slarrc</a> (jobt, n, vl, vu, d, e, pivmin, eigcnt, lcnt, rcnt, info)</td></tr>
<tr class="memdesc:a2e22da93c392e8a03fe0808ea1f4219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of eigenvalues of the symmetric tridiagonal matrix T that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T if JOBT = 'L'.  <br /></td></tr>
<tr class="separator:a2e22da93c392e8a03fe0808ea1f4219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe54f1833376e6f38c12cbfa38ad1aeb" id="r_abe54f1833376e6f38c12cbfa38ad1aeb"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abe54f1833376e6f38c12cbfa38ad1aeb">la_lapack_s::la_slarrd</a> (range, order, n, vl, vu, il, iu, gers, reltol, d, e, e2, pivmin, nsplit, isplit, m, w, werr, wl, wu, iblock, indexw, work, iwork, info)</td></tr>
<tr class="memdesc:abe54f1833376e6f38c12cbfa38ad1aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARRD: computes the eigenvalues of a symmetric tridiagonal matrix T to suitable accuracy. This is an auxiliary code to be called from SSTEMR. The user may ask for all eigenvalues, all eigenvalues in the half-open interval (VL, VU], or the IL-th through IU-th eigenvalues. To avoid overflow, the matrix must be scaled so that its largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest accuracy, it should not be much smaller than that. See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford University, July 21, 1966.  <br /></td></tr>
<tr class="separator:abe54f1833376e6f38c12cbfa38ad1aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b1a8642d0f20f7d5b0fc1997922055" id="r_a29b1a8642d0f20f7d5b0fc1997922055"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a29b1a8642d0f20f7d5b0fc1997922055">la_lapack_s::la_slarrj</a> (n, d, e2, ifirst, ilast, rtol, offset, w, werr, work, iwork, pivmin, spdiam, info)</td></tr>
<tr class="memdesc:a29b1a8642d0f20f7d5b0fc1997922055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the initial eigenvalue approximations of T, SLARRJ: does bisection to refine the eigenvalues of T, W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial guesses for these eigenvalues are input in W, the corresponding estimate of the error in these guesses in WERR. During bisection, intervals [left, right] are maintained by storing their mid-points and semi-widths in the arrays W and WERR respectively.  <br /></td></tr>
<tr class="separator:a29b1a8642d0f20f7d5b0fc1997922055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53274bb800bf71a225801880a91b78d0" id="r_a53274bb800bf71a225801880a91b78d0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a53274bb800bf71a225801880a91b78d0">la_lapack_s::la_slarrk</a> (n, iw, gl, gu, d, e2, pivmin, reltol, w, werr, info)</td></tr>
<tr class="memdesc:a53274bb800bf71a225801880a91b78d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARRK: computes one eigenvalue of a symmetric tridiagonal matrix T to suitable accuracy. This is an auxiliary code to be called from SSTEMR. To avoid overflow, the matrix must be scaled so that its largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest accuracy, it should not be much smaller than that. See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford University, July 21, 1966.  <br /></td></tr>
<tr class="separator:a53274bb800bf71a225801880a91b78d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277085f646b8b2fe8a03e725b4ee370f" id="r_a277085f646b8b2fe8a03e725b4ee370f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a277085f646b8b2fe8a03e725b4ee370f">la_lapack_s::la_slarrr</a> (n, d, e, info)</td></tr>
<tr class="memdesc:a277085f646b8b2fe8a03e725b4ee370f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform tests to decide whether the symmetric tridiagonal matrix T warrants expensive computations which guarantee high relative accuracy in the eigenvalues.  <br /></td></tr>
<tr class="separator:a277085f646b8b2fe8a03e725b4ee370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd68a5bad03276a397dd6b4efd2bd83" id="r_aabd68a5bad03276a397dd6b4efd2bd83"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aabd68a5bad03276a397dd6b4efd2bd83">la_lapack_s::la_slartg</a> (f, g, c, s, r)</td></tr>
<tr class="memdesc:aabd68a5bad03276a397dd6b4efd2bd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">!  <br /></td></tr>
<tr class="separator:aabd68a5bad03276a397dd6b4efd2bd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af339f24767ab40f6bc796ff5c5560f7c" id="r_af339f24767ab40f6bc796ff5c5560f7c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af339f24767ab40f6bc796ff5c5560f7c">la_lapack_s::la_slartgp</a> (f, g, cs, sn, r)</td></tr>
<tr class="memdesc:af339f24767ab40f6bc796ff5c5560f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARTGP: generates a plane rotation so that [ CS SN ] . [ F ] = [ R ] where CS**2 + SN**2 = 1. [ -SN CS ] [ G ] [ 0 ] This is a slower, more accurate version of the Level 1 BLAS routine SROTG, with the following other differences: F and G are unchanged on return. If G=0, then CS=(+/-)1 and SN=0. If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1. The sign is chosen so that R &gt;= 0.  <br /></td></tr>
<tr class="separator:af339f24767ab40f6bc796ff5c5560f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b7812ea3bd288d96512934061140fa" id="r_af1b7812ea3bd288d96512934061140fa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af1b7812ea3bd288d96512934061140fa">la_lapack_s::la_slartgs</a> (x, y, sigma, cs, sn)</td></tr>
<tr class="memdesc:af1b7812ea3bd288d96512934061140fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARTGS: generates a plane rotation designed to introduce a bulge in Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD problem. X and Y are the top-row entries, and SIGMA is the shift. The computed CS and SN define a plane rotation satisfying [ CS SN ] . [ X^2 - SIGMA ] = [ R ], [ -SN CS ] [ X * Y ] [ 0 ] with R nonnegative. If X^2 - SIGMA and X * Y are 0, then the rotation is by PI/2.  <br /></td></tr>
<tr class="separator:af1b7812ea3bd288d96512934061140fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882e0bd87f6174696069158f796f1e50" id="r_a882e0bd87f6174696069158f796f1e50"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a882e0bd87f6174696069158f796f1e50">la_lapack_s::la_slartv</a> (n, x, incx, y, incy, c, s, incc)</td></tr>
<tr class="memdesc:a882e0bd87f6174696069158f796f1e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARTV: applies a vector of real plane rotations to elements of the real vectors x and y. For i = 1,2,...,n ( x(i) ) := ( c(i) s(i) ) ( x(i) ) ( y(i) ) ( -s(i) c(i) ) ( y(i) )  <br /></td></tr>
<tr class="separator:a882e0bd87f6174696069158f796f1e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9872d6f18e29e7384d488781ba9d128" id="r_ab9872d6f18e29e7384d488781ba9d128"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab9872d6f18e29e7384d488781ba9d128">la_lapack_s::la_slaruv</a> (iseed, n, x)</td></tr>
<tr class="memdesc:ab9872d6f18e29e7384d488781ba9d128"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARUV: returns a vector of n random real numbers from a uniform (0,1) distribution (n &lt;= 128). This is an auxiliary routine called by SLARNV and CLARNV.  <br /></td></tr>
<tr class="separator:ab9872d6f18e29e7384d488781ba9d128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f538d72c282a7a4e223456d1c14e8c" id="r_a58f538d72c282a7a4e223456d1c14e8c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a58f538d72c282a7a4e223456d1c14e8c">la_lapack_s::la_slarz</a> (side, m, n, l, v, incv, tau, c, ldc, work)</td></tr>
<tr class="memdesc:a58f538d72c282a7a4e223456d1c14e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARZ: applies a real elementary reflector H to a real M-by-N matrix C, from either the left or the right. H is represented in the form H = I - tau * v * v**T where tau is a real scalar and v is a real vector. If tau = 0, then H is taken to be the unit matrix. H is a product of k elementary reflectors as returned by STZRZF.  <br /></td></tr>
<tr class="separator:a58f538d72c282a7a4e223456d1c14e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1702e83db974f3933e2a270be395d5f2" id="r_a1702e83db974f3933e2a270be395d5f2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1702e83db974f3933e2a270be395d5f2">la_lapack_s::la_slarzb</a> (side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, c, ldc, work, ldwork)</td></tr>
<tr class="memdesc:a1702e83db974f3933e2a270be395d5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARZB: applies a real block reflector H or its transpose H**T to a real distributed M-by-N C from the left or the right. Currently, only STOREV = 'R' and DIRECT = 'B' are supported.  <br /></td></tr>
<tr class="separator:a1702e83db974f3933e2a270be395d5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac841da88a7f0a81f617adc32fb32f387" id="r_ac841da88a7f0a81f617adc32fb32f387"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac841da88a7f0a81f617adc32fb32f387">la_lapack_s::la_slarzt</a> (direct, storev, n, k, v, ldv, tau, t, ldt)</td></tr>
<tr class="memdesc:ac841da88a7f0a81f617adc32fb32f387"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARZT: forms the triangular factor T of a real block reflector H of order &gt; n, which is defined as a product of k elementary reflectors. If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular; If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular. If STOREV = 'C', the vector which defines the elementary reflector H(i) is stored in the i-th column of the array V, and H = I - V * T * V**T If STOREV = 'R', the vector which defines the elementary reflector H(i) is stored in the i-th row of the array V, and H = I - V**T * T * V Currently, only STOREV = 'R' and DIRECT = 'B' are supported.  <br /></td></tr>
<tr class="separator:ac841da88a7f0a81f617adc32fb32f387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6032a4f9106611866bbc0a0000807ddf" id="r_a6032a4f9106611866bbc0a0000807ddf"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a6032a4f9106611866bbc0a0000807ddf">la_lapack_s::la_slas2</a> (f, g, h, ssmin, ssmax)</td></tr>
<tr class="memdesc:a6032a4f9106611866bbc0a0000807ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAS2: computes the singular values of the 2-by-2 matrix [ F G ] [ 0 H ]. On return, SSMIN is the smaller singular value and SSMAX is the larger singular value.  <br /></td></tr>
<tr class="separator:a6032a4f9106611866bbc0a0000807ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0910cb2bd50f8afdf309ee4e5c7fca33" id="r_a0910cb2bd50f8afdf309ee4e5c7fca33"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0910cb2bd50f8afdf309ee4e5c7fca33">la_lapack_s::la_slasd5</a> (i, d, z, delta, rho, dsigma, work)</td></tr>
<tr class="memdesc:a0910cb2bd50f8afdf309ee4e5c7fca33"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine computes the square root of the I-th eigenvalue of a positive symmetric rank-one modification of a 2-by-2 diagonal matrix diag( D ) * diag( D ) + RHO * Z * transpose(Z) . The diagonal entries in the array D are assumed to satisfy 0 &lt;= D(i) &lt; D(j) for i &lt; j . We also assume RHO &gt; 0 and that the Euclidean norm of the vector Z is one.  <br /></td></tr>
<tr class="separator:a0910cb2bd50f8afdf309ee4e5c7fca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda5cb49085b73fc60927c6c27053cd2" id="r_afda5cb49085b73fc60927c6c27053cd2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#afda5cb49085b73fc60927c6c27053cd2">la_lapack_s::la_slasdt</a> (n, lvl, nd, inode, ndiml, ndimr, msub)</td></tr>
<tr class="memdesc:afda5cb49085b73fc60927c6c27053cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASDT: creates a tree of subproblems for bidiagonal divide and conquer.  <br /></td></tr>
<tr class="separator:afda5cb49085b73fc60927c6c27053cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaa56062a507046ea65b05c77c0104f" id="r_a3eaa56062a507046ea65b05c77c0104f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3eaa56062a507046ea65b05c77c0104f">la_lapack_s::la_slaset</a> (uplo, m, n, alpha, beta, a, lda)</td></tr>
<tr class="memdesc:a3eaa56062a507046ea65b05c77c0104f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASET: initializes an m-by-n matrix A to BETA on the diagonal and ALPHA on the offdiagonals.  <br /></td></tr>
<tr class="separator:a3eaa56062a507046ea65b05c77c0104f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520e58d706cfa18bca68b8a9f04f1e35" id="r_a520e58d706cfa18bca68b8a9f04f1e35"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a520e58d706cfa18bca68b8a9f04f1e35">la_lapack_s::la_slasq4</a> (i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn, dn1, dn2, tau, ttype, g)</td></tr>
<tr class="memdesc:a520e58d706cfa18bca68b8a9f04f1e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASQ4: computes an approximation TAU to the smallest eigenvalue using values of d from the previous transform.  <br /></td></tr>
<tr class="separator:a520e58d706cfa18bca68b8a9f04f1e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07492787fdbe2163cf26bc14982a24b1" id="r_a07492787fdbe2163cf26bc14982a24b1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a07492787fdbe2163cf26bc14982a24b1">la_lapack_s::la_slasq5</a> (i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2, dn, dnm1, dnm2, ieee, eps)</td></tr>
<tr class="memdesc:a07492787fdbe2163cf26bc14982a24b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASQ5: computes one dqds transform in ping-pong form, one version for IEEE machines another for non IEEE machines.  <br /></td></tr>
<tr class="separator:a07492787fdbe2163cf26bc14982a24b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c5909d93788d8a221de133dc7beafb" id="r_a79c5909d93788d8a221de133dc7beafb"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a79c5909d93788d8a221de133dc7beafb">la_lapack_s::la_slasq6</a> (i0, n0, z, pp, dmin, dmin1, dmin2, dn, dnm1, dnm2)</td></tr>
<tr class="memdesc:a79c5909d93788d8a221de133dc7beafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASQ6: computes one dqd (shift equal to zero) transform in ping-pong form, with protection against underflow and overflow.  <br /></td></tr>
<tr class="separator:a79c5909d93788d8a221de133dc7beafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91ca475ec1636210600a15006c7ff78" id="r_ad91ca475ec1636210600a15006c7ff78"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad91ca475ec1636210600a15006c7ff78">la_lapack_s::la_slasr</a> (side, pivot, direct, m, n, c, s, a, lda)</td></tr>
<tr class="memdesc:ad91ca475ec1636210600a15006c7ff78"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASR: applies a sequence of plane rotations to a real matrix A, from either the left or the right. When SIDE = 'L', the transformation takes the form A := P*A and when SIDE = 'R', the transformation takes the form A := A*P**T where P is an orthogonal matrix consisting of a sequence of z plane rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R', and P**T is the transpose of P. When DIRECT = 'F' (Forward sequence), then P = P(z-1) * ... * P(2) * P(1) and when DIRECT = 'B' (Backward sequence), then P = P(1) * P(2) * ... * P(z-1) where P(k) is a plane rotation matrix defined by the 2-by-2 rotation R(k) = ( c(k) s(k) ) = ( -s(k) c(k) ). When PIVOT = 'V' (Variable pivot), the rotation is performed for the plane (k,k+1), i.e., P(k) has the form P(k) = ( 1 ) ( ... ) ( 1 ) ( c(k) s(k) ) ( -s(k) c(k) ) ( 1 ) ( ... ) ( 1 ) where R(k) appears as a rank-2 modification to the identity matrix in rows and columns k and k+1. When PIVOT = 'T' (Top pivot), the rotation is performed for the plane (1,k+1), so P(k) has the form P(k) = ( c(k) s(k) ) ( 1 ) ( ... ) ( 1 ) ( -s(k) c(k) ) ( 1 ) ( ... ) ( 1 ) where R(k) appears in rows and columns 1 and k+1. Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is performed for the plane (k,z), giving P(k) the form P(k) = ( 1 ) ( ... ) ( 1 ) ( c(k) s(k) ) ( 1 ) ( ... ) ( 1 ) ( -s(k) c(k) ) where R(k) appears in rows and columns k and z. The rotations are performed without ever forming P(k) explicitly.  <br /></td></tr>
<tr class="separator:ad91ca475ec1636210600a15006c7ff78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19beb351a658d51a9494b0b24abb22bd" id="r_a19beb351a658d51a9494b0b24abb22bd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a19beb351a658d51a9494b0b24abb22bd">la_lapack_s::la_slasrt</a> (id, n, d, info)</td></tr>
<tr class="memdesc:a19beb351a658d51a9494b0b24abb22bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the numbers in D in increasing order (if ID = 'I') or in decreasing order (if ID = 'D' ). Use Quick Sort, reverting to Insertion sort on arrays of size &lt;= 20. Dimension of STACK limits N to about 2**32.  <br /></td></tr>
<tr class="separator:a19beb351a658d51a9494b0b24abb22bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ffb8da40d4b0e1ec3c776507a088cc" id="r_a67ffb8da40d4b0e1ec3c776507a088cc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a67ffb8da40d4b0e1ec3c776507a088cc">la_lapack_s::la_slassq</a> (n, x, incx, scl, sumsq)</td></tr>
<tr class="memdesc:a67ffb8da40d4b0e1ec3c776507a088cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">!  <br /></td></tr>
<tr class="separator:a67ffb8da40d4b0e1ec3c776507a088cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a4879231fd3b2289e6beb335def092" id="r_ac8a4879231fd3b2289e6beb335def092"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac8a4879231fd3b2289e6beb335def092">la_lapack_s::la_slasv2</a> (f, g, h, ssmin, ssmax, snr, csr, snl, csl)</td></tr>
<tr class="memdesc:ac8a4879231fd3b2289e6beb335def092"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASV2: computes the singular value decomposition of a 2-by-2 triangular matrix [ F G ] [ 0 H ]. On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and right singular vectors for abs(SSMAX), giving the decomposition [ CSL SNL ] [ F G ] [ CSR -SNR ] = [ SSMAX 0 ] [-SNL CSL ] [ 0 H ] [ SNR CSR ] [ 0 SSMIN ].  <br /></td></tr>
<tr class="separator:ac8a4879231fd3b2289e6beb335def092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32210a3155cf4bcf4884b373e585f34f" id="r_a32210a3155cf4bcf4884b373e585f34f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a32210a3155cf4bcf4884b373e585f34f">la_lapack_s::la_slaswp</a> (n, a, lda, k1, k2, ipiv, incx)</td></tr>
<tr class="memdesc:a32210a3155cf4bcf4884b373e585f34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASWP: performs a series of row interchanges on the matrix A. One row interchange is initiated for each of rows K1 through K2 of A.  <br /></td></tr>
<tr class="separator:a32210a3155cf4bcf4884b373e585f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19329c2b5fa03d2cab358e6e261179e6" id="r_a19329c2b5fa03d2cab358e6e261179e6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a19329c2b5fa03d2cab358e6e261179e6">la_lapack_s::la_slasy2</a> (ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr, ldtr, b, ldb, scale, x, ldx, xnorm, info)</td></tr>
<tr class="memdesc:a19329c2b5fa03d2cab358e6e261179e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASY2: solves for the N1 by N2 matrix X, 1 &lt;= N1,N2 &lt;= 2, in op(TL)*X + ISGN*X*op(TR) = SCALE*B, where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or -1. op(T) = T or T**T, where T**T denotes the transpose of T.  <br /></td></tr>
<tr class="separator:a19329c2b5fa03d2cab358e6e261179e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ce907f9175efb55ad4806630d17192" id="r_a61ce907f9175efb55ad4806630d17192"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a61ce907f9175efb55ad4806630d17192">la_lapack_s::la_slasyf</a> (uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)</td></tr>
<tr class="memdesc:a61ce907f9175efb55ad4806630d17192"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASYF: computes a partial factorization of a real symmetric matrix A using the Bunch-Kaufman diagonal pivoting method. The partial factorization has the form: A = ( I U12 ) ( A11 0 ) ( I 0 ) if UPLO = 'U', or: ( 0 U22 ) ( 0 D ) ( U12**T U22**T ) A = ( L11 0 ) ( D 0 ) ( L11**T L21**T ) if UPLO = 'L' ( L21 I ) ( 0 A22 ) ( 0 I ) where the order of D is at most NB. The actual order is returned in the argument KB, and is either NB or NB-1, or N if N &lt;= NB. SLASYF is an auxiliary routine called by SSYTRF. It uses blocked code (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or A22 (if UPLO = 'L').  <br /></td></tr>
<tr class="separator:a61ce907f9175efb55ad4806630d17192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3be3b1edcf81e67869fdb142475b01" id="r_a2f3be3b1edcf81e67869fdb142475b01"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2f3be3b1edcf81e67869fdb142475b01">la_lapack_s::la_slasyf_rk</a> (uplo, n, nb, kb, a, lda, e, ipiv, w, ldw, info)</td></tr>
<tr class="memdesc:a2f3be3b1edcf81e67869fdb142475b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASYF_RK: computes a partial factorization of a real symmetric matrix A using the bounded Bunch-Kaufman (rook) diagonal pivoting method. The partial factorization has the form: A = ( I U12 ) ( A11 0 ) ( I 0 ) if UPLO = 'U', or: ( 0 U22 ) ( 0 D ) ( U12**T U22**T ) A = ( L11 0 ) ( D 0 ) ( L11**T L21**T ) if UPLO = 'L', ( L21 I ) ( 0 A22 ) ( 0 I ) where the order of D is at most NB. The actual order is returned in the argument KB, and is either NB or NB-1, or N if N &lt;= NB. SLASYF_RK is an auxiliary routine called by SSYTRF_RK. It uses blocked code (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or A22 (if UPLO = 'L').  <br /></td></tr>
<tr class="separator:a2f3be3b1edcf81e67869fdb142475b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c937c58f7811181b8f0d1b2d0540b8e" id="r_a4c937c58f7811181b8f0d1b2d0540b8e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4c937c58f7811181b8f0d1b2d0540b8e">la_lapack_s::la_slasyf_rook</a> (uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)</td></tr>
<tr class="memdesc:a4c937c58f7811181b8f0d1b2d0540b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASYF_ROOK: computes a partial factorization of a real symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method. The partial factorization has the form: A = ( I U12 ) ( A11 0 ) ( I 0 ) if UPLO = 'U', or: ( 0 U22 ) ( 0 D ) ( U12**T U22**T ) A = ( L11 0 ) ( D 0 ) ( L11**T L21**T ) if UPLO = 'L' ( L21 I ) ( 0 A22 ) ( 0 I ) where the order of D is at most NB. The actual order is returned in the argument KB, and is either NB or NB-1, or N if N &lt;= NB. SLASYF_ROOK is an auxiliary routine called by SSYTRF_ROOK. It uses blocked code (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or A22 (if UPLO = 'L').  <br /></td></tr>
<tr class="separator:a4c937c58f7811181b8f0d1b2d0540b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5481cf6f93198b518dfe6b2f6797187a" id="r_a5481cf6f93198b518dfe6b2f6797187a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a5481cf6f93198b518dfe6b2f6797187a">la_lapack_s::la_slatbs</a> (uplo, trans, diag, normin, n, kd, ab, ldab, x, scale, cnorm, info)</td></tr>
<tr class="memdesc:a5481cf6f93198b518dfe6b2f6797187a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLATBS: solves one of the triangular systems A *x = s*b or A**T*x = s*b with scaling to prevent overflow, where A is an upper or lower triangular band matrix. Here A**T denotes the transpose of A, x and b are n-element vectors, and s is a scaling factor, usually less than or equal to 1, chosen so that the components of x will be less than the overflow threshold. If the unscaled problem will not cause overflow, the Level 2 BLAS routine STBSV is called. If the matrix A is singular (A(j,j) = 0 for some j), then s is set to 0 and a non-trivial solution to A*x = 0 is returned.  <br /></td></tr>
<tr class="separator:a5481cf6f93198b518dfe6b2f6797187a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d15a6a15413139e7a29806148075d5" id="r_a15d15a6a15413139e7a29806148075d5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a15d15a6a15413139e7a29806148075d5">la_lapack_s::la_slatps</a> (uplo, trans, diag, normin, n, ap, x, scale, cnorm, info)</td></tr>
<tr class="memdesc:a15d15a6a15413139e7a29806148075d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLATPS: solves one of the triangular systems A *x = s*b or A**T*x = s*b with scaling to prevent overflow, where A is an upper or lower triangular matrix stored in packed form. Here A**T denotes the transpose of A, x and b are n-element vectors, and s is a scaling factor, usually less than or equal to 1, chosen so that the components of x will be less than the overflow threshold. If the unscaled problem will not cause overflow, the Level 2 BLAS routine STPSV is called. If the matrix A is singular (A(j,j) = 0 for some j), then s is set to 0 and a non-trivial solution to A*x = 0 is returned.  <br /></td></tr>
<tr class="separator:a15d15a6a15413139e7a29806148075d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be33840b5f73aee7f595b96369bb720" id="r_a2be33840b5f73aee7f595b96369bb720"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2be33840b5f73aee7f595b96369bb720">la_lapack_s::la_slatrs</a> (uplo, trans, diag, normin, n, a, lda, x, scale, cnorm, info)</td></tr>
<tr class="memdesc:a2be33840b5f73aee7f595b96369bb720"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLATRS: solves one of the triangular systems A *x = s*b or A**T*x = s*b with scaling to prevent overflow. Here A is an upper or lower triangular matrix, A**T denotes the transpose of A, x and b are n-element vectors, and s is a scaling factor, usually less than or equal to 1, chosen so that the components of x will be less than the overflow threshold. If the unscaled problem will not cause overflow, the Level 2 BLAS routine STRSV is called. If the matrix A is singular (A(j,j) = 0 for some j), then s is set to 0 and a non-trivial solution to A*x = 0 is returned.  <br /></td></tr>
<tr class="separator:a2be33840b5f73aee7f595b96369bb720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cd3b7f78ef835df9124f4e840e14d3" id="r_a38cd3b7f78ef835df9124f4e840e14d3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a38cd3b7f78ef835df9124f4e840e14d3">la_lapack_s::la_slauu2</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:a38cd3b7f78ef835df9124f4e840e14d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAUU2: computes the product U * U**T or L**T * L, where the triangular factor U or L is stored in the upper or lower triangular part of the array A. If UPLO = 'U' or 'u' then the upper triangle of the result is stored, overwriting the factor U in A. If UPLO = 'L' or 'l' then the lower triangle of the result is stored, overwriting the factor L in A. This is the unblocked form of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:a38cd3b7f78ef835df9124f4e840e14d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68932d0582407df8a265aca8e9dec21" id="r_ac68932d0582407df8a265aca8e9dec21"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac68932d0582407df8a265aca8e9dec21">la_lapack_s::la_slauum</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:ac68932d0582407df8a265aca8e9dec21"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAUUM: computes the product U * U**T or L**T * L, where the triangular factor U or L is stored in the upper or lower triangular part of the array A. If UPLO = 'U' or 'u' then the upper triangle of the result is stored, overwriting the factor U in A. If UPLO = 'L' or 'l' then the lower triangle of the result is stored, overwriting the factor L in A. This is the blocked form of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:ac68932d0582407df8a265aca8e9dec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a59f910776990e959d955a767c7323" id="r_a32a59f910776990e959d955a767c7323"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a32a59f910776990e959d955a767c7323">la_lapack_s::la_sorbdb6</a> (m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2, work, lwork, info)</td></tr>
<tr class="memdesc:a32a59f910776990e959d955a767c7323"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORBDB6: orthogonalizes the column vector X = [ X1 ] [ X2 ] with respect to the columns of Q = [ Q1 ] . [ Q2 ] The columns of Q must be orthonormal. If the projection is zero according to Kahan's "twice is enough" criterion, then the zero vector is returned.  <br /></td></tr>
<tr class="separator:a32a59f910776990e959d955a767c7323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6467e11886d47543e86e228b9575da82" id="r_a6467e11886d47543e86e228b9575da82"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a6467e11886d47543e86e228b9575da82">la_lapack_s::la_sorg2l</a> (m, n, k, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a6467e11886d47543e86e228b9575da82"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORG2L: generates an m by n real matrix Q with orthonormal columns, which is defined as the last n columns of a product of k elementary reflectors of order m Q = H(k) . . . H(2) H(1) as returned by SGEQLF.  <br /></td></tr>
<tr class="separator:a6467e11886d47543e86e228b9575da82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50ce79c5b9f671484ac787de35af9a3" id="r_ac50ce79c5b9f671484ac787de35af9a3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac50ce79c5b9f671484ac787de35af9a3">la_lapack_s::la_sorg2r</a> (m, n, k, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:ac50ce79c5b9f671484ac787de35af9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORG2R: generates an m by n real matrix Q with orthonormal columns, which is defined as the first n columns of a product of k elementary reflectors of order m Q = H(1) H(2) . . . H(k) as returned by SGEQRF.  <br /></td></tr>
<tr class="separator:ac50ce79c5b9f671484ac787de35af9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b6b7ed9e2baccac0cdab9696540ed3" id="r_a60b6b7ed9e2baccac0cdab9696540ed3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a60b6b7ed9e2baccac0cdab9696540ed3">la_lapack_s::la_sorgl2</a> (m, n, k, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a60b6b7ed9e2baccac0cdab9696540ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGL2: generates an m by n real matrix Q with orthonormal rows, which is defined as the first m rows of a product of k elementary reflectors of order n Q = H(k) . . . H(2) H(1) as returned by SGELQF.  <br /></td></tr>
<tr class="separator:a60b6b7ed9e2baccac0cdab9696540ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea44626dd991e17b1b9eeff676594d86" id="r_aea44626dd991e17b1b9eeff676594d86"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aea44626dd991e17b1b9eeff676594d86">la_lapack_s::la_sorglq</a> (m, n, k, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:aea44626dd991e17b1b9eeff676594d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGLQ: generates an M-by-N real matrix Q with orthonormal rows, which is defined as the first M rows of a product of K elementary reflectors of order N Q = H(k) . . . H(2) H(1) as returned by SGELQF.  <br /></td></tr>
<tr class="separator:aea44626dd991e17b1b9eeff676594d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9da29a60efb2f4b290e3e43c1af880" id="r_a6b9da29a60efb2f4b290e3e43c1af880"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a6b9da29a60efb2f4b290e3e43c1af880">la_lapack_s::la_sorgql</a> (m, n, k, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a6b9da29a60efb2f4b290e3e43c1af880"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGQL: generates an M-by-N real matrix Q with orthonormal columns, which is defined as the last N columns of a product of K elementary reflectors of order M Q = H(k) . . . H(2) H(1) as returned by SGEQLF.  <br /></td></tr>
<tr class="separator:a6b9da29a60efb2f4b290e3e43c1af880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c17964b5116204999558eb1393885f" id="r_aa5c17964b5116204999558eb1393885f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa5c17964b5116204999558eb1393885f">la_lapack_s::la_sorgqr</a> (m, n, k, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:aa5c17964b5116204999558eb1393885f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGQR: generates an M-by-N real matrix Q with orthonormal columns, which is defined as the first N columns of a product of K elementary reflectors of order M Q = H(1) H(2) . . . H(k) as returned by SGEQRF.  <br /></td></tr>
<tr class="separator:aa5c17964b5116204999558eb1393885f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f10367bbc437bd0a6ed0c14e6ab56a" id="r_a00f10367bbc437bd0a6ed0c14e6ab56a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a00f10367bbc437bd0a6ed0c14e6ab56a">la_lapack_s::la_sorgr2</a> (m, n, k, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a00f10367bbc437bd0a6ed0c14e6ab56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGR2: generates an m by n real matrix Q with orthonormal rows, which is defined as the last m rows of a product of k elementary reflectors of order n Q = H(1) H(2) . . . H(k) as returned by SGERQF.  <br /></td></tr>
<tr class="separator:a00f10367bbc437bd0a6ed0c14e6ab56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28402b710179465139f9b1c294f7a47" id="r_ab28402b710179465139f9b1c294f7a47"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab28402b710179465139f9b1c294f7a47">la_lapack_s::la_sorgrq</a> (m, n, k, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:ab28402b710179465139f9b1c294f7a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGRQ: generates an M-by-N real matrix Q with orthonormal rows, which is defined as the last M rows of a product of K elementary reflectors of order N Q = H(1) H(2) . . . H(k) as returned by SGERQF.  <br /></td></tr>
<tr class="separator:ab28402b710179465139f9b1c294f7a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e316935aeff7f94c34b1c6c94ee4a5" id="r_ad5e316935aeff7f94c34b1c6c94ee4a5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad5e316935aeff7f94c34b1c6c94ee4a5">la_lapack_s::la_sorgtsqr_row</a> (m, n, mb, nb, a, lda, t, ldt, work, lwork, info)</td></tr>
<tr class="memdesc:ad5e316935aeff7f94c34b1c6c94ee4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGTSQR_ROW: generates an M-by-N real matrix Q_out with orthonormal columns from the output of SLATSQR. These N orthonormal columns are the first N columns of a product of complex unitary matrices Q(k)_in of order M, which are returned by SLATSQR in a special format. Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ). The input matrices Q(k)_in are stored in row and column blocks in A. See the documentation of SLATSQR for more details on the format of Q(k)_in, where each Q(k)_in is represented by block Householder transformations. This routine calls an auxiliary routine SLARFB_GETT, where the computation is performed on each individual block. The algorithm first sweeps NB-sized column blocks from the right to left starting in the bottom row block and continues to the top row block (hence _ROW in the routine name). This sweep is in reverse order of the order in which SLATSQR generates the output blocks.  <br /></td></tr>
<tr class="separator:ad5e316935aeff7f94c34b1c6c94ee4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0e6e928cfc81e8e313247acfbf61aa" id="r_a6d0e6e928cfc81e8e313247acfbf61aa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a6d0e6e928cfc81e8e313247acfbf61aa">la_lapack_s::la_sorm22</a> (side, trans, m, n, n1, n2, q, ldq, c, ldc, work, lwork, info)</td></tr>
<tr class="separator:a6d0e6e928cfc81e8e313247acfbf61aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962e8d2786dff3f5cd5f35e645f4e300" id="r_a962e8d2786dff3f5cd5f35e645f4e300"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a962e8d2786dff3f5cd5f35e645f4e300">la_lapack_s::la_sorm2l</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:a962e8d2786dff3f5cd5f35e645f4e300"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORM2L: overwrites the general real m by n matrix C with Q * C if SIDE = 'L' and TRANS = 'N', or Q**T * C if SIDE = 'L' and TRANS = 'T', or C * Q if SIDE = 'R' and TRANS = 'N', or C * Q**T if SIDE = 'R' and TRANS = 'T', where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(k) . . . H(2) H(1) as returned by SGEQLF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a962e8d2786dff3f5cd5f35e645f4e300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc871fc63224d09fc6b3575cd46c87d" id="r_a9dc871fc63224d09fc6b3575cd46c87d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9dc871fc63224d09fc6b3575cd46c87d">la_lapack_s::la_sorm2r</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:a9dc871fc63224d09fc6b3575cd46c87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORM2R: overwrites the general real m by n matrix C with Q * C if SIDE = 'L' and TRANS = 'N', or Q**T* C if SIDE = 'L' and TRANS = 'T', or C * Q if SIDE = 'R' and TRANS = 'N', or C * Q**T if SIDE = 'R' and TRANS = 'T', where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(1) H(2) . . . H(k) as returned by SGEQRF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a9dc871fc63224d09fc6b3575cd46c87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2706ed56e5e3ad3abef5f292cab12b0b" id="r_a2706ed56e5e3ad3abef5f292cab12b0b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2706ed56e5e3ad3abef5f292cab12b0b">la_lapack_s::la_sorml2</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:a2706ed56e5e3ad3abef5f292cab12b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORML2: overwrites the general real m by n matrix C with Q * C if SIDE = 'L' and TRANS = 'N', or Q**T* C if SIDE = 'L' and TRANS = 'T', or C * Q if SIDE = 'R' and TRANS = 'N', or C * Q**T if SIDE = 'R' and TRANS = 'T', where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(k) . . . H(2) H(1) as returned by SGELQF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a2706ed56e5e3ad3abef5f292cab12b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843f6d93b320898de311fc0837e0944a" id="r_a843f6d93b320898de311fc0837e0944a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a843f6d93b320898de311fc0837e0944a">la_lapack_s::la_sormlq</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a843f6d93b320898de311fc0837e0944a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMLQ: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(k) . . . H(2) H(1) as returned by SGELQF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a843f6d93b320898de311fc0837e0944a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ed351d67c1567ceae04239031dd04f" id="r_ae6ed351d67c1567ceae04239031dd04f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ae6ed351d67c1567ceae04239031dd04f">la_lapack_s::la_sormql</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:ae6ed351d67c1567ceae04239031dd04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMQL: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(k) . . . H(2) H(1) as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:ae6ed351d67c1567ceae04239031dd04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675207ce317df13db048b8579ed02740" id="r_a675207ce317df13db048b8579ed02740"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a675207ce317df13db048b8579ed02740">la_lapack_s::la_sormqr</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a675207ce317df13db048b8579ed02740"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMQR: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(1) H(2) . . . H(k) as returned by SGEQRF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a675207ce317df13db048b8579ed02740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df969938e68cb4d69d3fe70c9ce3e45" id="r_a4df969938e68cb4d69d3fe70c9ce3e45"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4df969938e68cb4d69d3fe70c9ce3e45">la_lapack_s::la_sormr2</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:a4df969938e68cb4d69d3fe70c9ce3e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMR2: overwrites the general real m by n matrix C with Q * C if SIDE = 'L' and TRANS = 'N', or Q**T* C if SIDE = 'L' and TRANS = 'T', or C * Q if SIDE = 'R' and TRANS = 'N', or C * Q**T if SIDE = 'R' and TRANS = 'T', where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(1) H(2) . . . H(k) as returned by SGERQF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a4df969938e68cb4d69d3fe70c9ce3e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fd646092788c2390228238b87efa6e" id="r_ae0fd646092788c2390228238b87efa6e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ae0fd646092788c2390228238b87efa6e">la_lapack_s::la_sormr3</a> (side, trans, m, n, k, l, a, lda, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:ae0fd646092788c2390228238b87efa6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMR3: overwrites the general real m by n matrix C with Q * C if SIDE = 'L' and TRANS = 'N', or Q**T* C if SIDE = 'L' and TRANS = 'C', or C * Q if SIDE = 'R' and TRANS = 'N', or C * Q**T if SIDE = 'R' and TRANS = 'C', where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(1) H(2) . . . H(k) as returned by STZRZF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:ae0fd646092788c2390228238b87efa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c39c99283a53c26c7dbef16d3498367" id="r_a3c39c99283a53c26c7dbef16d3498367"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3c39c99283a53c26c7dbef16d3498367">la_lapack_s::la_sormrq</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a3c39c99283a53c26c7dbef16d3498367"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMRQ: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(1) H(2) . . . H(k) as returned by SGERQF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a3c39c99283a53c26c7dbef16d3498367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6ede3c321d44989281b9900572170a" id="r_abc6ede3c321d44989281b9900572170a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abc6ede3c321d44989281b9900572170a">la_lapack_s::la_sormrz</a> (side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:abc6ede3c321d44989281b9900572170a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMRZ: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix defined as the product of k elementary reflectors Q = H(1) H(2) . . . H(k) as returned by STZRZF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:abc6ede3c321d44989281b9900572170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a32b33fb3f5f035ba74b039986411f" id="r_a00a32b33fb3f5f035ba74b039986411f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a00a32b33fb3f5f035ba74b039986411f">la_lapack_s::la_spbequ</a> (uplo, n, kd, ab, ldab, s, scond, amax, info)</td></tr>
<tr class="memdesc:a00a32b33fb3f5f035ba74b039986411f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPBEQU: computes row and column scalings intended to equilibrate a symmetric positive definite band matrix A and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings.  <br /></td></tr>
<tr class="separator:a00a32b33fb3f5f035ba74b039986411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1663e08908f892dd84e289066a92f437" id="r_a1663e08908f892dd84e289066a92f437"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1663e08908f892dd84e289066a92f437">la_lapack_s::la_spbstf</a> (uplo, n, kd, ab, ldab, info)</td></tr>
<tr class="memdesc:a1663e08908f892dd84e289066a92f437"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPBSTF: computes a split Cholesky factorization of a real symmetric positive definite band matrix A. This routine is designed to be used in conjunction with SSBGST. The factorization has the form A = S**T*S where S is a band matrix of the same bandwidth as A and the following structure: S = ( U ) ( M L ) where U is upper triangular of order m = (n+kd)/2, and L is lower triangular of order n-m.  <br /></td></tr>
<tr class="separator:a1663e08908f892dd84e289066a92f437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b41e2591782808f6ced63efd135f42" id="r_a15b41e2591782808f6ced63efd135f42"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a15b41e2591782808f6ced63efd135f42">la_lapack_s::la_spbtf2</a> (uplo, n, kd, ab, ldab, info)</td></tr>
<tr class="memdesc:a15b41e2591782808f6ced63efd135f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPBTF2: computes the Cholesky factorization of a real symmetric positive definite band matrix A. The factorization has the form A = U**T * U , if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix, U**T is the transpose of U, and L is lower triangular. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:a15b41e2591782808f6ced63efd135f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ce73e2df5020449e9f35024f755fa5" id="r_a66ce73e2df5020449e9f35024f755fa5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a66ce73e2df5020449e9f35024f755fa5">la_lapack_s::la_spbtrs</a> (uplo, n, kd, nrhs, ab, ldab, b, ldb, info)</td></tr>
<tr class="memdesc:a66ce73e2df5020449e9f35024f755fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPBTRS: solves a system of linear equations A*X = B with a symmetric positive definite band matrix A using the Cholesky factorization A = U**T*U or A = L*L**T computed by SPBTRF.  <br /></td></tr>
<tr class="separator:a66ce73e2df5020449e9f35024f755fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c9e5ba019c01964939c234a0ef01d0" id="r_a68c9e5ba019c01964939c234a0ef01d0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a68c9e5ba019c01964939c234a0ef01d0">la_lapack_s::la_spoequ</a> (n, a, lda, s, scond, amax, info)</td></tr>
<tr class="memdesc:a68c9e5ba019c01964939c234a0ef01d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPOEQU: computes row and column scalings intended to equilibrate a symmetric positive definite matrix A and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings.  <br /></td></tr>
<tr class="separator:a68c9e5ba019c01964939c234a0ef01d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fda625ae8f292baaec0cb2ffbff248" id="r_a88fda625ae8f292baaec0cb2ffbff248"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a88fda625ae8f292baaec0cb2ffbff248">la_lapack_s::la_spoequb</a> (n, a, lda, s, scond, amax, info)</td></tr>
<tr class="memdesc:a88fda625ae8f292baaec0cb2ffbff248"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPOEQUB: computes row and column scalings intended to equilibrate a symmetric positive definite matrix A and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings. This routine differs from SPOEQU by restricting the scaling factors to a power of the radix. Barring over- and underflow, scaling by these factors introduces no additional rounding errors. However, the scaled diagonal entries are no longer approximately 1 but lie between sqrt(radix) and 1/sqrt(radix).  <br /></td></tr>
<tr class="separator:a88fda625ae8f292baaec0cb2ffbff248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa661b37dd85d4a0f44f7e826d47b8500" id="r_aa661b37dd85d4a0f44f7e826d47b8500"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa661b37dd85d4a0f44f7e826d47b8500">la_lapack_s::la_spotrs</a> (uplo, n, nrhs, a, lda, b, ldb, info)</td></tr>
<tr class="memdesc:aa661b37dd85d4a0f44f7e826d47b8500"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPOTRS: solves a system of linear equations A*X = B with a symmetric positive definite matrix A using the Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.  <br /></td></tr>
<tr class="separator:aa661b37dd85d4a0f44f7e826d47b8500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2b0c9cd6cc366e2169550591665295" id="r_ace2b0c9cd6cc366e2169550591665295"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ace2b0c9cd6cc366e2169550591665295">la_lapack_s::la_sppequ</a> (uplo, n, ap, s, scond, amax, info)</td></tr>
<tr class="memdesc:ace2b0c9cd6cc366e2169550591665295"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPPEQU: computes row and column scalings intended to equilibrate a symmetric positive definite matrix A in packed storage and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings.  <br /></td></tr>
<tr class="separator:ace2b0c9cd6cc366e2169550591665295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcf5f1bc5532f89f40ba857a9074185" id="r_a0bcf5f1bc5532f89f40ba857a9074185"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0bcf5f1bc5532f89f40ba857a9074185">la_lapack_s::la_spptrf</a> (uplo, n, ap, info)</td></tr>
<tr class="memdesc:a0bcf5f1bc5532f89f40ba857a9074185"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPPTRF: computes the Cholesky factorization of a real symmetric positive definite matrix A stored in packed format. The factorization has the form A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular.  <br /></td></tr>
<tr class="separator:a0bcf5f1bc5532f89f40ba857a9074185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e831b32e78bdf05281d5382653c697" id="r_ac7e831b32e78bdf05281d5382653c697"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac7e831b32e78bdf05281d5382653c697">la_lapack_s::la_spptrs</a> (uplo, n, nrhs, ap, b, ldb, info)</td></tr>
<tr class="memdesc:ac7e831b32e78bdf05281d5382653c697"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPPTRS: solves a system of linear equations A*X = B with a symmetric positive definite matrix A in packed storage using the Cholesky factorization A = U**T*U or A = L*L**T computed by SPPTRF.  <br /></td></tr>
<tr class="separator:ac7e831b32e78bdf05281d5382653c697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310778f8397baec40912fecbd8dce9fe" id="r_a310778f8397baec40912fecbd8dce9fe"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a310778f8397baec40912fecbd8dce9fe">la_lapack_s::la_sptcon</a> (n, d, e, anorm, rcond, work, info)</td></tr>
<tr class="memdesc:a310778f8397baec40912fecbd8dce9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPTCON: computes the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite tridiagonal matrix using the factorization A = L*D*L**T or A = U**T*D*U computed by SPTTRF. Norm(inv(A)) is computed by a direct method, and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a310778f8397baec40912fecbd8dce9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8191dd8d8f728b09d6b35af4c31dabd" id="r_aa8191dd8d8f728b09d6b35af4c31dabd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa8191dd8d8f728b09d6b35af4c31dabd">la_lapack_s::la_spttrf</a> (n, d, e, info)</td></tr>
<tr class="memdesc:aa8191dd8d8f728b09d6b35af4c31dabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPTTRF: computes the L*D*L**T factorization of a real symmetric positive definite tridiagonal matrix A. The factorization may also be regarded as having the form A = U**T*D*U.  <br /></td></tr>
<tr class="separator:aa8191dd8d8f728b09d6b35af4c31dabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98d21053f7ac4eacd2ef221b82b8b2c" id="r_aa98d21053f7ac4eacd2ef221b82b8b2c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa98d21053f7ac4eacd2ef221b82b8b2c">la_lapack_s::la_sptts2</a> (n, nrhs, d, e, b, ldb)</td></tr>
<tr class="memdesc:aa98d21053f7ac4eacd2ef221b82b8b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPTTS2: solves a tridiagonal system of the form A * X = B using the L*D*L**T factorization of A computed by SPTTRF. D is a diagonal matrix specified in the vector D, L is a unit bidiagonal matrix whose subdiagonal is specified in the vector E, and X and B are N by NRHS matrices.  <br /></td></tr>
<tr class="separator:aa98d21053f7ac4eacd2ef221b82b8b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783c8ae4ebd73b3e7afebebd367a6492" id="r_a783c8ae4ebd73b3e7afebebd367a6492"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a783c8ae4ebd73b3e7afebebd367a6492">la_lapack_s::la_srscl</a> (n, sa, sx, incx)</td></tr>
<tr class="memdesc:a783c8ae4ebd73b3e7afebebd367a6492"><td class="mdescLeft">&#160;</td><td class="mdescRight">SRSCL: multiplies an n-element real vector x by the real scalar 1/a. This is done without overflow or underflow as long as the final result x/a does not overflow or underflow.  <br /></td></tr>
<tr class="separator:a783c8ae4ebd73b3e7afebebd367a6492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a754bf0d9d016e6f2d25e8bf33cefab" id="r_a7a754bf0d9d016e6f2d25e8bf33cefab"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7a754bf0d9d016e6f2d25e8bf33cefab">la_lapack_s::la_ssbgst</a> (vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, info)</td></tr>
<tr class="memdesc:a7a754bf0d9d016e6f2d25e8bf33cefab"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSBGST: reduces a real symmetric-definite banded generalized eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y, such that C has the same bandwidth as A. B must have been previously factorized as S**T*S by SPBSTF, using a split Cholesky factorization. A is overwritten by C = X**T*A*X, where X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the bandwidth of A.  <br /></td></tr>
<tr class="separator:a7a754bf0d9d016e6f2d25e8bf33cefab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9da39d658551b30e6d7771e78da9a5" id="r_a2a9da39d658551b30e6d7771e78da9a5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2a9da39d658551b30e6d7771e78da9a5">la_lapack_s::la_ssbtrd</a> (vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work, info)</td></tr>
<tr class="memdesc:a2a9da39d658551b30e6d7771e78da9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSBTRD: reduces a real symmetric band matrix A to symmetric tridiagonal form T by an orthogonal similarity transformation: Q**T * A * Q = T.  <br /></td></tr>
<tr class="separator:a2a9da39d658551b30e6d7771e78da9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22676674895c4c6888c3df3be233506d" id="r_a22676674895c4c6888c3df3be233506d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a22676674895c4c6888c3df3be233506d">la_lapack_s::la_ssfrk</a> (transr, uplo, trans, n, k, alpha, a, lda, beta, c)</td></tr>
<tr class="memdesc:a22676674895c4c6888c3df3be233506d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level 3 BLAS like routine for C in RFP Format. SSFRK: performs one of the symmetric rank&ndash;k operations C := alpha*A*A**T + beta*C, or C := alpha*A**T*A + beta*C, where alpha and beta are real scalars, C is an n&ndash;by&ndash;n symmetric matrix and A is an n&ndash;by&ndash;k matrix in the first case and a k&ndash;by&ndash;n matrix in the second case.  <br /></td></tr>
<tr class="separator:a22676674895c4c6888c3df3be233506d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5aacc1018fb32e82a3553effe5f29f" id="r_a0e5aacc1018fb32e82a3553effe5f29f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0e5aacc1018fb32e82a3553effe5f29f">la_lapack_s::la_sspgst</a> (itype, uplo, n, ap, bp, info)</td></tr>
<tr class="memdesc:a0e5aacc1018fb32e82a3553effe5f29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPGST: reduces a real symmetric-definite generalized eigenproblem to standard form, using packed storage. If ITYPE = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T) If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L. B must have been previously factorized as U**T*U or L*L**T by SPPTRF.  <br /></td></tr>
<tr class="separator:a0e5aacc1018fb32e82a3553effe5f29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c722529f88f9259865e55977b136e90" id="r_a1c722529f88f9259865e55977b136e90"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1c722529f88f9259865e55977b136e90">la_lapack_s::la_ssptrf</a> (uplo, n, ap, ipiv, info)</td></tr>
<tr class="memdesc:a1c722529f88f9259865e55977b136e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPTRF: computes the factorization of a real symmetric matrix A stored in packed format using the Bunch-Kaufman diagonal pivoting method: A = U*D*U**T or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.  <br /></td></tr>
<tr class="separator:a1c722529f88f9259865e55977b136e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af792d8102a0d7261414353c06f8c34d9" id="r_af792d8102a0d7261414353c06f8c34d9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af792d8102a0d7261414353c06f8c34d9">la_lapack_s::la_ssptri</a> (uplo, n, ap, ipiv, work, info)</td></tr>
<tr class="memdesc:af792d8102a0d7261414353c06f8c34d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPTRI: computes the inverse of a real symmetric indefinite matrix A in packed storage using the factorization A = U*D*U**T or A = L*D*L**T computed by SSPTRF.  <br /></td></tr>
<tr class="separator:af792d8102a0d7261414353c06f8c34d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010c32683a29f5db039a93b89ae4fed1" id="r_a010c32683a29f5db039a93b89ae4fed1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a010c32683a29f5db039a93b89ae4fed1">la_lapack_s::la_ssptrs</a> (uplo, n, nrhs, ap, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a010c32683a29f5db039a93b89ae4fed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPTRS: solves a system of linear equations A*X = B with a real symmetric matrix A stored in packed format using the factorization A = U*D*U**T or A = L*D*L**T computed by SSPTRF.  <br /></td></tr>
<tr class="separator:a010c32683a29f5db039a93b89ae4fed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef34a79063948949c8cc2309cfe4a5a8" id="r_aef34a79063948949c8cc2309cfe4a5a8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aef34a79063948949c8cc2309cfe4a5a8">la_lapack_s::la_sstebz</a> (range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork, info)</td></tr>
<tr class="memdesc:aef34a79063948949c8cc2309cfe4a5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEBZ: computes the eigenvalues of a symmetric tridiagonal matrix T. The user may ask for all eigenvalues, all eigenvalues in the half-open interval (VL, VU], or the IL-th through IU-th eigenvalues. To avoid overflow, the matrix must be scaled so that its largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest accuracy, it should not be much smaller than that. See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford University, July 21, 1966.  <br /></td></tr>
<tr class="separator:aef34a79063948949c8cc2309cfe4a5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7b810157326017df962c1f1ffe85e" id="r_a8cc7b810157326017df962c1f1ffe85e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8cc7b810157326017df962c1f1ffe85e">la_lapack_s::la_ssyconv</a> (uplo, way, n, a, lda, ipiv, e, info)</td></tr>
<tr class="memdesc:a8cc7b810157326017df962c1f1ffe85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYCONV: convert A given by TRF into L and D and vice-versa. Get Non-diag elements of D (returned in workspace) and apply or reverse permutation done in TRF.  <br /></td></tr>
<tr class="separator:a8cc7b810157326017df962c1f1ffe85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea41e604137d5347ebcd6b82e04ea566" id="r_aea41e604137d5347ebcd6b82e04ea566"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aea41e604137d5347ebcd6b82e04ea566">la_lapack_s::la_ssyconvf</a> (uplo, way, n, a, lda, e, ipiv, info)</td></tr>
<tr class="memdesc:aea41e604137d5347ebcd6b82e04ea566"><td class="mdescLeft">&#160;</td><td class="mdescRight">If parameter WAY = 'C': SSYCONVF: converts the factorization output format used in SSYTRF provided on entry in parameter A into the factorization output format used in SSYTRF_RK (or SSYTRF_BK) that is stored on exit in parameters A and E. It also converts in place details of the intechanges stored in IPIV from the format used in SSYTRF into the format used in SSYTRF_RK (or SSYTRF_BK). If parameter WAY = 'R': SSYCONVF performs the conversion in reverse direction, i.e. converts the factorization output format used in SSYTRF_RK (or SSYTRF_BK) provided on entry in parameters A and E into the factorization output format used in SSYTRF that is stored on exit in parameter A. It also converts in place details of the intechanges stored in IPIV from the format used in SSYTRF_RK (or SSYTRF_BK) into the format used in SSYTRF.  <br /></td></tr>
<tr class="separator:aea41e604137d5347ebcd6b82e04ea566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6ad09a27880250a2a78d07adbec121" id="r_aeb6ad09a27880250a2a78d07adbec121"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aeb6ad09a27880250a2a78d07adbec121">la_lapack_s::la_ssyconvf_rook</a> (uplo, way, n, a, lda, e, ipiv, info)</td></tr>
<tr class="memdesc:aeb6ad09a27880250a2a78d07adbec121"><td class="mdescLeft">&#160;</td><td class="mdescRight">If parameter WAY = 'C': SSYCONVF_ROOK: converts the factorization output format used in SSYTRF_ROOK provided on entry in parameter A into the factorization output format used in SSYTRF_RK (or SSYTRF_BK) that is stored on exit in parameters A and E. IPIV format for SSYTRF_ROOK and SSYTRF_RK (or SSYTRF_BK) is the same and is not converted. If parameter WAY = 'R': SSYCONVF_ROOK performs the conversion in reverse direction, i.e. converts the factorization output format used in SSYTRF_RK (or SSYTRF_BK) provided on entry in parameters A and E into the factorization output format used in SSYTRF_ROOK that is stored on exit in parameter A. IPIV format for SSYTRF_ROOK and SSYTRF_RK (or SSYTRF_BK) is the same and is not converted.  <br /></td></tr>
<tr class="separator:aeb6ad09a27880250a2a78d07adbec121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f583c695d978ddb885161d3f15e67c" id="r_a99f583c695d978ddb885161d3f15e67c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a99f583c695d978ddb885161d3f15e67c">la_lapack_s::la_ssyequb</a> (uplo, n, a, lda, s, scond, amax, work, info)</td></tr>
<tr class="memdesc:a99f583c695d978ddb885161d3f15e67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEQUB: computes row and column scalings intended to equilibrate a symmetric matrix A (with respect to the Euclidean norm) and reduce its condition number. The scale factors S are computed by the BIN algorithm (see references) so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of the smallest possible condition number over all possible diagonal scalings.  <br /></td></tr>
<tr class="separator:a99f583c695d978ddb885161d3f15e67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37255b1d0699fda9ef2bb0f66ffbda1b" id="r_a37255b1d0699fda9ef2bb0f66ffbda1b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a37255b1d0699fda9ef2bb0f66ffbda1b">la_lapack_s::la_ssygs2</a> (itype, uplo, n, a, lda, b, ldb, info)</td></tr>
<tr class="memdesc:a37255b1d0699fda9ef2bb0f66ffbda1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYGS2: reduces a real symmetric-definite generalized eigenproblem to standard form. If ITYPE = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T) If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T *A*L. B must have been previously factorized as U**T *U or L*L**T by SPOTRF.  <br /></td></tr>
<tr class="separator:a37255b1d0699fda9ef2bb0f66ffbda1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c66603d8a7734d12ca179ee3c5dd38" id="r_a47c66603d8a7734d12ca179ee3c5dd38"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a47c66603d8a7734d12ca179ee3c5dd38">la_lapack_s::la_ssygst</a> (itype, uplo, n, a, lda, b, ldb, info)</td></tr>
<tr class="memdesc:a47c66603d8a7734d12ca179ee3c5dd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYGST: reduces a real symmetric-definite generalized eigenproblem to standard form. If ITYPE = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T) If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L. B must have been previously factorized as U**T*U or L*L**T by SPOTRF.  <br /></td></tr>
<tr class="separator:a47c66603d8a7734d12ca179ee3c5dd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3a68114fb576f0469f94df3c121508" id="r_a9e3a68114fb576f0469f94df3c121508"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9e3a68114fb576f0469f94df3c121508">la_lapack_s::la_ssyswapr</a> (uplo, n, a, lda, i1, i2)</td></tr>
<tr class="memdesc:a9e3a68114fb576f0469f94df3c121508"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYSWAPR: applies an elementary permutation on the rows and the columns of a symmetric matrix.  <br /></td></tr>
<tr class="separator:a9e3a68114fb576f0469f94df3c121508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c026e58aab17c10053b29bf999c2d9" id="r_a31c026e58aab17c10053b29bf999c2d9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a31c026e58aab17c10053b29bf999c2d9">la_lapack_s::la_ssytf2_rk</a> (uplo, n, a, lda, e, ipiv, info)</td></tr>
<tr class="memdesc:a31c026e58aab17c10053b29bf999c2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTF2_RK: computes the factorization of a real symmetric matrix A using the bounded Bunch-Kaufman (rook) diagonal pivoting method: A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T), where U (or L) is unit upper (or lower) triangular matrix, U**T (or L**T) is the transpose of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the unblocked version of the algorithm, calling Level 2 BLAS. For more information see Further Details section.  <br /></td></tr>
<tr class="separator:a31c026e58aab17c10053b29bf999c2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d69369e783031f0d68b34dd94a79834" id="r_a8d69369e783031f0d68b34dd94a79834"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8d69369e783031f0d68b34dd94a79834">la_lapack_s::la_ssytf2_rook</a> (uplo, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:a8d69369e783031f0d68b34dd94a79834"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTF2_ROOK: computes the factorization of a real symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method: A = U*D*U**T or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, U**T is the transpose of U, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:a8d69369e783031f0d68b34dd94a79834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dcfe095251eff4fb3eeff6eb3db5f9" id="r_a37dcfe095251eff4fb3eeff6eb3db5f9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a37dcfe095251eff4fb3eeff6eb3db5f9">la_lapack_s::la_ssytrf_rk</a> (uplo, n, a, lda, e, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:a37dcfe095251eff4fb3eeff6eb3db5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRF_RK: computes the factorization of a real symmetric matrix A using the bounded Bunch-Kaufman (rook) diagonal pivoting method: A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T), where U (or L) is unit upper (or lower) triangular matrix, U**T (or L**T) is the transpose of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the blocked version of the algorithm, calling Level 3 BLAS. For more information see Further Details section.  <br /></td></tr>
<tr class="separator:a37dcfe095251eff4fb3eeff6eb3db5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924dc023316d51a09504295f7565700e" id="r_a924dc023316d51a09504295f7565700e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a924dc023316d51a09504295f7565700e">la_lapack_s::la_ssytrf_rook</a> (uplo, n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:a924dc023316d51a09504295f7565700e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRF_ROOK: computes the factorization of a real symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method. The form of the factorization is A = U*D*U**T or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a924dc023316d51a09504295f7565700e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3bfcd8c32829d9a9b2a5e4cfdd886b" id="r_a4d3bfcd8c32829d9a9b2a5e4cfdd886b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4d3bfcd8c32829d9a9b2a5e4cfdd886b">la_lapack_s::la_ssytri</a> (uplo, n, a, lda, ipiv, work, info)</td></tr>
<tr class="memdesc:a4d3bfcd8c32829d9a9b2a5e4cfdd886b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRI: computes the inverse of a real symmetric indefinite matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by SSYTRF.  <br /></td></tr>
<tr class="separator:a4d3bfcd8c32829d9a9b2a5e4cfdd886b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac014693ceb0aeeaf50fa016f6863af06" id="r_ac014693ceb0aeeaf50fa016f6863af06"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac014693ceb0aeeaf50fa016f6863af06">la_lapack_s::la_ssytri_rook</a> (uplo, n, a, lda, ipiv, work, info)</td></tr>
<tr class="memdesc:ac014693ceb0aeeaf50fa016f6863af06"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRI_ROOK: computes the inverse of a real symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by SSYTRF_ROOK.  <br /></td></tr>
<tr class="separator:ac014693ceb0aeeaf50fa016f6863af06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424b078515fc6a45069bdaf2c6edff4c" id="r_a424b078515fc6a45069bdaf2c6edff4c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a424b078515fc6a45069bdaf2c6edff4c">la_lapack_s::la_ssytrs</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a424b078515fc6a45069bdaf2c6edff4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRS: solves a system of linear equations A*X = B with a real symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by SSYTRF.  <br /></td></tr>
<tr class="separator:a424b078515fc6a45069bdaf2c6edff4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41465ca7b3c7a77c2225cb39142d7a2" id="r_ad41465ca7b3c7a77c2225cb39142d7a2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad41465ca7b3c7a77c2225cb39142d7a2">la_lapack_s::la_ssytrs2</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, info)</td></tr>
<tr class="memdesc:ad41465ca7b3c7a77c2225cb39142d7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRS2: solves a system of linear equations A*X = B with a real symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by SSYTRF and converted by SSYCONV.  <br /></td></tr>
<tr class="separator:ad41465ca7b3c7a77c2225cb39142d7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2909f3201b0e17fe76d1e183c7d6c904" id="r_a2909f3201b0e17fe76d1e183c7d6c904"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2909f3201b0e17fe76d1e183c7d6c904">la_lapack_s::la_ssytrs_3</a> (uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a2909f3201b0e17fe76d1e183c7d6c904"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRS_3: solves a system of linear equations A * X = B with a real symmetric matrix A using the factorization computed by SSYTRF_RK or SSYTRF_BK: A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T), where U (or L) is unit upper (or lower) triangular matrix, U**T (or L**T) is the transpose of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This algorithm is using Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a2909f3201b0e17fe76d1e183c7d6c904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67029eac20ed5256373cf8074730d5a" id="r_ab67029eac20ed5256373cf8074730d5a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab67029eac20ed5256373cf8074730d5a">la_lapack_s::la_ssytrs_aa</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:ab67029eac20ed5256373cf8074730d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRS_AA: solves a system of linear equations A*X = B with a real symmetric matrix A using the factorization A = U**T*T*U or A = L*T*L**T computed by SSYTRF_AA.  <br /></td></tr>
<tr class="separator:ab67029eac20ed5256373cf8074730d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c553a9036dfa3167c15614ab476486" id="r_a84c553a9036dfa3167c15614ab476486"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a84c553a9036dfa3167c15614ab476486">la_lapack_s::la_ssytrs_rook</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a84c553a9036dfa3167c15614ab476486"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRS_ROOK: solves a system of linear equations A*X = B with a real symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by SSYTRF_ROOK.  <br /></td></tr>
<tr class="separator:a84c553a9036dfa3167c15614ab476486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eed92a687b3d2f9755f359a08f670de" id="r_a3eed92a687b3d2f9755f359a08f670de"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3eed92a687b3d2f9755f359a08f670de">la_lapack_s::la_stbrfs</a> (uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:a3eed92a687b3d2f9755f359a08f670de"><td class="mdescLeft">&#160;</td><td class="mdescRight">STBRFS: provides error bounds and backward error estimates for the solution to a system of linear equations with a triangular band coefficient matrix. The solution matrix X must be computed by STBTRS or some other means before entering this routine. STBRFS does not do iterative refinement because doing so cannot improve the backward error.  <br /></td></tr>
<tr class="separator:a3eed92a687b3d2f9755f359a08f670de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3433c02a9daab9978db9335a90b4934" id="r_af3433c02a9daab9978db9335a90b4934"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af3433c02a9daab9978db9335a90b4934">la_lapack_s::la_stbtrs</a> (uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, info)</td></tr>
<tr class="memdesc:af3433c02a9daab9978db9335a90b4934"><td class="mdescLeft">&#160;</td><td class="mdescRight">STBTRS: solves a triangular system of the form A * X = B or A**T * X = B, where A is a triangular band matrix of order N, and B is an N-by NRHS matrix. A check is made to verify that A is nonsingular.  <br /></td></tr>
<tr class="separator:af3433c02a9daab9978db9335a90b4934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43896d2d7a562054297364d471d80d0d" id="r_a43896d2d7a562054297364d471d80d0d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a43896d2d7a562054297364d471d80d0d">la_lapack_s::la_stfsm</a> (transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb)</td></tr>
<tr class="memdesc:a43896d2d7a562054297364d471d80d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level 3 BLAS like routine for A in RFP Format. STFSM: solves the matrix equation op( A )*X = alpha*B or X*op( A ) = alpha*B where alpha is a scalar, X and B are m by n matrices, A is a unit, or non-unit, upper or lower triangular matrix and op( A ) is one of op( A ) = A or op( A ) = A**T. A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.  <br /></td></tr>
<tr class="separator:a43896d2d7a562054297364d471d80d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b7f5a4a0e6f764f002a9ff2a09d00f" id="r_a63b7f5a4a0e6f764f002a9ff2a09d00f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a63b7f5a4a0e6f764f002a9ff2a09d00f">la_lapack_s::la_stfttp</a> (transr, uplo, n, arf, ap, info)</td></tr>
<tr class="memdesc:a63b7f5a4a0e6f764f002a9ff2a09d00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">STFTTP: copies a triangular matrix A from rectangular full packed format (TF) to standard packed format (TP).  <br /></td></tr>
<tr class="separator:a63b7f5a4a0e6f764f002a9ff2a09d00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6cfa9b5fcc7ef8fdb049be07e3556b" id="r_aba6cfa9b5fcc7ef8fdb049be07e3556b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aba6cfa9b5fcc7ef8fdb049be07e3556b">la_lapack_s::la_stfttr</a> (transr, uplo, n, arf, a, lda, info)</td></tr>
<tr class="memdesc:aba6cfa9b5fcc7ef8fdb049be07e3556b"><td class="mdescLeft">&#160;</td><td class="mdescRight">STFTTR: copies a triangular matrix A from rectangular full packed format (TF) to standard full format (TR).  <br /></td></tr>
<tr class="separator:aba6cfa9b5fcc7ef8fdb049be07e3556b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5dcc0b6f70342c48aa1525aa0d0df8" id="r_a3c5dcc0b6f70342c48aa1525aa0d0df8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3c5dcc0b6f70342c48aa1525aa0d0df8">la_lapack_s::la_stprfb</a> (side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork)</td></tr>
<tr class="memdesc:a3c5dcc0b6f70342c48aa1525aa0d0df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPRFB: applies a real "triangular-pentagonal" block reflector H or its conjugate transpose H^H to a real matrix C, which is composed of two blocks A and B, either from the left or right.  <br /></td></tr>
<tr class="separator:a3c5dcc0b6f70342c48aa1525aa0d0df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a9248b7530659c86c71f18319b525a" id="r_a71a9248b7530659c86c71f18319b525a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a71a9248b7530659c86c71f18319b525a">la_lapack_s::la_stprfs</a> (uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:a71a9248b7530659c86c71f18319b525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPRFS: provides error bounds and backward error estimates for the solution to a system of linear equations with a triangular packed coefficient matrix. The solution matrix X must be computed by STPTRS or some other means before entering this routine. STPRFS does not do iterative refinement because doing so cannot improve the backward error.  <br /></td></tr>
<tr class="separator:a71a9248b7530659c86c71f18319b525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4d10c9a354d69ffa30bb43fd2a13a4" id="r_a7f4d10c9a354d69ffa30bb43fd2a13a4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7f4d10c9a354d69ffa30bb43fd2a13a4">la_lapack_s::la_stptri</a> (uplo, diag, n, ap, info)</td></tr>
<tr class="memdesc:a7f4d10c9a354d69ffa30bb43fd2a13a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPTRI: computes the inverse of a real upper or lower triangular matrix A stored in packed format.  <br /></td></tr>
<tr class="separator:a7f4d10c9a354d69ffa30bb43fd2a13a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3116bd04e281963980a0378de849c1" id="r_a7d3116bd04e281963980a0378de849c1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7d3116bd04e281963980a0378de849c1">la_lapack_s::la_stptrs</a> (uplo, trans, diag, n, nrhs, ap, b, ldb, info)</td></tr>
<tr class="memdesc:a7d3116bd04e281963980a0378de849c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPTRS: solves a triangular system of the form A * X = B or A**T * X = B, where A is a triangular matrix of order N stored in packed format, and B is an N-by-NRHS matrix. A check is made to verify that A is nonsingular.  <br /></td></tr>
<tr class="separator:a7d3116bd04e281963980a0378de849c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a5107fc7b5ecdaba0939a4f6bfe38a" id="r_a13a5107fc7b5ecdaba0939a4f6bfe38a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a13a5107fc7b5ecdaba0939a4f6bfe38a">la_lapack_s::la_stpttf</a> (transr, uplo, n, ap, arf, info)</td></tr>
<tr class="memdesc:a13a5107fc7b5ecdaba0939a4f6bfe38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPTTF: copies a triangular matrix A from standard packed format (TP) to rectangular full packed format (TF).  <br /></td></tr>
<tr class="separator:a13a5107fc7b5ecdaba0939a4f6bfe38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f13f6f84489faaf866987f20baa14d7" id="r_a9f13f6f84489faaf866987f20baa14d7"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9f13f6f84489faaf866987f20baa14d7">la_lapack_s::la_stpttr</a> (uplo, n, ap, a, lda, info)</td></tr>
<tr class="memdesc:a9f13f6f84489faaf866987f20baa14d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPTTR: copies a triangular matrix A from standard packed format (TP) to standard full format (TR).  <br /></td></tr>
<tr class="separator:a9f13f6f84489faaf866987f20baa14d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92c1c2398039a0f15f536179dd17211" id="r_ac92c1c2398039a0f15f536179dd17211"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac92c1c2398039a0f15f536179dd17211">la_lapack_s::la_strrfs</a> (uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:ac92c1c2398039a0f15f536179dd17211"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRRFS: provides error bounds and backward error estimates for the solution to a system of linear equations with a triangular coefficient matrix. The solution matrix X must be computed by STRTRS or some other means before entering this routine. STRRFS does not do iterative refinement because doing so cannot improve the backward error.  <br /></td></tr>
<tr class="separator:ac92c1c2398039a0f15f536179dd17211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1825d3e253eed70022be6e45f2e69121" id="r_a1825d3e253eed70022be6e45f2e69121"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1825d3e253eed70022be6e45f2e69121">la_lapack_s::la_strti2</a> (uplo, diag, n, a, lda, info)</td></tr>
<tr class="memdesc:a1825d3e253eed70022be6e45f2e69121"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRTI2: computes the inverse of a real upper or lower triangular matrix. This is the Level 2 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:a1825d3e253eed70022be6e45f2e69121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f079d7d62b337682c03978fa4ea7e7a" id="r_a8f079d7d62b337682c03978fa4ea7e7a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8f079d7d62b337682c03978fa4ea7e7a">la_lapack_s::la_strtri</a> (uplo, diag, n, a, lda, info)</td></tr>
<tr class="memdesc:a8f079d7d62b337682c03978fa4ea7e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRTRI: computes the inverse of a real upper or lower triangular matrix A. This is the Level 3 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:a8f079d7d62b337682c03978fa4ea7e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af445fc9c7e6588a73f335ad49bbaf3e0" id="r_af445fc9c7e6588a73f335ad49bbaf3e0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af445fc9c7e6588a73f335ad49bbaf3e0">la_lapack_s::la_strtrs</a> (uplo, trans, diag, n, nrhs, a, lda, b, ldb, info)</td></tr>
<tr class="memdesc:af445fc9c7e6588a73f335ad49bbaf3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRTRS: solves a triangular system of the form A * X = B or A**T * X = B, where A is a triangular matrix of order N, and B is an N-by-NRHS matrix. A check is made to verify that A is nonsingular.  <br /></td></tr>
<tr class="separator:af445fc9c7e6588a73f335ad49bbaf3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254233d6e2972af88dcb649005589595" id="r_a254233d6e2972af88dcb649005589595"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a254233d6e2972af88dcb649005589595">la_lapack_s::la_strttf</a> (transr, uplo, n, a, lda, arf, info)</td></tr>
<tr class="memdesc:a254233d6e2972af88dcb649005589595"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRTTF: copies a triangular matrix A from standard full format (TR) to rectangular full packed format (TF) .  <br /></td></tr>
<tr class="separator:a254233d6e2972af88dcb649005589595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daa52f0abacd3b142c09de68c20a8c9" id="r_a5daa52f0abacd3b142c09de68c20a8c9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a5daa52f0abacd3b142c09de68c20a8c9">la_lapack_s::la_strttp</a> (uplo, n, a, lda, ap, info)</td></tr>
<tr class="memdesc:a5daa52f0abacd3b142c09de68c20a8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRTTP: copies a triangular matrix A from full format (TR) to standard packed format (TP).  <br /></td></tr>
<tr class="separator:a5daa52f0abacd3b142c09de68c20a8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1f5ba59e82bea7199124279527aaa5" id="r_acb1f5ba59e82bea7199124279527aaa5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#acb1f5ba59e82bea7199124279527aaa5">la_lapack_s::la_sbbcsd</a> (jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork, info)</td></tr>
<tr class="memdesc:acb1f5ba59e82bea7199124279527aaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SBBCSD: computes the CS decomposition of an orthogonal matrix in bidiagonal-block form, [ B11 | B12 0 0 ] [ 0 | 0 -I 0 ] X = [-------------&mdash;] [ B21 | B22 0 0 ] [ 0 | 0 0 I ] [ C | -S 0 0 ] [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**T = [------&mdash;] [------------&mdash;] [------&mdash;] . [ | U2 ] [ S | C 0 0 ] [ | V2 ] [ 0 | 0 0 I ] X is M-by-M, its top-left block is P-by-Q, and Q must be no larger than P, M-P, or M-Q. (If Q is not the smallest index, then X must be transposed and/or permuted. This can be done in constant time using the TRANS and SIGNS options. See SORCSD for details.) The bidiagonal matrices B11, B12, B21, and B22 are represented implicitly by angles THETA(1:Q) and PHI(1:Q-1). The orthogonal matrices U1, U2, V1T, and V2T are input/output. The input matrices are pre- or post-multiplied by the appropriate singular vector matrices.  <br /></td></tr>
<tr class="separator:acb1f5ba59e82bea7199124279527aaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac329abaf40e03b2e8c99ddeeb7ff67cd" id="r_ac329abaf40e03b2e8c99ddeeb7ff67cd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac329abaf40e03b2e8c99ddeeb7ff67cd">la_lapack_s::la_sdisna</a> (job, m, n, d, sep, info)</td></tr>
<tr class="memdesc:ac329abaf40e03b2e8c99ddeeb7ff67cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDISNA: computes the reciprocal condition numbers for the eigenvectors of a real symmetric or complex Hermitian matrix or for the left or right singular vectors of a general m-by-n matrix. The reciprocal condition number is the 'gap' between the corresponding eigenvalue or singular value and the nearest other one. The bound on the error, measured by angle in radians, in the I-th computed vector is given by SLAMCH( 'E' ) * ( ANORM / SEP( I ) ) where ANORM = 2-norm(A) = max( abs( D(j) ) ). SEP(I) is not allowed to be smaller than SLAMCH( 'E' )*ANORM in order to limit the size of the error bound. SDISNA may also be used to compute error bounds for eigenvectors of the generalized symmetric definite eigenproblem.  <br /></td></tr>
<tr class="separator:ac329abaf40e03b2e8c99ddeeb7ff67cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e3f821219b14daeaa0ace711edd0fd" id="r_a30e3f821219b14daeaa0ace711edd0fd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a30e3f821219b14daeaa0ace711edd0fd">la_lapack_s::la_sgbbrd</a> (vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, info)</td></tr>
<tr class="memdesc:a30e3f821219b14daeaa0ace711edd0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBBRD: reduces a real general m-by-n band matrix A to upper bidiagonal form B by an orthogonal transformation: Q**T * A * P = B. The routine computes B, and optionally forms Q or P**T, or computes Q**T*C for a given matrix C.  <br /></td></tr>
<tr class="separator:a30e3f821219b14daeaa0ace711edd0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691b5a25a19f7f6e4446c9af3abd8079" id="r_a691b5a25a19f7f6e4446c9af3abd8079"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a691b5a25a19f7f6e4446c9af3abd8079">la_lapack_s::la_sgbcon</a> (norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a691b5a25a19f7f6e4446c9af3abd8079"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBCON: estimates the reciprocal of the condition number of a real general band matrix A, in either the 1-norm or the infinity-norm, using the LU factorization computed by SGBTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).  <br /></td></tr>
<tr class="separator:a691b5a25a19f7f6e4446c9af3abd8079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc981cb784519e5487f18375b3cdb090" id="r_adc981cb784519e5487f18375b3cdb090"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#adc981cb784519e5487f18375b3cdb090">la_lapack_s::la_sgbequ</a> (m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, info)</td></tr>
<tr class="memdesc:adc981cb784519e5487f18375b3cdb090"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBEQU: computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its condition number. R returns the row scale factors and C the column scale factors, chosen to try to make the largest element in each row and column of the matrix B with elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1. R(i) and C(j) are restricted to be between SMLNUM = smallest safe number and BIGNUM = largest safe number. Use of these scaling factors is not guaranteed to reduce the condition number of A but works well in practice.  <br /></td></tr>
<tr class="separator:adc981cb784519e5487f18375b3cdb090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0aad1033cef8484bc918d5fe6c68115" id="r_ad0aad1033cef8484bc918d5fe6c68115"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad0aad1033cef8484bc918d5fe6c68115">la_lapack_s::la_sgbequb</a> (m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, info)</td></tr>
<tr class="memdesc:ad0aad1033cef8484bc918d5fe6c68115"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBEQUB: computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its condition number. R returns the row scale factors and C the column scale factors, chosen to try to make the largest element in each row and column of the matrix B with elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most the radix. R(i) and C(j) are restricted to be a power of the radix between SMLNUM = smallest safe number and BIGNUM = largest safe number. Use of these scaling factors is not guaranteed to reduce the condition number of A but works well in practice. This routine differs from SGEEQU by restricting the scaling factors to a power of the radix. Barring over- and underflow, scaling by these factors introduces no additional rounding errors. However, the scaled entries' magnitudes are no longer approximately 1 but lie between sqrt(radix) and 1/sqrt(radix).  <br /></td></tr>
<tr class="separator:ad0aad1033cef8484bc918d5fe6c68115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0bc542af8023ac3b2b01fa44b669a3" id="r_a1a0bc542af8023ac3b2b01fa44b669a3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1a0bc542af8023ac3b2b01fa44b669a3">la_lapack_s::la_sgbrfs</a> (trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:a1a0bc542af8023ac3b2b01fa44b669a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBRFS: improves the computed solution to a system of linear equations when the coefficient matrix is banded, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:a1a0bc542af8023ac3b2b01fa44b669a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f5cbf6c3cbdbd87c07730258e690e" id="r_a0d1f5cbf6c3cbdbd87c07730258e690e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0d1f5cbf6c3cbdbd87c07730258e690e">la_lapack_s::la_sgbtrf</a> (m, n, kl, ku, ab, ldab, ipiv, info)</td></tr>
<tr class="memdesc:a0d1f5cbf6c3cbdbd87c07730258e690e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBTRF: computes an LU factorization of a real m-by-n band matrix A using partial pivoting with row interchanges. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a0d1f5cbf6c3cbdbd87c07730258e690e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16461502bb9c41cd14262e865f063051" id="r_a16461502bb9c41cd14262e865f063051"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a16461502bb9c41cd14262e865f063051">la_lapack_s::la_sgecon</a> (norm, n, a, lda, anorm, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a16461502bb9c41cd14262e865f063051"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGECON: estimates the reciprocal of the condition number of a general real matrix A, in either the 1-norm or the infinity-norm, using the LU factorization computed by SGETRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).  <br /></td></tr>
<tr class="separator:a16461502bb9c41cd14262e865f063051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aee7c53e47802d9149de5d4dc4e664d" id="r_a2aee7c53e47802d9149de5d4dc4e664d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2aee7c53e47802d9149de5d4dc4e664d">la_lapack_s::la_sgeequ</a> (m, n, a, lda, r, c, rowcnd, colcnd, amax, info)</td></tr>
<tr class="memdesc:a2aee7c53e47802d9149de5d4dc4e664d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEEQU: computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its condition number. R returns the row scale factors and C the column scale factors, chosen to try to make the largest element in each row and column of the matrix B with elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1. R(i) and C(j) are restricted to be between SMLNUM = smallest safe number and BIGNUM = largest safe number. Use of these scaling factors is not guaranteed to reduce the condition number of A but works well in practice.  <br /></td></tr>
<tr class="separator:a2aee7c53e47802d9149de5d4dc4e664d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ead82d6e2cbc4158250e0a2b3668474" id="r_a5ead82d6e2cbc4158250e0a2b3668474"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a5ead82d6e2cbc4158250e0a2b3668474">la_lapack_s::la_sgeequb</a> (m, n, a, lda, r, c, rowcnd, colcnd, amax, info)</td></tr>
<tr class="memdesc:a5ead82d6e2cbc4158250e0a2b3668474"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEEQUB: computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its condition number. R returns the row scale factors and C the column scale factors, chosen to try to make the largest element in each row and column of the matrix B with elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most the radix. R(i) and C(j) are restricted to be a power of the radix between SMLNUM = smallest safe number and BIGNUM = largest safe number. Use of these scaling factors is not guaranteed to reduce the condition number of A but works well in practice. This routine differs from SGEEQU by restricting the scaling factors to a power of the radix. Barring over- and underflow, scaling by these factors introduces no additional rounding errors. However, the scaled entries' magnitudes are no longer approximately 1 but lie between sqrt(radix) and 1/sqrt(radix).  <br /></td></tr>
<tr class="separator:a5ead82d6e2cbc4158250e0a2b3668474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae960ee808a7063af5a4954b3f218f1a7" id="r_ae960ee808a7063af5a4954b3f218f1a7"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ae960ee808a7063af5a4954b3f218f1a7">la_lapack_s::la_sgemlqt</a> (side, trans, m, n, k, mb, v, ldv, t, ldt, c, ldc, work, info)</td></tr>
<tr class="memdesc:ae960ee808a7063af5a4954b3f218f1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGEMLQT overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q C C Q TRANS = 'T': Q**T C C Q**T where Q is a real orthogonal matrix defined as the product of K elementary reflectors: Q = H(1) H(2) . . . H(K) = I - V T V**T generated using the compact WY representation as returned by SGELQT. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:ae960ee808a7063af5a4954b3f218f1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab129ec78f424543322cf738b841b4a1d" id="r_ab129ec78f424543322cf738b841b4a1d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab129ec78f424543322cf738b841b4a1d">la_lapack_s::la_sgemqrt</a> (side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work, info)</td></tr>
<tr class="memdesc:ab129ec78f424543322cf738b841b4a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEMQRT: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q C C Q TRANS = 'T': Q**T C C Q**T where Q is a real orthogonal matrix defined as the product of K elementary reflectors: Q = H(1) H(2) . . . H(K) = I - V T V**T generated using the compact WY representation as returned by SGEQRT. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:ab129ec78f424543322cf738b841b4a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1b808e204c0ecbd784054f30a6e644" id="r_a8c1b808e204c0ecbd784054f30a6e644"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8c1b808e204c0ecbd784054f30a6e644">la_lapack_s::la_sgesc2</a> (n, a, lda, rhs, ipiv, jpiv, scale)</td></tr>
<tr class="memdesc:a8c1b808e204c0ecbd784054f30a6e644"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGESC2: solves a system of linear equations A * X = scale* RHS with a general N-by-N matrix A using the LU factorization with complete pivoting computed by SGETC2.  <br /></td></tr>
<tr class="separator:a8c1b808e204c0ecbd784054f30a6e644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d7aa2b82a8fb584ccfa86e493ccdc1" id="r_a43d7aa2b82a8fb584ccfa86e493ccdc1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a43d7aa2b82a8fb584ccfa86e493ccdc1">la_lapack_s::la_sgetc2</a> (n, a, lda, ipiv, jpiv, info)</td></tr>
<tr class="memdesc:a43d7aa2b82a8fb584ccfa86e493ccdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETC2: computes an LU factorization with complete pivoting of the n-by-n matrix A. The factorization has the form A = P * L * U * Q, where P and Q are permutation matrices, L is lower triangular with unit diagonal elements and U is upper triangular. This is the Level 2 BLAS algorithm.  <br /></td></tr>
<tr class="separator:a43d7aa2b82a8fb584ccfa86e493ccdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd0b58c4eaade6645954184c7fa77ff" id="r_a2bd0b58c4eaade6645954184c7fa77ff"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2bd0b58c4eaade6645954184c7fa77ff">la_lapack_s::la_sgetf2</a> (m, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:a2bd0b58c4eaade6645954184c7fa77ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETF2: computes an LU factorization of a general m-by-n matrix A using partial pivoting with row interchanges. The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n). This is the right-looking Level 2 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:a2bd0b58c4eaade6645954184c7fa77ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af146ad3e3b1faac7ed8cdf3a6f5ec9c6" id="r_af146ad3e3b1faac7ed8cdf3a6f5ec9c6"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af146ad3e3b1faac7ed8cdf3a6f5ec9c6">la_lapack_s::la_sgetrf2</a> (m, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:af146ad3e3b1faac7ed8cdf3a6f5ec9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETRF2: computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n). This is the recursive version of the algorithm. It divides the matrix into four submatrices: [ A11 | A12 ] where A11 is n1 by n1 and A22 is n2 by n2 A = [ --&mdash;|--&mdash; ] with n1 = min(m,n)/2 [ A21 | A22 ] n2 = n-n1 [ A11 ] The subroutine calls itself to factor [ &mdash; ], [ A12 ] [ A12 ] do the swaps on [ &mdash; ], solve A12, update A22, [ A22 ] then calls itself to factor A22 and do the swaps on A21.  <br /></td></tr>
<tr class="separator:af146ad3e3b1faac7ed8cdf3a6f5ec9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ff0c677d715119fa74d5470845421a" id="r_aa4ff0c677d715119fa74d5470845421a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa4ff0c677d715119fa74d5470845421a">la_lapack_s::la_sgetri</a> (n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:aa4ff0c677d715119fa74d5470845421a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETRI: computes the inverse of a matrix using the LU factorization computed by SGETRF. This method inverts U and then computes inv(A) by solving the system inv(A)*L = inv(U) for inv(A).  <br /></td></tr>
<tr class="separator:aa4ff0c677d715119fa74d5470845421a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d34fe45d34864828857d33f89e8498d" id="r_a7d34fe45d34864828857d33f89e8498d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7d34fe45d34864828857d33f89e8498d">la_lapack_s::la_sgetrs</a> (trans, n, nrhs, a, lda, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a7d34fe45d34864828857d33f89e8498d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETRS: solves a system of linear equations A * X = B or A**T * X = B with a general N-by-N matrix A using the LU factorization computed by SGETRF.  <br /></td></tr>
<tr class="separator:a7d34fe45d34864828857d33f89e8498d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba86deeb280f023a8577473fd9811d5" id="r_a3ba86deeb280f023a8577473fd9811d5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3ba86deeb280f023a8577473fd9811d5">la_lapack_s::la_sggbal</a> (job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work, info)</td></tr>
<tr class="memdesc:a3ba86deeb280f023a8577473fd9811d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGBAL: balances a pair of general real matrices (A,B). This involves, first, permuting A and B by similarity transformations to isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N elements on the diagonal; and second, applying a diagonal similarity transformation to rows and columns ILO to IHI to make the rows and columns as close in norm as possible. Both steps are optional. Balancing may reduce the 1-norm of the matrices, and improve the accuracy of the computed eigenvalues and/or eigenvectors in the generalized eigenvalue problem A*x = lambda*B*x.  <br /></td></tr>
<tr class="separator:a3ba86deeb280f023a8577473fd9811d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba31ecd524f8a1f3159b0119df14559b" id="r_aba31ecd524f8a1f3159b0119df14559b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aba31ecd524f8a1f3159b0119df14559b">la_lapack_s::la_sgghrd</a> (compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, info)</td></tr>
<tr class="memdesc:aba31ecd524f8a1f3159b0119df14559b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGHRD: reduces a pair of real matrices (A,B) to generalized upper Hessenberg form using orthogonal transformations, where A is a general matrix and B is upper triangular. The form of the generalized eigenvalue problem is A*x = lambda*B*x, and B is typically made upper triangular by computing its QR factorization and moving the orthogonal matrix Q to the left side of the equation. This subroutine simultaneously reduces A to a Hessenberg matrix H: Q**T*A*Z = H and transforms B to another upper triangular matrix T: Q**T*B*Z = T in order to reduce the problem to its standard form H*y = lambda*T*y where y = Z**T*x. The orthogonal matrices Q and Z are determined as products of Givens rotations. They may either be formed explicitly, or they may be postmultiplied into input matrices Q1 and Z1, so that Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T If Q1 is the orthogonal matrix from the QR factorization of B in the original equation A*x = lambda*B*x, then SGGHRD reduces the original problem to generalized Hessenberg form.  <br /></td></tr>
<tr class="separator:aba31ecd524f8a1f3159b0119df14559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992250d92f6d8ca4bacfbe5c7ec6dad8" id="r_a992250d92f6d8ca4bacfbe5c7ec6dad8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a992250d92f6d8ca4bacfbe5c7ec6dad8">la_lapack_s::la_sgttrs</a> (trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a992250d92f6d8ca4bacfbe5c7ec6dad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGTTRS: solves one of the systems of equations A*X = B or A**T*X = B, with a tridiagonal matrix A using the LU factorization computed by SGTTRF.  <br /></td></tr>
<tr class="separator:a992250d92f6d8ca4bacfbe5c7ec6dad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d4b806648873f614d26ba3f9d00512" id="r_af8d4b806648873f614d26ba3f9d00512"><td class="memItemLeft" align="right" valign="top">pure logical(<a class="el" href="namespacela__constants.html#ab69b1529685742074aaa0fa65f97a084">lk</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af8d4b806648873f614d26ba3f9d00512">la_lapack_s::la_sisnan</a> (sin)</td></tr>
<tr class="memdesc:af8d4b806648873f614d26ba3f9d00512"><td class="mdescLeft">&#160;</td><td class="mdescRight">SISNAN: returns .TRUE. if its argument is NaN, and .FALSE. otherwise. To be replaced by the Fortran 2003 intrinsic in the future.  <br /></td></tr>
<tr class="separator:af8d4b806648873f614d26ba3f9d00512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8424012f04b0c29b848bcdadbb33d7c2" id="r_a8424012f04b0c29b848bcdadbb33d7c2"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8424012f04b0c29b848bcdadbb33d7c2">la_lapack_s::la_sla_gbamv</a> (trans, m, n, kl, ku, alpha, ab, ldab, x, incx, beta, y, incy)</td></tr>
<tr class="memdesc:a8424012f04b0c29b848bcdadbb33d7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_GBAMV: performs one of the matrix-vector operations y := alpha*abs(A)*abs(x) + beta*abs(y), or y := alpha*abs(A)**T*abs(x) + beta*abs(y), where alpha and beta are scalars, x and y are vectors and A is an m by n matrix. This function is primarily used in calculating error bounds. To protect against underflow during evaluation, components in the resulting vector are perturbed away from zero by (N+1) times the underflow threshold. To prevent unnecessarily large errors for block-structure embedded in general matrices, "symbolically" zero components are not perturbed. A zero entry is considered "symbolic" if all multiplications involved in computing that entry have at least one zero multiplicand.  <br /></td></tr>
<tr class="separator:a8424012f04b0c29b848bcdadbb33d7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac93208239085af4f5cdd694f3446fe5" id="r_aac93208239085af4f5cdd694f3446fe5"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aac93208239085af4f5cdd694f3446fe5">la_lapack_s::la_sla_gbrcond</a> (trans, n, kl, ku, ab, ldab, afb, ldafb, ipiv, cmode, c, info, work, iwork)</td></tr>
<tr class="memdesc:aac93208239085af4f5cdd694f3446fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_GBRCOND: Estimates the Skeel condition number of op(A) * op2(C) where op2 is determined by CMODE as follows CMODE = 1 op2(C) = C CMODE = 0 op2(C) = I CMODE = -1 op2(C) = inv(C) The Skeel condition number cond(A) = norminf( |inv(A)||A| ) is computed by computing scaling factors R such that diag(R)*A*op2(C) is row equilibrated and computing the standard infinity-norm condition number.  <br /></td></tr>
<tr class="separator:aac93208239085af4f5cdd694f3446fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee1ce9a016ad460b0a07092087d83c7" id="r_a9ee1ce9a016ad460b0a07092087d83c7"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9ee1ce9a016ad460b0a07092087d83c7">la_lapack_s::la_sla_geamv</a> (trans, m, n, alpha, a, lda, x, incx, beta, y, incy)</td></tr>
<tr class="memdesc:a9ee1ce9a016ad460b0a07092087d83c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_GEAMV: performs one of the matrix-vector operations y := alpha*abs(A)*abs(x) + beta*abs(y), or y := alpha*abs(A)**T*abs(x) + beta*abs(y), where alpha and beta are scalars, x and y are vectors and A is an m by n matrix. This function is primarily used in calculating error bounds. To protect against underflow during evaluation, components in the resulting vector are perturbed away from zero by (N+1) times the underflow threshold. To prevent unnecessarily large errors for block-structure embedded in general matrices, "symbolically" zero components are not perturbed. A zero entry is considered "symbolic" if all multiplications involved in computing that entry have at least one zero multiplicand.  <br /></td></tr>
<tr class="separator:a9ee1ce9a016ad460b0a07092087d83c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf09d8f3d1e8ecdd268b04cbb56cbdf9" id="r_acf09d8f3d1e8ecdd268b04cbb56cbdf9"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#acf09d8f3d1e8ecdd268b04cbb56cbdf9">la_lapack_s::la_sla_gercond</a> (trans, n, a, lda, af, ldaf, ipiv, cmode, c, info, work, iwork)</td></tr>
<tr class="memdesc:acf09d8f3d1e8ecdd268b04cbb56cbdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_GERCOND: estimates the Skeel condition number of op(A) * op2(C) where op2 is determined by CMODE as follows CMODE = 1 op2(C) = C CMODE = 0 op2(C) = I CMODE = -1 op2(C) = inv(C) The Skeel condition number cond(A) = norminf( |inv(A)||A| ) is computed by computing scaling factors R such that diag(R)*A*op2(C) is row equilibrated and computing the standard infinity-norm condition number.  <br /></td></tr>
<tr class="separator:acf09d8f3d1e8ecdd268b04cbb56cbdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e29dd6dfce326b6bb8649bdc470b122" id="r_a9e29dd6dfce326b6bb8649bdc470b122"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9e29dd6dfce326b6bb8649bdc470b122">la_lapack_s::la_sla_lin_berr</a> (n, nz, nrhs, res, ayb, berr)</td></tr>
<tr class="memdesc:a9e29dd6dfce326b6bb8649bdc470b122"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_LIN_BERR: computes componentwise relative backward error from the formula max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) ) where abs(Z) is the componentwise absolute value of the matrix or vector Z.  <br /></td></tr>
<tr class="separator:a9e29dd6dfce326b6bb8649bdc470b122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e399eee6ea1a17eeb4006cadc8b62b" id="r_a72e399eee6ea1a17eeb4006cadc8b62b"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a72e399eee6ea1a17eeb4006cadc8b62b">la_lapack_s::la_sla_porcond</a> (uplo, n, a, lda, af, ldaf, cmode, c, info, work, iwork)</td></tr>
<tr class="memdesc:a72e399eee6ea1a17eeb4006cadc8b62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_PORCOND: Estimates the Skeel condition number of op(A) * op2(C) where op2 is determined by CMODE as follows CMODE = 1 op2(C) = C CMODE = 0 op2(C) = I CMODE = -1 op2(C) = inv(C) The Skeel condition number cond(A) = norminf( |inv(A)||A| ) is computed by computing scaling factors R such that diag(R)*A*op2(C) is row equilibrated and computing the standard infinity-norm condition number.  <br /></td></tr>
<tr class="separator:a72e399eee6ea1a17eeb4006cadc8b62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3847e3390c4c9c20c6d4a5f4d217bd50" id="r_a3847e3390c4c9c20c6d4a5f4d217bd50"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3847e3390c4c9c20c6d4a5f4d217bd50">la_lapack_s::la_sla_syamv</a> (uplo, n, alpha, a, lda, x, incx, beta, y, incy)</td></tr>
<tr class="memdesc:a3847e3390c4c9c20c6d4a5f4d217bd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_SYAMV: performs the matrix-vector operation y := alpha*abs(A)*abs(x) + beta*abs(y), where alpha and beta are scalars, x and y are vectors and A is an n by n symmetric matrix. This function is primarily used in calculating error bounds. To protect against underflow during evaluation, components in the resulting vector are perturbed away from zero by (N+1) times the underflow threshold. To prevent unnecessarily large errors for block-structure embedded in general matrices, "symbolically" zero components are not perturbed. A zero entry is considered "symbolic" if all multiplications involved in computing that entry have at least one zero multiplicand.  <br /></td></tr>
<tr class="separator:a3847e3390c4c9c20c6d4a5f4d217bd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca7850aba22b800d477bab2b1578df7" id="r_a7ca7850aba22b800d477bab2b1578df7"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7ca7850aba22b800d477bab2b1578df7">la_lapack_s::la_sla_syrcond</a> (uplo, n, a, lda, af, ldaf, ipiv, cmode, c, info, work, iwork)</td></tr>
<tr class="memdesc:a7ca7850aba22b800d477bab2b1578df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_SYRCOND: estimates the Skeel condition number of op(A) * op2(C) where op2 is determined by CMODE as follows CMODE = 1 op2(C) = C CMODE = 0 op2(C) = I CMODE = -1 op2(C) = inv(C) The Skeel condition number cond(A) = norminf( |inv(A)||A| ) is computed by computing scaling factors R such that diag(R)*A*op2(C) is row equilibrated and computing the standard infinity-norm condition number.  <br /></td></tr>
<tr class="separator:a7ca7850aba22b800d477bab2b1578df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae229706023abc9c5e6eb31c7252c2472" id="r_ae229706023abc9c5e6eb31c7252c2472"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ae229706023abc9c5e6eb31c7252c2472">la_lapack_s::la_sla_syrpvgrw</a> (uplo, n, info, a, lda, af, ldaf, ipiv, work)</td></tr>
<tr class="memdesc:ae229706023abc9c5e6eb31c7252c2472"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_SYRPVGRW: computes the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If this is much less than 1, the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, estimated condition numbers, and error bounds could be unreliable.  <br /></td></tr>
<tr class="separator:ae229706023abc9c5e6eb31c7252c2472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ab950f8fe8695b02b6f6f53d8168cf" id="r_ac9ab950f8fe8695b02b6f6f53d8168cf"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac9ab950f8fe8695b02b6f6f53d8168cf">la_lapack_s::la_sladiv1</a> (a, b, c, d, p, q)</td></tr>
<tr class="separator:ac9ab950f8fe8695b02b6f6f53d8168cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8369147b8a7d4d5275d52e88a57166" id="r_acb8369147b8a7d4d5275d52e88a57166"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#acb8369147b8a7d4d5275d52e88a57166">la_lapack_s::la_slaed6</a> (kniter, orgati, rho, d, z, finit, tau, info)</td></tr>
<tr class="memdesc:acb8369147b8a7d4d5275d52e88a57166"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAED6: computes the positive or negative root (closest to the origin) of z(1) z(2) z(3) f(x) = rho + ------&mdash; + -------&mdash; + ------&mdash; d(1)-x d(2)-x d(3)-x It is assumed that if ORGATI = .true. the root is between d(2) and d(3); otherwise it is between d(1) and d(2) This routine will be called by SLAED4 when necessary. In most cases, the root sought is the smallest in magnitude, though it might not be in some extremely rare situations.  <br /></td></tr>
<tr class="separator:acb8369147b8a7d4d5275d52e88a57166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0f54424bf91a63b1e27bd4bcbd7a67" id="r_a3b0f54424bf91a63b1e27bd4bcbd7a67"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3b0f54424bf91a63b1e27bd4bcbd7a67">la_lapack_s::la_slags2</a> (upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, snv, csq, snq)</td></tr>
<tr class="memdesc:a3b0f54424bf91a63b1e27bd4bcbd7a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAGS2: computes 2-by-2 orthogonal matrices U, V and Q, such that if ( UPPER ) then U**T <em>A*Q = U**T *( A1 A2 )*Q = ( x 0 ) ( 0 A3 ) ( x x ) and V**T*B*Q = V**T *( B1 B2 )*Q = ( x 0 ) ( 0 B3 ) ( x x ) or if ( .NOT.UPPER ) then U**T *A*Q = U**T *( A1 0 )*Q = ( x x ) ( A2 A3 ) ( 0 x ) and V**T*B*Q = V**T</em>( B1 0 )*Q = ( x x ) ( B2 B3 ) ( 0 x ) The rows of the transformed A and B are parallel, where U = ( CSU SNU ), V = ( CSV SNV ), Q = ( CSQ SNQ ) ( -SNU CSU ) ( -SNV CSV ) ( -SNQ CSQ ) Z**T denotes the transpose of Z.  <br /></td></tr>
<tr class="separator:a3b0f54424bf91a63b1e27bd4bcbd7a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90117112a05000381a9427dca297f1e3" id="r_a90117112a05000381a9427dca297f1e3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a90117112a05000381a9427dca297f1e3">la_lapack_s::la_slagtf</a> (n, a, lambda, b, c, tol, d, in, info)</td></tr>
<tr class="memdesc:a90117112a05000381a9427dca297f1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAGTF: factorizes the matrix (T - lambda*I), where T is an n by n tridiagonal matrix and lambda is a scalar, as T - lambda*I = PLU, where P is a permutation matrix, L is a unit lower tridiagonal matrix with at most one non-zero sub-diagonal elements per column and U is an upper triangular matrix with at most two non-zero super-diagonal elements per column. The factorization is obtained by Gaussian elimination with partial pivoting and implicit row scaling. The parameter LAMBDA is included in the routine so that SLAGTF may be used, in conjunction with SLAGTS, to obtain eigenvectors of T by inverse iteration.  <br /></td></tr>
<tr class="separator:a90117112a05000381a9427dca297f1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53929632d0c0a3cd847f244a8e5b6400" id="r_a53929632d0c0a3cd847f244a8e5b6400"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a53929632d0c0a3cd847f244a8e5b6400">la_lapack_s::la_slagts</a> (job, n, a, b, c, d, in, y, tol, info)</td></tr>
<tr class="memdesc:a53929632d0c0a3cd847f244a8e5b6400"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAGTS: may be used to solve one of the systems of equations (T - lambda*I)*x = y or (T - lambda*I)**T*x = y, where T is an n by n tridiagonal matrix, for x, following the factorization of (T - lambda*I) as (T - lambda*I) = P*L*U , by routine SLAGTF. The choice of equation to be solved is controlled by the argument JOB, and in each case there is an option to perturb zero or very small diagonal elements of U, this option being intended for use in applications such as inverse iteration.  <br /></td></tr>
<tr class="separator:a53929632d0c0a3cd847f244a8e5b6400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8c0349487599bdb5bf05e1bf51fdc3" id="r_aff8c0349487599bdb5bf05e1bf51fdc3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aff8c0349487599bdb5bf05e1bf51fdc3">la_lapack_s::la_slaic1</a> (job, j, x, sest, w, gamma, sestpr, s, c)</td></tr>
<tr class="memdesc:aff8c0349487599bdb5bf05e1bf51fdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAIC1: applies one step of incremental condition estimation in its simplest version: Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j lower triangular matrix L, such that twonorm(L*x) = sest Then SLAIC1 computes sestpr, s, c such that the vector [ s*x ] xhat = [ c ] is an approximate singular vector of [ L 0 ] Lhat = [ w**T gamma ] in the sense that twonorm(Lhat*xhat) = sestpr. Depending on JOB, an estimate for the largest or smallest singular value is computed. Note that [s c]**T and sestpr**2 is an eigenpair of the system diag(sest*sest, 0) + [alpha gamma] * [ alpha ] [ gamma ] where alpha = x**T*w.  <br /></td></tr>
<tr class="separator:aff8c0349487599bdb5bf05e1bf51fdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaea1672dc87c7003f60023e7d793892" id="r_adaea1672dc87c7003f60023e7d793892"><td class="memItemLeft" align="right" valign="top">pure integer(<a class="el" href="namespacela__constants.html#a855ee4571ad1f4065aca0717ce55fd0f">ilp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#adaea1672dc87c7003f60023e7d793892">la_lapack_s::la_slaneg</a> (n, d, lld, sigma, pivmin, r)</td></tr>
<tr class="memdesc:adaea1672dc87c7003f60023e7d793892"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANEG: computes the Sturm count, the number of negative pivots encountered while factoring tridiagonal T - sigma I = L D L^T. This implementation works directly on the factors without forming the tridiagonal matrix T. The Sturm count is also the number of eigenvalues of T less than sigma. This routine is called from SLARRB. The current routine does not use the PIVMIN parameter but rather requires IEEE-754 propagation of Infinities and NaNs. This routine also has no input range restrictions but does require default exception handling such that x/0 produces Inf when x is non-zero, and Inf/Inf produces NaN. For more information, see: Marques, Riedy, and Voemel, "Benefits of IEEE-754 Features in
 Modern Symmetric Tridiagonal Eigensolvers," SIAM Journal on Scientific Computing, v28, n5, 2006. DOI 10.1137/050641624 (Tech report version in LAWN 172 with the same title.)  <br /></td></tr>
<tr class="separator:adaea1672dc87c7003f60023e7d793892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353bfd9fb23298734c63bf8be6b937ea" id="r_a353bfd9fb23298734c63bf8be6b937ea"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a353bfd9fb23298734c63bf8be6b937ea">la_lapack_s::la_slangb</a> (norm, n, kl, ku, ab, ldab, work)</td></tr>
<tr class="memdesc:a353bfd9fb23298734c63bf8be6b937ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANGB: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of an n by n band matrix A, with kl sub-diagonals and ku super-diagonals.  <br /></td></tr>
<tr class="separator:a353bfd9fb23298734c63bf8be6b937ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d33585c4db87678755acf014fcfa1d" id="r_a83d33585c4db87678755acf014fcfa1d"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a83d33585c4db87678755acf014fcfa1d">la_lapack_s::la_slange</a> (norm, m, n, a, lda, work)</td></tr>
<tr class="memdesc:a83d33585c4db87678755acf014fcfa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANGE: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real matrix A.  <br /></td></tr>
<tr class="separator:a83d33585c4db87678755acf014fcfa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02812f67c9cf2487562e34a10314dfe6" id="r_a02812f67c9cf2487562e34a10314dfe6"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a02812f67c9cf2487562e34a10314dfe6">la_lapack_s::la_slangt</a> (norm, n, dl, d, du)</td></tr>
<tr class="memdesc:a02812f67c9cf2487562e34a10314dfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANGT: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real tridiagonal matrix A.  <br /></td></tr>
<tr class="separator:a02812f67c9cf2487562e34a10314dfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e30f65ee3fb67fa3ac7d2eebbf26ca2" id="r_a9e30f65ee3fb67fa3ac7d2eebbf26ca2"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9e30f65ee3fb67fa3ac7d2eebbf26ca2">la_lapack_s::la_slanhs</a> (norm, n, a, lda, work)</td></tr>
<tr class="memdesc:a9e30f65ee3fb67fa3ac7d2eebbf26ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANHS: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a Hessenberg matrix A.  <br /></td></tr>
<tr class="separator:a9e30f65ee3fb67fa3ac7d2eebbf26ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b74c83548fe999d993f6dd81fbdd6ff" id="r_a8b74c83548fe999d993f6dd81fbdd6ff"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8b74c83548fe999d993f6dd81fbdd6ff">la_lapack_s::la_slansb</a> (norm, uplo, n, k, ab, ldab, work)</td></tr>
<tr class="memdesc:a8b74c83548fe999d993f6dd81fbdd6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANSB: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of an n by n symmetric band matrix A, with k super-diagonals.  <br /></td></tr>
<tr class="separator:a8b74c83548fe999d993f6dd81fbdd6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975ef8acb6482b58a07a46b5b4b53fcb" id="r_a975ef8acb6482b58a07a46b5b4b53fcb"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a975ef8acb6482b58a07a46b5b4b53fcb">la_lapack_s::la_slansf</a> (norm, transr, uplo, n, a, work)</td></tr>
<tr class="memdesc:a975ef8acb6482b58a07a46b5b4b53fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANSF: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real symmetric matrix A in RFP format.  <br /></td></tr>
<tr class="separator:a975ef8acb6482b58a07a46b5b4b53fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3501d72356f7d50b8a7aaa993b6f197a" id="r_a3501d72356f7d50b8a7aaa993b6f197a"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3501d72356f7d50b8a7aaa993b6f197a">la_lapack_s::la_slansp</a> (norm, uplo, n, ap, work)</td></tr>
<tr class="memdesc:a3501d72356f7d50b8a7aaa993b6f197a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANSP: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real symmetric matrix A, supplied in packed form.  <br /></td></tr>
<tr class="separator:a3501d72356f7d50b8a7aaa993b6f197a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65960283d55ea3ff6efa385dcd72354" id="r_ad65960283d55ea3ff6efa385dcd72354"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad65960283d55ea3ff6efa385dcd72354">la_lapack_s::la_slanst</a> (norm, n, d, e)</td></tr>
<tr class="memdesc:ad65960283d55ea3ff6efa385dcd72354"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANST: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real symmetric tridiagonal matrix A.  <br /></td></tr>
<tr class="separator:ad65960283d55ea3ff6efa385dcd72354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df53676956015e94db9644594894c0a" id="r_a9df53676956015e94db9644594894c0a"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9df53676956015e94db9644594894c0a">la_lapack_s::la_slansy</a> (norm, uplo, n, a, lda, work)</td></tr>
<tr class="memdesc:a9df53676956015e94db9644594894c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANSY: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real symmetric matrix A.  <br /></td></tr>
<tr class="separator:a9df53676956015e94db9644594894c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8dba4fdb90668e621166ed11291c63" id="r_a4c8dba4fdb90668e621166ed11291c63"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4c8dba4fdb90668e621166ed11291c63">la_lapack_s::la_slantb</a> (norm, uplo, diag, n, k, ab, ldab, work)</td></tr>
<tr class="memdesc:a4c8dba4fdb90668e621166ed11291c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANTB: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of an n by n triangular band matrix A, with ( k + 1 ) diagonals.  <br /></td></tr>
<tr class="separator:a4c8dba4fdb90668e621166ed11291c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a7fa0f549ac471655d79552bf3365c" id="r_ac5a7fa0f549ac471655d79552bf3365c"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac5a7fa0f549ac471655d79552bf3365c">la_lapack_s::la_slantp</a> (norm, uplo, diag, n, ap, work)</td></tr>
<tr class="memdesc:ac5a7fa0f549ac471655d79552bf3365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANTP: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a triangular matrix A, supplied in packed form.  <br /></td></tr>
<tr class="separator:ac5a7fa0f549ac471655d79552bf3365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bada3fedb8efd1af250730afea5e073" id="r_a3bada3fedb8efd1af250730afea5e073"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3bada3fedb8efd1af250730afea5e073">la_lapack_s::la_slantr</a> (norm, uplo, diag, m, n, a, lda, work)</td></tr>
<tr class="memdesc:a3bada3fedb8efd1af250730afea5e073"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANTR: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a trapezoidal or triangular matrix A.  <br /></td></tr>
<tr class="separator:a3bada3fedb8efd1af250730afea5e073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0e034d216518ad02f6de070555524e" id="r_a8a0e034d216518ad02f6de070555524e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8a0e034d216518ad02f6de070555524e">la_lapack_s::la_slaorhr_col_getrfnp</a> (m, n, a, lda, d, info)</td></tr>
<tr class="memdesc:a8a0e034d216518ad02f6de070555524e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAORHR_COL_GETRFNP: computes the modified LU factorization without pivoting of a real general M-by-N matrix A. The factorization has the form: A - S = L * U, where: S is a m-by-n diagonal sign matrix with the diagonal D, so that D(i) = S(i,i), 1 &lt;= i &lt;= min(M,N). The diagonal D is constructed as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing i-1 steps of Gaussian elimination. This means that the diagonal element at each step of "modified" Gaussian elimination is at least one in absolute value (so that division-by-zero not not possible during the division by the diagonal element); L is a M-by-N lower triangular matrix with unit diagonal elements (lower trapezoidal if M &gt; N); and U is a M-by-N upper triangular matrix (upper trapezoidal if M &lt; N). This routine is an auxiliary routine used in the Householder reconstruction routine SORHR_COL. In SORHR_COL, this routine is applied to an M-by-N matrix A with orthonormal columns, where each element is bounded by one in absolute value. With the choice of the matrix S above, one can show that the diagonal element at each step of Gaussian elimination is the largest (in absolute value) in the column on or below the diagonal, so that no pivoting is required for numerical stability [1]. For more details on the Householder reconstruction algorithm, including the modified LU factorization, see [1]. This is the blocked right-looking version of the algorithm, calling Level 3 BLAS to update the submatrix. To factorize a block, this routine calls the recursive routine SLAORHR_COL_GETRFNP2. [1] "Reconstructing Householder vectors from tall-skinny QR", G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen, E. Solomonik, J. Parallel Distrib. Comput., vol. 85, pp. 3-31, 2015.  <br /></td></tr>
<tr class="separator:a8a0e034d216518ad02f6de070555524e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e70d6d165ba95d10e4f8592c02475c7" id="r_a9e70d6d165ba95d10e4f8592c02475c7"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9e70d6d165ba95d10e4f8592c02475c7">la_lapack_s::la_slapy2</a> (x, y)</td></tr>
<tr class="memdesc:a9e70d6d165ba95d10e4f8592c02475c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAPY2: returns sqrt(x**2+y**2), taking care not to cause unnecessary overflow and unnecessary underflow.  <br /></td></tr>
<tr class="separator:a9e70d6d165ba95d10e4f8592c02475c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2a1fa139ac5f6c44679d45728fdfa5" id="r_a9e2a1fa139ac5f6c44679d45728fdfa5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9e2a1fa139ac5f6c44679d45728fdfa5">la_lapack_s::la_slaqz1</a> (a, lda, b, ldb, sr1, sr2, si, beta1, beta2, v)</td></tr>
<tr class="memdesc:a9e2a1fa139ac5f6c44679d45728fdfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a 3-by-3 matrix pencil (A,B), SLAQZ1: sets v to a scalar multiple of the first column of the product (*) K = (A - (beta2*sr2 - i*si)*B)*B^(-1)*(beta1*A - (sr2 + i*si2)*B)*B^(-1). It is assumed that either 1) sr1 = sr2 or 2) si = 0. This is useful for starting double implicit shift bulges in the QZ algorithm.  <br /></td></tr>
<tr class="separator:a9e2a1fa139ac5f6c44679d45728fdfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797870e2f487fe93c3a16444c8cebf3d" id="r_a797870e2f487fe93c3a16444c8cebf3d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a797870e2f487fe93c3a16444c8cebf3d">la_lapack_s::la_slaqz2</a> (ilq, ilz, k, istartm, istopm, ihi, a, lda, b, ldb, nq, qstart, q, ldq, nz, zstart, z, ldz)</td></tr>
<tr class="memdesc:a797870e2f487fe93c3a16444c8cebf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQZ2: chases a 2x2 shift bulge in a matrix pencil down a single position.  <br /></td></tr>
<tr class="separator:a797870e2f487fe93c3a16444c8cebf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba72d16f109a099679688f1dfe0b8cc" id="r_acba72d16f109a099679688f1dfe0b8cc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#acba72d16f109a099679688f1dfe0b8cc">la_lapack_s::la_slaqz4</a> (ilschur, ilq, ilz, n, ilo, ihi, nshifts, nblock_desired, sr, si, ss, a, lda, b, ldb, q, ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork, info)</td></tr>
<tr class="memdesc:acba72d16f109a099679688f1dfe0b8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQZ4: Executes a single multishift QZ sweep.  <br /></td></tr>
<tr class="separator:acba72d16f109a099679688f1dfe0b8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506545a813ce44f0242d7edf233d4e74" id="r_a506545a813ce44f0242d7edf233d4e74"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a506545a813ce44f0242d7edf233d4e74">la_lapack_s::la_slar1v</a> (n, b1, bn, lambda, d, l, ld, lld, pivmin, gaptol, z, wantnc, negcnt, ztz, mingma, r, isuppz, nrminv, resid, rqcorr, work)</td></tr>
<tr class="memdesc:a506545a813ce44f0242d7edf233d4e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAR1V: computes the (scaled) r-th column of the inverse of the sumbmatrix in rows B1 through BN of the tridiagonal matrix L D L**T - sigma I. When sigma is close to an eigenvalue, the computed vector is an accurate eigenvector. Usually, r corresponds to the index where the eigenvector is largest in magnitude. The following steps accomplish this computation : (a) Stationary qd transform, L D L**T - sigma I = L(+) D(+) L(+)**T, (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T, (c) Computation of the diagonal elements of the inverse of L D L**T - sigma I by combining the above transforms, and choosing r as the index where the diagonal of the inverse is (one of the) largest in magnitude. (d) Computation of the (scaled) r-th column of the inverse using the twisted factorization obtained by combining the top part of the the stationary and the bottom part of the progressive transform.  <br /></td></tr>
<tr class="separator:a506545a813ce44f0242d7edf233d4e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abfbd65886bc302a2f9526f8de41388" id="r_a7abfbd65886bc302a2f9526f8de41388"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7abfbd65886bc302a2f9526f8de41388">la_lapack_s::la_slarfg</a> (n, alpha, x, incx, tau)</td></tr>
<tr class="memdesc:a7abfbd65886bc302a2f9526f8de41388"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARFG: generates a real elementary reflector H of order n, such that H * ( alpha ) = ( beta ), H**T * H = I. ( x ) ( 0 ) where alpha and beta are scalars, and x is an (n-1)-element real vector. H is represented in the form H = I - tau * ( 1 ) * ( 1 v**T ) , ( v ) where tau is a real scalar and v is a real (n-1)-element vector. If the elements of x are all zero, then tau = 0 and H is taken to be the unit matrix. Otherwise 1 &lt;= tau &lt;= 2.  <br /></td></tr>
<tr class="separator:a7abfbd65886bc302a2f9526f8de41388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715453b9a55a7e212287986b22e5f960" id="r_a715453b9a55a7e212287986b22e5f960"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a715453b9a55a7e212287986b22e5f960">la_lapack_s::la_slarfgp</a> (n, alpha, x, incx, tau)</td></tr>
<tr class="memdesc:a715453b9a55a7e212287986b22e5f960"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARFGP: generates a real elementary reflector H of order n, such that H * ( alpha ) = ( beta ), H**T * H = I. ( x ) ( 0 ) where alpha and beta are scalars, beta is non-negative, and x is an (n-1)-element real vector. H is represented in the form H = I - tau * ( 1 ) * ( 1 v**T ) , ( v ) where tau is a real scalar and v is a real (n-1)-element vector. If the elements of x are all zero, then tau = 0 and H is taken to be the unit matrix.  <br /></td></tr>
<tr class="separator:a715453b9a55a7e212287986b22e5f960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af116985d3651befccd08a9bf078fa45d" id="r_af116985d3651befccd08a9bf078fa45d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af116985d3651befccd08a9bf078fa45d">la_lapack_s::la_slarnv</a> (idist, iseed, n, x)</td></tr>
<tr class="memdesc:af116985d3651befccd08a9bf078fa45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARNV: returns a vector of n random real numbers from a uniform or normal distribution.  <br /></td></tr>
<tr class="separator:af116985d3651befccd08a9bf078fa45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efa747fc5a31c48367c20f93d810762" id="r_a6efa747fc5a31c48367c20f93d810762"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a6efa747fc5a31c48367c20f93d810762">la_lapack_s::la_slarrb</a> (n, d, lld, ifirst, ilast, rtol1, rtol2, offset, w, wgap, werr, work, iwork, pivmin, spdiam, twist, info)</td></tr>
<tr class="memdesc:a6efa747fc5a31c48367c20f93d810762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the relatively robust representation(RRR) L D L^T, SLARRB: does "limited" bisection to refine the eigenvalues of L D L^T, W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial guesses for these eigenvalues are input in W, the corresponding estimate of the error in these guesses and their gaps are input in WERR and WGAP, respectively. During bisection, intervals [left, right] are maintained by storing their mid-points and semi-widths in the arrays W and WERR respectively.  <br /></td></tr>
<tr class="separator:a6efa747fc5a31c48367c20f93d810762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc0817dfd30ff2a9e0c439feeedac25" id="r_a7bc0817dfd30ff2a9e0c439feeedac25"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7bc0817dfd30ff2a9e0c439feeedac25">la_lapack_s::la_slarrf</a> (n, d, l, ld, clstrt, clend, w, wgap, werr, spdiam, clgapl, clgapr, pivmin, sigma, dplus, lplus, work, info)</td></tr>
<tr class="memdesc:a7bc0817dfd30ff2a9e0c439feeedac25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the initial representation L D L^T and its cluster of close eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ... W( CLEND ), SLARRF: finds a new relatively robust representation L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the eigenvalues of L(+) D(+) L(+)^T is relatively isolated.  <br /></td></tr>
<tr class="separator:a7bc0817dfd30ff2a9e0c439feeedac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28d7283b66e9aa07fccbe763a258bc1" id="r_ab28d7283b66e9aa07fccbe763a258bc1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab28d7283b66e9aa07fccbe763a258bc1">la_lapack_s::la_slarrv</a> (n, vl, vu, d, l, pivmin, isplit, m, dol, dou, minrgp, rtol1, rtol2, w, werr, wgap, iblock, indexw, gers, z, ldz, isuppz, work, iwork, info)</td></tr>
<tr class="memdesc:ab28d7283b66e9aa07fccbe763a258bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLARRV: computes the eigenvectors of the tridiagonal matrix T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T. The input eigenvalues should have been computed by SLARRE.  <br /></td></tr>
<tr class="separator:ab28d7283b66e9aa07fccbe763a258bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9dd0fd241334b15353e5b245ff6477" id="r_acd9dd0fd241334b15353e5b245ff6477"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#acd9dd0fd241334b15353e5b245ff6477">la_lapack_s::la_slascl</a> (type, kl, ku, cfrom, cto, m, n, a, lda, info)</td></tr>
<tr class="memdesc:acd9dd0fd241334b15353e5b245ff6477"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASCL: multiplies the M by N real matrix A by the real scalar CTO/CFROM. This is done without over/underflow as long as the final result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that A may be full, upper triangular, lower triangular, upper Hessenberg, or banded.  <br /></td></tr>
<tr class="separator:acd9dd0fd241334b15353e5b245ff6477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba4a4867dd89d177dfa2248e3339dac" id="r_a1ba4a4867dd89d177dfa2248e3339dac"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1ba4a4867dd89d177dfa2248e3339dac">la_lapack_s::la_slasd4</a> (n, i, d, z, delta, rho, sigma, work, info)</td></tr>
<tr class="memdesc:a1ba4a4867dd89d177dfa2248e3339dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine computes the square root of the I-th updated eigenvalue of a positive symmetric rank-one modification to a positive diagonal matrix whose entries are given as the squares of the corresponding entries in the array d, and that 0 &lt;= D(i) &lt; D(j) for i &lt; j and that RHO &gt; 0. This is arranged by the calling routine, and is no loss in generality. The rank-one modified system is thus diag( D ) * diag( D ) + RHO * Z * Z_transpose. where we assume the Euclidean norm of Z is 1. The method consists of approximating the rational functions in the secular equation by simpler interpolating rational functions.  <br /></td></tr>
<tr class="separator:a1ba4a4867dd89d177dfa2248e3339dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86abc3dd9bd7aef9887043a265c2d48b" id="r_a86abc3dd9bd7aef9887043a265c2d48b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a86abc3dd9bd7aef9887043a265c2d48b">la_lapack_s::la_slasd7</a> (icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl, vlw, alpha, beta, dsigma, idx, idxp, idxq, perm, givptr, givcol, ldgcol, givnum, ldgnum, c, s, info)</td></tr>
<tr class="memdesc:a86abc3dd9bd7aef9887043a265c2d48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASD7: merges the two sets of singular values together into a single sorted set. Then it tries to deflate the size of the problem. There are two ways in which deflation can occur: when two or more singular values are close together or if there is a tiny entry in the Z vector. For each such occurrence the order of the related secular equation problem is reduced by one. SLASD7 is called from SLASD6.  <br /></td></tr>
<tr class="separator:a86abc3dd9bd7aef9887043a265c2d48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68532e9a303ab02a336b44657a7d032" id="r_ac68532e9a303ab02a336b44657a7d032"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac68532e9a303ab02a336b44657a7d032">la_lapack_s::la_slasd8</a> (icompq, k, d, z, vf, vl, difl, difr, lddifr, dsigma, work, info)</td></tr>
<tr class="memdesc:ac68532e9a303ab02a336b44657a7d032"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASD8: finds the square roots of the roots of the secular equation, as defined by the values in DSIGMA and Z. It makes the appropriate calls to SLASD4, and stores, for each element in D, the distance to its two nearest poles (elements in DSIGMA). It also updates the arrays VF and VL, the first and last components of all the right singular vectors of the original bidiagonal matrix. SLASD8 is called from SLASD6.  <br /></td></tr>
<tr class="separator:ac68532e9a303ab02a336b44657a7d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2322cfc69fa42247a70d953ab8b1ea94" id="r_a2322cfc69fa42247a70d953ab8b1ea94"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2322cfc69fa42247a70d953ab8b1ea94">la_lapack_s::la_slasq3</a> (i0, n0, z, pp, dmin, sigma, desig, qmax, nfail, iter, ndiv, ieee, ttype, dmin1, dmin2, dn, dn1, dn2, g, tau)</td></tr>
<tr class="memdesc:a2322cfc69fa42247a70d953ab8b1ea94"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASQ3: checks for deflation, computes a shift (TAU) and calls dqds. In case of failure it changes shifts, and tries again until output is positive.  <br /></td></tr>
<tr class="separator:a2322cfc69fa42247a70d953ab8b1ea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c5477c1f6a0c71e887c6884fc17cda" id="r_ac8c5477c1f6a0c71e887c6884fc17cda"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac8c5477c1f6a0c71e887c6884fc17cda">la_lapack_s::la_slatdf</a> (ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv, jpiv)</td></tr>
<tr class="memdesc:ac8c5477c1f6a0c71e887c6884fc17cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLATDF: uses the LU factorization of the n-by-n matrix Z computed by SGETC2 and computes a contribution to the reciprocal Dif-estimate by solving Z * x = b for x, and choosing the r.h.s. b such that the norm of x is as large as possible. On entry RHS = b holds the contribution from earlier solved sub-systems, and on return RHS = x. The factorization of Z returned by SGETC2 has the form Z = P*L*U*Q, where P and Q are permutation matrices. L is lower triangular with unit diagonal elements and U is upper triangular.  <br /></td></tr>
<tr class="separator:ac8c5477c1f6a0c71e887c6884fc17cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b358e84c96ad12ae6509b07b1447a1" id="r_af2b358e84c96ad12ae6509b07b1447a1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af2b358e84c96ad12ae6509b07b1447a1">la_lapack_s::la_slatrd</a> (uplo, n, nb, a, lda, e, tau, w, ldw)</td></tr>
<tr class="memdesc:af2b358e84c96ad12ae6509b07b1447a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLATRD: reduces NB rows and columns of a real symmetric matrix A to symmetric tridiagonal form by an orthogonal similarity transformation Q**T * A * Q, and returns the matrices V and W which are needed to apply the transformation to the unreduced part of A. If UPLO = 'U', SLATRD reduces the last NB rows and columns of a matrix, of which the upper triangle is supplied; if UPLO = 'L', SLATRD reduces the first NB rows and columns of a matrix, of which the lower triangle is supplied. This is an auxiliary routine called by SSYTRD.  <br /></td></tr>
<tr class="separator:af2b358e84c96ad12ae6509b07b1447a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ef483d91abf723f3c877919a8eda68" id="r_a16ef483d91abf723f3c877919a8eda68"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a16ef483d91abf723f3c877919a8eda68">la_lapack_s::la_slatrz</a> (m, n, l, a, lda, tau, work)</td></tr>
<tr class="memdesc:a16ef483d91abf723f3c877919a8eda68"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLATRZ: factors the M-by-(M+L) real upper trapezoidal matrix [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R 0 ) * Z, by means of orthogonal transformations. Z is an (M+L)-by-(M+L) orthogonal matrix and, R and A1 are M-by-M upper triangular matrices.  <br /></td></tr>
<tr class="separator:a16ef483d91abf723f3c877919a8eda68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957c32576a7255dbb92c14284b8b9ebc" id="r_a957c32576a7255dbb92c14284b8b9ebc"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a957c32576a7255dbb92c14284b8b9ebc">la_lapack_s::la_sorbdb</a> (trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork, info)</td></tr>
<tr class="memdesc:a957c32576a7255dbb92c14284b8b9ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORBDB: simultaneously bidiagonalizes the blocks of an M-by-M partitioned orthogonal matrix X: [ B11 | B12 0 0 ] [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**T X = [--------&mdash;] = [------&mdash;] [-------------&mdash;] [------&mdash;] . [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ] [ 0 | 0 0 I ] X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is not the case, then X must be transposed and/or permuted. This can be done in constant time using the TRANS and SIGNS options. See SORCSD for details.) The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by- (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are represented implicitly by Householder vectors. B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented implicitly by angles THETA, PHI.  <br /></td></tr>
<tr class="separator:a957c32576a7255dbb92c14284b8b9ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae229dc9dd25a842dc5492fb9bcbbd49f" id="r_ae229dc9dd25a842dc5492fb9bcbbd49f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ae229dc9dd25a842dc5492fb9bcbbd49f">la_lapack_s::la_sorbdb5</a> (m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2, work, lwork, info)</td></tr>
<tr class="memdesc:ae229dc9dd25a842dc5492fb9bcbbd49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORBDB5: orthogonalizes the column vector X = [ X1 ] [ X2 ] with respect to the columns of Q = [ Q1 ] . [ Q2 ] The columns of Q must be orthonormal. If the projection is zero according to Kahan's "twice is enough" criterion, then some other vector from the orthogonal complement is returned. This vector is chosen in an arbitrary but deterministic way.  <br /></td></tr>
<tr class="separator:ae229dc9dd25a842dc5492fb9bcbbd49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eedc10ad125aec469195e176a247388" id="r_a2eedc10ad125aec469195e176a247388"><td class="memItemLeft" align="right" valign="top">recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2eedc10ad125aec469195e176a247388">la_lapack_s::la_sorcsd</a> (jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:a2eedc10ad125aec469195e176a247388"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORCSD: computes the CS decomposition of an M-by-M partitioned orthogonal matrix X: [ I 0 0 | 0 0 0 ] [ 0 C 0 | 0 -S 0 ] [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**T X = [--------&mdash;] = [------&mdash;] [------------------&mdash;] [------&mdash;] . [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ] [ 0 S 0 | 0 C 0 ] [ 0 0 I | 0 0 0 ] X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P, (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which R = MIN(P,M-P,Q,M-Q).  <br /></td></tr>
<tr class="separator:a2eedc10ad125aec469195e176a247388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee8cb23c73a586699fd56be18f8ce85" id="r_a1ee8cb23c73a586699fd56be18f8ce85"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1ee8cb23c73a586699fd56be18f8ce85">la_lapack_s::la_sorghr</a> (n, ilo, ihi, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a1ee8cb23c73a586699fd56be18f8ce85"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGHR: generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by SGEHRD: Q = H(ilo) H(ilo+1) . . . H(ihi-1).  <br /></td></tr>
<tr class="separator:a1ee8cb23c73a586699fd56be18f8ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361f38638afd63da9b279bb8719ddbee" id="r_a361f38638afd63da9b279bb8719ddbee"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a361f38638afd63da9b279bb8719ddbee">la_lapack_s::la_sorhr_col</a> (m, n, nb, a, lda, t, ldt, d, info)</td></tr>
<tr class="memdesc:a361f38638afd63da9b279bb8719ddbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORHR_COL: takes an M-by-N real matrix Q_in with orthonormal columns as input, stored in A, and performs Householder Reconstruction (HR), i.e. reconstructs Householder vectors V(i) implicitly representing another M-by-N matrix Q_out, with the property that Q_in = Q_out*S, where S is an N-by-N diagonal matrix with diagonal entries equal to +1 or -1. The Householder vectors (columns V(i) of V) are stored in A on output, and the diagonal entries of S are stored in D. Block reflectors are also returned in T (same output format as SGEQRT).  <br /></td></tr>
<tr class="separator:a361f38638afd63da9b279bb8719ddbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6429e3077fa3b866611a5f0a6c5c33" id="r_abc6429e3077fa3b866611a5f0a6c5c33"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abc6429e3077fa3b866611a5f0a6c5c33">la_lapack_s::la_sormhr</a> (side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:abc6429e3077fa3b866611a5f0a6c5c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMHR: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix of order nq, with nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of IHI-ILO elementary reflectors, as returned by SGEHRD: Q = H(ilo) H(ilo+1) . . . H(ihi-1).  <br /></td></tr>
<tr class="separator:abc6429e3077fa3b866611a5f0a6c5c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f05ba8f9a64a1b8c306f2fce6b54af" id="r_a67f05ba8f9a64a1b8c306f2fce6b54af"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a67f05ba8f9a64a1b8c306f2fce6b54af">la_lapack_s::la_spbcon</a> (uplo, n, kd, ab, ldab, anorm, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a67f05ba8f9a64a1b8c306f2fce6b54af"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPBCON: estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite band matrix using the Cholesky factorization A = U**T*U or A = L*L**T computed by SPBTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a67f05ba8f9a64a1b8c306f2fce6b54af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71c02aaee2d8ed41ace68724e0c7ac8" id="r_af71c02aaee2d8ed41ace68724e0c7ac8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af71c02aaee2d8ed41ace68724e0c7ac8">la_lapack_s::la_spbrfs</a> (uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:af71c02aaee2d8ed41ace68724e0c7ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPBRFS: improves the computed solution to a system of linear equations when the coefficient matrix is symmetric positive definite and banded, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:af71c02aaee2d8ed41ace68724e0c7ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05579229779f52ec7743b0b097fba75" id="r_ae05579229779f52ec7743b0b097fba75"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ae05579229779f52ec7743b0b097fba75">la_lapack_s::la_spftrs</a> (transr, uplo, n, nrhs, a, b, ldb, info)</td></tr>
<tr class="memdesc:ae05579229779f52ec7743b0b097fba75"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPFTRS: solves a system of linear equations A*X = B with a symmetric positive definite matrix A using the Cholesky factorization A = U**T*U or A = L*L**T computed by SPFTRF.  <br /></td></tr>
<tr class="separator:ae05579229779f52ec7743b0b097fba75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd662ca257fdf4bd7577ef8ea2d7791a" id="r_afd662ca257fdf4bd7577ef8ea2d7791a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#afd662ca257fdf4bd7577ef8ea2d7791a">la_lapack_s::la_spocon</a> (uplo, n, a, lda, anorm, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:afd662ca257fdf4bd7577ef8ea2d7791a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPOCON: estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite matrix using the Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:afd662ca257fdf4bd7577ef8ea2d7791a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7fcc717ab6e52e1e58f9fd55106fd0" id="r_aac7fcc717ab6e52e1e58f9fd55106fd0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aac7fcc717ab6e52e1e58f9fd55106fd0">la_lapack_s::la_sporfs</a> (uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:aac7fcc717ab6e52e1e58f9fd55106fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPORFS: improves the computed solution to a system of linear equations when the coefficient matrix is symmetric positive definite, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:aac7fcc717ab6e52e1e58f9fd55106fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d217cec2b5cf563fdf76d9e97bcc2f" id="r_ad0d217cec2b5cf563fdf76d9e97bcc2f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad0d217cec2b5cf563fdf76d9e97bcc2f">la_lapack_s::la_spotf2</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:ad0d217cec2b5cf563fdf76d9e97bcc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPOTF2: computes the Cholesky factorization of a real symmetric positive definite matrix A. The factorization has the form A = U**T * U , if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:ad0d217cec2b5cf563fdf76d9e97bcc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34523317c26232b976481d49b4e1b45" id="r_af34523317c26232b976481d49b4e1b45"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af34523317c26232b976481d49b4e1b45">la_lapack_s::la_spotrf2</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:af34523317c26232b976481d49b4e1b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPOTRF2: computes the Cholesky factorization of a real symmetric positive definite matrix A using the recursive algorithm. The factorization has the form A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular. This is the recursive version of the algorithm. It divides the matrix into four submatrices: [ A11 | A12 ] where A11 is n1 by n1 and A22 is n2 by n2 A = [ --&mdash;|--&mdash; ] with n1 = n/2 [ A21 | A22 ] n2 = n-n1 The subroutine calls itself to factor A11. Update and scale A21 or A12, update A22 then call itself to factor A22.  <br /></td></tr>
<tr class="separator:af34523317c26232b976481d49b4e1b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1644a598f7a8eb708aba92ad2e0daef8" id="r_a1644a598f7a8eb708aba92ad2e0daef8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1644a598f7a8eb708aba92ad2e0daef8">la_lapack_s::la_spotri</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:a1644a598f7a8eb708aba92ad2e0daef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPOTRI: computes the inverse of a real symmetric positive definite matrix A using the Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.  <br /></td></tr>
<tr class="separator:a1644a598f7a8eb708aba92ad2e0daef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d4e85de91e5a7de32e047017a7fe53" id="r_a46d4e85de91e5a7de32e047017a7fe53"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a46d4e85de91e5a7de32e047017a7fe53">la_lapack_s::la_sppcon</a> (uplo, n, ap, anorm, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a46d4e85de91e5a7de32e047017a7fe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPPCON: estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite packed matrix using the Cholesky factorization A = U**T*U or A = L*L**T computed by SPPTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a46d4e85de91e5a7de32e047017a7fe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4d507c347afb03a1eedcb96836f4ad" id="r_a7f4d507c347afb03a1eedcb96836f4ad"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7f4d507c347afb03a1eedcb96836f4ad">la_lapack_s::la_spprfs</a> (uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:a7f4d507c347afb03a1eedcb96836f4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPPRFS: improves the computed solution to a system of linear equations when the coefficient matrix is symmetric positive definite and packed, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:a7f4d507c347afb03a1eedcb96836f4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df8821c49ddb5adf34cd9ce6b9690f1" id="r_a2df8821c49ddb5adf34cd9ce6b9690f1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2df8821c49ddb5adf34cd9ce6b9690f1">la_lapack_s::la_sppsv</a> (uplo, n, nrhs, ap, b, ldb, info)</td></tr>
<tr class="memdesc:a2df8821c49ddb5adf34cd9ce6b9690f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPPSV: computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite matrix stored in packed format and X and B are N-by-NRHS matrices. The Cholesky decomposition is used to factor A as A = U**T* U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is a lower triangular matrix. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a2df8821c49ddb5adf34cd9ce6b9690f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b20000abcddcd62a322df31bee46d3" id="r_a44b20000abcddcd62a322df31bee46d3"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a44b20000abcddcd62a322df31bee46d3">la_lapack_s::la_sppsvx</a> (fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:a44b20000abcddcd62a322df31bee46d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPPSVX: uses the Cholesky factorization A = U**T*U or A = L*L**T to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite matrix stored in packed format and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a44b20000abcddcd62a322df31bee46d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece0bf89b950f7ee11d711708f1702df" id="r_aece0bf89b950f7ee11d711708f1702df"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aece0bf89b950f7ee11d711708f1702df">la_lapack_s::la_spptri</a> (uplo, n, ap, info)</td></tr>
<tr class="memdesc:aece0bf89b950f7ee11d711708f1702df"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPPTRI: computes the inverse of a real symmetric positive definite matrix A using the Cholesky factorization A = U**T*U or A = L*L**T computed by SPPTRF.  <br /></td></tr>
<tr class="separator:aece0bf89b950f7ee11d711708f1702df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b7e41f4f710b324dbc2a18d50cba04" id="r_a07b7e41f4f710b324dbc2a18d50cba04"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a07b7e41f4f710b324dbc2a18d50cba04">la_lapack_s::la_spstf2</a> (uplo, n, a, lda, piv, rank, tol, work, info)</td></tr>
<tr class="memdesc:a07b7e41f4f710b324dbc2a18d50cba04"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPSTF2: computes the Cholesky factorization with complete pivoting of a real symmetric positive semidefinite matrix A. The factorization has the form P**T * A * P = U**T * U , if UPLO = 'U', P**T * A * P = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular, and P is stored as vector PIV. This algorithm does not attempt to check that A is positive semidefinite. This version of the algorithm calls level 2 BLAS.  <br /></td></tr>
<tr class="separator:a07b7e41f4f710b324dbc2a18d50cba04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09f050f7405ea8c1493a60e60829f98" id="r_ab09f050f7405ea8c1493a60e60829f98"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab09f050f7405ea8c1493a60e60829f98">la_lapack_s::la_spstrf</a> (uplo, n, a, lda, piv, rank, tol, work, info)</td></tr>
<tr class="memdesc:ab09f050f7405ea8c1493a60e60829f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPSTRF: computes the Cholesky factorization with complete pivoting of a real symmetric positive semidefinite matrix A. The factorization has the form P**T * A * P = U**T * U , if UPLO = 'U', P**T * A * P = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular, and P is stored as vector PIV. This algorithm does not attempt to check that A is positive semidefinite. This version of the algorithm calls level 3 BLAS.  <br /></td></tr>
<tr class="separator:ab09f050f7405ea8c1493a60e60829f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31326688c6441df71b20dcf0468740aa" id="r_a31326688c6441df71b20dcf0468740aa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a31326688c6441df71b20dcf0468740aa">la_lapack_s::la_spttrs</a> (n, nrhs, d, e, b, ldb, info)</td></tr>
<tr class="memdesc:a31326688c6441df71b20dcf0468740aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPTTRS: solves a tridiagonal system of the form A * X = B using the L*D*L**T factorization of A computed by SPTTRF. D is a diagonal matrix specified in the vector D, L is a unit bidiagonal matrix whose subdiagonal is specified in the vector E, and X and B are N by NRHS matrices.  <br /></td></tr>
<tr class="separator:a31326688c6441df71b20dcf0468740aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efb8175e39eae761c029fe03fdcd7fa" id="r_a0efb8175e39eae761c029fe03fdcd7fa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0efb8175e39eae761c029fe03fdcd7fa">la_lapack_s::la_ssb2st_kernels</a> (uplo, wantz, ttype, st, ed, sweep, n, nb, ib, a, lda, v, tau, ldvt, work)</td></tr>
<tr class="memdesc:a0efb8175e39eae761c029fe03fdcd7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSB2ST_KERNELS: is an internal routine used by the SSYTRD_SB2ST subroutine.  <br /></td></tr>
<tr class="separator:a0efb8175e39eae761c029fe03fdcd7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ff7a465f199b14e4f7a2d5e6576426" id="r_a58ff7a465f199b14e4f7a2d5e6576426"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a58ff7a465f199b14e4f7a2d5e6576426">la_lapack_s::la_sspcon</a> (uplo, n, ap, ipiv, anorm, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a58ff7a465f199b14e4f7a2d5e6576426"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPCON: estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric packed matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by SSPTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a58ff7a465f199b14e4f7a2d5e6576426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0b894b92225dd0c4a373276223ecd4" id="r_abe0b894b92225dd0c4a373276223ecd4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abe0b894b92225dd0c4a373276223ecd4">la_lapack_s::la_ssprfs</a> (uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:abe0b894b92225dd0c4a373276223ecd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPRFS: improves the computed solution to a system of linear equations when the coefficient matrix is symmetric indefinite and packed, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:abe0b894b92225dd0c4a373276223ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a864d5ccd42ecb3652ee020697fcbc" id="r_a62a864d5ccd42ecb3652ee020697fcbc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a62a864d5ccd42ecb3652ee020697fcbc">la_lapack_s::la_sspsv</a> (uplo, n, nrhs, ap, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a62a864d5ccd42ecb3652ee020697fcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPSV: computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix stored in packed format and X and B are N-by-NRHS matrices. The diagonal pivoting method is used to factor A as A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a62a864d5ccd42ecb3652ee020697fcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939b495ee452b070b84bb51682caa557" id="r_a939b495ee452b070b84bb51682caa557"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a939b495ee452b070b84bb51682caa557">la_lapack_s::la_sspsvx</a> (fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:a939b495ee452b070b84bb51682caa557"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPSVX: uses the diagonal pivoting factorization A = U*D*U**T or A = L*D*L**T to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix stored in packed format and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a939b495ee452b070b84bb51682caa557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920301586f8e2e839ebfe1a59c210770" id="r_a920301586f8e2e839ebfe1a59c210770"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a920301586f8e2e839ebfe1a59c210770">la_lapack_s::la_ssptrd</a> (uplo, n, ap, d, e, tau, info)</td></tr>
<tr class="memdesc:a920301586f8e2e839ebfe1a59c210770"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPTRD: reduces a real symmetric matrix A stored in packed form to symmetric tridiagonal form T by an orthogonal similarity transformation: Q**T * A * Q = T.  <br /></td></tr>
<tr class="separator:a920301586f8e2e839ebfe1a59c210770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a0f71129c42ceab2db8fcfbeddf4ae" id="r_a87a0f71129c42ceab2db8fcfbeddf4ae"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a87a0f71129c42ceab2db8fcfbeddf4ae">la_lapack_s::la_sstein</a> (n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifail, info)</td></tr>
<tr class="memdesc:a87a0f71129c42ceab2db8fcfbeddf4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEIN: computes the eigenvectors of a real symmetric tridiagonal matrix T corresponding to specified eigenvalues, using inverse iteration. The maximum number of iterations allowed for each eigenvector is specified by an internal parameter MAXITS (currently set to 5).  <br /></td></tr>
<tr class="separator:a87a0f71129c42ceab2db8fcfbeddf4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6c89197d420409e760bc62c0f1d805" id="r_afa6c89197d420409e760bc62c0f1d805"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#afa6c89197d420409e760bc62c0f1d805">la_lapack_s::la_ssteqr</a> (compz, n, d, e, z, ldz, work, info)</td></tr>
<tr class="memdesc:afa6c89197d420409e760bc62c0f1d805"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEQR: computes all eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the implicit QL or QR method. The eigenvectors of a full or band symmetric matrix can also be found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to tridiagonal form.  <br /></td></tr>
<tr class="separator:afa6c89197d420409e760bc62c0f1d805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eca67d333b238ec42119aff95df00a" id="r_ab9eca67d333b238ec42119aff95df00a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab9eca67d333b238ec42119aff95df00a">la_lapack_s::la_ssterf</a> (n, d, e, info)</td></tr>
<tr class="memdesc:ab9eca67d333b238ec42119aff95df00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTERF: computes all eigenvalues of a symmetric tridiagonal matrix using the Pal-Walker-Kahan variant of the QL or QR algorithm.  <br /></td></tr>
<tr class="separator:ab9eca67d333b238ec42119aff95df00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3178127a492ae702c9913c2e86fb934" id="r_ac3178127a492ae702c9913c2e86fb934"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac3178127a492ae702c9913c2e86fb934">la_lapack_s::la_sstev</a> (jobz, n, d, e, z, ldz, work, info)</td></tr>
<tr class="memdesc:ac3178127a492ae702c9913c2e86fb934"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEV: computes all eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix A.  <br /></td></tr>
<tr class="separator:ac3178127a492ae702c9913c2e86fb934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa1533e20e43f465005c16c156ef58b" id="r_aefa1533e20e43f465005c16c156ef58b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aefa1533e20e43f465005c16c156ef58b">la_lapack_s::la_sstevx</a> (jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info)</td></tr>
<tr class="memdesc:aefa1533e20e43f465005c16c156ef58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEVX: computes selected eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:aefa1533e20e43f465005c16c156ef58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c2d9e25db1ab4dba9643d2d3d1b5bd" id="r_a56c2d9e25db1ab4dba9643d2d3d1b5bd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a56c2d9e25db1ab4dba9643d2d3d1b5bd">la_lapack_s::la_ssycon</a> (uplo, n, a, lda, ipiv, anorm, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a56c2d9e25db1ab4dba9643d2d3d1b5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYCON: estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by SSYTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a56c2d9e25db1ab4dba9643d2d3d1b5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745da4f449b1cd11330f838da9e81fec" id="r_a745da4f449b1cd11330f838da9e81fec"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a745da4f449b1cd11330f838da9e81fec">la_lapack_s::la_ssycon_rook</a> (uplo, n, a, lda, ipiv, anorm, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a745da4f449b1cd11330f838da9e81fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYCON_ROOK: estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by SSYTRF_ROOK. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a745da4f449b1cd11330f838da9e81fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032b00c66590e524ff4ce3a6df28ac51" id="r_a032b00c66590e524ff4ce3a6df28ac51"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a032b00c66590e524ff4ce3a6df28ac51">la_lapack_s::la_ssyrfs</a> (uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:a032b00c66590e524ff4ce3a6df28ac51"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYRFS: improves the computed solution to a system of linear equations when the coefficient matrix is symmetric indefinite, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:a032b00c66590e524ff4ce3a6df28ac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88bd4259bd970ab14717dfc32ea7876" id="r_ab88bd4259bd970ab14717dfc32ea7876"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab88bd4259bd970ab14717dfc32ea7876">la_lapack_s::la_ssysv_rk</a> (uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:ab88bd4259bd970ab14717dfc32ea7876"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYSV_RK: computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices. The bounded Bunch-Kaufman (rook) diagonal pivoting method is used to factor A as A = P*U*D*(U**T)*(P**T), if UPLO = 'U', or A = P*L*D*(L**T)*(P**T), if UPLO = 'L', where U (or L) is unit upper (or lower) triangular matrix, U**T (or L**T) is the transpose of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. SSYTRF_RK is called to compute the factorization of a real symmetric matrix. The factored form of A is then used to solve the system of equations A * X = B by calling BLAS3 routine SSYTRS_3.  <br /></td></tr>
<tr class="separator:ab88bd4259bd970ab14717dfc32ea7876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdadd37b8535dd6481f2fea331f5c139" id="r_abdadd37b8535dd6481f2fea331f5c139"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abdadd37b8535dd6481f2fea331f5c139">la_lapack_s::la_ssysv_rook</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:abdadd37b8535dd6481f2fea331f5c139"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYSV_ROOK: computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices. The diagonal pivoting method is used to factor A as A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. SSYTRF_ROOK is called to compute the factorization of a real symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method. The factored form of A is then used to solve the system of equations A * X = B by calling SSYTRS_ROOK.  <br /></td></tr>
<tr class="separator:abdadd37b8535dd6481f2fea331f5c139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530737cca4b40a9d38f692c533944249" id="r_a530737cca4b40a9d38f692c533944249"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a530737cca4b40a9d38f692c533944249">la_lapack_s::la_ssytd2</a> (uplo, n, a, lda, d, e, tau, info)</td></tr>
<tr class="memdesc:a530737cca4b40a9d38f692c533944249"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTD2: reduces a real symmetric matrix A to symmetric tridiagonal form T by an orthogonal similarity transformation: Q**T * A * Q = T.  <br /></td></tr>
<tr class="separator:a530737cca4b40a9d38f692c533944249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada17e07fa6864da10d71ac9b55211fbe" id="r_ada17e07fa6864da10d71ac9b55211fbe"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ada17e07fa6864da10d71ac9b55211fbe">la_lapack_s::la_ssytf2</a> (uplo, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:ada17e07fa6864da10d71ac9b55211fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTF2: computes the factorization of a real symmetric matrix A using the Bunch-Kaufman diagonal pivoting method: A = U*D*U**T or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, U**T is the transpose of U, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:ada17e07fa6864da10d71ac9b55211fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681deee1151ae6f2605270519140b502" id="r_a681deee1151ae6f2605270519140b502"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a681deee1151ae6f2605270519140b502">la_lapack_s::la_ssytrd</a> (uplo, n, a, lda, d, e, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a681deee1151ae6f2605270519140b502"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRD: reduces a real symmetric matrix A to real symmetric tridiagonal form T by an orthogonal similarity transformation: Q**T * A * Q = T.  <br /></td></tr>
<tr class="separator:a681deee1151ae6f2605270519140b502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac287d41b5a2c2d99fec3f439c6d402" id="r_adac287d41b5a2c2d99fec3f439c6d402"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#adac287d41b5a2c2d99fec3f439c6d402">la_lapack_s::la_ssytrd_sb2st</a> (stage1, vect, uplo, n, kd, ab, ldab, d, e, hous, lhous, work, lwork, info)</td></tr>
<tr class="memdesc:adac287d41b5a2c2d99fec3f439c6d402"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRD_SB2ST: reduces a real symmetric band matrix A to real symmetric tridiagonal form T by a orthogonal similarity transformation: Q**T * A * Q = T.  <br /></td></tr>
<tr class="separator:adac287d41b5a2c2d99fec3f439c6d402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48e625b758ea45cb279a4d18c8466b5" id="r_ad48e625b758ea45cb279a4d18c8466b5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad48e625b758ea45cb279a4d18c8466b5">la_lapack_s::la_ssytrf</a> (uplo, n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:ad48e625b758ea45cb279a4d18c8466b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRF: computes the factorization of a real symmetric matrix A using the Bunch-Kaufman diagonal pivoting method. The form of the factorization is A = U**T*D*U or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:ad48e625b758ea45cb279a4d18c8466b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39020a3c468e75777904c83c53ea3767" id="r_a39020a3c468e75777904c83c53ea3767"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a39020a3c468e75777904c83c53ea3767">la_lapack_s::la_stbcon</a> (norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a39020a3c468e75777904c83c53ea3767"><td class="mdescLeft">&#160;</td><td class="mdescRight">STBCON: estimates the reciprocal of the condition number of a triangular band matrix A, in either the 1-norm or the infinity-norm. The norm of A is computed and an estimate is obtained for norm(inv(A)), then the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).  <br /></td></tr>
<tr class="separator:a39020a3c468e75777904c83c53ea3767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fbe7d9afa8aa1e03f05b3a7f708c06" id="r_af6fbe7d9afa8aa1e03f05b3a7f708c06"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af6fbe7d9afa8aa1e03f05b3a7f708c06">la_lapack_s::la_stftri</a> (transr, uplo, diag, n, a, info)</td></tr>
<tr class="memdesc:af6fbe7d9afa8aa1e03f05b3a7f708c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">STFTRI: computes the inverse of a triangular matrix A stored in RFP format. This is a Level 3 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:af6fbe7d9afa8aa1e03f05b3a7f708c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf47118bfb033e19a7ea707e175b9b6" id="r_aeaf47118bfb033e19a7ea707e175b9b6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aeaf47118bfb033e19a7ea707e175b9b6">la_lapack_s::la_stgsy2</a> (trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, rdsum, rdscal, iwork, pq, info)</td></tr>
<tr class="memdesc:aeaf47118bfb033e19a7ea707e175b9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">STGSY2: solves the generalized Sylvester equation: A * R - L * B = scale * C (1) D * R - L * E = scale * F, using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices, (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M, N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E) must be in generalized Schur canonical form, i.e. A, B are upper quasi triangular and D, E are upper triangular. The solution (R, L) overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output scaling factor chosen to avoid overflow. In matrix notation solving equation (1) corresponds to solve Z*x = scale*b, where Z is defined as Z = [ kron(In, A) -kron(B**T, Im) ] (2) [ kron(In, D) -kron(E**T, Im) ], Ik is the identity matrix of size k and X**T is the transpose of X. kron(X, Y) is the Kronecker product between the matrices X and Y. In the process of solving (1), we solve a number of such systems where Dim(In), Dim(In) = 1 or 2. If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y, which is equivalent to solve for R and L in A**T * R + D**T * L = scale * C (3) R * B**T + L * E**T = scale * -F This case is used to compute an estimate of Dif[(A, D), (B, E)] = sigma_min(Z) using reverse communication with SLACON. STGSY2 also (IJOB &gt;= 1) contributes to the computation in STGSYL of an upper bound on the separation between to matrix pairs. Then the input (A, D), (B, E) are sub-pencils of the matrix pair in STGSYL. See STGSYL for details.  <br /></td></tr>
<tr class="separator:aeaf47118bfb033e19a7ea707e175b9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a4433aba6bacf1fc6fba69ed2ce54f" id="r_a01a4433aba6bacf1fc6fba69ed2ce54f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a01a4433aba6bacf1fc6fba69ed2ce54f">la_lapack_s::la_stgsyl</a> (trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:a01a4433aba6bacf1fc6fba69ed2ce54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">STGSYL: solves the generalized Sylvester equation: A * R - L * B = scale * C (1) D * R - L * E = scale * F where R and L are unknown m-by-n matrices, (A, D), (B, E) and (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n, respectively, with real entries. (A, D) and (B, E) must be in generalized (real) Schur canonical form, i.e. A, B are upper quasi triangular and D, E are upper triangular. The solution (R, L) overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output scaling factor chosen to avoid overflow. In matrix notation (1) is equivalent to solve Zx = scale b, where Z is defined as Z = [ kron(In, A) -kron(B**T, Im) ] (2) [ kron(In, D) -kron(E**T, Im) ]. Here Ik is the identity matrix of size k and X**T is the transpose of X. kron(X, Y) is the Kronecker product between the matrices X and Y. If TRANS = 'T', STGSYL solves the transposed system Z**T*y = scale*b, which is equivalent to solve for R and L in A**T * R + D**T * L = scale * C (3) R * B**T + L * E**T = scale * -F This case (TRANS = 'T') is used to compute an one-norm-based estimate of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D) and (B,E), using SLACON. If IJOB &gt;= 1, STGSYL computes a Frobenius norm-based estimate of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the reciprocal of the smallest singular value of Z. See [1-2] for more information. This is a level 3 BLAS algorithm.  <br /></td></tr>
<tr class="separator:a01a4433aba6bacf1fc6fba69ed2ce54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aed6d59850dc88afd11434d51aff78c" id="r_a7aed6d59850dc88afd11434d51aff78c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7aed6d59850dc88afd11434d51aff78c">la_lapack_s::la_stpcon</a> (norm, uplo, diag, n, ap, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a7aed6d59850dc88afd11434d51aff78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPCON: estimates the reciprocal of the condition number of a packed triangular matrix A, in either the 1-norm or the infinity-norm. The norm of A is computed and an estimate is obtained for norm(inv(A)), then the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).  <br /></td></tr>
<tr class="separator:a7aed6d59850dc88afd11434d51aff78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81523005c9d3974dfd80aa5d361feaa" id="r_aa81523005c9d3974dfd80aa5d361feaa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa81523005c9d3974dfd80aa5d361feaa">la_lapack_s::la_stplqt2</a> (m, n, l, a, lda, b, ldb, t, ldt, info)</td></tr>
<tr class="memdesc:aa81523005c9d3974dfd80aa5d361feaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPLQT2: computes a LQ a factorization of a real "triangular-pentagonal" matrix C, which is composed of a triangular block A and pentagonal block B, using the compact WY representation for Q.  <br /></td></tr>
<tr class="separator:aa81523005c9d3974dfd80aa5d361feaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5eb71b9fe848c7e199635f3022c444" id="r_adc5eb71b9fe848c7e199635f3022c444"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#adc5eb71b9fe848c7e199635f3022c444">la_lapack_s::la_stpmlqt</a> (side, trans, m, n, k, l, mb, v, ldv, t, ldt, a, lda, b, ldb, work, info)</td></tr>
<tr class="memdesc:adc5eb71b9fe848c7e199635f3022c444"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPMLQT: applies a real orthogonal matrix Q obtained from a "triangular-pentagonal" real block reflector H to a general real matrix C, which consists of two blocks A and B.  <br /></td></tr>
<tr class="separator:adc5eb71b9fe848c7e199635f3022c444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365041ce6931acd968b296279b3d7536" id="r_a365041ce6931acd968b296279b3d7536"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a365041ce6931acd968b296279b3d7536">la_lapack_s::la_stpmqrt</a> (side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work, info)</td></tr>
<tr class="memdesc:a365041ce6931acd968b296279b3d7536"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPMQRT: applies a real orthogonal matrix Q obtained from a "triangular-pentagonal" real block reflector H to a general real matrix C, which consists of two blocks A and B.  <br /></td></tr>
<tr class="separator:a365041ce6931acd968b296279b3d7536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57aa70b30d8278a0e9281d2ca0b3c306" id="r_a57aa70b30d8278a0e9281d2ca0b3c306"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a57aa70b30d8278a0e9281d2ca0b3c306">la_lapack_s::la_stpqrt2</a> (m, n, l, a, lda, b, ldb, t, ldt, info)</td></tr>
<tr class="memdesc:a57aa70b30d8278a0e9281d2ca0b3c306"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPQRT2: computes a QR factorization of a real "triangular-pentagonal" matrix C, which is composed of a triangular block A and pentagonal block B, using the compact WY representation for Q.  <br /></td></tr>
<tr class="separator:a57aa70b30d8278a0e9281d2ca0b3c306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d6d4a94ac44fad5a43d8d320aeb355" id="r_a01d6d4a94ac44fad5a43d8d320aeb355"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a01d6d4a94ac44fad5a43d8d320aeb355">la_lapack_s::la_strcon</a> (norm, uplo, diag, n, a, lda, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a01d6d4a94ac44fad5a43d8d320aeb355"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRCON: estimates the reciprocal of the condition number of a triangular matrix A, in either the 1-norm or the infinity-norm. The norm of A is computed and an estimate is obtained for norm(inv(A)), then the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).  <br /></td></tr>
<tr class="separator:a01d6d4a94ac44fad5a43d8d320aeb355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac340052c00d12b4fc20c316c86ac6609" id="r_ac340052c00d12b4fc20c316c86ac6609"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac340052c00d12b4fc20c316c86ac6609">la_lapack_s::la_stzrzf</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:ac340052c00d12b4fc20c316c86ac6609"><td class="mdescLeft">&#160;</td><td class="mdescRight">STZRZF: reduces the M-by-N ( M&lt;=N ) real upper trapezoidal matrix A to upper triangular form by means of orthogonal transformations. The upper trapezoidal matrix A is factored as A = ( R 0 ) * Z, where Z is an N-by-N orthogonal matrix and R is an M-by-M upper triangular matrix.  <br /></td></tr>
<tr class="separator:ac340052c00d12b4fc20c316c86ac6609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5101f608503db107c9105227233c8a" id="r_a3a5101f608503db107c9105227233c8a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3a5101f608503db107c9105227233c8a">la_lapack_s::la_sgbsv</a> (n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a3a5101f608503db107c9105227233c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBSV: computes the solution to a real system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a3a5101f608503db107c9105227233c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fbf4c17b38de52302eda77831e18be" id="r_a36fbf4c17b38de52302eda77831e18be"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a36fbf4c17b38de52302eda77831e18be">la_lapack_s::la_sgbsvx</a> (fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:a36fbf4c17b38de52302eda77831e18be"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBSVX: uses the LU factorization to compute the solution to a real system of linear equations A * X = B, A**T * X = B, or A**H * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a36fbf4c17b38de52302eda77831e18be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab14c6774be2f16b0ec143eb34d0c01c" id="r_aab14c6774be2f16b0ec143eb34d0c01c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aab14c6774be2f16b0ec143eb34d0c01c">la_lapack_s::la_sgebal</a> (job, n, a, lda, ilo, ihi, scale, info)</td></tr>
<tr class="memdesc:aab14c6774be2f16b0ec143eb34d0c01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEBAL: balances a general real matrix A. This involves, first, permuting A by a similarity transformation to isolate eigenvalues in the first 1 to ILO-1 and last IHI+1 to N elements on the diagonal; and second, applying a diagonal similarity transformation to rows and columns ILO to IHI to make the rows and columns as close in norm as possible. Both steps are optional. Balancing may reduce the 1-norm of the matrix, and improve the accuracy of the computed eigenvalues and/or eigenvectors.  <br /></td></tr>
<tr class="separator:aab14c6774be2f16b0ec143eb34d0c01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad885ec480d1bbdd724e8eb0fe45cfb8" id="r_aad885ec480d1bbdd724e8eb0fe45cfb8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aad885ec480d1bbdd724e8eb0fe45cfb8">la_lapack_s::la_sgebd2</a> (m, n, a, lda, d, e, tauq, taup, work, info)</td></tr>
<tr class="memdesc:aad885ec480d1bbdd724e8eb0fe45cfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEBD2: reduces a real general m by n matrix A to upper or lower bidiagonal form B by an orthogonal transformation: Q**T * A * P = B. If m &gt;= n, B is upper bidiagonal; if m &lt; n, B is lower bidiagonal.  <br /></td></tr>
<tr class="separator:aad885ec480d1bbdd724e8eb0fe45cfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6f3dcb5a3b262e9a3d6e530bc7782a" id="r_afd6f3dcb5a3b262e9a3d6e530bc7782a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#afd6f3dcb5a3b262e9a3d6e530bc7782a">la_lapack_s::la_sgehd2</a> (n, ilo, ihi, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:afd6f3dcb5a3b262e9a3d6e530bc7782a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEHD2: reduces a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation: Q**T * A * Q = H .  <br /></td></tr>
<tr class="separator:afd6f3dcb5a3b262e9a3d6e530bc7782a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af458474e65133f1b5b3f42050164f0f5" id="r_af458474e65133f1b5b3f42050164f0f5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af458474e65133f1b5b3f42050164f0f5">la_lapack_s::la_sgelq2</a> (m, n, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:af458474e65133f1b5b3f42050164f0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGELQ2: computes an LQ factorization of a real m-by-n matrix A: A = ( L 0 ) * Q where: Q is a n-by-n orthogonal matrix; L is a lower-triangular m-by-m matrix; 0 is a m-by-(n-m) zero matrix, if m &lt; n.  <br /></td></tr>
<tr class="separator:af458474e65133f1b5b3f42050164f0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721beb80f0d071295cd4db4d8aac1b39" id="r_a721beb80f0d071295cd4db4d8aac1b39"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a721beb80f0d071295cd4db4d8aac1b39">la_lapack_s::la_sgelqf</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a721beb80f0d071295cd4db4d8aac1b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGELQF: computes an LQ factorization of a real M-by-N matrix A: A = ( L 0 ) * Q where: Q is a N-by-N orthogonal matrix; L is a lower-triangular M-by-M matrix; 0 is a M-by-(N-M) zero matrix, if M &lt; N.  <br /></td></tr>
<tr class="separator:a721beb80f0d071295cd4db4d8aac1b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f287ca945cb62e9550aff50759528c" id="r_a22f287ca945cb62e9550aff50759528c"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a22f287ca945cb62e9550aff50759528c">la_lapack_s::la_sgelqt3</a> (m, n, a, lda, t, ldt, info)</td></tr>
<tr class="memdesc:a22f287ca945cb62e9550aff50759528c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGELQT3: recursively computes a LQ factorization of a real M-by-N matrix A, using the compact WY representation of Q. Based on the algorithm of Elmroth and Gustavson, IBM J. Res. Develop. Vol 44 No. 4 July 2000.  <br /></td></tr>
<tr class="separator:a22f287ca945cb62e9550aff50759528c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad0a37ba786ad0177cf207186b81345" id="r_a0ad0a37ba786ad0177cf207186b81345"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0ad0a37ba786ad0177cf207186b81345">la_lapack_s::la_sgeql2</a> (m, n, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a0ad0a37ba786ad0177cf207186b81345"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQL2: computes a QL factorization of a real m by n matrix A: A = Q * L.  <br /></td></tr>
<tr class="separator:a0ad0a37ba786ad0177cf207186b81345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cf5c2d3ee4d45ab7f8239c2b16f5df" id="r_a05cf5c2d3ee4d45ab7f8239c2b16f5df"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a05cf5c2d3ee4d45ab7f8239c2b16f5df">la_lapack_s::la_sgeqlf</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a05cf5c2d3ee4d45ab7f8239c2b16f5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQLF: computes a QL factorization of a real M-by-N matrix A: A = Q * L.  <br /></td></tr>
<tr class="separator:a05cf5c2d3ee4d45ab7f8239c2b16f5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad980098756b1e6a624184516e365ed45" id="r_ad980098756b1e6a624184516e365ed45"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad980098756b1e6a624184516e365ed45">la_lapack_s::la_sgeqr2</a> (m, n, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:ad980098756b1e6a624184516e365ed45"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQR2: computes a QR factorization of a real m-by-n matrix A: A = Q * ( R ), ( 0 ) where: Q is a m-by-m orthogonal matrix; R is an upper-triangular n-by-n matrix; 0 is a (m-n)-by-n zero matrix, if m &gt; n.  <br /></td></tr>
<tr class="separator:ad980098756b1e6a624184516e365ed45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace554156ef38f159c7259eb8097ef7fa" id="r_ace554156ef38f159c7259eb8097ef7fa"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ace554156ef38f159c7259eb8097ef7fa">la_lapack_s::la_sgeqr2p</a> (m, n, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:ace554156ef38f159c7259eb8097ef7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQR2P: computes a QR factorization of a real m-by-n matrix A: A = Q * ( R ), ( 0 ) where: Q is a m-by-m orthogonal matrix; R is an upper-triangular n-by-n matrix with nonnegative diagonal entries; 0 is a (m-n)-by-n zero matrix, if m &gt; n.  <br /></td></tr>
<tr class="separator:ace554156ef38f159c7259eb8097ef7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ec775b671b37193a0422dffb6b684d" id="r_ae4ec775b671b37193a0422dffb6b684d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ae4ec775b671b37193a0422dffb6b684d">la_lapack_s::la_sgeqrf</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:ae4ec775b671b37193a0422dffb6b684d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQRF: computes a QR factorization of a real M-by-N matrix A: A = Q * ( R ), ( 0 ) where: Q is a M-by-M orthogonal matrix; R is an upper-triangular N-by-N matrix; 0 is a (M-N)-by-N zero matrix, if M &gt; N.  <br /></td></tr>
<tr class="separator:ae4ec775b671b37193a0422dffb6b684d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdbe939dfeba96541bb67faa2f3710b" id="r_a1fdbe939dfeba96541bb67faa2f3710b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1fdbe939dfeba96541bb67faa2f3710b">la_lapack_s::la_sgeqrfp</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a1fdbe939dfeba96541bb67faa2f3710b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQR2P computes a QR factorization of a real M-by-N matrix A: A = Q * ( R ), ( 0 ) where: Q is a M-by-M orthogonal matrix; R is an upper-triangular N-by-N matrix with nonnegative diagonal entries; 0 is a (M-N)-by-N zero matrix, if M &gt; N.  <br /></td></tr>
<tr class="separator:a1fdbe939dfeba96541bb67faa2f3710b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24766f809ec15b11de8cff3236acfe2c" id="r_a24766f809ec15b11de8cff3236acfe2c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a24766f809ec15b11de8cff3236acfe2c">la_lapack_s::la_sgeqrt2</a> (m, n, a, lda, t, ldt, info)</td></tr>
<tr class="memdesc:a24766f809ec15b11de8cff3236acfe2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQRT2: computes a QR factorization of a real M-by-N matrix A, using the compact WY representation of Q.  <br /></td></tr>
<tr class="separator:a24766f809ec15b11de8cff3236acfe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9b364c9b9434f6fde52c8969ba3549" id="r_a2d9b364c9b9434f6fde52c8969ba3549"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2d9b364c9b9434f6fde52c8969ba3549">la_lapack_s::la_sgeqrt3</a> (m, n, a, lda, t, ldt, info)</td></tr>
<tr class="memdesc:a2d9b364c9b9434f6fde52c8969ba3549"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQRT3: recursively computes a QR factorization of a real M-by-N matrix A, using the compact WY representation of Q. Based on the algorithm of Elmroth and Gustavson, IBM J. Res. Develop. Vol 44 No. 4 July 2000.  <br /></td></tr>
<tr class="separator:a2d9b364c9b9434f6fde52c8969ba3549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb683575539565716508fba4cb251411" id="r_abb683575539565716508fba4cb251411"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abb683575539565716508fba4cb251411">la_lapack_s::la_sgerfs</a> (trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:abb683575539565716508fba4cb251411"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGERFS: improves the computed solution to a system of linear equations and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:abb683575539565716508fba4cb251411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cff8cd10058f41bb912a786ebe67d1f" id="r_a7cff8cd10058f41bb912a786ebe67d1f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7cff8cd10058f41bb912a786ebe67d1f">la_lapack_s::la_sgerq2</a> (m, n, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a7cff8cd10058f41bb912a786ebe67d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGERQ2: computes an RQ factorization of a real m by n matrix A: A = R * Q.  <br /></td></tr>
<tr class="separator:a7cff8cd10058f41bb912a786ebe67d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99125299ad716550fda38aade31661" id="r_a9a99125299ad716550fda38aade31661"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9a99125299ad716550fda38aade31661">la_lapack_s::la_sgerqf</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a9a99125299ad716550fda38aade31661"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGERQF: computes an RQ factorization of a real M-by-N matrix A: A = R * Q.  <br /></td></tr>
<tr class="separator:a9a99125299ad716550fda38aade31661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa202cc3caf2158b910f972bb794d3c10" id="r_aa202cc3caf2158b910f972bb794d3c10"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa202cc3caf2158b910f972bb794d3c10">la_lapack_s::la_sgetrf</a> (m, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:aa202cc3caf2158b910f972bb794d3c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETRF: computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n). This is the right-looking Level 3 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:aa202cc3caf2158b910f972bb794d3c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c11f620a88431ddae94a520081e9fa" id="r_a93c11f620a88431ddae94a520081e9fa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a93c11f620a88431ddae94a520081e9fa">la_lapack_s::la_sgghd3</a> (compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork, info)</td></tr>
<tr class="memdesc:a93c11f620a88431ddae94a520081e9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGHD3: reduces a pair of real matrices (A,B) to generalized upper Hessenberg form using orthogonal transformations, where A is a general matrix and B is upper triangular. The form of the generalized eigenvalue problem is A*x = lambda*B*x, and B is typically made upper triangular by computing its QR factorization and moving the orthogonal matrix Q to the left side of the equation. This subroutine simultaneously reduces A to a Hessenberg matrix H: Q**T*A*Z = H and transforms B to another upper triangular matrix T: Q**T*B*Z = T in order to reduce the problem to its standard form H*y = lambda*T*y where y = Z**T*x. The orthogonal matrices Q and Z are determined as products of Givens rotations. They may either be formed explicitly, or they may be postmultiplied into input matrices Q1 and Z1, so that Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T If Q1 is the orthogonal matrix from the QR factorization of B in the original equation A*x = lambda*B*x, then SGGHD3 reduces the original problem to generalized Hessenberg form. This is a blocked variant of SGGHRD, using matrix-matrix multiplications for parts of the computation to enhance performance.  <br /></td></tr>
<tr class="separator:a93c11f620a88431ddae94a520081e9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9d2f9c0561d0c4a9b7fbf22d85cffc" id="r_a4d9d2f9c0561d0c4a9b7fbf22d85cffc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4d9d2f9c0561d0c4a9b7fbf22d85cffc">la_lapack_s::la_sggqrf</a> (n, m, p, a, lda, taua, b, ldb, taub, work, lwork, info)</td></tr>
<tr class="memdesc:a4d9d2f9c0561d0c4a9b7fbf22d85cffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGQRF: computes a generalized QR factorization of an N-by-M matrix A and an N-by-P matrix B: A = Q*R, B = Q*T*Z, where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal matrix, and R and T assume one of the forms: if N &gt;= M, R = ( R11 ) M , or if N &lt; M, R = ( R11 R12 ) N, ( 0 ) N-M N M-N M where R11 is upper triangular, and if N &lt;= P, T = ( 0 T12 ) N, or if N &gt; P, T = ( T11 ) N-P, P-N N ( T21 ) P P where T12 or T21 is upper triangular. In particular, if B is square and nonsingular, the GQR factorization of A and B implicitly gives the QR factorization of inv(B)*A: inv(B)*A = Z**T*(inv(T)*R) where inv(B) denotes the inverse of the matrix B, and Z**T denotes the transpose of the matrix Z.  <br /></td></tr>
<tr class="separator:a4d9d2f9c0561d0c4a9b7fbf22d85cffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea9a71f41b96f07dc12505649a468ba" id="r_aaea9a71f41b96f07dc12505649a468ba"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aaea9a71f41b96f07dc12505649a468ba">la_lapack_s::la_sggrqf</a> (m, p, n, a, lda, taua, b, ldb, taub, work, lwork, info)</td></tr>
<tr class="memdesc:aaea9a71f41b96f07dc12505649a468ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGRQF: computes a generalized RQ factorization of an M-by-N matrix A and a P-by-N matrix B: A = R*Q, B = Z*T*Q, where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal matrix, and R and T assume one of the forms: if M &lt;= N, R = ( 0 R12 ) M, or if M &gt; N, R = ( R11 ) M-N, N-M M ( R21 ) N N where R12 or R21 is upper triangular, and if P &gt;= N, T = ( T11 ) N , or if P &lt; N, T = ( T11 T12 ) P, ( 0 ) P-N P N-P N where T11 is upper triangular. In particular, if B is square and nonsingular, the GRQ factorization of A and B implicitly gives the RQ factorization of A*inv(B): A*inv(B) = (R*inv(T))*Z**T where inv(B) denotes the inverse of the matrix B, and Z**T denotes the transpose of the matrix Z.  <br /></td></tr>
<tr class="separator:aaea9a71f41b96f07dc12505649a468ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93aa73ada84c6514dce302fab217be66" id="r_a93aa73ada84c6514dce302fab217be66"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a93aa73ada84c6514dce302fab217be66">la_lapack_s::la_sgtcon</a> (norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork, info)</td></tr>
<tr class="memdesc:a93aa73ada84c6514dce302fab217be66"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGTCON: estimates the reciprocal of the condition number of a real tridiagonal matrix A using the LU factorization as computed by SGTTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a93aa73ada84c6514dce302fab217be66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e83e9cf2315c5a725308155863bcba6" id="r_a6e83e9cf2315c5a725308155863bcba6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a6e83e9cf2315c5a725308155863bcba6">la_lapack_s::la_sgtrfs</a> (trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:a6e83e9cf2315c5a725308155863bcba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGTRFS: improves the computed solution to a system of linear equations when the coefficient matrix is tridiagonal, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:a6e83e9cf2315c5a725308155863bcba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06669a00a7437c098842ef9f2de35eb7" id="r_a06669a00a7437c098842ef9f2de35eb7"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a06669a00a7437c098842ef9f2de35eb7">la_lapack_s::la_sgtsvx</a> (fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:a06669a00a7437c098842ef9f2de35eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGTSVX: uses the LU factorization to compute the solution to a real system of linear equations A * X = B or A**T * X = B, where A is a tridiagonal matrix of order N and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a06669a00a7437c098842ef9f2de35eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53997c215d52ad7a14da8aea2711890b" id="r_a53997c215d52ad7a14da8aea2711890b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a53997c215d52ad7a14da8aea2711890b">la_lapack_s::la_shgeqz</a> (job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork, info)</td></tr>
<tr class="memdesc:a53997c215d52ad7a14da8aea2711890b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHGEQZ: computes the eigenvalues of a real matrix pair (H,T), where H is an upper Hessenberg matrix and T is upper triangular, using the double-shift QZ method. Matrix pairs of this type are produced by the reduction to generalized upper Hessenberg form of a real matrix pair (A,B): A = Q1*H*Z1**T, B = Q1*T*Z1**T, as computed by SGGHRD. If JOB='S', then the Hessenberg-triangular pair (H,T) is also reduced to generalized Schur form, H = Q*S*Z**T, T = Q*P*Z**T, where Q and Z are orthogonal matrices, P is an upper triangular matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2 diagonal blocks. The 1-by-1 blocks correspond to real eigenvalues of the matrix pair (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of eigenvalues. Additionally, the 2-by-2 upper triangular diagonal blocks of P corresponding to 2-by-2 blocks of S are reduced to positive diagonal form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0, P(j,j) &gt; 0, and P(j+1,j+1) &gt; 0. Optionally, the orthogonal matrix Q from the generalized Schur factorization may be postmultiplied into an input matrix Q1, and the orthogonal matrix Z may be postmultiplied into an input matrix Z1. If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced the matrix pair (A,B) to generalized upper Hessenberg form, then the output matrices Q1*Q and Z1*Z are the orthogonal factors from the generalized Schur factorization of (A,B): A = (Q1*Q)*S*(Z1*Z)**T, B = (Q1*Q)*P*(Z1*Z)**T. To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently, of (A,B)) are computed as a pair of values (alpha,beta), where alpha is complex and beta real. If beta is nonzero, lambda = alpha / beta is an eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP) A*x = lambda*B*x and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the alternate form of the GNEP mu*A*y = B*y. Real eigenvalues can be read directly from the generalized Schur form: alpha = S(i,i), beta = P(i,i). Ref: C.B. Moler Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973), pp. 241&ndash;256.  <br /></td></tr>
<tr class="separator:a53997c215d52ad7a14da8aea2711890b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac316cbbad37c025bb097d2cf2f84cf10" id="r_ac316cbbad37c025bb097d2cf2f84cf10"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac316cbbad37c025bb097d2cf2f84cf10">la_lapack_s::la_slabrd</a> (m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y, ldy)</td></tr>
<tr class="memdesc:ac316cbbad37c025bb097d2cf2f84cf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLABRD: reduces the first NB rows and columns of a real general m by n matrix A to upper or lower bidiagonal form by an orthogonal transformation Q**T * A * P, and returns the matrices X and Y which are needed to apply the transformation to the unreduced part of A. If m &gt;= n, A is reduced to upper bidiagonal form; if m &lt; n, to lower bidiagonal form. This is an auxiliary routine called by SGEBRD.  <br /></td></tr>
<tr class="separator:ac316cbbad37c025bb097d2cf2f84cf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98aeb3fda13e720406014580920e7f9" id="r_ad98aeb3fda13e720406014580920e7f9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad98aeb3fda13e720406014580920e7f9">la_lapack_s::la_sladiv</a> (a, b, c, d, p, q)</td></tr>
<tr class="memdesc:ad98aeb3fda13e720406014580920e7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLADIV: performs complex division in real arithmetic a + i*b p + i*q = ------&mdash; c + i*d The algorithm is due to Michael Baudin and Robert L. Smith and can be found in the paper "A Robust Complex Division in Scilab".  <br /></td></tr>
<tr class="separator:ad98aeb3fda13e720406014580920e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8c71deea73b764aeacae152d7c49c9" id="r_acd8c71deea73b764aeacae152d7c49c9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#acd8c71deea73b764aeacae152d7c49c9">la_lapack_s::la_slaed4</a> (n, i, d, z, delta, rho, dlam, info)</td></tr>
<tr class="memdesc:acd8c71deea73b764aeacae152d7c49c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine computes the I-th updated eigenvalue of a symmetric rank-one modification to a diagonal matrix whose elements are given in the array d, and that D(i) &lt; D(j) for i &lt; j and that RHO &gt; 0. This is arranged by the calling routine, and is no loss in generality. The rank-one modified system is thus diag( D ) + RHO * Z * Z_transpose. where we assume the Euclidean norm of Z is 1. The method consists of approximating the rational functions in the secular equation by simpler interpolating rational functions.  <br /></td></tr>
<tr class="separator:acd8c71deea73b764aeacae152d7c49c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a1085484c4fd9899ae7942589945eb" id="r_aa7a1085484c4fd9899ae7942589945eb"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa7a1085484c4fd9899ae7942589945eb">la_lapack_s::la_slaed8</a> (icompq, k, n, qsiz, d, q, ldq, indxq, rho, cutpnt, z, dlamda, q2, ldq2, w, perm, givptr, givcol, givnum, indxp, indx, info)</td></tr>
<tr class="memdesc:aa7a1085484c4fd9899ae7942589945eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAED8: merges the two sets of eigenvalues together into a single sorted set. Then it tries to deflate the size of the problem. There are two ways in which deflation can occur: when two or more eigenvalues are close together or if there is a tiny element in the Z vector. For each such occurrence the order of the related secular equation problem is reduced by one.  <br /></td></tr>
<tr class="separator:aa7a1085484c4fd9899ae7942589945eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9067c069be55dc35ecdf58d4628d2b" id="r_a3b9067c069be55dc35ecdf58d4628d2b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3b9067c069be55dc35ecdf58d4628d2b">la_lapack_s::la_slaed9</a> (k, kstart, kstop, n, d, q, ldq, rho, dlamda, w, s, lds, info)</td></tr>
<tr class="memdesc:a3b9067c069be55dc35ecdf58d4628d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAED9: finds the roots of the secular equation, as defined by the values in D, Z, and RHO, between KSTART and KSTOP. It makes the appropriate calls to SLAED4 and then stores the new matrix of eigenvectors for use in calculating the next level of Z vectors.  <br /></td></tr>
<tr class="separator:a3b9067c069be55dc35ecdf58d4628d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac169eab6eb32b91f24e1d55d94d108d8" id="r_ac169eab6eb32b91f24e1d55d94d108d8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac169eab6eb32b91f24e1d55d94d108d8">la_lapack_s::la_slaein</a> (rightv, noinit, n, h, ldh, wr, wi, vr, vi, b, ldb, work, eps3, smlnum, bignum, info)</td></tr>
<tr class="memdesc:ac169eab6eb32b91f24e1d55d94d108d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAEIN: uses inverse iteration to find a right or left eigenvector corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg matrix H.  <br /></td></tr>
<tr class="separator:ac169eab6eb32b91f24e1d55d94d108d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af845c5c9884b4522c7615ad61041d674" id="r_af845c5c9884b4522c7615ad61041d674"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af845c5c9884b4522c7615ad61041d674">la_lapack_s::la_slagv2</a> (a, lda, b, ldb, alphar, alphai, beta, csl, snl, csr, snr)</td></tr>
<tr class="memdesc:af845c5c9884b4522c7615ad61041d674"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAGV2: computes the Generalized Schur factorization of a real 2-by-2 matrix pencil (A,B) where B is upper triangular. This routine computes orthogonal (rotation) matrices given by CSL, SNL and CSR, SNR such that 1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0 types), then [ a11 a12 ] := [ CSL SNL ] [ a11 a12 ] [ CSR -SNR ] [ 0 a22 ] [ -SNL CSL ] [ a21 a22 ] [ SNR CSR ] [ b11 b12 ] := [ CSL SNL ] [ b11 b12 ] [ CSR -SNR ] [ 0 b22 ] [ -SNL CSL ] [ 0 b22 ] [ SNR CSR ], 2) if the pencil (A,B) has a pair of complex conjugate eigenvalues, then [ a11 a12 ] := [ CSL SNL ] [ a11 a12 ] [ CSR -SNR ] [ a21 a22 ] [ -SNL CSL ] [ a21 a22 ] [ SNR CSR ] [ b11 0 ] := [ CSL SNL ] [ b11 b12 ] [ CSR -SNR ] [ 0 b22 ] [ -SNL CSL ] [ 0 b22 ] [ SNR CSR ] where b11 &gt;= b22 &gt; 0.  <br /></td></tr>
<tr class="separator:af845c5c9884b4522c7615ad61041d674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792b0f88561ca84ba7993ed596066c31" id="r_a792b0f88561ca84ba7993ed596066c31"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a792b0f88561ca84ba7993ed596066c31">la_lapack_s::la_slahr2</a> (n, k, nb, a, lda, tau, t, ldt, y, ldy)</td></tr>
<tr class="memdesc:a792b0f88561ca84ba7993ed596066c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAHR2: reduces the first NB columns of A real general n-BY-(n-k+1) matrix A so that elements below the k-th subdiagonal are zero. The reduction is performed by an orthogonal similarity transformation Q**T * A * Q. The routine returns the matrices V and T which determine Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T. This is an auxiliary routine called by SGEHRD.  <br /></td></tr>
<tr class="separator:a792b0f88561ca84ba7993ed596066c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4cfb776339618f06749826b76fd421" id="r_a0e4cfb776339618f06749826b76fd421"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0e4cfb776339618f06749826b76fd421">la_lapack_s::la_slaln2</a> (ltrans, na, nw, smin, ca, a, lda, d1, d2, b, ldb, wr, wi, x, ldx, scale, xnorm, info)</td></tr>
<tr class="memdesc:a0e4cfb776339618f06749826b76fd421"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLALN2: solves a system of the form (ca A - w D ) X = s B or (ca A**T - w D) X = s B with possible scaling ("s") and perturbation of A. (A**T means A-transpose.) A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA real diagonal matrix, w is a real or complex value, and X and B are NA x 1 matrices &ndash; real if w is real, complex if w is complex. NA may be 1 or 2. If w is complex, X and B are represented as NA x 2 matrices, the first column of each being the real part and the second being the imaginary part. "s" is a scaling factor (&lt;= 1), computed by SLALN2, which is so chosen that X can be computed without overflow. X is further scaled if necessary to assure that norm(ca A - w D)*norm(X) is less than overflow. If both singular values of (ca A - w D) are less than SMIN, SMIN*identity will be used instead of (ca A - w D). If only one singular value is less than SMIN, one element of (ca A - w D) will be perturbed enough to make the smallest singular value roughly SMIN. If both singular values are at least SMIN, (ca A - w D) will not be perturbed. In any case, the perturbation will be at most some small multiple of max( SMIN, ulp*norm(ca A - w D) ). The singular values are computed by infinity-norm approximations, and thus will only be correct to a factor of 2 or so. Note: all input quantities are assumed to be smaller than overflow by a reasonable factor. (See BIGNUM.)  <br /></td></tr>
<tr class="separator:a0e4cfb776339618f06749826b76fd421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b14f8474302c0473cef0cfc8bb4bba" id="r_a56b14f8474302c0473cef0cfc8bb4bba"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a56b14f8474302c0473cef0cfc8bb4bba">la_lapack_s::la_slals0</a> (icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx, perm, givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z, k, c, s, work, info)</td></tr>
<tr class="memdesc:a56b14f8474302c0473cef0cfc8bb4bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLALS0: applies back the multiplying factors of either the left or the right singular vector matrix of a diagonal matrix appended by a row to the right hand side matrix B in solving the least squares problem using the divide-and-conquer SVD approach. For the left singular vector matrix, three types of orthogonal matrices are involved: (1L) Givens rotations: the number of such rotations is GIVPTR; the pairs of columns/rows they were applied to are stored in GIVCOL; and the C- and S-values of these rotations are stored in GIVNUM. (2L) Permutation. The (NL+1)-st row of B is to be moved to the first row, and for J=2:N, PERM(J)-th row of B is to be moved to the J-th row. (3L) The left singular vector matrix of the remaining matrix. For the right singular vector matrix, four types of orthogonal matrices are involved: (1R) The right singular vector matrix of the remaining matrix. (2R) If SQRE = 1, one extra Givens rotation to generate the right null space. (3R) The inverse transformation of (2L). (4R) The inverse transformation of (1L).  <br /></td></tr>
<tr class="separator:a56b14f8474302c0473cef0cfc8bb4bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4a3e29c1f59649a6e7179edbd496d0" id="r_a9d4a3e29c1f59649a6e7179edbd496d0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9d4a3e29c1f59649a6e7179edbd496d0">la_lapack_s::la_slamswlq</a> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a9d4a3e29c1f59649a6e7179edbd496d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAMSWLQ: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix defined as the product of blocked elementary reflectors computed by short wide LQ factorization (SLASWLQ)  <br /></td></tr>
<tr class="separator:a9d4a3e29c1f59649a6e7179edbd496d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04973119a636cc2688274fa233500774" id="r_a04973119a636cc2688274fa233500774"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a04973119a636cc2688274fa233500774">la_lapack_s::la_slamtsqr</a> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a04973119a636cc2688274fa233500774"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAMTSQR: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix defined as the product of blocked elementary reflectors computed by tall skinny QR factorization (SLATSQR)  <br /></td></tr>
<tr class="separator:a04973119a636cc2688274fa233500774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624b6bcc941f0e0c25cf8585878a3e6c" id="r_a624b6bcc941f0e0c25cf8585878a3e6c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a624b6bcc941f0e0c25cf8585878a3e6c">la_lapack_s::la_slanv2</a> (a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn)</td></tr>
<tr class="memdesc:a624b6bcc941f0e0c25cf8585878a3e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLANV2: computes the Schur factorization of a real 2-by-2 nonsymmetric matrix in standard form: [ A B ] = [ CS -SN ] [ AA BB ] [ CS SN ] [ C D ] [ SN CS ] [ CC DD ] [-SN CS ] where either 1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or 2) AA = DD and BB*CC &lt; 0, so that AA + or - sqrt(BB*CC) are complex conjugate eigenvalues.  <br /></td></tr>
<tr class="separator:a624b6bcc941f0e0c25cf8585878a3e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af168a136abe81d226254ca0be0a90539" id="r_af168a136abe81d226254ca0be0a90539"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af168a136abe81d226254ca0be0a90539">la_lapack_s::la_slapll</a> (n, x, incx, y, incy, ssmin)</td></tr>
<tr class="memdesc:af168a136abe81d226254ca0be0a90539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two column vectors X and Y, let A = ( X Y ). The subroutine first computes the QR factorization of A = Q*R, and then computes the SVD of the 2-by-2 upper triangular matrix R. The smaller singular value of R is returned in SSMIN, which is used as the measurement of the linear dependency of the vectors X and Y.  <br /></td></tr>
<tr class="separator:af168a136abe81d226254ca0be0a90539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9feaa614d185a4222a07e6659e514b" id="r_afe9feaa614d185a4222a07e6659e514b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#afe9feaa614d185a4222a07e6659e514b">la_lapack_s::la_slaqp2</a> (m, n, offset, a, lda, jpvt, tau, vn1, vn2, work)</td></tr>
<tr class="memdesc:afe9feaa614d185a4222a07e6659e514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQP2: computes a QR factorization with column pivoting of the block A(OFFSET+1:M,1:N). The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.  <br /></td></tr>
<tr class="separator:afe9feaa614d185a4222a07e6659e514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff83b99bce6e7e2d03c353cd7866b92" id="r_aaff83b99bce6e7e2d03c353cd7866b92"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aaff83b99bce6e7e2d03c353cd7866b92">la_lapack_s::la_slaqps</a> (m, n, offset, nb, kb, a, lda, jpvt, tau, vn1, vn2, auxv, f, ldf)</td></tr>
<tr class="memdesc:aaff83b99bce6e7e2d03c353cd7866b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQPS: computes a step of QR factorization with column pivoting of a real M-by-N matrix A by using Blas-3. It tries to factorize NB columns from A starting from the row OFFSET+1, and updates all of the matrix with Blas-3 xGEMM. In some cases, due to catastrophic cancellations, it cannot factorize NB columns. Hence, the actual number of factorized columns is returned in KB. Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.  <br /></td></tr>
<tr class="separator:aaff83b99bce6e7e2d03c353cd7866b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3287a59fb1885c3321281ab29ddae491" id="r_a3287a59fb1885c3321281ab29ddae491"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3287a59fb1885c3321281ab29ddae491">la_lapack_s::la_slaqr5</a> (wantt, wantz, kacc22, n, ktop, kbot, nshfts, sr, si, h, ldh, iloz, ihiz, z, ldz, v, ldv, u, ldu, nv, wv, ldwv, nh, wh, ldwh)</td></tr>
<tr class="memdesc:a3287a59fb1885c3321281ab29ddae491"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQR5:, called by SLAQR0, performs a single small-bulge multi-shift QR sweep.  <br /></td></tr>
<tr class="separator:a3287a59fb1885c3321281ab29ddae491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104a0536be55925b1548027e9a00e997" id="r_a104a0536be55925b1548027e9a00e997"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a104a0536be55925b1548027e9a00e997">la_lapack_s::la_slaqtr</a> (ltran, lreal, n, t, ldt, b, w, scale, x, work, info)</td></tr>
<tr class="memdesc:a104a0536be55925b1548027e9a00e997"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQTR: solves the real quasi-triangular system op(T)*p = scale*c, if LREAL = .TRUE. or the complex quasi-triangular systems op(T + iB)*(p+iq) = scale*(c+id), if LREAL = .FALSE. in real arithmetic, where T is upper quasi-triangular. If LREAL = .FALSE., then the first diagonal block of T must be 1 by 1, B is the specially structured matrix B = [ b(1) b(2) ... b(n) ] [ w ] [ w ] [ . ] [ w ] op(A) = A or A**T, A**T denotes the transpose of matrix A. On input, X = [ c ]. On output, X = [ p ]. [ d ] [ q ] This subroutine is designed for the condition number estimation in routine STRSNA.  <br /></td></tr>
<tr class="separator:a104a0536be55925b1548027e9a00e997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb968f5c2511b78fb2768077a04347f" id="r_affb968f5c2511b78fb2768077a04347f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#affb968f5c2511b78fb2768077a04347f">la_lapack_s::la_slasd3</a> (nl, nr, sqre, k, d, q, ldq, dsigma, u, ldu, u2, ldu2, vt, ldvt, vt2, ldvt2, idxc, ctot, z, info)</td></tr>
<tr class="memdesc:affb968f5c2511b78fb2768077a04347f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASD3: finds all the square roots of the roots of the secular equation, as defined by the values in D and Z. It makes the appropriate calls to SLASD4 and then updates the singular vectors by matrix multiplication. This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. SLASD3 is called from SLASD1.  <br /></td></tr>
<tr class="separator:affb968f5c2511b78fb2768077a04347f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed17a4b0e6a51696d57a3b1c96676e3" id="r_a2ed17a4b0e6a51696d57a3b1c96676e3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2ed17a4b0e6a51696d57a3b1c96676e3">la_lapack_s::la_slasd6</a> (icompq, nl, nr, sqre, d, vf, vl, alpha, beta, idxq, perm, givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z, k, c, s, work, iwork, info)</td></tr>
<tr class="memdesc:a2ed17a4b0e6a51696d57a3b1c96676e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASD6: computes the SVD of an updated upper bidiagonal matrix B obtained by merging two smaller ones by appending a row. This routine is used only for the problem which requires all singular values and optionally singular vector matrices in factored form. B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE. A related subroutine, SLASD1, handles the case in which all singular values and singular vectors of the bidiagonal matrix are desired. SLASD6 computes the SVD as follows: ( D1(in) 0 0 0 ) B = U(in) * ( Z1**T a Z2**T b ) * VT(in) ( 0 0 D2(in) 0 ) = U(out) * ( D(out) 0) * VT(out) where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros elsewhere; and the entry b is empty if SQRE = 0. The singular values of B can be computed using D1, D2, the first components of all the right singular vectors of the lower block, and the last components of all the right singular vectors of the upper block. These components are stored and updated in VF and VL, respectively, in SLASD6. Hence U and VT are not explicitly referenced. The singular values are stored in D. The algorithm consists of two stages: The first stage consists of deflating the size of the problem when there are multiple singular values or if there is a zero in the Z vector. For each such occurrence the dimension of the secular equation problem is reduced by one. This stage is performed by the routine SLASD7. The second stage consists of calculating the updated singular values. This is done by finding the roots of the secular equation via the routine SLASD4 (as called by SLASD8). This routine also updates VF and VL and computes the distances between the updated singular values and the old singular values. SLASD6 is called from SLASDA.  <br /></td></tr>
<tr class="separator:a2ed17a4b0e6a51696d57a3b1c96676e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd378df109b39d28d06ae60814281dd" id="r_a7bd378df109b39d28d06ae60814281dd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7bd378df109b39d28d06ae60814281dd">la_lapack_s::la_sopgtr</a> (uplo, n, ap, tau, q, ldq, work, info)</td></tr>
<tr class="memdesc:a7bd378df109b39d28d06ae60814281dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOPGTR: generates a real orthogonal matrix Q which is defined as the product of n-1 elementary reflectors H(i) of order n, as returned by SSPTRD using packed storage: if UPLO = 'U', Q = H(n-1) . . . H(2) H(1), if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).  <br /></td></tr>
<tr class="separator:a7bd378df109b39d28d06ae60814281dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f9e9c560b281af2fa3ce96a23f47cd" id="r_aa1f9e9c560b281af2fa3ce96a23f47cd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa1f9e9c560b281af2fa3ce96a23f47cd">la_lapack_s::la_sopmtr</a> (side, uplo, trans, m, n, ap, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:aa1f9e9c560b281af2fa3ce96a23f47cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOPMTR: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix of order nq, with nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of nq-1 elementary reflectors, as returned by SSPTRD using packed storage: if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1); if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).  <br /></td></tr>
<tr class="separator:aa1f9e9c560b281af2fa3ce96a23f47cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5065fe63c15baef1c2ebaeb47ab309b2" id="r_a5065fe63c15baef1c2ebaeb47ab309b2"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a5065fe63c15baef1c2ebaeb47ab309b2">la_lapack_s::la_sorbdb1</a> (m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info)</td></tr>
<tr class="memdesc:a5065fe63c15baef1c2ebaeb47ab309b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORBDB1: simultaneously bidiagonalizes the blocks of a tall and skinny matrix X with orthonomal columns: [ B11 ] [ X11 ] [ P1 | ] [ 0 ] [--&mdash;] = [------&mdash;] [--&mdash;] Q1**T . [ X21 ] [ | P2 ] [ B21 ] [ 0 ] X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P, M-P, or M-Q. Routines SORBDB2, SORBDB3, and SORBDB4 handle cases in which Q is not the minimum dimension. The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P), and (M-Q)-by-(M-Q), respectively. They are represented implicitly by Householder vectors. B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by angles THETA, PHI.  <br /></td></tr>
<tr class="separator:a5065fe63c15baef1c2ebaeb47ab309b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50381b2a0e81b2a8140fd46b022756b9" id="r_a50381b2a0e81b2a8140fd46b022756b9"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a50381b2a0e81b2a8140fd46b022756b9">la_lapack_s::la_sorbdb2</a> (m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info)</td></tr>
<tr class="memdesc:a50381b2a0e81b2a8140fd46b022756b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORBDB2: simultaneously bidiagonalizes the blocks of a tall and skinny matrix X with orthonomal columns: [ B11 ] [ X11 ] [ P1 | ] [ 0 ] [--&mdash;] = [------&mdash;] [--&mdash;] Q1**T . [ X21 ] [ | P2 ] [ B21 ] [ 0 ] X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P, Q, or M-Q. Routines SORBDB1, SORBDB3, and SORBDB4 handle cases in which P is not the minimum dimension. The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P), and (M-Q)-by-(M-Q), respectively. They are represented implicitly by Householder vectors. B11 and B12 are P-by-P bidiagonal matrices represented implicitly by angles THETA, PHI.  <br /></td></tr>
<tr class="separator:a50381b2a0e81b2a8140fd46b022756b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af54ba2339d6e16ea1c09fd9a01064e" id="r_a2af54ba2339d6e16ea1c09fd9a01064e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2af54ba2339d6e16ea1c09fd9a01064e">la_lapack_s::la_sorbdb3</a> (m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info)</td></tr>
<tr class="memdesc:a2af54ba2339d6e16ea1c09fd9a01064e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORBDB3: simultaneously bidiagonalizes the blocks of a tall and skinny matrix X with orthonomal columns: [ B11 ] [ X11 ] [ P1 | ] [ 0 ] [--&mdash;] = [------&mdash;] [--&mdash;] Q1**T . [ X21 ] [ | P2 ] [ B21 ] [ 0 ] X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P, Q, or M-Q. Routines SORBDB1, SORBDB2, and SORBDB4 handle cases in which M-P is not the minimum dimension. The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P), and (M-Q)-by-(M-Q), respectively. They are represented implicitly by Householder vectors. B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented implicitly by angles THETA, PHI.  <br /></td></tr>
<tr class="separator:a2af54ba2339d6e16ea1c09fd9a01064e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9681d4798e4b43e1471b1480968587b5" id="r_a9681d4798e4b43e1471b1480968587b5"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9681d4798e4b43e1471b1480968587b5">la_lapack_s::la_sorbdb4</a> (m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, phantom, work, lwork, info)</td></tr>
<tr class="memdesc:a9681d4798e4b43e1471b1480968587b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORBDB4: simultaneously bidiagonalizes the blocks of a tall and skinny matrix X with orthonomal columns: [ B11 ] [ X11 ] [ P1 | ] [ 0 ] [--&mdash;] = [------&mdash;] [--&mdash;] Q1**T . [ X21 ] [ | P2 ] [ B21 ] [ 0 ] X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P, M-P, or Q. Routines SORBDB1, SORBDB2, and SORBDB3 handle cases in which M-Q is not the minimum dimension. The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P), and (M-Q)-by-(M-Q), respectively. They are represented implicitly by Householder vectors. B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented implicitly by angles THETA, PHI.  <br /></td></tr>
<tr class="separator:a9681d4798e4b43e1471b1480968587b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb5bff702f634f5ab9f1ac48610098b" id="r_acfb5bff702f634f5ab9f1ac48610098b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#acfb5bff702f634f5ab9f1ac48610098b">la_lapack_s::la_sorcsd2by1</a> (jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:acfb5bff702f634f5ab9f1ac48610098b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORCSD2BY1: computes the CS decomposition of an M-by-Q matrix X with orthonormal columns that has been partitioned into a 2-by-1 block structure: [ I1 0 0 ] [ 0 C 0 ] [ X11 ] [ U1 | ] [ 0 0 0 ] X = [--&mdash;] = [------&mdash;] [-------&mdash;] V1**T . [ X21 ] [ | U2 ] [ 0 0 0 ] [ 0 S 0 ] [ 0 0 I2] X11 is P-by-Q. The orthogonal matrices U1, U2, and V1 are P-by-P, (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).  <br /></td></tr>
<tr class="separator:acfb5bff702f634f5ab9f1ac48610098b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20fab77cffac1f7f040a0b4be7adc2b" id="r_ab20fab77cffac1f7f040a0b4be7adc2b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab20fab77cffac1f7f040a0b4be7adc2b">la_lapack_s::la_sorgtr</a> (uplo, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:ab20fab77cffac1f7f040a0b4be7adc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGTR: generates a real orthogonal matrix Q which is defined as the product of n-1 elementary reflectors of order N, as returned by SSYTRD: if UPLO = 'U', Q = H(n-1) . . . H(2) H(1), if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).  <br /></td></tr>
<tr class="separator:ab20fab77cffac1f7f040a0b4be7adc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8854d1a05d228bade8375b2ed3c9e3" id="r_a2c8854d1a05d228bade8375b2ed3c9e3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2c8854d1a05d228bade8375b2ed3c9e3">la_lapack_s::la_sorgtsqr</a> (m, n, mb, nb, a, lda, t, ldt, work, lwork, info)</td></tr>
<tr class="memdesc:a2c8854d1a05d228bade8375b2ed3c9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGTSQR: generates an M-by-N real matrix Q_out with orthonormal columns, which are the first N columns of a product of real orthogonal matrices of order M which are returned by SLATSQR Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ). See the documentation for SLATSQR.  <br /></td></tr>
<tr class="separator:a2c8854d1a05d228bade8375b2ed3c9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7a97e6052e8cdb71022c0c02e43107" id="r_a4d7a97e6052e8cdb71022c0c02e43107"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4d7a97e6052e8cdb71022c0c02e43107">la_lapack_s::la_sormtr</a> (side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a4d7a97e6052e8cdb71022c0c02e43107"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMTR: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix of order nq, with nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of nq-1 elementary reflectors, as returned by SSYTRD: if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1); if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).  <br /></td></tr>
<tr class="separator:a4d7a97e6052e8cdb71022c0c02e43107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221886237cbe6249cee1eccbac251583" id="r_a221886237cbe6249cee1eccbac251583"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a221886237cbe6249cee1eccbac251583">la_lapack_s::la_spbtrf</a> (uplo, n, kd, ab, ldab, info)</td></tr>
<tr class="memdesc:a221886237cbe6249cee1eccbac251583"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPBTRF: computes the Cholesky factorization of a real symmetric positive definite band matrix A. The factorization has the form A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular.  <br /></td></tr>
<tr class="separator:a221886237cbe6249cee1eccbac251583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeb17174a55233e2c3f6c2122350138" id="r_aefeb17174a55233e2c3f6c2122350138"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aefeb17174a55233e2c3f6c2122350138">la_lapack_s::la_spftri</a> (transr, uplo, n, a, info)</td></tr>
<tr class="memdesc:aefeb17174a55233e2c3f6c2122350138"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPFTRI: computes the inverse of a real (symmetric) positive definite matrix A using the Cholesky factorization A = U**T*U or A = L*L**T computed by SPFTRF.  <br /></td></tr>
<tr class="separator:aefeb17174a55233e2c3f6c2122350138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024fe719e5cfb08511ba6240720d0ad1" id="r_a024fe719e5cfb08511ba6240720d0ad1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a024fe719e5cfb08511ba6240720d0ad1">la_lapack_s::la_spotrf</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:a024fe719e5cfb08511ba6240720d0ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPOTRF: computes the Cholesky factorization of a real symmetric positive definite matrix A. The factorization has the form A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular. This is the block version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a024fe719e5cfb08511ba6240720d0ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe653fdecf6271dbd6a87a45c129cb4f" id="r_abe653fdecf6271dbd6a87a45c129cb4f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abe653fdecf6271dbd6a87a45c129cb4f">la_lapack_s::la_sptrfs</a> (n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, info)</td></tr>
<tr class="memdesc:abe653fdecf6271dbd6a87a45c129cb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPTRFS: improves the computed solution to a system of linear equations when the coefficient matrix is symmetric positive definite and tridiagonal, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:abe653fdecf6271dbd6a87a45c129cb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1dce08e8214c3dbb67fd3a4a68d220" id="r_aef1dce08e8214c3dbb67fd3a4a68d220"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aef1dce08e8214c3dbb67fd3a4a68d220">la_lapack_s::la_sptsv</a> (n, nrhs, d, e, b, ldb, info)</td></tr>
<tr class="memdesc:aef1dce08e8214c3dbb67fd3a4a68d220"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPTSV: computes the solution to a real system of linear equations A*X = B, where A is an N-by-N symmetric positive definite tridiagonal matrix, and X and B are N-by-NRHS matrices. A is factored as A = L*D*L**T, and the factored form of A is then used to solve the system of equations.  <br /></td></tr>
<tr class="separator:aef1dce08e8214c3dbb67fd3a4a68d220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92fe591e225d7599699e7a6ee2817c1" id="r_ad92fe591e225d7599699e7a6ee2817c1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad92fe591e225d7599699e7a6ee2817c1">la_lapack_s::la_sptsvx</a> (fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, info)</td></tr>
<tr class="memdesc:ad92fe591e225d7599699e7a6ee2817c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPTSVX: uses the factorization A = L*D*L**T to compute the solution to a real system of linear equations A*X = B, where A is an N-by-N symmetric positive definite tridiagonal matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:ad92fe591e225d7599699e7a6ee2817c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed56a773e0404ae25b2b3556d4753a0d" id="r_aed56a773e0404ae25b2b3556d4753a0d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aed56a773e0404ae25b2b3556d4753a0d">la_lapack_s::la_ssbev</a> (jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, info)</td></tr>
<tr class="memdesc:aed56a773e0404ae25b2b3556d4753a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSBEV: computes all the eigenvalues and, optionally, eigenvectors of a real symmetric band matrix A.  <br /></td></tr>
<tr class="separator:aed56a773e0404ae25b2b3556d4753a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba7457e9e5bb12d47ad5466402c725" id="r_ac5ba7457e9e5bb12d47ad5466402c725"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac5ba7457e9e5bb12d47ad5466402c725">la_lapack_s::la_ssbevx</a> (jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info)</td></tr>
<tr class="memdesc:ac5ba7457e9e5bb12d47ad5466402c725"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSBEVX: computes selected eigenvalues and, optionally, eigenvectors of a real symmetric band matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:ac5ba7457e9e5bb12d47ad5466402c725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e65df066857197d6fb725c1c20c603" id="r_a41e65df066857197d6fb725c1c20c603"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a41e65df066857197d6fb725c1c20c603">la_lapack_s::la_ssbgv</a> (jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, info)</td></tr>
<tr class="memdesc:a41e65df066857197d6fb725c1c20c603"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSBGV: computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite banded eigenproblem, of the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and banded, and B is also positive definite.  <br /></td></tr>
<tr class="separator:a41e65df066857197d6fb725c1c20c603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34d3f2b4ed125a218d2fd9048a900c9" id="r_af34d3f2b4ed125a218d2fd9048a900c9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af34d3f2b4ed125a218d2fd9048a900c9">la_lapack_s::la_ssbgvx</a> (jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info)</td></tr>
<tr class="memdesc:af34d3f2b4ed125a218d2fd9048a900c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSBGVX: computes selected eigenvalues, and optionally, eigenvectors of a real generalized symmetric-definite banded eigenproblem, of the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and banded, and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either all eigenvalues, a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:af34d3f2b4ed125a218d2fd9048a900c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43110e926ea98cb8841b90f783db6b4e" id="r_a43110e926ea98cb8841b90f783db6b4e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a43110e926ea98cb8841b90f783db6b4e">la_lapack_s::la_sspev</a> (jobz, uplo, n, ap, w, z, ldz, work, info)</td></tr>
<tr class="memdesc:a43110e926ea98cb8841b90f783db6b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPEV: computes all the eigenvalues and, optionally, eigenvectors of a real symmetric matrix A in packed storage.  <br /></td></tr>
<tr class="separator:a43110e926ea98cb8841b90f783db6b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a06ec36fbe719c1b4304bff7d7167d" id="r_a15a06ec36fbe719c1b4304bff7d7167d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a15a06ec36fbe719c1b4304bff7d7167d">la_lapack_s::la_sspevx</a> (jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info)</td></tr>
<tr class="memdesc:a15a06ec36fbe719c1b4304bff7d7167d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPEVX: computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A in packed storage. Eigenvalues/vectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:a15a06ec36fbe719c1b4304bff7d7167d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048602330b7b26261b8b1b103c361438" id="r_a048602330b7b26261b8b1b103c361438"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a048602330b7b26261b8b1b103c361438">la_lapack_s::la_sspgv</a> (itype, jobz, uplo, n, ap, bp, w, z, ldz, work, info)</td></tr>
<tr class="memdesc:a048602330b7b26261b8b1b103c361438"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPGV: computes all the eigenvalues and, optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric, stored in packed format, and B is also positive definite.  <br /></td></tr>
<tr class="separator:a048602330b7b26261b8b1b103c361438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74435863b37835155b45a2d279030301" id="r_a74435863b37835155b45a2d279030301"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a74435863b37835155b45a2d279030301">la_lapack_s::la_sspgvx</a> (itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info)</td></tr>
<tr class="memdesc:a74435863b37835155b45a2d279030301"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPGVX: computes selected eigenvalues, and optionally, eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric, stored in packed storage, and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:a74435863b37835155b45a2d279030301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fe12d90ebe9ffd72db5ec888449e4d" id="r_a76fe12d90ebe9ffd72db5ec888449e4d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a76fe12d90ebe9ffd72db5ec888449e4d">la_lapack_s::la_ssyev</a> (jobz, uplo, n, a, lda, w, work, lwork, info)</td></tr>
<tr class="memdesc:a76fe12d90ebe9ffd72db5ec888449e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEV: computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A.  <br /></td></tr>
<tr class="separator:a76fe12d90ebe9ffd72db5ec888449e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a28e7569dceb376eb589ce142ee3d2" id="r_ad1a28e7569dceb376eb589ce142ee3d2"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad1a28e7569dceb376eb589ce142ee3d2">la_lapack_s::la_ssyevx</a> (jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info)</td></tr>
<tr class="memdesc:ad1a28e7569dceb376eb589ce142ee3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEVX: computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:ad1a28e7569dceb376eb589ce142ee3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3820e6c92681ae89b6de234a7c3a91eb" id="r_a3820e6c92681ae89b6de234a7c3a91eb"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3820e6c92681ae89b6de234a7c3a91eb">la_lapack_s::la_ssygv</a> (itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, info)</td></tr>
<tr class="memdesc:a3820e6c92681ae89b6de234a7c3a91eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYGV: computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric and B is also positive definite.  <br /></td></tr>
<tr class="separator:a3820e6c92681ae89b6de234a7c3a91eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c60fef538d70162a3079c65000f4ba" id="r_a44c60fef538d70162a3079c65000f4ba"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a44c60fef538d70162a3079c65000f4ba">la_lapack_s::la_ssygvx</a> (itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info)</td></tr>
<tr class="memdesc:a44c60fef538d70162a3079c65000f4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYGVX: computes selected eigenvalues, and optionally, eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:a44c60fef538d70162a3079c65000f4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fac495798555a3c6aba5baf023765e7" id="r_a0fac495798555a3c6aba5baf023765e7"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0fac495798555a3c6aba5baf023765e7">la_lapack_s::la_ssysv</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a0fac495798555a3c6aba5baf023765e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYSV: computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices. The diagonal pivoting method is used to factor A as A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a0fac495798555a3c6aba5baf023765e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15de0ab371c87c5573d07e1e83481ce4" id="r_a15de0ab371c87c5573d07e1e83481ce4"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a15de0ab371c87c5573d07e1e83481ce4">la_lapack_s::la_ssysvx</a> (fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:a15de0ab371c87c5573d07e1e83481ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYSVX: uses the diagonal pivoting factorization to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a15de0ab371c87c5573d07e1e83481ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c487c9e1c0beb7c1d53fa9551d9c4d1" id="r_a1c487c9e1c0beb7c1d53fa9551d9c4d1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1c487c9e1c0beb7c1d53fa9551d9c4d1">la_lapack_s::la_ssytrd_sy2sb</a> (uplo, n, kd, a, lda, ab, ldab, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a1c487c9e1c0beb7c1d53fa9551d9c4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRD_SY2SB: reduces a real symmetric matrix A to real symmetric band-diagonal form AB by a orthogonal similarity transformation: Q**T * A * Q = AB.  <br /></td></tr>
<tr class="separator:a1c487c9e1c0beb7c1d53fa9551d9c4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21becd8e197dd4df2adab4e3d1bbfe8e" id="r_a21becd8e197dd4df2adab4e3d1bbfe8e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a21becd8e197dd4df2adab4e3d1bbfe8e">la_lapack_s::la_stgevc</a> (side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, info)</td></tr>
<tr class="memdesc:a21becd8e197dd4df2adab4e3d1bbfe8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">STGEVC: computes some or all of the right and/or left eigenvectors of a pair of real matrices (S,P), where S is a quasi-triangular matrix and P is upper triangular. Matrix pairs of this type are produced by the generalized Schur factorization of a matrix pair (A,B): A = Q*S*Z**T, B = Q*P*Z**T as computed by SGGHRD + SHGEQZ. The right eigenvector x and the left eigenvector y of (S,P) corresponding to an eigenvalue w are defined by: S*x = w*P*x, (y**H)*S = w*(y**H)*P, where y**H denotes the conjugate tranpose of y. The eigenvalues are not input to this routine, but are computed directly from the diagonal blocks of S and P. This routine returns the matrices X and/or Y of right and left eigenvectors of (S,P), or the products Z*X and/or Q*Y, where Z and Q are input matrices. If Q and Z are the orthogonal factors from the generalized Schur factorization of a matrix pair (A,B), then Z*X and Q*Y are the matrices of right and left eigenvectors of (A,B).  <br /></td></tr>
<tr class="separator:a21becd8e197dd4df2adab4e3d1bbfe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dbaa703a155a40458730782c4f996d" id="r_a46dbaa703a155a40458730782c4f996d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a46dbaa703a155a40458730782c4f996d">la_lapack_s::la_stgex2</a> (wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, j1, n1, n2, work, lwork, info)</td></tr>
<tr class="memdesc:a46dbaa703a155a40458730782c4f996d"><td class="mdescLeft">&#160;</td><td class="mdescRight">STGEX2: swaps adjacent diagonal blocks (A11, B11) and (A22, B22) of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair (A, B) by an orthogonal equivalence transformation. (A, B) must be in generalized real Schur canonical form (as returned by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper triangular. Optionally, the matrices Q and Z of generalized Schur vectors are updated. Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T.  <br /></td></tr>
<tr class="separator:a46dbaa703a155a40458730782c4f996d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dd4abbe6f3d5723a0a1f8222616c9f" id="r_a77dd4abbe6f3d5723a0a1f8222616c9f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a77dd4abbe6f3d5723a0a1f8222616c9f">la_lapack_s::la_stgexc</a> (wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, work, lwork, info)</td></tr>
<tr class="memdesc:a77dd4abbe6f3d5723a0a1f8222616c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">STGEXC: reorders the generalized real Schur decomposition of a real matrix pair (A,B) using an orthogonal equivalence transformation (A, B) = Q * (A, B) * Z**T, so that the diagonal block of (A, B) with row index IFST is moved to row ILST. (A, B) must be in generalized real Schur canonical form (as returned by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper triangular. Optionally, the matrices Q and Z of generalized Schur vectors are updated. Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T.  <br /></td></tr>
<tr class="separator:a77dd4abbe6f3d5723a0a1f8222616c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a171c04424491f0f877dfda21eaa661" id="r_a5a171c04424491f0f877dfda21eaa661"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a5a171c04424491f0f877dfda21eaa661">la_lapack_s::la_stgsen</a> (ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a5a171c04424491f0f877dfda21eaa661"><td class="mdescLeft">&#160;</td><td class="mdescRight">STGSEN: reorders the generalized real Schur decomposition of a real matrix pair (A, B) (in terms of an orthonormal equivalence trans- formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper quasi-triangular matrix A and the upper triangular B. The leading columns of Q and Z form orthonormal bases of the corresponding left and right eigen- spaces (deflating subspaces). (A, B) must be in generalized real Schur canonical form (as returned by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper triangular. STGSEN also computes the generalized eigenvalues w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j) of the reordered matrix pair (A, B). Optionally, STGSEN computes the estimates of reciprocal condition numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11), (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s) between the matrix pairs (A11, B11) and (A22,B22) that correspond to the selected cluster and the eigenvalues outside the cluster, resp., and norms of "projections" onto left and right eigenspaces w.r.t. the selected cluster in the (1,1)-block.  <br /></td></tr>
<tr class="separator:a5a171c04424491f0f877dfda21eaa661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613d67786d01a47dfaffe260e9db5d0a" id="r_a613d67786d01a47dfaffe260e9db5d0a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a613d67786d01a47dfaffe260e9db5d0a">la_lapack_s::la_stgsja</a> (jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle, info)</td></tr>
<tr class="memdesc:a613d67786d01a47dfaffe260e9db5d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">STGSJA: computes the generalized singular value decomposition (GSVD) of two real upper triangular (or trapezoidal) matrices A and B. On entry, it is assumed that matrices A and B have the following forms, which may be obtained by the preprocessing subroutine SGGSVP from a general M-by-N matrix A and P-by-N matrix B: N-K-L K L A = K ( 0 A12 A13 ) if M-K-L &gt;= 0; L ( 0 0 A23 ) M-K-L ( 0 0 0 ) N-K-L K L A = K ( 0 A12 A13 ) if M-K-L &lt; 0; M-K ( 0 0 A23 ) N-K-L K L B = L ( 0 0 B13 ) P-L ( 0 0 0 ) where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular upper triangular; A23 is L-by-L upper triangular if M-K-L &gt;= 0, otherwise A23 is (M-K)-by-L upper trapezoidal. On exit, U**T <em>A*Q = D1</em>( 0 R ), V**T <em>B*Q = D2</em>( 0 R ), where U, V and Q are orthogonal matrices. R is a nonsingular upper triangular matrix, and D1 and D2 are `&lsquo;diagonal&rsquo;' matrices, which are of the following structures: If M-K-L &gt;= 0, K L D1 = K ( I 0 ) L ( 0 C ) M-K-L ( 0 0 ) K L D2 = L ( 0 S ) P-L ( 0 0 ) N-K-L K L ( 0 R ) = K ( 0 R11 R12 ) K L ( 0 0 R22 ) L where C = diag( ALPHA(K+1), ... , ALPHA(K+L) ), S = diag( BETA(K+1), ... , BETA(K+L) ), C**2 + S**2 = I. R is stored in A(1:K+L,N-K-L+1:N) on exit. If M-K-L &lt; 0, K M-K K+L-M D1 = K ( I 0 0 ) M-K ( 0 C 0 ) K M-K K+L-M D2 = M-K ( 0 S 0 ) K+L-M ( 0 0 I ) P-L ( 0 0 0 ) N-K-L K M-K K+L-M ( 0 R ) = K ( 0 R11 R12 R13 ) M-K ( 0 0 R22 R23 ) K+L-M ( 0 0 0 R33 ) where C = diag( ALPHA(K+1), ... , ALPHA(M) ), S = diag( BETA(K+1), ... , BETA(M) ), C**2 + S**2 = I. R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored ( 0 R22 R23 ) in B(M-K+1:L,N+M-K-L+1:N) on exit. The computation of the orthogonal transformation matrices U, V or Q is optional. These matrices may either be formed explicitly, or they may be postmultiplied into input matrices U1, V1, or Q1.  <br /></td></tr>
<tr class="separator:a613d67786d01a47dfaffe260e9db5d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a31dcd51e438d5a32305430df955a1" id="r_a06a31dcd51e438d5a32305430df955a1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a06a31dcd51e438d5a32305430df955a1">la_lapack_s::la_stgsna</a> (job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:a06a31dcd51e438d5a32305430df955a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">STGSNA: estimates reciprocal condition numbers for specified eigenvalues and/or eigenvectors of a matrix pair (A, B) in generalized real Schur canonical form (or of any matrix pair (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where Z**T denotes the transpose of Z. (A, B) must be in generalized real Schur form (as returned by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper triangular.  <br /></td></tr>
<tr class="separator:a06a31dcd51e438d5a32305430df955a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041bffce0b09aadd8d1972958d4e28b2" id="r_a041bffce0b09aadd8d1972958d4e28b2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a041bffce0b09aadd8d1972958d4e28b2">la_lapack_s::la_stplqt</a> (m, n, l, mb, a, lda, b, ldb, t, ldt, work, info)</td></tr>
<tr class="memdesc:a041bffce0b09aadd8d1972958d4e28b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPLQT: computes a blocked LQ factorization of a real "triangular-pentagonal" matrix C, which is composed of a triangular block A and pentagonal block B, using the compact WY representation for Q.  <br /></td></tr>
<tr class="separator:a041bffce0b09aadd8d1972958d4e28b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf0f6b3d467d49f9c0b5ea58786acd5" id="r_a5cf0f6b3d467d49f9c0b5ea58786acd5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a5cf0f6b3d467d49f9c0b5ea58786acd5">la_lapack_s::la_stpqrt</a> (m, n, l, nb, a, lda, b, ldb, t, ldt, work, info)</td></tr>
<tr class="memdesc:a5cf0f6b3d467d49f9c0b5ea58786acd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">STPQRT: computes a blocked QR factorization of a real "triangular-pentagonal" matrix C, which is composed of a triangular block A and pentagonal block B, using the compact WY representation for Q.  <br /></td></tr>
<tr class="separator:a5cf0f6b3d467d49f9c0b5ea58786acd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242285af4a4652221797cefbcde79bb9" id="r_a242285af4a4652221797cefbcde79bb9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a242285af4a4652221797cefbcde79bb9">la_lapack_s::la_strevc</a> (side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, info)</td></tr>
<tr class="memdesc:a242285af4a4652221797cefbcde79bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">STREVC: computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T. Matrices of this type are produced by the Schur factorization of a real general matrix: A = Q*T*Q**T, as computed by SHSEQR. The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by: T*x = w*x, (y**H)*T = w*(y**H) where y**H denotes the conjugate transpose of y. The eigenvalues are not input to this routine, but are read directly from the diagonal blocks of T. This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the orthogonal factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.  <br /></td></tr>
<tr class="separator:a242285af4a4652221797cefbcde79bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa298a258c2d3e83cf7acc0fc4fcf10fe" id="r_aa298a258c2d3e83cf7acc0fc4fcf10fe"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa298a258c2d3e83cf7acc0fc4fcf10fe">la_lapack_s::la_strevc3</a> (side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, lwork, info)</td></tr>
<tr class="memdesc:aa298a258c2d3e83cf7acc0fc4fcf10fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">STREVC3: computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T. Matrices of this type are produced by the Schur factorization of a real general matrix: A = Q*T*Q**T, as computed by SHSEQR. The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by: T*x = w*x, (y**T)*T = w*(y**T) where y**T denotes the transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal blocks of T. This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the orthogonal factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A. This uses a Level 3 BLAS version of the back transformation.  <br /></td></tr>
<tr class="separator:aa298a258c2d3e83cf7acc0fc4fcf10fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bd2d01fe35a200f9b259dbd39c3f18" id="r_ac2bd2d01fe35a200f9b259dbd39c3f18"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ac2bd2d01fe35a200f9b259dbd39c3f18">la_lapack_s::la_strsyl</a> (trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)</td></tr>
<tr class="memdesc:ac2bd2d01fe35a200f9b259dbd39c3f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRSYL: solves the real Sylvester matrix equation: op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C, where op(A) = A or A**T, and A and B are both upper quasi- triangular. A is M-by-M and B is N-by-N; the right hand side C and the solution X are M-by-N; and scale is an output scale factor, set &lt;= 1 to avoid overflow in X. A and B must be in Schur canonical form (as returned by SHSEQR), that is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block has its diagonal elements equal and its off-diagonal elements of opposite sign.  <br /></td></tr>
<tr class="separator:ac2bd2d01fe35a200f9b259dbd39c3f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5534cc2dd98ca29a75876630f6bfdf" id="r_afd5534cc2dd98ca29a75876630f6bfdf"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#afd5534cc2dd98ca29a75876630f6bfdf">la_lapack_s::la_sgebrd</a> (m, n, a, lda, d, e, tauq, taup, work, lwork, info)</td></tr>
<tr class="memdesc:afd5534cc2dd98ca29a75876630f6bfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEBRD: reduces a general real M-by-N matrix A to upper or lower bidiagonal form B by an orthogonal transformation: Q**T * A * P = B. If m &gt;= n, B is upper bidiagonal; if m &lt; n, B is lower bidiagonal.  <br /></td></tr>
<tr class="separator:afd5534cc2dd98ca29a75876630f6bfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e6992eed32e44a7850722890a6b9d5" id="r_a07e6992eed32e44a7850722890a6b9d5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a07e6992eed32e44a7850722890a6b9d5">la_lapack_s::la_sgehrd</a> (n, ilo, ihi, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a07e6992eed32e44a7850722890a6b9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEHRD: reduces a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation: Q**T * A * Q = H .  <br /></td></tr>
<tr class="separator:a07e6992eed32e44a7850722890a6b9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4205f3ed703474a4618bc652f2cf23a2" id="r_a4205f3ed703474a4618bc652f2cf23a2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4205f3ed703474a4618bc652f2cf23a2">la_lapack_s::la_sgelqt</a> (m, n, mb, a, lda, t, ldt, work, info)</td></tr>
<tr class="memdesc:a4205f3ed703474a4618bc652f2cf23a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGELQT computes a blocked LQ factorization of a real M-by-N matrix A using the compact WY representation of Q.  <br /></td></tr>
<tr class="separator:a4205f3ed703474a4618bc652f2cf23a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556f02eaba129f98f96dd2c903a67c49" id="r_a556f02eaba129f98f96dd2c903a67c49"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a556f02eaba129f98f96dd2c903a67c49">la_lapack_s::la_sgels</a> (trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a556f02eaba129f98f96dd2c903a67c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGELS: solves overdetermined or underdetermined real linear systems involving an M-by-N matrix A, or its transpose, using a QR or LQ factorization of A. It is assumed that A has full rank. The following options are provided:  <br /></td></tr>
<tr class="separator:a556f02eaba129f98f96dd2c903a67c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b93de31e4b4147cd66afbe3e2024964" id="r_a9b93de31e4b4147cd66afbe3e2024964"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9b93de31e4b4147cd66afbe3e2024964">la_lapack_s::la_sgemlq</a> (side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a9b93de31e4b4147cd66afbe3e2024964"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEMLQ: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix defined as the product of blocked elementary reflectors computed by short wide LQ factorization (SGELQ)  <br /></td></tr>
<tr class="separator:a9b93de31e4b4147cd66afbe3e2024964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd76a6706f583b1e3a5abe5aeb7b2076" id="r_acd76a6706f583b1e3a5abe5aeb7b2076"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#acd76a6706f583b1e3a5abe5aeb7b2076">la_lapack_s::la_sgemqr</a> (side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:acd76a6706f583b1e3a5abe5aeb7b2076"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEMQR: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T where Q is a real orthogonal matrix defined as the product of blocked elementary reflectors computed by tall skinny QR factorization (SGEQR)  <br /></td></tr>
<tr class="separator:acd76a6706f583b1e3a5abe5aeb7b2076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfdfed34bd1fe2e38dea64530de7dfe" id="r_a8dfdfed34bd1fe2e38dea64530de7dfe"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8dfdfed34bd1fe2e38dea64530de7dfe">la_lapack_s::la_sgeqp3</a> (m, n, a, lda, jpvt, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a8dfdfed34bd1fe2e38dea64530de7dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQP3: computes a QR factorization with column pivoting of a matrix A: A*P = Q*R using Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a8dfdfed34bd1fe2e38dea64530de7dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd29897c59e61f3d5b3982402cecd167" id="r_acd29897c59e61f3d5b3982402cecd167"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#acd29897c59e61f3d5b3982402cecd167">la_lapack_s::la_sgeqrt</a> (m, n, nb, a, lda, t, ldt, work, info)</td></tr>
<tr class="memdesc:acd29897c59e61f3d5b3982402cecd167"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQRT: computes a blocked QR factorization of a real M-by-N matrix A using the compact WY representation of Q.  <br /></td></tr>
<tr class="separator:acd29897c59e61f3d5b3982402cecd167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9227edcc07d4f8cb53052c6777a10d" id="r_abf9227edcc07d4f8cb53052c6777a10d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abf9227edcc07d4f8cb53052c6777a10d">la_lapack_s::la_sgesv</a> (n, nrhs, a, lda, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:abf9227edcc07d4f8cb53052c6777a10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGESV: computes the solution to a real system of linear equations A * X = B, where A is an N-by-N matrix and X and B are N-by-NRHS matrices. The LU decomposition with partial pivoting and row interchanges is used to factor A as A = P * L * U, where P is a permutation matrix, L is unit lower triangular, and U is upper triangular. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:abf9227edcc07d4f8cb53052c6777a10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47bd351571ef1cfed43a16f791f5548" id="r_af47bd351571ef1cfed43a16f791f5548"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af47bd351571ef1cfed43a16f791f5548">la_lapack_s::la_sgesvx</a> (fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:af47bd351571ef1cfed43a16f791f5548"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGESVX: uses the LU factorization to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:af47bd351571ef1cfed43a16f791f5548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad74776b6aba24a572445d8127e819c" id="r_a0ad74776b6aba24a572445d8127e819c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0ad74776b6aba24a572445d8127e819c">la_lapack_s::la_sgges</a> (jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork, info)</td></tr>
<tr class="memdesc:a0ad74776b6aba24a572445d8127e819c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGES: computes for a pair of N-by-N real nonsymmetric matrices (A,B), the generalized eigenvalues, the generalized real Schur form (S,T), optionally, the left and/or right matrices of Schur vectors (VSL and VSR). This gives the generalized Schur factorization (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T ) Optionally, it also orders the eigenvalues so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper quasi-triangular matrix S and the upper triangular matrix T.The leading columns of VSL and VSR then form an orthonormal basis for the corresponding left and right eigenspaces (deflating subspaces). (If only the generalized eigenvalues are needed, use the driver SGGEV instead, which is faster.) A generalized eigenvalue for a pair of matrices (A,B) is a scalar w or a ratio alpha/beta = w, such that A - w*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0 or both being zero. A pair of matrices (S,T) is in generalized real Schur form if T is upper triangular with non-negative diagonal and S is block upper triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond to real generalized eigenvalues, while 2-by-2 blocks of S will be "standardized" by making the corresponding elements of T have the form: [ a 0 ] [ 0 b ] and the pair of corresponding 2-by-2 blocks in S and T will have a complex conjugate pair of generalized eigenvalues.  <br /></td></tr>
<tr class="separator:a0ad74776b6aba24a572445d8127e819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3a90115be834fe460ad455e8955559" id="r_add3a90115be834fe460ad455e8955559"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#add3a90115be834fe460ad455e8955559">la_lapack_s::la_sggesx</a> (jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork, info)</td></tr>
<tr class="memdesc:add3a90115be834fe460ad455e8955559"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGESX: computes for a pair of N-by-N real nonsymmetric matrices (A,B), the generalized eigenvalues, the real Schur form (S,T), and, optionally, the left and/or right matrices of Schur vectors (VSL and VSR). This gives the generalized Schur factorization (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T ) Optionally, it also orders the eigenvalues so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper quasi-triangular matrix S and the upper triangular matrix T; computes a reciprocal condition number for the average of the selected eigenvalues (RCONDE); and computes a reciprocal condition number for the right and left deflating subspaces corresponding to the selected eigenvalues (RCONDV). The leading columns of VSL and VSR then form an orthonormal basis for the corresponding left and right eigenspaces (deflating subspaces). A generalized eigenvalue for a pair of matrices (A,B) is a scalar w or a ratio alpha/beta = w, such that A - w*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0 or for both being zero. A pair of matrices (S,T) is in generalized real Schur form if T is upper triangular with non-negative diagonal and S is block upper triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond to real generalized eigenvalues, while 2-by-2 blocks of S will be "standardized" by making the corresponding elements of T have the form: [ a 0 ] [ 0 b ] and the pair of corresponding 2-by-2 blocks in S and T will have a complex conjugate pair of generalized eigenvalues.  <br /></td></tr>
<tr class="separator:add3a90115be834fe460ad455e8955559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19d166f06ac8af0bcf7f46066f3b5e5" id="r_aa19d166f06ac8af0bcf7f46066f3b5e5"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa19d166f06ac8af0bcf7f46066f3b5e5">la_lapack_s::la_sggev</a> (jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork, info)</td></tr>
<tr class="memdesc:aa19d166f06ac8af0bcf7f46066f3b5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGEV: computes for a pair of N-by-N real nonsymmetric matrices (A,B) the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors. A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta = lambda, such that A - lambda*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0, and even for both being zero. The right eigenvector v(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies A * v(j) = lambda(j) * B * v(j). The left eigenvector u(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies u(j)**H * A = lambda(j) * u(j)**H * B . where u(j)**H is the conjugate-transpose of u(j).  <br /></td></tr>
<tr class="separator:aa19d166f06ac8af0bcf7f46066f3b5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1bbf4c8cea5f26c6b308d20c56d29e" id="r_a6e1bbf4c8cea5f26c6b308d20c56d29e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a6e1bbf4c8cea5f26c6b308d20c56d29e">la_lapack_s::la_sggevx</a> (balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork, info)</td></tr>
<tr class="memdesc:a6e1bbf4c8cea5f26c6b308d20c56d29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGEVX: computes for a pair of N-by-N real nonsymmetric matrices (A,B) the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors. Optionally also, it computes a balancing transformation to improve the conditioning of the eigenvalues and eigenvectors (ILO, IHI, LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for the eigenvalues (RCONDE), and reciprocal condition numbers for the right eigenvectors (RCONDV). A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta = lambda, such that A - lambda*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0, and even for both being zero. The right eigenvector v(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies A * v(j) = lambda(j) * B * v(j) . The left eigenvector u(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies u(j)**H * A = lambda(j) * u(j)**H * B. where u(j)**H is the conjugate-transpose of u(j).  <br /></td></tr>
<tr class="separator:a6e1bbf4c8cea5f26c6b308d20c56d29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2705de4ab71dbfbd2aed92703df66a14" id="r_a2705de4ab71dbfbd2aed92703df66a14"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a2705de4ab71dbfbd2aed92703df66a14">la_lapack_s::la_sggglm</a> (n, m, p, a, lda, b, ldb, d, x, y, work, lwork, info)</td></tr>
<tr class="memdesc:a2705de4ab71dbfbd2aed92703df66a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGGLM: solves a general Gauss-Markov linear model (GLM) problem: minimize || y ||_2 subject to d = A*x + B*y x where A is an N-by-M matrix, B is an N-by-P matrix, and d is a given N-vector. It is assumed that M &lt;= N &lt;= M+P, and rank(A) = M and rank( A B ) = N. Under these assumptions, the constrained equation is always consistent, and there is a unique solution x and a minimal 2-norm solution y, which is obtained using a generalized QR factorization of the matrices (A, B) given by A = Q*(R), B = Q*T*Z. (0) In particular, if matrix B is square nonsingular, then the problem GLM is equivalent to the following weighted linear least squares problem minimize || inv(B)*(d-A*x) ||_2 x where inv(B) denotes the inverse of B.  <br /></td></tr>
<tr class="separator:a2705de4ab71dbfbd2aed92703df66a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd87f7df4e1c6e3231b3767af4c7b384" id="r_abd87f7df4e1c6e3231b3767af4c7b384"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abd87f7df4e1c6e3231b3767af4c7b384">la_lapack_s::la_sgglse</a> (m, n, p, a, lda, b, ldb, c, d, x, work, lwork, info)</td></tr>
<tr class="memdesc:abd87f7df4e1c6e3231b3767af4c7b384"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGLSE: solves the linear equality-constrained least squares (LSE) problem: minimize || c - A*x ||_2 subject to B*x = d where A is an M-by-N matrix, B is a P-by-N matrix, c is a given M-vector, and d is a given P-vector. It is assumed that P &lt;= N &lt;= M+P, and rank(B) = P and rank( (A) ) = N. ( (B) ) These conditions ensure that the LSE problem has a unique solution, which is obtained using a generalized RQ factorization of the matrices (B, A) given by B = (0 R)*Q, A = Z*T*Q.  <br /></td></tr>
<tr class="separator:abd87f7df4e1c6e3231b3767af4c7b384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ba1d1c0e9f03f0df2481f3bb20589f" id="r_ab4ba1d1c0e9f03f0df2481f3bb20589f"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab4ba1d1c0e9f03f0df2481f3bb20589f">la_lapack_s::la_shsein</a> (side, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr, info)</td></tr>
<tr class="memdesc:ab4ba1d1c0e9f03f0df2481f3bb20589f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHSEIN: uses inverse iteration to find specified right and/or left eigenvectors of a real upper Hessenberg matrix H. The right eigenvector x and the left eigenvector y of the matrix H corresponding to an eigenvalue w are defined by: H * x = w * x, y**h * H = w * y**h where y**h denotes the conjugate transpose of the vector y.  <br /></td></tr>
<tr class="separator:ab4ba1d1c0e9f03f0df2481f3bb20589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fba5465036f4033038210de28f0aa22" id="r_a1fba5465036f4033038210de28f0aa22"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1fba5465036f4033038210de28f0aa22">la_lapack_s::la_sla_porpvgrw</a> (uplo, ncols, a, lda, af, ldaf, work)</td></tr>
<tr class="memdesc:a1fba5465036f4033038210de28f0aa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLA_PORPVGRW: computes the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If this is much less than 1, the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, estimated condition numbers, and error bounds could be unreliable.  <br /></td></tr>
<tr class="separator:a1fba5465036f4033038210de28f0aa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaee1a858201d2d52c27945217fdf17c" id="r_acaee1a858201d2d52c27945217fdf17c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#acaee1a858201d2d52c27945217fdf17c">la_lapack_s::la_slaed3</a> (k, n, n1, d, q, ldq, rho, dlamda, q2, indx, ctot, w, s, info)</td></tr>
<tr class="memdesc:acaee1a858201d2d52c27945217fdf17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAED3: finds the roots of the secular equation, as defined by the values in D, W, and RHO, between 1 and K. It makes the appropriate calls to SLAED4 and then updates the eigenvectors by multiplying the matrix of eigenvectors of the pair of eigensystems being combined by the matrix of eigenvectors of the K-by-K system which is solved here. This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:acaee1a858201d2d52c27945217fdf17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ebc659bed0d28d18a1731ce52a294a" id="r_ad0ebc659bed0d28d18a1731ce52a294a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad0ebc659bed0d28d18a1731ce52a294a">la_lapack_s::la_slaed7</a> (icompq, n, qsiz, tlvls, curlvl, curpbm, d, q, ldq, indxq, rho, cutpnt, qstore, qptr, prmptr, perm, givptr, givcol, givnum, work, iwork, info)</td></tr>
<tr class="memdesc:ad0ebc659bed0d28d18a1731ce52a294a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAED7: computes the updated eigensystem of a diagonal matrix after modification by a rank-one symmetric matrix. This routine is used only for the eigenproblem which requires all eigenvalues and optionally eigenvectors of a dense symmetric matrix that has been reduced to tridiagonal form. SLAED1 handles the case in which all eigenvalues and eigenvectors of a symmetric tridiagonal matrix are desired. T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out) where Z = Q**Tu, u is a vector of length N with ones in the CUTPNT and CUTPNT + 1 th elements and zeros elsewhere. The eigenvectors of the original matrix are stored in Q, and the eigenvalues are in D. The algorithm consists of three stages: The first stage consists of deflating the size of the problem when there are multiple eigenvalues or if there is a zero in the Z vector. For each such occurrence the dimension of the secular equation problem is reduced by one. This stage is performed by the routine SLAED8. The second stage consists of calculating the updated eigenvalues. This is done by finding the roots of the secular equation via the routine SLAED4 (as called by SLAED9). This routine also calculates the eigenvectors of the current problem. The final stage consists of computing the updated eigenvectors directly using the updated eigenvalues. The eigenvectors for the current problem are multiplied with the eigenvectors from the overall problem.  <br /></td></tr>
<tr class="separator:ad0ebc659bed0d28d18a1731ce52a294a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e64cad5031c844e7df2d6533bca7a7" id="r_ab8e64cad5031c844e7df2d6533bca7a7"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab8e64cad5031c844e7df2d6533bca7a7">la_lapack_s::la_slaexc</a> (wantq, n, t, ldt, q, ldq, j1, n1, n2, work, info)</td></tr>
<tr class="memdesc:ab8e64cad5031c844e7df2d6533bca7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAEXC: swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in an upper quasi-triangular matrix T by an orthogonal similarity transformation. T must be in Schur canonical form, that is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block has its diagonal elements equal and its off-diagonal elements of opposite sign.  <br /></td></tr>
<tr class="separator:ab8e64cad5031c844e7df2d6533bca7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20afc3c9a57d732787914f6246ddd139" id="r_a20afc3c9a57d732787914f6246ddd139"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a20afc3c9a57d732787914f6246ddd139">la_lapack_s::la_slahqr</a> (wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihiz, z, ldz, info)</td></tr>
<tr class="memdesc:a20afc3c9a57d732787914f6246ddd139"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAHQR: is an auxiliary routine called by SHSEQR to update the eigenvalues and Schur decomposition already computed by SHSEQR, by dealing with the Hessenberg submatrix in rows and columns ILO to IHI.  <br /></td></tr>
<tr class="separator:a20afc3c9a57d732787914f6246ddd139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f8d85273f96a8facf0f650033fbb8a" id="r_aa0f8d85273f96a8facf0f650033fbb8a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa0f8d85273f96a8facf0f650033fbb8a">la_lapack_s::la_slasd2</a> (nl, nr, sqre, k, d, z, alpha, beta, u, ldu, vt, ldvt, dsigma, u2, ldu2, vt2, ldvt2, idxp, idx, idxc, idxq, coltyp, info)</td></tr>
<tr class="memdesc:aa0f8d85273f96a8facf0f650033fbb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASD2: merges the two sets of singular values together into a single sorted set. Then it tries to deflate the size of the problem. There are two ways in which deflation can occur: when two or more singular values are close together or if there is a tiny entry in the Z vector. For each such occurrence the order of the related secular equation problem is reduced by one. SLASD2 is called from SLASD1.  <br /></td></tr>
<tr class="separator:aa0f8d85273f96a8facf0f650033fbb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110d0f37ecb979187f6aca60887e423f" id="r_a110d0f37ecb979187f6aca60887e423f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a110d0f37ecb979187f6aca60887e423f">la_lapack_s::la_slaswlq</a> (m, n, mb, nb, a, lda, t, ldt, work, lwork, info)</td></tr>
<tr class="memdesc:a110d0f37ecb979187f6aca60887e423f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASWLQ: computes a blocked Tall-Skinny LQ factorization of a real M-by-N matrix A for M &lt;= N: A = ( L 0 ) * Q, where: Q is a n-by-N orthogonal matrix, stored on exit in an implicit form in the elements above the diagonal of the array A and in the elements of the array T; L is a lower-triangular M-by-M matrix stored on exit in the elements on and below the diagonal of the array A. 0 is a M-by-(N-M) zero matrix, if M &lt; N, and is not stored.  <br /></td></tr>
<tr class="separator:a110d0f37ecb979187f6aca60887e423f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800e856bfb9a981f54af1db83ea9aed9" id="r_a800e856bfb9a981f54af1db83ea9aed9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a800e856bfb9a981f54af1db83ea9aed9">la_lapack_s::la_slatsqr</a> (m, n, mb, nb, a, lda, t, ldt, work, lwork, info)</td></tr>
<tr class="memdesc:a800e856bfb9a981f54af1db83ea9aed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLATSQR: computes a blocked Tall-Skinny QR factorization of a real M-by-N matrix A for M &gt;= N: A = Q * ( R ), ( 0 ) where: Q is a M-by-M orthogonal matrix, stored on exit in an implicit form in the elements below the diagonal of the array A and in the elements of the array T; R is an upper-triangular N-by-N matrix, stored on exit in the elements on and above the diagonal of the array A. 0 is a (M-N)-by-N zero matrix, and is not stored.  <br /></td></tr>
<tr class="separator:a800e856bfb9a981f54af1db83ea9aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7a62ea30803729511d6c100c289a1f" id="r_adb7a62ea30803729511d6c100c289a1f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#adb7a62ea30803729511d6c100c289a1f">la_lapack_s::la_sorgbr</a> (vect, m, n, k, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:adb7a62ea30803729511d6c100c289a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGBR: generates one of the real orthogonal matrices Q or P**T determined by SGEBRD when reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and P**T are defined as products of elementary reflectors H(i) or G(i) respectively. If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q is of order M: if m &gt;= k, Q = H(1) H(2) . . . H(k) and SORGBR returns the first n columns of Q, where m &gt;= n &gt;= k; if m &lt; k, Q = H(1) H(2) . . . H(m-1) and SORGBR returns Q as an M-by-M matrix. If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T is of order N: if k &lt; n, P**T = G(k) . . . G(2) G(1) and SORGBR returns the first m rows of P**T, where n &gt;= m &gt;= k; if k &gt;= n, P**T = G(n-1) . . . G(2) G(1) and SORGBR returns P**T as an N-by-N matrix.  <br /></td></tr>
<tr class="separator:adb7a62ea30803729511d6c100c289a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c4fdfb6e355cf33318f68241d700c8" id="r_a76c4fdfb6e355cf33318f68241d700c8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a76c4fdfb6e355cf33318f68241d700c8">la_lapack_s::la_sormbr</a> (vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a76c4fdfb6e355cf33318f68241d700c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If VECT = 'Q', SORMBR: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**T * C C * Q**T If VECT = 'P', SORMBR overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': P * C C * P TRANS = 'T': P**T * C C * P**T Here Q and P**T are the orthogonal matrices determined by SGEBRD when reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and P**T are defined as products of elementary reflectors H(i) and G(i) respectively. Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the order of the orthogonal matrix Q or P**T that is applied. If VECT = 'Q', A is assumed to have been an NQ-by-K matrix: if nq &gt;= k, Q = H(1) H(2) . . . H(k); if nq &lt; k, Q = H(1) H(2) . . . H(nq-1). If VECT = 'P', A is assumed to have been a K-by-NQ matrix: if k &lt; nq, P = G(1) G(2) . . . G(k); if k &gt;= nq, P = G(1) G(2) . . . G(nq-1).  <br /></td></tr>
<tr class="separator:a76c4fdfb6e355cf33318f68241d700c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452df2d84fa9928587a4990e43fadff5" id="r_a452df2d84fa9928587a4990e43fadff5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a452df2d84fa9928587a4990e43fadff5">la_lapack_s::la_spbsv</a> (uplo, n, kd, nrhs, ab, ldab, b, ldb, info)</td></tr>
<tr class="memdesc:a452df2d84fa9928587a4990e43fadff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPBSV: computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite band matrix and X and B are N-by-NRHS matrices. The Cholesky decomposition is used to factor A as A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular band matrix, and L is a lower triangular band matrix, with the same number of superdiagonals or subdiagonals as A. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a452df2d84fa9928587a4990e43fadff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af720a6ac5c297e82cb8c630b90f311bb" id="r_af720a6ac5c297e82cb8c630b90f311bb"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af720a6ac5c297e82cb8c630b90f311bb">la_lapack_s::la_spbsvx</a> (fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:af720a6ac5c297e82cb8c630b90f311bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPBSVX: uses the Cholesky factorization A = U**T*U or A = L*L**T to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite band matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:af720a6ac5c297e82cb8c630b90f311bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182a05bdc67cbc14aefd084660d1878b" id="r_a182a05bdc67cbc14aefd084660d1878b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a182a05bdc67cbc14aefd084660d1878b">la_lapack_s::la_spftrf</a> (transr, uplo, n, a, info)</td></tr>
<tr class="memdesc:a182a05bdc67cbc14aefd084660d1878b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPFTRF: computes the Cholesky factorization of a real symmetric positive definite matrix A. The factorization has the form A = U**T * U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular. This is the block version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a182a05bdc67cbc14aefd084660d1878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfbcaac9b96de5ce336c9b9a57be66a" id="r_a0cfbcaac9b96de5ce336c9b9a57be66a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0cfbcaac9b96de5ce336c9b9a57be66a">la_lapack_s::la_sposv</a> (uplo, n, nrhs, a, lda, b, ldb, info)</td></tr>
<tr class="memdesc:a0cfbcaac9b96de5ce336c9b9a57be66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPOSV: computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite matrix and X and B are N-by-NRHS matrices. The Cholesky decomposition is used to factor A as A = U**T* U, if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is a lower triangular matrix. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a0cfbcaac9b96de5ce336c9b9a57be66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d50d83f760c7c5579d6c545cdacc4c" id="r_aa7d50d83f760c7c5579d6c545cdacc4c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa7d50d83f760c7c5579d6c545cdacc4c">la_lapack_s::la_sposvx</a> (fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)</td></tr>
<tr class="memdesc:aa7d50d83f760c7c5579d6c545cdacc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPOSVX: uses the Cholesky factorization A = U**T*U or A = L*L**T to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:aa7d50d83f760c7c5579d6c545cdacc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac398160ac843907a72186419a9a33b" id="r_a0ac398160ac843907a72186419a9a33b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0ac398160ac843907a72186419a9a33b">la_lapack_s::la_strexc</a> (compq, n, t, ldt, q, ldq, ifst, ilst, work, info)</td></tr>
<tr class="memdesc:a0ac398160ac843907a72186419a9a33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">STREXC: reorders the real Schur factorization of a real matrix A = Q*T*Q**T, so that the diagonal block of T with row index IFST is moved to row ILST. The real Schur form T is reordered by an orthogonal similarity transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors is updated by postmultiplying it with Z. T must be in Schur canonical form (as returned by SHSEQR), that is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block has its diagonal elements equal and its off-diagonal elements of opposite sign.  <br /></td></tr>
<tr class="separator:a0ac398160ac843907a72186419a9a33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64318d3414d7037103beb1168543194b" id="r_a64318d3414d7037103beb1168543194b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a64318d3414d7037103beb1168543194b">la_lapack_s::la_strsen</a> (job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a64318d3414d7037103beb1168543194b"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRSEN: reorders the real Schur factorization of a real matrix A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper quasi-triangular matrix T, and the leading columns of Q form an orthonormal basis of the corresponding right invariant subspace. Optionally the routine computes the reciprocal condition numbers of the cluster of eigenvalues and/or the invariant subspace. T must be in Schur canonical form (as returned by SHSEQR), that is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block has its diagonal elements equal and its off-diagonal elements of opposite sign.  <br /></td></tr>
<tr class="separator:a64318d3414d7037103beb1168543194b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8303097a2505e680203f5b2b5a8800f6" id="r_a8303097a2505e680203f5b2b5a8800f6"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a8303097a2505e680203f5b2b5a8800f6">la_lapack_s::la_strsna</a> (job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork, info)</td></tr>
<tr class="memdesc:a8303097a2505e680203f5b2b5a8800f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRSNA: estimates reciprocal condition numbers for specified eigenvalues and/or right eigenvectors of a real upper quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q orthogonal). T must be in Schur canonical form (as returned by SHSEQR), that is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block has its diagonal elements equal and its off-diagonal elements of opposite sign.  <br /></td></tr>
<tr class="separator:a8303097a2505e680203f5b2b5a8800f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a97222427f57c4e84495323b15223c2" id="r_a4a97222427f57c4e84495323b15223c2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4a97222427f57c4e84495323b15223c2">la_lapack_s::la_sgelq</a> (m, n, a, lda, t, tsize, work, lwork, info)</td></tr>
<tr class="memdesc:a4a97222427f57c4e84495323b15223c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGELQ: computes an LQ factorization of a real M-by-N matrix A: A = ( L 0 ) * Q where: Q is a N-by-N orthogonal matrix; L is a lower-triangular M-by-M matrix; 0 is a M-by-(N-M) zero matrix, if M &lt; N.  <br /></td></tr>
<tr class="separator:a4a97222427f57c4e84495323b15223c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b29fd8c9abd1c77b094cea884c28b2" id="r_aa1b29fd8c9abd1c77b094cea884c28b2"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa1b29fd8c9abd1c77b094cea884c28b2">la_lapack_s::la_sgelsy</a> (m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, info)</td></tr>
<tr class="memdesc:aa1b29fd8c9abd1c77b094cea884c28b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGELSY: computes the minimum-norm solution to a real linear least squares problem: minimize || A * X - B || using a complete orthogonal factorization of A. A is an M-by-N matrix which may be rank-deficient. Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X. The routine first computes a QR factorization with column pivoting: A * P = Q * [ R11 R12 ] [ 0 R22 ] with R11 defined as the largest leading submatrix whose estimated condition number is less than 1/RCOND. The order of R11, RANK, is the effective rank of A. Then, R22 is considered to be negligible, and R12 is annihilated by orthogonal transformations from the right, arriving at the complete orthogonal factorization: A * P = Q * [ T11 0 ] * Z [ 0 0 ] The minimum-norm solution is then X = P * Z**T [ inv(T11)*Q1**T*B ] [ 0 ] where Q1 consists of the first RANK columns of Q. This routine is basically identical to the original xGELSX except three differences: o The call to the subroutine xGEQPF has been substituted by the the call to the subroutine xGEQP3. This subroutine is a Blas-3 version of the QR factorization with column pivoting. o Matrix B (the right hand side) is updated with Blas-3. o The permutation of matrix B (the right hand side) is faster and more simple.  <br /></td></tr>
<tr class="separator:aa1b29fd8c9abd1c77b094cea884c28b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa620a2713d9531f20f2e122429b6495f" id="r_aa620a2713d9531f20f2e122429b6495f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa620a2713d9531f20f2e122429b6495f">la_lapack_s::la_sgeqr</a> (m, n, a, lda, t, tsize, work, lwork, info)</td></tr>
<tr class="memdesc:aa620a2713d9531f20f2e122429b6495f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEQR: computes a QR factorization of a real M-by-N matrix A: A = Q * ( R ), ( 0 ) where: Q is a M-by-M orthogonal matrix; R is an upper-triangular N-by-N matrix; 0 is a (M-N)-by-N zero matrix, if M &gt; N.  <br /></td></tr>
<tr class="separator:aa620a2713d9531f20f2e122429b6495f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d36a07de1ceaf9edd0a21f7905aef3" id="r_a11d36a07de1ceaf9edd0a21f7905aef3"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a11d36a07de1ceaf9edd0a21f7905aef3">la_lapack_s::la_sgetsls</a> (trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a11d36a07de1ceaf9edd0a21f7905aef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETSLS: solves overdetermined or underdetermined real linear systems involving an M-by-N matrix A, using a tall skinny QR or short wide LQ factorization of A. It is assumed that A has full rank. The following options are provided:  <br /></td></tr>
<tr class="separator:a11d36a07de1ceaf9edd0a21f7905aef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b855619ac1b51b8c65c7bb57efeaa3c" id="r_a1b855619ac1b51b8c65c7bb57efeaa3c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a1b855619ac1b51b8c65c7bb57efeaa3c">la_lapack_s::la_sgetsqrhrt</a> (m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork, info)</td></tr>
<tr class="memdesc:a1b855619ac1b51b8c65c7bb57efeaa3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETSQRHRT: computes a NB2-sized column blocked QR-factorization of a complex M-by-N matrix A with M &gt;= N, A = Q * R. The routine uses internally a NB1-sized column blocked and MB1-sized row blocked TSQR-factorization and perfors the reconstruction of the Householder vectors from the TSQR output. The routine also converts the R_tsqr factor from the TSQR-factorization output into the R factor that corresponds to the Householder QR-factorization, A = Q_tsqr * R_tsqr = Q * R. The output Q and R factors are stored in the same format as in SGEQRT (Q is in blocked compact WY-representation). See the documentation of SGEQRT for more details on the format.  <br /></td></tr>
<tr class="separator:a1b855619ac1b51b8c65c7bb57efeaa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015f3aa296cd5ff5b80376a3093b39b2" id="r_a015f3aa296cd5ff5b80376a3093b39b2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a015f3aa296cd5ff5b80376a3093b39b2">la_lapack_s::la_slaed2</a> (k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w, q2, indx, indxc, indxp, coltyp, info)</td></tr>
<tr class="memdesc:a015f3aa296cd5ff5b80376a3093b39b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAED2: merges the two sets of eigenvalues together into a single sorted set. Then it tries to deflate the size of the problem. There are two ways in which deflation can occur: when two or more eigenvalues are close together or if there is a tiny entry in the Z vector. For each such occurrence the order of the related secular equation problem is reduced by one.  <br /></td></tr>
<tr class="separator:a015f3aa296cd5ff5b80376a3093b39b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f6bbfce1ccc13ae59cf8d1f4fb0aa1" id="r_a79f6bbfce1ccc13ae59cf8d1f4fb0aa1"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a79f6bbfce1ccc13ae59cf8d1f4fb0aa1">la_lapack_s::la_slaqr2</a> (wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz, z, ldz, ns, nd, sr, si, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork)</td></tr>
<tr class="memdesc:a79f6bbfce1ccc13ae59cf8d1f4fb0aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQR2: is identical to SLAQR3 except that it avoids recursion by calling SLAHQR instead of SLAQR4. Aggressive early deflation: This subroutine accepts as input an upper Hessenberg matrix H and performs an orthogonal similarity transformation designed to detect and deflate fully converged eigenvalues from a trailing principal submatrix. On output H has been over- written by a new Hessenberg matrix that is a perturbation of an orthogonal similarity transformation of H. It is to be hoped that the final version of H has many zero subdiagonal entries.  <br /></td></tr>
<tr class="separator:a79f6bbfce1ccc13ae59cf8d1f4fb0aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647b6813c937ab203eff24204ae96a90" id="r_a647b6813c937ab203eff24204ae96a90"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a647b6813c937ab203eff24204ae96a90">la_lapack_s::la_slasd1</a> (nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt, idxq, iwork, work, info)</td></tr>
<tr class="memdesc:a647b6813c937ab203eff24204ae96a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASD1: computes the SVD of an upper bidiagonal N-by-M matrix B, where N = NL + NR + 1 and M = N + SQRE. SLASD1 is called from SLASD0. A related subroutine SLASD7 handles the case in which the singular values (and the singular vectors in factored form) are desired. SLASD1 computes the SVD as follows: ( D1(in) 0 0 0 ) B = U(in) * ( Z1**T a Z2**T b ) * VT(in) ( 0 0 D2(in) 0 ) = U(out) * ( D(out) 0) * VT(out) where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros elsewhere; and the entry b is empty if SQRE = 0. The left singular vectors of the original matrix are stored in U, and the transpose of the right singular vectors are stored in VT, and the singular values are in D. The algorithm consists of three stages: The first stage consists of deflating the size of the problem when there are multiple singular values or when there are zeros in the Z vector. For each such occurrence the dimension of the secular equation problem is reduced by one. This stage is performed by the routine SLASD2. The second stage consists of calculating the updated singular values. This is done by finding the square roots of the roots of the secular equation via the routine SLASD4 (as called by SLASD3). This routine also calculates the singular vectors of the current problem. The final stage consists of computing the updated singular vectors directly using the updated singular values. The singular vectors for the current problem are multiplied with the singular vectors from the overall problem.  <br /></td></tr>
<tr class="separator:a647b6813c937ab203eff24204ae96a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691208f73ccbc5d00218ae7ebbb83939" id="r_a691208f73ccbc5d00218ae7ebbb83939"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a691208f73ccbc5d00218ae7ebbb83939">la_lapack_s::la_slaed1</a> (n, d, q, ldq, indxq, rho, cutpnt, work, iwork, info)</td></tr>
<tr class="memdesc:a691208f73ccbc5d00218ae7ebbb83939"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAED1: computes the updated eigensystem of a diagonal matrix after modification by a rank-one symmetric matrix. This routine is used only for the eigenproblem which requires all eigenvalues and eigenvectors of a tridiagonal matrix. SLAED7 handles the case in which eigenvalues only or eigenvalues and eigenvectors of a full symmetric matrix (which was reduced to tridiagonal form) are desired. T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out) where Z = Q**T*u, u is a vector of length N with ones in the CUTPNT and CUTPNT + 1 th elements and zeros elsewhere. The eigenvectors of the original matrix are stored in Q, and the eigenvalues are in D. The algorithm consists of three stages: The first stage consists of deflating the size of the problem when there are multiple eigenvalues or if there is a zero in the Z vector. For each such occurrence the dimension of the secular equation problem is reduced by one. This stage is performed by the routine SLAED2. The second stage consists of calculating the updated eigenvalues. This is done by finding the roots of the secular equation via the routine SLAED4 (as called by SLAED3). This routine also calculates the eigenvectors of the current problem. The final stage consists of computing the updated eigenvectors directly using the updated eigenvalues. The eigenvectors for the current problem are multiplied with the eigenvectors from the overall problem.  <br /></td></tr>
<tr class="separator:a691208f73ccbc5d00218ae7ebbb83939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5eb8d1ebbb6d825b4dd75a61ff143c" id="r_afd5eb8d1ebbb6d825b4dd75a61ff143c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#afd5eb8d1ebbb6d825b4dd75a61ff143c">la_lapack_s::la_slaed0</a> (icompq, qsiz, n, d, e, q, ldq, qstore, ldqs, work, iwork, info)</td></tr>
<tr class="memdesc:afd5eb8d1ebbb6d825b4dd75a61ff143c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAED0: computes all eigenvalues and corresponding eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <br /></td></tr>
<tr class="separator:afd5eb8d1ebbb6d825b4dd75a61ff143c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c1b8cd257f624b441398d64a26c608" id="r_a38c1b8cd257f624b441398d64a26c608"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a38c1b8cd257f624b441398d64a26c608">la_lapack_s::la_sstedc</a> (compz, n, d, e, z, ldz, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a38c1b8cd257f624b441398d64a26c608"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEDC: computes all eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. The eigenvectors of a full or band real symmetric matrix can also be found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to tridiagonal form. This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See SLAED3 for details.  <br /></td></tr>
<tr class="separator:a38c1b8cd257f624b441398d64a26c608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ecfaa3e6ba2b32f0df79a2baea5bc8" id="r_a92ecfaa3e6ba2b32f0df79a2baea5bc8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a92ecfaa3e6ba2b32f0df79a2baea5bc8">la_lapack_s::la_sstevd</a> (jobz, n, d, e, z, ldz, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a92ecfaa3e6ba2b32f0df79a2baea5bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEVD: computes all eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a92ecfaa3e6ba2b32f0df79a2baea5bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef8b4fab3e03c6a5dadbb0dadf4db0d" id="r_abef8b4fab3e03c6a5dadbb0dadf4db0d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abef8b4fab3e03c6a5dadbb0dadf4db0d">la_lapack_s::la_ssyevd</a> (jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:abef8b4fab3e03c6a5dadbb0dadf4db0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEVD: computes all eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. Because of large use of BLAS of level 3, SSYEVD needs N**2 more workspace than SSYEVX.  <br /></td></tr>
<tr class="separator:abef8b4fab3e03c6a5dadbb0dadf4db0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc97738b8ebcd3625b5d351b89a83195" id="r_adc97738b8ebcd3625b5d351b89a83195"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#adc97738b8ebcd3625b5d351b89a83195">la_lapack_s::la_ssygvd</a> (itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:adc97738b8ebcd3625b5d351b89a83195"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYGVD: computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric and B is also positive definite. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:adc97738b8ebcd3625b5d351b89a83195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b688d8ab3829a97f33824e9396fe7f0" id="r_a5b688d8ab3829a97f33824e9396fe7f0"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a5b688d8ab3829a97f33824e9396fe7f0">la_lapack_s::la_ssbevd</a> (jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a5b688d8ab3829a97f33824e9396fe7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSBEVD: computes all the eigenvalues and, optionally, eigenvectors of a real symmetric band matrix A. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a5b688d8ab3829a97f33824e9396fe7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec81c2d7d629af92f03d0011f81aec15" id="r_aec81c2d7d629af92f03d0011f81aec15"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aec81c2d7d629af92f03d0011f81aec15">la_lapack_s::la_ssbgvd</a> (jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:aec81c2d7d629af92f03d0011f81aec15"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSBGVD: computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite banded eigenproblem, of the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and banded, and B is also positive definite. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:aec81c2d7d629af92f03d0011f81aec15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c8980c68c42dab9710aa5baf5cb50b" id="r_aa9c8980c68c42dab9710aa5baf5cb50b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa9c8980c68c42dab9710aa5baf5cb50b">la_lapack_s::la_sspevd</a> (jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:aa9c8980c68c42dab9710aa5baf5cb50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPEVD: computes all the eigenvalues and, optionally, eigenvectors of a real symmetric matrix A in packed storage. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:aa9c8980c68c42dab9710aa5baf5cb50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaf5ca464e1dc12643dd25415f8cbe6" id="r_aabaf5ca464e1dc12643dd25415f8cbe6"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aabaf5ca464e1dc12643dd25415f8cbe6">la_lapack_s::la_sspgvd</a> (itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:aabaf5ca464e1dc12643dd25415f8cbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSPGVD: computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be symmetric, stored in packed format, and B is also positive definite. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:aabaf5ca464e1dc12643dd25415f8cbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c49c66535895f047d6a47cf1691f93d" id="r_a4c49c66535895f047d6a47cf1691f93d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a4c49c66535895f047d6a47cf1691f93d">la_lapack_s::la_sbdsdc</a> (uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork, info)</td></tr>
<tr class="memdesc:a4c49c66535895f047d6a47cf1691f93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SBDSDC: computes the singular value decomposition (SVD) of a real N-by-N (upper or lower) bidiagonal matrix B: B = U * S * VT, using a divide and conquer method, where S is a diagonal matrix with non-negative diagonal elements (the singular values of B), and U and VT are orthogonal matrices of left and right singular vectors, respectively. SBDSDC can be used to compute all singular values, and optionally, singular vectors or singular vectors in compact form. This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See SLASD3 for details. The code currently calls SLASDQ if singular values only are desired. However, it can be slightly modified to compute singular values using the divide and conquer method.  <br /></td></tr>
<tr class="separator:a4c49c66535895f047d6a47cf1691f93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0dd2e65d1d378c71c7480b355c1b26" id="r_aec0dd2e65d1d378c71c7480b355c1b26"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aec0dd2e65d1d378c71c7480b355c1b26">la_lapack_s::la_sbdsqr</a> (uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work, info)</td></tr>
<tr class="memdesc:aec0dd2e65d1d378c71c7480b355c1b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">SBDSQR: computes the singular values and, optionally, the right and/or left singular vectors from the singular value decomposition (SVD) of a real N-by-N (upper or lower) bidiagonal matrix B using the implicit zero-shift QR algorithm. The SVD of B has the form B = Q * S * P**T where S is the diagonal matrix of singular values, Q is an orthogonal matrix of left singular vectors, and P is an orthogonal matrix of right singular vectors. If left singular vectors are requested, this subroutine actually returns U*Q instead of Q, and, if right singular vectors are requested, this subroutine returns P**T*VT instead of P**T, for given real input matrices U and VT. When U and VT are the orthogonal matrices that reduce a general matrix A to bidiagonal form: A = U*B*VT, as computed by SGEBRD, then A = (U*Q) * S * (P**T*VT) is the SVD of A. Optionally, the subroutine may also compute Q**T*C for a given real input matrix C. See "Computing  Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan, LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11, no. 5, pp. 873-912, Sept 1990) and "Accurate singular values and differential qd algorithms," by B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics Department, University of California at Berkeley, July 1992 for a detailed description of the algorithm.  <br /></td></tr>
<tr class="separator:aec0dd2e65d1d378c71c7480b355c1b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c488e1d38bc08ae8f91e8509b0547e" id="r_a43c488e1d38bc08ae8f91e8509b0547e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a43c488e1d38bc08ae8f91e8509b0547e">la_lapack_s::la_sgees</a> (jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork, info)</td></tr>
<tr class="memdesc:a43c488e1d38bc08ae8f91e8509b0547e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEES: computes for an N-by-N real nonsymmetric matrix A, the eigenvalues, the real Schur form T, and, optionally, the matrix of Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T). Optionally, it also orders the eigenvalues on the diagonal of the real Schur form so that selected eigenvalues are at the top left. The leading columns of Z then form an orthonormal basis for the invariant subspace corresponding to the selected eigenvalues. A matrix is in real Schur form if it is upper quasi-triangular with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the form [ a b ] [ c a ] where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).  <br /></td></tr>
<tr class="separator:a43c488e1d38bc08ae8f91e8509b0547e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd999c3d0ac5972f4b9886e34e3e32f1" id="r_abd999c3d0ac5972f4b9886e34e3e32f1"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abd999c3d0ac5972f4b9886e34e3e32f1">la_lapack_s::la_sgeesx</a> (jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork, info)</td></tr>
<tr class="memdesc:abd999c3d0ac5972f4b9886e34e3e32f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEESX: computes for an N-by-N real nonsymmetric matrix A, the eigenvalues, the real Schur form T, and, optionally, the matrix of Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T). Optionally, it also orders the eigenvalues on the diagonal of the real Schur form so that selected eigenvalues are at the top left; computes a reciprocal condition number for the average of the selected eigenvalues (RCONDE); and computes a reciprocal condition number for the right invariant subspace corresponding to the selected eigenvalues (RCONDV). The leading columns of Z form an orthonormal basis for this invariant subspace. For further explanation of the reciprocal condition numbers RCONDE and RCONDV, see Section 4.10_sp of the LAPACK Users' Guide (where these quantities are called s and sep respectively). A real matrix is in real Schur form if it is upper quasi-triangular with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the form [ a b ] [ c a ] where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).  <br /></td></tr>
<tr class="separator:abd999c3d0ac5972f4b9886e34e3e32f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4e94b4e6a50095523b1dfddcedbdb6" id="r_aff4e94b4e6a50095523b1dfddcedbdb6"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aff4e94b4e6a50095523b1dfddcedbdb6">la_lapack_s::la_sgeev</a> (jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork, info)</td></tr>
<tr class="memdesc:aff4e94b4e6a50095523b1dfddcedbdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEEV: computes for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors. The right eigenvector v(j) of A satisfies A * v(j) = lambda(j) * v(j) where lambda(j) is its eigenvalue. The left eigenvector u(j) of A satisfies u(j)**H * A = lambda(j) * u(j)**H where u(j)**H denotes the conjugate-transpose of u(j). The computed eigenvectors are normalized to have Euclidean norm equal to 1 and largest component real.  <br /></td></tr>
<tr class="separator:aff4e94b4e6a50095523b1dfddcedbdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70be4a028106d8356cddf04d772ef89c" id="r_a70be4a028106d8356cddf04d772ef89c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a70be4a028106d8356cddf04d772ef89c">la_lapack_s::la_sgeevx</a> (balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:a70be4a028106d8356cddf04d772ef89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEEVX: computes for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors. Optionally also, it computes a balancing transformation to improve the conditioning of the eigenvalues and eigenvectors (ILO, IHI, SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues (RCONDE), and reciprocal condition numbers for the right eigenvectors (RCONDV). The right eigenvector v(j) of A satisfies A * v(j) = lambda(j) * v(j) where lambda(j) is its eigenvalue. The left eigenvector u(j) of A satisfies u(j)**H * A = lambda(j) * u(j)**H where u(j)**H denotes the conjugate-transpose of u(j). The computed eigenvectors are normalized to have Euclidean norm equal to 1 and largest component real. Balancing a matrix means permuting the rows and columns to make it more nearly upper triangular, and applying a diagonal similarity transformation D * A * D**(-1), where D is a diagonal matrix, to make its rows and columns closer in norm and the condition numbers of its eigenvalues and eigenvectors smaller. The computed reciprocal condition numbers correspond to the balanced matrix. Permuting rows and columns will not change the condition numbers (in exact arithmetic) but diagonal scaling will. For further explanation of balancing, see section 4.10.2_sp of the LAPACK Users' Guide.  <br /></td></tr>
<tr class="separator:a70be4a028106d8356cddf04d772ef89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ec8c9c067c0ef8fb5ae719fe40cd8c" id="r_a77ec8c9c067c0ef8fb5ae719fe40cd8c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a77ec8c9c067c0ef8fb5ae719fe40cd8c">la_lapack_s::la_sgejsv</a> (joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:a77ec8c9c067c0ef8fb5ae719fe40cd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGEJSV: computes the singular value decomposition (SVD) of a real M-by-N matrix [A], where M &gt;= N. The SVD of [A] is written as [A] = [U] * [SIGMA] * [V]^t, where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are the singular values of [A]. The columns of [U] and [V] are the left and the right singular vectors of [A], respectively. The matrices [U] and [V] are computed and stored in the arrays U and V, respectively. The diagonal of [SIGMA] is computed and stored in the array SVA. SGEJSV can sometimes compute tiny singular values and their singular vectors much more accurately than other SVD routines, see below under Further Details.  <br /></td></tr>
<tr class="separator:a77ec8c9c067c0ef8fb5ae719fe40cd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd769f9ba8e7ff12485a3b20d07de8d9" id="r_abd769f9ba8e7ff12485a3b20d07de8d9"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abd769f9ba8e7ff12485a3b20d07de8d9">la_lapack_s::la_sgelsd</a> (m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:abd769f9ba8e7ff12485a3b20d07de8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGELSD: computes the minimum-norm solution to a real linear least squares problem: minimize 2-norm(| b - A*x |) using the singular value decomposition (SVD) of A. A is an M-by-N matrix which may be rank-deficient. Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X. The problem is solved in three steps: (1) Reduce the coefficient matrix A to bidiagonal form with Householder transformations, reducing the original problem into a "bidiagonal least squares problem" (BLS) (2) Solve the BLS using a divide and conquer approach. (3) Apply back all the Householder transformations to solve the original least squares problem. The effective rank of A is determined by treating as zero those singular values which are less than RCOND times the largest singular value. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:abd769f9ba8e7ff12485a3b20d07de8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa83dd9674b6837e02b127f3bcc21a7" id="r_aefa83dd9674b6837e02b127f3bcc21a7"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aefa83dd9674b6837e02b127f3bcc21a7">la_lapack_s::la_sgelss</a> (m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, info)</td></tr>
<tr class="memdesc:aefa83dd9674b6837e02b127f3bcc21a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGELSS: computes the minimum norm solution to a real linear least squares problem: Minimize 2-norm(| b - A*x |). using the singular value decomposition (SVD) of A. A is an M-by-N matrix which may be rank-deficient. Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X. The effective rank of A is determined by treating as zero those singular values which are less than RCOND times the largest singular value.  <br /></td></tr>
<tr class="separator:aefa83dd9674b6837e02b127f3bcc21a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f298f7874123102a98f5f04319058e" id="r_a00f298f7874123102a98f5f04319058e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a00f298f7874123102a98f5f04319058e">la_lapack_s::la_sgesdd</a> (jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:a00f298f7874123102a98f5f04319058e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGESDD: computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and right singular vectors. If singular vectors are desired, it uses a divide-and-conquer algorithm. The SVD is written A = U * SIGMA * transpose(V) where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A. Note that the routine returns VT = V**T, not V. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a00f298f7874123102a98f5f04319058e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf0de537c41f787dc3f89a84c1cd08c" id="r_abbf0de537c41f787dc3f89a84c1cd08c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abbf0de537c41f787dc3f89a84c1cd08c">la_lapack_s::la_sgesvd</a> (jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, info)</td></tr>
<tr class="memdesc:abbf0de537c41f787dc3f89a84c1cd08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGESVD: computes the singular value decomposition (SVD) of a real M-by-N matrix A, optionally computing the left and/or right singular vectors. The SVD is written A = U * SIGMA * transpose(V) where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A. Note that the routine returns V**T, not V.  <br /></td></tr>
<tr class="separator:abbf0de537c41f787dc3f89a84c1cd08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0698aa1e4d887c06010ff00e1e254fa" id="r_ad0698aa1e4d887c06010ff00e1e254fa"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ad0698aa1e4d887c06010ff00e1e254fa">la_lapack_s::la_sgesvdq</a> (joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork, info)</td></tr>
<tr class="memdesc:ad0698aa1e4d887c06010ff00e1e254fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGESVDQ: computes the singular value decomposition (SVD) of a real M-by-N matrix A, where M &gt;= N. The SVD of A is written as [++] [xx] [x0] [xx] A = U * SIGMA * V^*, [++] = [xx] * [ox] * [xx] [++] [xx] where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A. The columns of U and V are the left and the right singular vectors of A, respectively.  <br /></td></tr>
<tr class="separator:ad0698aa1e4d887c06010ff00e1e254fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79549bc1c73f0f3347498a182ae2092" id="r_ab79549bc1c73f0f3347498a182ae2092"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#ab79549bc1c73f0f3347498a182ae2092">la_lapack_s::la_sgesvj</a> (joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, work, lwork, info)</td></tr>
<tr class="memdesc:ab79549bc1c73f0f3347498a182ae2092"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGESVJ: computes the singular value decomposition (SVD) of a real M-by-N matrix A, where M &gt;= N. The SVD of A is written as [++] [xx] [x0] [xx] A = U * SIGMA * V^t, [++] = [xx] * [ox] * [xx] [++] [xx] where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A. The columns of U and V are the left and the right singular vectors of A, respectively. SGESVJ can sometimes compute tiny singular values and their singular vectors much more accurately than other SVD routines, see below under Further Details.  <br /></td></tr>
<tr class="separator:ab79549bc1c73f0f3347498a182ae2092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04827eeebb3ce470ddc3318c9b09b35f" id="r_a04827eeebb3ce470ddc3318c9b09b35f"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a04827eeebb3ce470ddc3318c9b09b35f">la_lapack_s::la_sgges3</a> (jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork, info)</td></tr>
<tr class="memdesc:a04827eeebb3ce470ddc3318c9b09b35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGES3: computes for a pair of N-by-N real nonsymmetric matrices (A,B), the generalized eigenvalues, the generalized real Schur form (S,T), optionally, the left and/or right matrices of Schur vectors (VSL and VSR). This gives the generalized Schur factorization (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T ) Optionally, it also orders the eigenvalues so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper quasi-triangular matrix S and the upper triangular matrix T.The leading columns of VSL and VSR then form an orthonormal basis for the corresponding left and right eigenspaces (deflating subspaces). (If only the generalized eigenvalues are needed, use the driver SGGEV instead, which is faster.) A generalized eigenvalue for a pair of matrices (A,B) is a scalar w or a ratio alpha/beta = w, such that A - w*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0 or both being zero. A pair of matrices (S,T) is in generalized real Schur form if T is upper triangular with non-negative diagonal and S is block upper triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond to real generalized eigenvalues, while 2-by-2 blocks of S will be "standardized" by making the corresponding elements of T have the form: [ a 0 ] [ 0 b ] and the pair of corresponding 2-by-2 blocks in S and T will have a complex conjugate pair of generalized eigenvalues.  <br /></td></tr>
<tr class="separator:a04827eeebb3ce470ddc3318c9b09b35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3832602cc73d19f1d3bad13ccf3bbebd" id="r_a3832602cc73d19f1d3bad13ccf3bbebd"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a3832602cc73d19f1d3bad13ccf3bbebd">la_lapack_s::la_sggev3</a> (jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork, info)</td></tr>
<tr class="memdesc:a3832602cc73d19f1d3bad13ccf3bbebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGEV3: computes for a pair of N-by-N real nonsymmetric matrices (A,B) the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors. A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta = lambda, such that A - lambda*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0, and even for both being zero. The right eigenvector v(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies A * v(j) = lambda(j) * B * v(j). The left eigenvector u(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies u(j)**H * A = lambda(j) * u(j)**H * B . where u(j)**H is the conjugate-transpose of u(j).  <br /></td></tr>
<tr class="separator:a3832602cc73d19f1d3bad13ccf3bbebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf06185403181cad6507e39e7390bbf" id="r_aadf06185403181cad6507e39e7390bbf"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aadf06185403181cad6507e39e7390bbf">la_lapack_s::la_sgsvj0</a> (jobv, m, n, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork, info)</td></tr>
<tr class="memdesc:aadf06185403181cad6507e39e7390bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGSVJ0: is called from SGESVJ as a pre-processor and that is its main purpose. It applies Jacobi rotations in the same way as SGESVJ does, but it does not check convergence (stopping criterion). Few tuning parameters (marked by [TP]) are available for the implementer.  <br /></td></tr>
<tr class="separator:aadf06185403181cad6507e39e7390bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0419abb9347e8ba64371d1c3af182ed0" id="r_a0419abb9347e8ba64371d1c3af182ed0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0419abb9347e8ba64371d1c3af182ed0">la_lapack_s::la_sgsvj1</a> (jobv, m, n, n1, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork, info)</td></tr>
<tr class="memdesc:a0419abb9347e8ba64371d1c3af182ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGSVJ1: is called from SGESVJ as a pre-processor and that is its main purpose. It applies Jacobi rotations in the same way as SGESVJ does, but it targets only particular pivots and it does not check convergence (stopping criterion). Few tuning parameters (marked by [TP]) are available for the implementer. Further Details ~~~~~~~~~~~~~~~ SGSVJ1 applies few sweeps of Jacobi rotations in the column space of the input M-by-N matrix A. The pivot pairs are taken from the (1,2) off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The block-entries (tiles) of the (1,2) off-diagonal block are marked by the [x]'s in the following scheme: | * * * [x] [x] [x]| | * * * [x] [x] [x]| Row-cycling in the nblr-by-nblc [x] blocks. | * * * [x] [x] [x]| Row-cyclic pivoting inside each [x] block. |[x] [x] [x] * * * | |[x] [x] [x] * * * | |[x] [x] [x] * * * | In terms of the columns of A, the first N1 columns are rotated 'against' the remaining N-N1 columns, trying to increase the angle between the corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter. The number of sweeps is given in NSWEEP and the orthogonality threshold is given in TOL.  <br /></td></tr>
<tr class="separator:a0419abb9347e8ba64371d1c3af182ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c650f0f7b76b2e7c955ab99e577622" id="r_aa5c650f0f7b76b2e7c955ab99e577622"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aa5c650f0f7b76b2e7c955ab99e577622">la_lapack_s::la_shseqr</a> (job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork, info)</td></tr>
<tr class="memdesc:aa5c650f0f7b76b2e7c955ab99e577622"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHSEQR: computes the eigenvalues of a Hessenberg matrix H and, optionally, the matrices T and Z from the Schur decomposition H = Z T Z**T, where T is an upper quasi-triangular matrix (the Schur form), and Z is the orthogonal matrix of Schur vectors. Optionally Z may be postmultiplied into an input orthogonal matrix Q so that this routine can give the Schur factorization of a matrix A which has been reduced to the Hessenberg form H by the orthogonal matrix Q: A = Q*H*Q**T = (QZ)*T*(QZ)**T.  <br /></td></tr>
<tr class="separator:aa5c650f0f7b76b2e7c955ab99e577622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3303866da6908b83441a758964979cb" id="r_af3303866da6908b83441a758964979cb"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#af3303866da6908b83441a758964979cb">la_lapack_s::la_slalsa</a> (icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, vt, k, difl, difr, z, poles, givptr, givcol, ldgcol, perm, givnum, c, s, work, iwork, info)</td></tr>
<tr class="memdesc:af3303866da6908b83441a758964979cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLALSA: is an itermediate step in solving the least squares problem by computing the SVD of the coefficient matrix in compact form (The singular vectors are computed as products of simple orthorgonal matrices.). If ICOMPQ = 0, SLALSA applies the inverse of the left singular vector matrix of an upper bidiagonal matrix to the right hand side; and if ICOMPQ = 1, SLALSA applies the right singular vector matrix to the right hand side. The singular vector matrices were generated in compact form by SLALSA.  <br /></td></tr>
<tr class="separator:af3303866da6908b83441a758964979cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a46e2270ab89716b2b8880eee0f97da" id="r_a7a46e2270ab89716b2b8880eee0f97da"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7a46e2270ab89716b2b8880eee0f97da">la_lapack_s::la_slalsd</a> (uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond, rank, work, iwork, info)</td></tr>
<tr class="memdesc:a7a46e2270ab89716b2b8880eee0f97da"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLALSD: uses the singular value decomposition of A to solve the least squares problem of finding X to minimize the Euclidean norm of each column of A*X-B, where A is N-by-N upper bidiagonal, and X and B are N-by-NRHS. The solution X overwrites B. The singular values of A smaller than RCOND times the largest singular value are treated as zero in solving the least squares problem; in this case a minimum norm solution is returned. The actual singular values are returned in D in ascending order. This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a7a46e2270ab89716b2b8880eee0f97da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3e7151047e92da44bc41c4581515b5" id="r_a0b3e7151047e92da44bc41c4581515b5"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a0b3e7151047e92da44bc41c4581515b5">la_lapack_s::la_slaqr0</a> (wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihiz, z, ldz, work, lwork, info)</td></tr>
<tr class="memdesc:a0b3e7151047e92da44bc41c4581515b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQR0: computes the eigenvalues of a Hessenberg matrix H and, optionally, the matrices T and Z from the Schur decomposition H = Z T Z**T, where T is an upper quasi-triangular matrix (the Schur form), and Z is the orthogonal matrix of Schur vectors. Optionally Z may be postmultiplied into an input orthogonal matrix Q so that this routine can give the Schur factorization of a matrix A which has been reduced to the Hessenberg form H by the orthogonal matrix Q: A = Q*H*Q**T = (QZ)*T*(QZ)**T.  <br /></td></tr>
<tr class="separator:a0b3e7151047e92da44bc41c4581515b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b80378fd76956d60da5f2f895dafdbf" id="r_a9b80378fd76956d60da5f2f895dafdbf"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9b80378fd76956d60da5f2f895dafdbf">la_lapack_s::la_slaqr3</a> (wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz, z, ldz, ns, nd, sr, si, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork)</td></tr>
<tr class="memdesc:a9b80378fd76956d60da5f2f895dafdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggressive early deflation: SLAQR3: accepts as input an upper Hessenberg matrix H and performs an orthogonal similarity transformation designed to detect and deflate fully converged eigenvalues from a trailing principal submatrix. On output H has been over- written by a new Hessenberg matrix that is a perturbation of an orthogonal similarity transformation of H. It is to be hoped that the final version of H has many zero subdiagonal entries.  <br /></td></tr>
<tr class="separator:a9b80378fd76956d60da5f2f895dafdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd23aae408540ca5933401fb18eb858" id="r_aabd23aae408540ca5933401fb18eb858"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aabd23aae408540ca5933401fb18eb858">la_lapack_s::la_slaqr4</a> (wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihiz, z, ldz, work, lwork, info)</td></tr>
<tr class="memdesc:aabd23aae408540ca5933401fb18eb858"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQR4: implements one level of recursion for SLAQR0. It is a complete implementation of the small bulge multi-shift QR algorithm. It may be called by SLAQR0 and, for large enough deflation window size, it may be called by SLAQR3. This subroutine is identical to SLAQR0 except that it calls SLAQR2 instead of SLAQR3. SLAQR4 computes the eigenvalues of a Hessenberg matrix H and, optionally, the matrices T and Z from the Schur decomposition H = Z T Z**T, where T is an upper quasi-triangular matrix (the Schur form), and Z is the orthogonal matrix of Schur vectors. Optionally Z may be postmultiplied into an input orthogonal matrix Q so that this routine can give the Schur factorization of a matrix A which has been reduced to the Hessenberg form H by the orthogonal matrix Q: A = Q*H*Q**T = (QZ)*T*(QZ)**T.  <br /></td></tr>
<tr class="separator:aabd23aae408540ca5933401fb18eb858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918915d6fa929aef9a11f4570fef2e99" id="r_a918915d6fa929aef9a11f4570fef2e99"><td class="memItemLeft" align="right" valign="top">recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a918915d6fa929aef9a11f4570fef2e99">la_lapack_s::la_slaqz0</a> (wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, work, lwork, rec, info)</td></tr>
<tr class="memdesc:a918915d6fa929aef9a11f4570fef2e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQZ0: computes the eigenvalues of a real matrix pair (H,T), where H is an upper Hessenberg matrix and T is upper triangular, using the double-shift QZ method. Matrix pairs of this type are produced by the reduction to generalized upper Hessenberg form of a real matrix pair (A,B): A = Q1*H*Z1**T, B = Q1*T*Z1**T, as computed by SGGHRD. If JOB='S', then the Hessenberg-triangular pair (H,T) is also reduced to generalized Schur form, H = Q*S*Z**T, T = Q*P*Z**T, where Q and Z are orthogonal matrices, P is an upper triangular matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2 diagonal blocks. The 1-by-1 blocks correspond to real eigenvalues of the matrix pair (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of eigenvalues. Additionally, the 2-by-2 upper triangular diagonal blocks of P corresponding to 2-by-2 blocks of S are reduced to positive diagonal form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0, P(j,j) &gt; 0, and P(j+1,j+1) &gt; 0. Optionally, the orthogonal matrix Q from the generalized Schur factorization may be postmultiplied into an input matrix Q1, and the orthogonal matrix Z may be postmultiplied into an input matrix Z1. If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced the matrix pair (A,B) to generalized upper Hessenberg form, then the output matrices Q1*Q and Z1*Z are the orthogonal factors from the generalized Schur factorization of (A,B): A = (Q1*Q)*S*(Z1*Z)**T, B = (Q1*Q)*P*(Z1*Z)**T. To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently, of (A,B)) are computed as a pair of values (alpha,beta), where alpha is complex and beta real. If beta is nonzero, lambda = alpha / beta is an eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP) A*x = lambda*B*x and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the alternate form of the GNEP mu*A*y = B*y. Real eigenvalues can be read directly from the generalized Schur form: alpha = S(i,i), beta = P(i,i). Ref: C.B. Moler Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
 pp. 241&amp;ndash;256.
 Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ Algorithm with Aggressive Early Deflation", SIAM J. Numer.
 Anal., 29(2006), pp. 199&amp;ndash;227.
 Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift, multipole rational QZ method with agressive early deflation".  <br /></td></tr>
<tr class="separator:a918915d6fa929aef9a11f4570fef2e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9d2c997ed8ec0e656e97c186911186" id="r_abd9d2c997ed8ec0e656e97c186911186"><td class="memItemLeft" align="right" valign="top">recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#abd9d2c997ed8ec0e656e97c186911186">la_lapack_s::la_slaqz3</a> (ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb, q, ldq, z, ldz, ns, nd, alphar, alphai, beta, qc, ldqc, zc, ldzc, work, lwork, rec, info)</td></tr>
<tr class="memdesc:abd9d2c997ed8ec0e656e97c186911186"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLAQZ3: performs AED.  <br /></td></tr>
<tr class="separator:abd9d2c997ed8ec0e656e97c186911186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256e89163d63dd9104cb998011d9d446" id="r_a256e89163d63dd9104cb998011d9d446"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a256e89163d63dd9104cb998011d9d446">la_lapack_s::la_slarre</a> (range, n, vl, vu, il, iu, d, e, e2, rtol1, rtol2, spltol, nsplit, isplit, m, w, werr, wgap, iblock, indexw, gers, pivmin, work, iwork, info)</td></tr>
<tr class="memdesc:a256e89163d63dd9104cb998011d9d446"><td class="mdescLeft">&#160;</td><td class="mdescRight">To find the desired eigenvalues of a given real symmetric tridiagonal matrix T, SLARRE: sets any "small" off-diagonal elements to zero, and for each unreduced block T_i, it finds (a) a suitable shift at one end of the block's spectrum, (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and (c) eigenvalues of each L_i D_i L_i^T. The representations and eigenvalues found are then used by SSTEMR to compute the eigenvectors of T. The accuracy varies depending on whether bisection is used to find a few eigenvalues or the dqds algorithm (subroutine SLASQ2) to conpute all and then discard any unwanted one. As an added benefit, SLARRE also outputs the n Gerschgorin intervals for the matrices L_i D_i L_i^T.  <br /></td></tr>
<tr class="separator:a256e89163d63dd9104cb998011d9d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dddfeac054b251024e3a6380500e08f" id="r_a7dddfeac054b251024e3a6380500e08f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7dddfeac054b251024e3a6380500e08f">la_lapack_s::la_slasd0</a> (n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork, work, info)</td></tr>
<tr class="memdesc:a7dddfeac054b251024e3a6380500e08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using a divide and conquer approach, SLASD0: computes the singular value decomposition (SVD) of a real upper bidiagonal N-by-M matrix B with diagonal D and offdiagonal E, where M = N + SQRE. The algorithm computes orthogonal matrices U and VT such that B = U * S * VT. The singular values S are overwritten on D. A related subroutine, SLASDA, computes only the singular values, and optionally, the singular vectors in compact form.  <br /></td></tr>
<tr class="separator:a7dddfeac054b251024e3a6380500e08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742b768b684f4625c54daf1e2d1d6e45" id="r_a742b768b684f4625c54daf1e2d1d6e45"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a742b768b684f4625c54daf1e2d1d6e45">la_lapack_s::la_slasda</a> (icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k, difl, difr, z, poles, givptr, givcol, ldgcol, perm, givnum, c, s, work, iwork, info)</td></tr>
<tr class="memdesc:a742b768b684f4625c54daf1e2d1d6e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using a divide and conquer approach, SLASDA: computes the singular value decomposition (SVD) of a real upper bidiagonal N-by-M matrix B with diagonal D and offdiagonal E, where M = N + SQRE. The algorithm computes the singular values in the SVD B = U * S * VT. The orthogonal matrices U and VT are optionally computed in compact form. A related subroutine, SLASD0, computes the singular values and the singular vectors in explicit form.  <br /></td></tr>
<tr class="separator:a742b768b684f4625c54daf1e2d1d6e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616d97054f76ff8d1cdc3a0f76e97f74" id="r_a616d97054f76ff8d1cdc3a0f76e97f74"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a616d97054f76ff8d1cdc3a0f76e97f74">la_lapack_s::la_slasdq</a> (uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work, info)</td></tr>
<tr class="memdesc:a616d97054f76ff8d1cdc3a0f76e97f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASDQ: computes the singular value decomposition (SVD) of a real (upper or lower) bidiagonal matrix with diagonal D and offdiagonal E, accumulating the transformations if desired. Letting B denote the input bidiagonal matrix, the algorithm computes orthogonal matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose of P). The singular values S are overwritten on D. The input matrix U is changed to U * Q if desired. The input matrix VT is changed to P**T * VT if desired. The input matrix C is changed to Q**T * C if desired. See "Computing  Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan, LAPACK Working Note #3, for a detailed description of the algorithm.  <br /></td></tr>
<tr class="separator:a616d97054f76ff8d1cdc3a0f76e97f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd52883d5efb79c2b2338ac95e924ae" id="r_aecd52883d5efb79c2b2338ac95e924ae"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#aecd52883d5efb79c2b2338ac95e924ae">la_lapack_s::la_slasq1</a> (n, d, e, work, info)</td></tr>
<tr class="memdesc:aecd52883d5efb79c2b2338ac95e924ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASQ1: computes the singular values of a real N-by-N bidiagonal matrix with diagonal D and off-diagonal E. The singular values are computed to high relative accuracy, in the absence of denormalization, underflow and overflow. The algorithm was first presented in "Accurate singular values and differential qd algorithms" by K. V. Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230, 1994, and the present implementation is described in "An implementation of
 the dqds Algorithm (Positive Case)", LAPACK Working Note.  <br /></td></tr>
<tr class="separator:aecd52883d5efb79c2b2338ac95e924ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fb6a730c9eb9353a9816114e2c3825" id="r_a73fb6a730c9eb9353a9816114e2c3825"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a73fb6a730c9eb9353a9816114e2c3825">la_lapack_s::la_slasq2</a> (n, z, info)</td></tr>
<tr class="memdesc:a73fb6a730c9eb9353a9816114e2c3825"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLASQ2: computes all the eigenvalues of the symmetric positive definite tridiagonal matrix associated with the qd array Z to high relative accuracy are computed to high relative accuracy, in the absence of denormalization, underflow and overflow. To see the relation of Z to the tridiagonal matrix, let L be a unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and let U be an upper bidiagonal matrix with 1's above and diagonal Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the symmetric tridiagonal to which it is similar. Note : SLASQ2 defines a logical variable, IEEE, which is true on machines which follow ieee-754 floating-point standard in their handling of infinities and NaNs, and false otherwise. This variable is passed to SLASQ3.  <br /></td></tr>
<tr class="separator:a73fb6a730c9eb9353a9816114e2c3825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08edab7cff5876848c36521ed8a909a3" id="r_a08edab7cff5876848c36521ed8a909a3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a08edab7cff5876848c36521ed8a909a3">la_lapack_s::la_slasyf_aa</a> (uplo, j1, m, nb, a, lda, ipiv, h, ldh, work)</td></tr>
<tr class="memdesc:a08edab7cff5876848c36521ed8a909a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">DLATRF_AA factorizes a panel of a real symmetric matrix A using the Aasen's algorithm. The panel consists of a set of NB rows of A when UPLO is U, or a set of NB columns when UPLO is L. In order to factorize the panel, the Aasen's algorithm requires the last row, or column, of the previous panel. The first row, or column, of A is set to be the first row, or column, of an identity matrix, which is used to factorize the first panel. The resulting J-th row of U, or J-th column of L, is stored in the (J-1)-th row, or column, of A (without the unit diagonals), while the diagonal and subdiagonal of A are overwritten by those of T.  <br /></td></tr>
<tr class="separator:a08edab7cff5876848c36521ed8a909a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca655efe0766babac402a984e3ec019" id="r_adca655efe0766babac402a984e3ec019"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#adca655efe0766babac402a984e3ec019">la_lapack_s::la_spteqr</a> (compz, n, d, e, z, ldz, work, info)</td></tr>
<tr class="memdesc:adca655efe0766babac402a984e3ec019"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPTEQR: computes all eigenvalues and, optionally, eigenvectors of a symmetric positive definite tridiagonal matrix by first factoring the matrix using SPTTRF, and then calling SBDSQR to compute the singular values of the bidiagonal factor. This routine computes the eigenvalues of the positive definite tridiagonal matrix to high relative accuracy. This means that if the eigenvalues range over many orders of magnitude in size, then the small eigenvalues and corresponding eigenvectors will be computed more accurately than, for example, with the standard QR method. The eigenvectors of a full or band symmetric positive definite matrix can also be found if SSYTRD, SSPTRD, or SSBTRD has been used to reduce this matrix to tridiagonal form. (The reduction to tridiagonal form, however, may preclude the possibility of obtaining high relative accuracy in the small eigenvalues of the original matrix, if these eigenvalues range over many orders of magnitude.)  <br /></td></tr>
<tr class="separator:adca655efe0766babac402a984e3ec019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f3281b2a336a1a00092ee1eb6e5a64" id="r_a51f3281b2a336a1a00092ee1eb6e5a64"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a51f3281b2a336a1a00092ee1eb6e5a64">la_lapack_s::la_sstegr</a> (jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a51f3281b2a336a1a00092ee1eb6e5a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEGR: computes selected eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix T. Any such unreduced matrix has a well defined set of pairwise different real eigenvalues, the corresponding real eigenvectors are pairwise orthogonal. The spectrum may be computed either completely or partially by specifying either an interval (VL,VU] or a range of indices IL:IU for the desired eigenvalues. SSTEGR is a compatibility wrapper around the improved SSTEMR routine. See SSTEMR for further details. One important change is that the ABSTOL parameter no longer provides any benefit and hence is no longer used. Note : SSTEGR and SSTEMR work only on machines which follow IEEE-754 floating-point standard in their handling of infinities and NaNs. Normal execution may create these exceptiona values and hence may abort due to a floating point exception in environments which do not conform to the IEEE-754 standard.  <br /></td></tr>
<tr class="separator:a51f3281b2a336a1a00092ee1eb6e5a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bc6b7d78f3fd8e53da8e1bb968afb2" id="r_a62bc6b7d78f3fd8e53da8e1bb968afb2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a62bc6b7d78f3fd8e53da8e1bb968afb2">la_lapack_s::la_sstemr</a> (jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a62bc6b7d78f3fd8e53da8e1bb968afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEMR: computes selected eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix T. Any such unreduced matrix has a well defined set of pairwise different real eigenvalues, the corresponding real eigenvectors are pairwise orthogonal. The spectrum may be computed either completely or partially by specifying either an interval (VL,VU] or a range of indices IL:IU for the desired eigenvalues. Depending on the number of desired eigenvalues, these are computed either by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are computed by the use of various suitable L D L^T factorizations near clusters of close eigenvalues (referred to as RRRs, Relatively Robust Representations). An informal sketch of the algorithm follows. For each unreduced block (submatrix) of T, (a) Compute T - sigma I = L D L^T, so that L and D define all the wanted eigenvalues to high relative accuracy. This means that small relative changes in the entries of D and L cause only small relative changes in the eigenvalues and eigenvectors. The standard (unfactored) representation of the tridiagonal matrix T does not have this property in general. (b) Compute the eigenvalues to suitable accuracy. If the eigenvectors are desired, the algorithm attains full accuracy of the computed eigenvalues only right before the corresponding vectors have to be computed, see steps c) and d). (c) For each cluster of close eigenvalues, select a new shift close to the cluster, find a new factorization, and refine the shifted eigenvalues to suitable accuracy. (d) For each eigenvalue with a large enough relative separation compute the corresponding eigenvector by forming a rank revealing twisted factorization. Go back to (c) for any clusters that remain. For more details, see:  <br /></td></tr>
<tr class="separator:a62bc6b7d78f3fd8e53da8e1bb968afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7f882315172c08874b0388e5786b83" id="r_a7e7f882315172c08874b0388e5786b83"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a7e7f882315172c08874b0388e5786b83">la_lapack_s::la_sstevr</a> (jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a7e7f882315172c08874b0388e5786b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEVR: computes selected eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix T. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues. Whenever possible, SSTEVR calls SSTEMR to compute the eigenspectrum using Relatively Robust Representations. SSTEMR computes eigenvalues by the dqds algorithm, while orthogonal eigenvectors are computed from various "good" L D L^T representations (also known as Relatively Robust Representations). Gram-Schmidt orthogonalization is avoided as far as possible. More specifically, the various steps of the algorithm are as follows. For the i-th unreduced block of T, (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T is a relatively robust representation, (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high relative accuracy by the dqds algorithm, (c) If there is a cluster of close eigenvalues, "choose" sigma_i close to the cluster, and go to step (a), (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T, compute the corresponding eigenvector by forming a rank-revealing twisted factorization. The desired accuracy of the output can be specified by the input parameter ABSTOL. For more details, see "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon, Computer Science Division Technical Report No. UCB//CSD-97-971, UC Berkeley, May 1997. Note 1 : SSTEVR calls SSTEMR when the full spectrum is requested on machines which conform to the ieee-754 floating point standard. SSTEVR calls SSTEBZ and SSTEIN on non-ieee machines and when partial spectrum requests are made. Normal execution of SSTEMR may create NaNs and infinities and hence may abort due to a floating point exception in environments which do not handle NaNs and infinities in the ieee standard default manner.  <br /></td></tr>
<tr class="separator:a7e7f882315172c08874b0388e5786b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aec32873c196af2d9f9f818047e2498" id="r_a9aec32873c196af2d9f9f818047e2498"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a9aec32873c196af2d9f9f818047e2498">la_lapack_s::la_ssyevr</a> (jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a9aec32873c196af2d9f9f818047e2498"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYEVR: computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues. SSYEVR first reduces the matrix A to tridiagonal form T with a call to SSYTRD. Then, whenever possible, SSYEVR calls SSTEMR to compute the eigenspectrum using Relatively Robust Representations. SSTEMR computes eigenvalues by the dqds algorithm, while orthogonal eigenvectors are computed from various "good" L D L^T representations (also known as Relatively Robust Representations). Gram-Schmidt orthogonalization is avoided as far as possible. More specifically, the various steps of the algorithm are as follows. For each unreduced block (submatrix) of T, (a) Compute T - sigma I = L D L^T, so that L and D define all the wanted eigenvalues to high relative accuracy. This means that small relative changes in the entries of D and L cause only small relative changes in the eigenvalues and eigenvectors. The standard (unfactored) representation of the tridiagonal matrix T does not have this property in general. (b) Compute the eigenvalues to suitable accuracy. If the eigenvectors are desired, the algorithm attains full accuracy of the computed eigenvalues only right before the corresponding vectors have to be computed, see steps c) and d). (c) For each cluster of close eigenvalues, select a new shift close to the cluster, find a new factorization, and refine the shifted eigenvalues to suitable accuracy. (d) For each eigenvalue with a large enough relative separation compute the corresponding eigenvector by forming a rank revealing twisted factorization. Go back to (c) for any clusters that remain. The desired accuracy of the output can be specified by the input parameter ABSTOL. For more details, see SSTEMR's documentation and:  <br /></td></tr>
<tr class="separator:a9aec32873c196af2d9f9f818047e2498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ecb4126c173acf82eeb10641789be4" id="r_a17ecb4126c173acf82eeb10641789be4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a17ecb4126c173acf82eeb10641789be4">la_lapack_s::la_ssysv_aa</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a17ecb4126c173acf82eeb10641789be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYSV computes the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices. Aasen's algorithm is used to factor A as A = U**T * T * U, if UPLO = 'U', or A = L * T * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and T is symmetric tridiagonal. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a17ecb4126c173acf82eeb10641789be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338263e986fdc106dc0e630dbb997fb0" id="r_a338263e986fdc106dc0e630dbb997fb0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__s.html#a338263e986fdc106dc0e630dbb997fb0">la_lapack_s::la_ssytrf_aa</a> (uplo, n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:a338263e986fdc106dc0e630dbb997fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSYTRF_AA: computes the factorization of a real symmetric matrix A using the Aasen's algorithm. The form of the factorization is A = U**T*T*U or A = L*T*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and T is a symmetric tridiagonal matrix. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a338263e986fdc106dc0e630dbb997fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="la__lapack__s_8f90.html">la_lapack_s.f90</a></li>
    <li class="footer">Generated on Sun Jan 26 2025 11:04:29 for fortran-lapack by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
