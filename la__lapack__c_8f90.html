<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fortran-lapack: la_lapack_c.f90 File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init()
        </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fortran-lapack
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('la__lapack__c_8f90.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Modules</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle"><div class="title">la_lapack_c.f90 File Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Modules</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">module &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html">la_lapack_c</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a6f9340f354f5756d6e4f876dcc254f89" id="r_a6f9340f354f5756d6e4f876dcc254f89"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6f9340f354f5756d6e4f876dcc254f89">la_lapack_c::la_cgbequ</a> (m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, info)</td></tr>
<tr class="memdesc:a6f9340f354f5756d6e4f876dcc254f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBEQU: computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its condition number. R returns the row scale factors and C the column scale factors, chosen to try to make the largest element in each row and column of the matrix B with elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1. R(i) and C(j) are restricted to be between SMLNUM = smallest safe number and BIGNUM = largest safe number. Use of these scaling factors is not guaranteed to reduce the condition number of A but works well in practice.  <br /></td></tr>
<tr class="separator:a6f9340f354f5756d6e4f876dcc254f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af500ae2e17da6fb9d7703f7637815fe4" id="r_af500ae2e17da6fb9d7703f7637815fe4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af500ae2e17da6fb9d7703f7637815fe4">la_lapack_c::la_cgbequb</a> (m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, info)</td></tr>
<tr class="memdesc:af500ae2e17da6fb9d7703f7637815fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBEQUB: computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its condition number. R returns the row scale factors and C the column scale factors, chosen to try to make the largest element in each row and column of the matrix B with elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most the radix. R(i) and C(j) are restricted to be a power of the radix between SMLNUM = smallest safe number and BIGNUM = largest safe number. Use of these scaling factors is not guaranteed to reduce the condition number of A but works well in practice. This routine differs from CGEEQU by restricting the scaling factors to a power of the radix. Barring over- and underflow, scaling by these factors introduces no additional rounding errors. However, the scaled entries' magnitudes are no longer approximately 1 but lie between sqrt(radix) and 1/sqrt(radix).  <br /></td></tr>
<tr class="separator:af500ae2e17da6fb9d7703f7637815fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214e4009c5a2a23826821e8011183ced" id="r_a214e4009c5a2a23826821e8011183ced"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a214e4009c5a2a23826821e8011183ced">la_lapack_c::la_cgbtf2</a> (m, n, kl, ku, ab, ldab, ipiv, info)</td></tr>
<tr class="memdesc:a214e4009c5a2a23826821e8011183ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBTF2: computes an LU factorization of a complex m-by-n band matrix A using partial pivoting with row interchanges. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:a214e4009c5a2a23826821e8011183ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8bd7bbbd51a2fe169815b22bfa0f0e" id="r_aed8bd7bbbd51a2fe169815b22bfa0f0e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aed8bd7bbbd51a2fe169815b22bfa0f0e">la_lapack_c::la_cgebak</a> (job, side, n, ilo, ihi, scale, m, v, ldv, info)</td></tr>
<tr class="memdesc:aed8bd7bbbd51a2fe169815b22bfa0f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEBAK: forms the right or left eigenvectors of a complex general matrix by backward transformation on the computed eigenvectors of the balanced matrix output by CGEBAL.  <br /></td></tr>
<tr class="separator:aed8bd7bbbd51a2fe169815b22bfa0f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5f3a714e4a601abe8ba986e6a5c455" id="r_add5f3a714e4a601abe8ba986e6a5c455"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#add5f3a714e4a601abe8ba986e6a5c455">la_lapack_c::la_cgebal</a> (job, n, a, lda, ilo, ihi, scale, info)</td></tr>
<tr class="memdesc:add5f3a714e4a601abe8ba986e6a5c455"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEBAL: balances a general complex matrix A. This involves, first, permuting A by a similarity transformation to isolate eigenvalues in the first 1 to ILO-1 and last IHI+1 to N elements on the diagonal; and second, applying a diagonal similarity transformation to rows and columns ILO to IHI to make the rows and columns as close in norm as possible. Both steps are optional. Balancing may reduce the 1-norm of the matrix, and improve the accuracy of the computed eigenvalues and/or eigenvectors.  <br /></td></tr>
<tr class="separator:add5f3a714e4a601abe8ba986e6a5c455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6400708454a06ed2e7bd131b1ac7ba2" id="r_ab6400708454a06ed2e7bd131b1ac7ba2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab6400708454a06ed2e7bd131b1ac7ba2">la_lapack_c::la_cgeequ</a> (m, n, a, lda, r, c, rowcnd, colcnd, amax, info)</td></tr>
<tr class="memdesc:ab6400708454a06ed2e7bd131b1ac7ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEEQU: computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its condition number. R returns the row scale factors and C the column scale factors, chosen to try to make the largest element in each row and column of the matrix B with elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1. R(i) and C(j) are restricted to be between SMLNUM = smallest safe number and BIGNUM = largest safe number. Use of these scaling factors is not guaranteed to reduce the condition number of A but works well in practice.  <br /></td></tr>
<tr class="separator:ab6400708454a06ed2e7bd131b1ac7ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f4b4b93d201282f88305425d76a7a1" id="r_af6f4b4b93d201282f88305425d76a7a1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af6f4b4b93d201282f88305425d76a7a1">la_lapack_c::la_cgeequb</a> (m, n, a, lda, r, c, rowcnd, colcnd, amax, info)</td></tr>
<tr class="memdesc:af6f4b4b93d201282f88305425d76a7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEEQUB: computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its condition number. R returns the row scale factors and C the column scale factors, chosen to try to make the largest element in each row and column of the matrix B with elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most the radix. R(i) and C(j) are restricted to be a power of the radix between SMLNUM = smallest safe number and BIGNUM = largest safe number. Use of these scaling factors is not guaranteed to reduce the condition number of A but works well in practice. This routine differs from CGEEQU by restricting the scaling factors to a power of the radix. Barring over- and underflow, scaling by these factors introduces no additional rounding errors. However, the scaled entries' magnitudes are no longer approximately 1 but lie between sqrt(radix) and 1/sqrt(radix).  <br /></td></tr>
<tr class="separator:af6f4b4b93d201282f88305425d76a7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79802cc17dfe4239f6dbd5eb5e1d035" id="r_ac79802cc17dfe4239f6dbd5eb5e1d035"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac79802cc17dfe4239f6dbd5eb5e1d035">la_lapack_c::la_cgetc2</a> (n, a, lda, ipiv, jpiv, info)</td></tr>
<tr class="memdesc:ac79802cc17dfe4239f6dbd5eb5e1d035"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETC2: computes an LU factorization, using complete pivoting, of the n-by-n matrix A. The factorization has the form A = P * L * U * Q, where P and Q are permutation matrices, L is lower triangular with unit diagonal elements and U is upper triangular. This is a level 1 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:ac79802cc17dfe4239f6dbd5eb5e1d035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3d050368169adfc97cc9f4ae97e5d9" id="r_a9b3d050368169adfc97cc9f4ae97e5d9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9b3d050368169adfc97cc9f4ae97e5d9">la_lapack_c::la_cgetf2</a> (m, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:a9b3d050368169adfc97cc9f4ae97e5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETF2: computes an LU factorization of a general m-by-n matrix A using partial pivoting with row interchanges. The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n). This is the right-looking Level 2 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:a9b3d050368169adfc97cc9f4ae97e5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e7c92360aefff73ea435dbd6851fe5" id="r_ad1e7c92360aefff73ea435dbd6851fe5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad1e7c92360aefff73ea435dbd6851fe5">la_lapack_c::la_cggbak</a> (job, side, n, ilo, ihi, lscale, rscale, m, v, ldv, info)</td></tr>
<tr class="memdesc:ad1e7c92360aefff73ea435dbd6851fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGBAK: forms the right or left eigenvectors of a complex generalized eigenvalue problem A*x = lambda*B*x, by backward transformation on the computed eigenvectors of the balanced pair of matrices output by CGGBAL.  <br /></td></tr>
<tr class="separator:ad1e7c92360aefff73ea435dbd6851fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fcd950a4c713f9534996ccef046977" id="r_a80fcd950a4c713f9534996ccef046977"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a80fcd950a4c713f9534996ccef046977">la_lapack_c::la_cggbal</a> (job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work, info)</td></tr>
<tr class="memdesc:a80fcd950a4c713f9534996ccef046977"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGBAL: balances a pair of general complex matrices (A,B). This involves, first, permuting A and B by similarity transformations to isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N elements on the diagonal; and second, applying a diagonal similarity transformation to rows and columns ILO to IHI to make the rows and columns as close in norm as possible. Both steps are optional. Balancing may reduce the 1-norm of the matrices, and improve the accuracy of the computed eigenvalues and/or eigenvectors in the generalized eigenvalue problem A*x = lambda*B*x.  <br /></td></tr>
<tr class="separator:a80fcd950a4c713f9534996ccef046977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f0f0d1550e804f9bcf4aa49e84c9fb" id="r_a32f0f0d1550e804f9bcf4aa49e84c9fb"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a32f0f0d1550e804f9bcf4aa49e84c9fb">la_lapack_c::la_cgtsv</a> (n, nrhs, dl, d, du, b, ldb, info)</td></tr>
<tr class="memdesc:a32f0f0d1550e804f9bcf4aa49e84c9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGTSV: solves the equation A*X = B, where A is an N-by-N tridiagonal matrix, by Gaussian elimination with partial pivoting. Note that the equation A**T *X = B may be solved by interchanging the order of the arguments DU and DL.  <br /></td></tr>
<tr class="separator:a32f0f0d1550e804f9bcf4aa49e84c9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4eac5992cca0ddd44f380af8260c9a" id="r_a1d4eac5992cca0ddd44f380af8260c9a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1d4eac5992cca0ddd44f380af8260c9a">la_lapack_c::la_cgttrf</a> (n, dl, d, du, du2, ipiv, info)</td></tr>
<tr class="memdesc:a1d4eac5992cca0ddd44f380af8260c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGTTRF: computes an LU factorization of a complex tridiagonal matrix A using elimination with partial pivoting and row interchanges. The factorization has the form A = L * U where L is a product of permutation and unit lower bidiagonal matrices and U is upper triangular with nonzeros in only the main diagonal and first two superdiagonals.  <br /></td></tr>
<tr class="separator:a1d4eac5992cca0ddd44f380af8260c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0b276b15d76d79e5bb5a694f8a116b" id="r_a7e0b276b15d76d79e5bb5a694f8a116b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a7e0b276b15d76d79e5bb5a694f8a116b">la_lapack_c::la_cgtts2</a> (itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb)</td></tr>
<tr class="memdesc:a7e0b276b15d76d79e5bb5a694f8a116b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGTTS2: solves one of the systems of equations A * X = B, A**T * X = B, or A**H * X = B, with a tridiagonal matrix A using the LU factorization computed by CGTTRF.  <br /></td></tr>
<tr class="separator:a7e0b276b15d76d79e5bb5a694f8a116b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1985c751f9e83536b6d3ff51ed6a9cdb" id="r_a1985c751f9e83536b6d3ff51ed6a9cdb"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1985c751f9e83536b6d3ff51ed6a9cdb">la_lapack_c::la_cheswapr</a> (uplo, n, a, lda, i1, i2)</td></tr>
<tr class="memdesc:a1985c751f9e83536b6d3ff51ed6a9cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHESWAPR: applies an elementary permutation on the rows and the columns of a hermitian matrix.  <br /></td></tr>
<tr class="separator:a1985c751f9e83536b6d3ff51ed6a9cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46614b37b9515dda4ae9b3fed47c192" id="r_af46614b37b9515dda4ae9b3fed47c192"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af46614b37b9515dda4ae9b3fed47c192">la_lapack_c::la_chetf2</a> (uplo, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:af46614b37b9515dda4ae9b3fed47c192"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETF2: computes the factorization of a complex Hermitian matrix A using the Bunch-Kaufman diagonal pivoting method: A = U*D*U**H or A = L*D*L**H where U (or L) is a product of permutation and unit upper (lower) triangular matrices, U**H is the conjugate transpose of U, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:af46614b37b9515dda4ae9b3fed47c192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d4b4c63b5fbc38d5982ca049ed9495" id="r_ad9d4b4c63b5fbc38d5982ca049ed9495"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad9d4b4c63b5fbc38d5982ca049ed9495">la_lapack_c::la_chetf2_rk</a> (uplo, n, a, lda, e, ipiv, info)</td></tr>
<tr class="memdesc:ad9d4b4c63b5fbc38d5982ca049ed9495"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETF2_RK: computes the factorization of a complex Hermitian matrix A using the bounded Bunch-Kaufman (rook) diagonal pivoting method: A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T), where U (or L) is unit upper (or lower) triangular matrix, U**H (or L**H) is the conjugate of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the unblocked version of the algorithm, calling Level 2 BLAS. For more information see Further Details section.  <br /></td></tr>
<tr class="separator:ad9d4b4c63b5fbc38d5982ca049ed9495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153bc58e7e5dc7efd0b2178642d10e4c" id="r_a153bc58e7e5dc7efd0b2178642d10e4c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a153bc58e7e5dc7efd0b2178642d10e4c">la_lapack_c::la_chetf2_rook</a> (uplo, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:a153bc58e7e5dc7efd0b2178642d10e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETF2_ROOK: computes the factorization of a complex Hermitian matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method: A = U*D*U**H or A = L*D*L**H where U (or L) is a product of permutation and unit upper (lower) triangular matrices, U**H is the conjugate transpose of U, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:a153bc58e7e5dc7efd0b2178642d10e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c908101d39832dc9576675ff66ac3e5" id="r_a0c908101d39832dc9576675ff66ac3e5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0c908101d39832dc9576675ff66ac3e5">la_lapack_c::la_chetri</a> (uplo, n, a, lda, ipiv, work, info)</td></tr>
<tr class="memdesc:a0c908101d39832dc9576675ff66ac3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRI: computes the inverse of a complex Hermitian indefinite matrix A using the factorization A = U*D*U**H or A = L*D*L**H computed by CHETRF.  <br /></td></tr>
<tr class="separator:a0c908101d39832dc9576675ff66ac3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48cb9fe0fc5d27704f458232983cd7b" id="r_ab48cb9fe0fc5d27704f458232983cd7b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab48cb9fe0fc5d27704f458232983cd7b">la_lapack_c::la_chetri_rook</a> (uplo, n, a, lda, ipiv, work, info)</td></tr>
<tr class="memdesc:ab48cb9fe0fc5d27704f458232983cd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRI_ROOK: computes the inverse of a complex Hermitian indefinite matrix A using the factorization A = U*D*U**H or A = L*D*L**H computed by CHETRF_ROOK.  <br /></td></tr>
<tr class="separator:ab48cb9fe0fc5d27704f458232983cd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e53cd2e5336985c3b6ff5a8610c048e" id="r_a8e53cd2e5336985c3b6ff5a8610c048e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a8e53cd2e5336985c3b6ff5a8610c048e">la_lapack_c::la_chetrs_3</a> (uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a8e53cd2e5336985c3b6ff5a8610c048e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRS_3: solves a system of linear equations A * X = B with a complex Hermitian matrix A using the factorization computed by CHETRF_RK or CHETRF_BK: A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T), where U (or L) is unit upper (or lower) triangular matrix, U**H (or L**H) is the conjugate of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This algorithm is using Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a8e53cd2e5336985c3b6ff5a8610c048e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5aa97d507ee552c7485858e8f6f9ca" id="r_a6d5aa97d507ee552c7485858e8f6f9ca"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6d5aa97d507ee552c7485858e8f6f9ca">la_lapack_c::la_chfrk</a> (transr, uplo, trans, n, k, alpha, a, lda, beta, c)</td></tr>
<tr class="memdesc:a6d5aa97d507ee552c7485858e8f6f9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level 3 BLAS like routine for C in RFP Format. CHFRK: performs one of the Hermitian rank&ndash;k operations C := alpha*A*A**H + beta*C, or C := alpha*A**H*A + beta*C, where alpha and beta are real scalars, C is an n&ndash;by&ndash;n Hermitian matrix and A is an n&ndash;by&ndash;k matrix in the first case and a k&ndash;by&ndash;n matrix in the second case.  <br /></td></tr>
<tr class="separator:a6d5aa97d507ee552c7485858e8f6f9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbbda92a89fb723be1f0848405d2afc" id="r_acbbbda92a89fb723be1f0848405d2afc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#acbbbda92a89fb723be1f0848405d2afc">la_lapack_c::la_chpgst</a> (itype, uplo, n, ap, bp, info)</td></tr>
<tr class="memdesc:acbbbda92a89fb723be1f0848405d2afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPGST: reduces a complex Hermitian-definite generalized eigenproblem to standard form, using packed storage. If ITYPE = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H) If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L. B must have been previously factorized as U**H*U or L*L**H by CPPTRF.  <br /></td></tr>
<tr class="separator:acbbbda92a89fb723be1f0848405d2afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd29d89cdda6d0f4f5eb9afe745065c" id="r_a7cd29d89cdda6d0f4f5eb9afe745065c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a7cd29d89cdda6d0f4f5eb9afe745065c">la_lapack_c::la_chptrf</a> (uplo, n, ap, ipiv, info)</td></tr>
<tr class="memdesc:a7cd29d89cdda6d0f4f5eb9afe745065c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPTRF: computes the factorization of a complex Hermitian packed matrix A using the Bunch-Kaufman diagonal pivoting method: A = U*D*U**H or A = L*D*L**H where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.  <br /></td></tr>
<tr class="separator:a7cd29d89cdda6d0f4f5eb9afe745065c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca54ee27860996069113aeb556fbd300" id="r_aca54ee27860996069113aeb556fbd300"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aca54ee27860996069113aeb556fbd300">la_lapack_c::la_chptri</a> (uplo, n, ap, ipiv, work, info)</td></tr>
<tr class="memdesc:aca54ee27860996069113aeb556fbd300"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPTRI: computes the inverse of a complex Hermitian indefinite matrix A in packed storage using the factorization A = U*D*U**H or A = L*D*L**H computed by CHPTRF.  <br /></td></tr>
<tr class="separator:aca54ee27860996069113aeb556fbd300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ca13af0c8c4f4f8c3b15f6da993b36" id="r_a98ca13af0c8c4f4f8c3b15f6da993b36"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a98ca13af0c8c4f4f8c3b15f6da993b36">la_lapack_c::la_cla_gbamv</a> (trans, m, n, kl, ku, alpha, ab, ldab, x, incx, beta, y, incy)</td></tr>
<tr class="memdesc:a98ca13af0c8c4f4f8c3b15f6da993b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_GBAMV: performs one of the matrix-vector operations y := alpha*abs(A)*abs(x) + beta*abs(y), or y := alpha*abs(A)**T*abs(x) + beta*abs(y), where alpha and beta are scalars, x and y are vectors and A is an m by n matrix. This function is primarily used in calculating error bounds. To protect against underflow during evaluation, components in the resulting vector are perturbed away from zero by (N+1) times the underflow threshold. To prevent unnecessarily large errors for block-structure embedded in general matrices, "symbolically" zero components are not perturbed. A zero entry is considered "symbolic" if all multiplications involved in computing that entry have at least one zero multiplicand.  <br /></td></tr>
<tr class="separator:a98ca13af0c8c4f4f8c3b15f6da993b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe01774a09fc7d00c32f6349ff9b640" id="r_afbe01774a09fc7d00c32f6349ff9b640"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#afbe01774a09fc7d00c32f6349ff9b640">la_lapack_c::la_cla_gbrpvgrw</a> (n, kl, ku, ncols, ab, ldab, afb, ldafb)</td></tr>
<tr class="memdesc:afbe01774a09fc7d00c32f6349ff9b640"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_GBRPVGRW: computes the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If this is much less than 1, the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, estimated condition numbers, and error bounds could be unreliable.  <br /></td></tr>
<tr class="separator:afbe01774a09fc7d00c32f6349ff9b640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da3a16378f802d8f09fc097a524c067" id="r_a0da3a16378f802d8f09fc097a524c067"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0da3a16378f802d8f09fc097a524c067">la_lapack_c::la_cla_geamv</a> (trans, m, n, alpha, a, lda, x, incx, beta, y, incy)</td></tr>
<tr class="memdesc:a0da3a16378f802d8f09fc097a524c067"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_GEAMV: performs one of the matrix-vector operations y := alpha*abs(A)*abs(x) + beta*abs(y), or y := alpha*abs(A)**T*abs(x) + beta*abs(y), where alpha and beta are scalars, x and y are vectors and A is an m by n matrix. This function is primarily used in calculating error bounds. To protect against underflow during evaluation, components in the resulting vector are perturbed away from zero by (N+1) times the underflow threshold. To prevent unnecessarily large errors for block-structure embedded in general matrices, "symbolically" zero components are not perturbed. A zero entry is considered "symbolic" if all multiplications involved in computing that entry have at least one zero multiplicand.  <br /></td></tr>
<tr class="separator:a0da3a16378f802d8f09fc097a524c067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d9b7568af22f8b97fab6a9eeda15aa" id="r_a00d9b7568af22f8b97fab6a9eeda15aa"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a00d9b7568af22f8b97fab6a9eeda15aa">la_lapack_c::la_cla_gerpvgrw</a> (n, ncols, a, lda, af, ldaf)</td></tr>
<tr class="memdesc:a00d9b7568af22f8b97fab6a9eeda15aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_GERPVGRW: computes the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If this is much less than 1, the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, estimated condition numbers, and error bounds could be unreliable.  <br /></td></tr>
<tr class="separator:a00d9b7568af22f8b97fab6a9eeda15aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e081c2c4690fcc9c16659c577854ce3" id="r_a4e081c2c4690fcc9c16659c577854ce3"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4e081c2c4690fcc9c16659c577854ce3">la_lapack_c::la_cla_heamv</a> (uplo, n, alpha, a, lda, x, incx, beta, y, incy)</td></tr>
<tr class="memdesc:a4e081c2c4690fcc9c16659c577854ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_SYAMV performs the matrix-vector operation y := alpha*abs(A)*abs(x) + beta*abs(y), where alpha and beta are scalars, x and y are vectors and A is an n by n symmetric matrix. This function is primarily used in calculating error bounds. To protect against underflow during evaluation, components in the resulting vector are perturbed away from zero by (N+1) times the underflow threshold. To prevent unnecessarily large errors for block-structure embedded in general matrices, "symbolically" zero components are not perturbed. A zero entry is considered "symbolic" if all multiplications involved in computing that entry have at least one zero multiplicand.  <br /></td></tr>
<tr class="separator:a4e081c2c4690fcc9c16659c577854ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821285f8dea9d8f1bc6862d30f24e140" id="r_a821285f8dea9d8f1bc6862d30f24e140"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a821285f8dea9d8f1bc6862d30f24e140">la_lapack_c::la_cla_lin_berr</a> (n, nz, nrhs, res, ayb, berr)</td></tr>
<tr class="memdesc:a821285f8dea9d8f1bc6862d30f24e140"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_LIN_BERR: computes componentwise relative backward error from the formula max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) ) where abs(Z) is the componentwise absolute value of the matrix or vector Z.  <br /></td></tr>
<tr class="separator:a821285f8dea9d8f1bc6862d30f24e140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d0558d50ed081a55a4545c44a24b75" id="r_a43d0558d50ed081a55a4545c44a24b75"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a43d0558d50ed081a55a4545c44a24b75">la_lapack_c::la_cla_porpvgrw</a> (uplo, ncols, a, lda, af, ldaf, work)</td></tr>
<tr class="memdesc:a43d0558d50ed081a55a4545c44a24b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_PORPVGRW: computes the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If this is much less than 1, the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, estimated condition numbers, and error bounds could be unreliable.  <br /></td></tr>
<tr class="separator:a43d0558d50ed081a55a4545c44a24b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d8503212d569d91f1e69a9b9017ce3" id="r_ac0d8503212d569d91f1e69a9b9017ce3"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac0d8503212d569d91f1e69a9b9017ce3">la_lapack_c::la_cla_syamv</a> (uplo, n, alpha, a, lda, x, incx, beta, y, incy)</td></tr>
<tr class="memdesc:ac0d8503212d569d91f1e69a9b9017ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_SYAMV: performs the matrix-vector operation y := alpha*abs(A)*abs(x) + beta*abs(y), where alpha and beta are scalars, x and y are vectors and A is an n by n symmetric matrix. This function is primarily used in calculating error bounds. To protect against underflow during evaluation, components in the resulting vector are perturbed away from zero by (N+1) times the underflow threshold. To prevent unnecessarily large errors for block-structure embedded in general matrices, "symbolically" zero components are not perturbed. A zero entry is considered "symbolic" if all multiplications involved in computing that entry have at least one zero multiplicand.  <br /></td></tr>
<tr class="separator:ac0d8503212d569d91f1e69a9b9017ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7e807317b4fef9a892da53f4e3810e" id="r_a4d7e807317b4fef9a892da53f4e3810e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4d7e807317b4fef9a892da53f4e3810e">la_lapack_c::la_cla_wwaddw</a> (n, x, y, w)</td></tr>
<tr class="memdesc:a4d7e807317b4fef9a892da53f4e3810e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_WWADDW: adds a vector W into a doubled-single vector (X, Y). This works for all extant IBM's hex and binary floating point arithmetic, but not for decimal.  <br /></td></tr>
<tr class="separator:a4d7e807317b4fef9a892da53f4e3810e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458ee49506ae512d1c2d93ad1fdcbc11" id="r_a458ee49506ae512d1c2d93ad1fdcbc11"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a458ee49506ae512d1c2d93ad1fdcbc11">la_lapack_c::la_clacgv</a> (n, x, incx)</td></tr>
<tr class="memdesc:a458ee49506ae512d1c2d93ad1fdcbc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLACGV: conjugates a complex vector of length N.  <br /></td></tr>
<tr class="separator:a458ee49506ae512d1c2d93ad1fdcbc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a18fed030896d19839b3aef3aa48ca" id="r_aa8a18fed030896d19839b3aef3aa48ca"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa8a18fed030896d19839b3aef3aa48ca">la_lapack_c::la_clacn2</a> (n, v, x, est, kase, isave)</td></tr>
<tr class="memdesc:aa8a18fed030896d19839b3aef3aa48ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLACN2: estimates the 1-norm of a square, complex matrix A. Reverse communication is used for evaluating matrix-vector products.  <br /></td></tr>
<tr class="separator:aa8a18fed030896d19839b3aef3aa48ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9077fce7c5298a28c6455fb330ef827e" id="r_a9077fce7c5298a28c6455fb330ef827e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9077fce7c5298a28c6455fb330ef827e">la_lapack_c::la_clacon</a> (n, v, x, est, kase)</td></tr>
<tr class="memdesc:a9077fce7c5298a28c6455fb330ef827e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLACON: estimates the 1-norm of a square, complex matrix A. Reverse communication is used for evaluating matrix-vector products.  <br /></td></tr>
<tr class="separator:a9077fce7c5298a28c6455fb330ef827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43df0053f989e521283eb88c61885e4b" id="r_a43df0053f989e521283eb88c61885e4b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a43df0053f989e521283eb88c61885e4b">la_lapack_c::la_clacp2</a> (uplo, m, n, a, lda, b, ldb)</td></tr>
<tr class="memdesc:a43df0053f989e521283eb88c61885e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLACP2: copies all or part of a real two-dimensional matrix A to a complex matrix B.  <br /></td></tr>
<tr class="separator:a43df0053f989e521283eb88c61885e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f50f05cdea6ccd3a055c994a570fcd" id="r_a94f50f05cdea6ccd3a055c994a570fcd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a94f50f05cdea6ccd3a055c994a570fcd">la_lapack_c::la_clacpy</a> (uplo, m, n, a, lda, b, ldb)</td></tr>
<tr class="memdesc:a94f50f05cdea6ccd3a055c994a570fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLACPY: copies all or part of a two-dimensional matrix A to another matrix B.  <br /></td></tr>
<tr class="separator:a94f50f05cdea6ccd3a055c994a570fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8985879593e1ccb9e7c1634c6418edd" id="r_af8985879593e1ccb9e7c1634c6418edd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af8985879593e1ccb9e7c1634c6418edd">la_lapack_c::la_clacrm</a> (m, n, a, lda, b, ldb, c, ldc, rwork)</td></tr>
<tr class="memdesc:af8985879593e1ccb9e7c1634c6418edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLACRM: performs a very simple matrix-matrix multiplication: C := A * B, where A is M by N and complex; B is N by N and real; C is M by N and complex.  <br /></td></tr>
<tr class="separator:af8985879593e1ccb9e7c1634c6418edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1213382c37334f9ca6da97fae62064" id="r_a0b1213382c37334f9ca6da97fae62064"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0b1213382c37334f9ca6da97fae62064">la_lapack_c::la_clacrt</a> (n, cx, incx, cy, incy, c, s)</td></tr>
<tr class="memdesc:a0b1213382c37334f9ca6da97fae62064"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLACRT: performs the operation ( c s )( x ) ==&gt; ( x ) ( -s c )( y ) ( y ) where c and s are complex and the vectors x and y are complex.  <br /></td></tr>
<tr class="separator:a0b1213382c37334f9ca6da97fae62064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1497c47c4ec8521fd6c8d29fc75e98" id="r_a6e1497c47c4ec8521fd6c8d29fc75e98"><td class="memItemLeft" align="right" valign="top">pure complex(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6e1497c47c4ec8521fd6c8d29fc75e98">la_lapack_c::la_cladiv</a> (x, y)</td></tr>
<tr class="memdesc:a6e1497c47c4ec8521fd6c8d29fc75e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLADIV: := X / Y, where X and Y are complex. The computation of X / Y will not overflow on an intermediary step unless the results overflows.  <br /></td></tr>
<tr class="separator:a6e1497c47c4ec8521fd6c8d29fc75e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4951b07cf7760fa17dba74c05467df40" id="r_a4951b07cf7760fa17dba74c05467df40"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4951b07cf7760fa17dba74c05467df40">la_lapack_c::la_claed8</a> (k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda, q2, ldq2, w, indxp, indx, indxq, perm, givptr, givcol, givnum, info)</td></tr>
<tr class="memdesc:a4951b07cf7760fa17dba74c05467df40"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAED8: merges the two sets of eigenvalues together into a single sorted set. Then it tries to deflate the size of the problem. There are two ways in which deflation can occur: when two or more eigenvalues are close together or if there is a tiny element in the Z vector. For each such occurrence the order of the related secular equation problem is reduced by one.  <br /></td></tr>
<tr class="separator:a4951b07cf7760fa17dba74c05467df40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4364f3f4aac47559096e90871e193320" id="r_a4364f3f4aac47559096e90871e193320"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4364f3f4aac47559096e90871e193320">la_lapack_c::la_claesy</a> (a, b, c, rt1, rt2, evscal, cs1, sn1)</td></tr>
<tr class="memdesc:a4364f3f4aac47559096e90871e193320"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAESY: computes the eigendecomposition of a 2-by-2 symmetric matrix ( ( A, B );( B, C ) ) provided the norm of the matrix of eigenvectors is larger than some threshold value. RT1 is the eigenvalue of larger absolute value, and RT2 of smaller absolute value. If the eigenvectors are computed, then on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence [ CS1 SN1 ] . [ A B ] . [ CS1 -SN1 ] = [ RT1 0 ] [ -SN1 CS1 ] [ B C ] [ SN1 CS1 ] [ 0 RT2 ].  <br /></td></tr>
<tr class="separator:a4364f3f4aac47559096e90871e193320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd7724f6ea0ac3e9518a75356c69729" id="r_a0cd7724f6ea0ac3e9518a75356c69729"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0cd7724f6ea0ac3e9518a75356c69729">la_lapack_c::la_claev2</a> (a, b, c, rt1, rt2, cs1, sn1)</td></tr>
<tr class="memdesc:a0cd7724f6ea0ac3e9518a75356c69729"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAEV2: computes the eigendecomposition of a 2-by-2 Hermitian matrix [ A B ] [ CONJG(B) C ]. On return, RT1 is the eigenvalue of larger absolute value, RT2 is the eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right eigenvector for RT1, giving the decomposition [ CS1 CONJG(SN1) ] [ A B ] [ CS1 -CONJG(SN1) ] = [ RT1 0 ] [-SN1 CS1 ] [ CONJG(B) C ] [ SN1 CS1 ] [ 0 RT2 ].  <br /></td></tr>
<tr class="separator:a0cd7724f6ea0ac3e9518a75356c69729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb9b55c5f126f9b35f4c3643195b961" id="r_a4cb9b55c5f126f9b35f4c3643195b961"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4cb9b55c5f126f9b35f4c3643195b961">la_lapack_c::la_clag2z</a> (m, n, sa, ldsa, a, lda, info)</td></tr>
<tr class="memdesc:a4cb9b55c5f126f9b35f4c3643195b961"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAG2Z: converts a COMPLEX matrix, SA, to a COMPLEX*16 matrix, A. Note that while it is possible to overflow while converting from double to single, it is not possible to overflow when converting from single to double. This is an auxiliary routine so there is no argument checking.  <br /></td></tr>
<tr class="separator:a4cb9b55c5f126f9b35f4c3643195b961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dbb46dc8e1d9550ddce4d482fe9626" id="r_a19dbb46dc8e1d9550ddce4d482fe9626"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a19dbb46dc8e1d9550ddce4d482fe9626">la_lapack_c::la_clagtm</a> (trans, n, nrhs, alpha, dl, d, du, x, ldx, beta, b, ldb)</td></tr>
<tr class="memdesc:a19dbb46dc8e1d9550ddce4d482fe9626"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAGTM: performs a matrix-vector product of the form B := alpha * A * X + beta * B where A is a tridiagonal matrix of order N, B and X are N by NRHS matrices, and alpha and beta are real scalars, each of which may be 0., 1., or -1.  <br /></td></tr>
<tr class="separator:a19dbb46dc8e1d9550ddce4d482fe9626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32db2ef632debc744359259009b8248b" id="r_a32db2ef632debc744359259009b8248b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a32db2ef632debc744359259009b8248b">la_lapack_c::la_clahef</a> (uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)</td></tr>
<tr class="memdesc:a32db2ef632debc744359259009b8248b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAHEF: computes a partial factorization of a complex Hermitian matrix A using the Bunch-Kaufman diagonal pivoting method. The partial factorization has the form: A = ( I U12 ) ( A11 0 ) ( I 0 ) if UPLO = 'U', or: ( 0 U22 ) ( 0 D ) ( U12**H U22**H ) A = ( L11 0 ) ( D 0 ) ( L11**H L21**H ) if UPLO = 'L' ( L21 I ) ( 0 A22 ) ( 0 I ) where the order of D is at most NB. The actual order is returned in the argument KB, and is either NB or NB-1, or N if N &lt;= NB. Note that U**H denotes the conjugate transpose of U. CLAHEF is an auxiliary routine called by CHETRF. It uses blocked code (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or A22 (if UPLO = 'L').  <br /></td></tr>
<tr class="separator:a32db2ef632debc744359259009b8248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a6ae2a708e61b15dc6b72ecef88191" id="r_a84a6ae2a708e61b15dc6b72ecef88191"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a84a6ae2a708e61b15dc6b72ecef88191">la_lapack_c::la_clahef_rk</a> (uplo, n, nb, kb, a, lda, e, ipiv, w, ldw, info)</td></tr>
<tr class="memdesc:a84a6ae2a708e61b15dc6b72ecef88191"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAHEF_RK: computes a partial factorization of a complex Hermitian matrix A using the bounded Bunch-Kaufman (rook) diagonal pivoting method. The partial factorization has the form: A = ( I U12 ) ( A11 0 ) ( I 0 ) if UPLO = 'U', or: ( 0 U22 ) ( 0 D ) ( U12**H U22**H ) A = ( L11 0 ) ( D 0 ) ( L11**H L21**H ) if UPLO = 'L', ( L21 I ) ( 0 A22 ) ( 0 I ) where the order of D is at most NB. The actual order is returned in the argument KB, and is either NB or NB-1, or N if N &lt;= NB. CLAHEF_RK is an auxiliary routine called by CHETRF_RK. It uses blocked code (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or A22 (if UPLO = 'L').  <br /></td></tr>
<tr class="separator:a84a6ae2a708e61b15dc6b72ecef88191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987792307500cb275633bfbaba5c3aef" id="r_a987792307500cb275633bfbaba5c3aef"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a987792307500cb275633bfbaba5c3aef">la_lapack_c::la_clahef_rook</a> (uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)</td></tr>
<tr class="memdesc:a987792307500cb275633bfbaba5c3aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAHEF_ROOK: computes a partial factorization of a complex Hermitian matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method. The partial factorization has the form: A = ( I U12 ) ( A11 0 ) ( I 0 ) if UPLO = 'U', or: ( 0 U22 ) ( 0 D ) ( U12**H U22**H ) A = ( L11 0 ) ( D 0 ) ( L11**H L21**H ) if UPLO = 'L' ( L21 I ) ( 0 A22 ) ( 0 I ) where the order of D is at most NB. The actual order is returned in the argument KB, and is either NB or NB-1, or N if N &lt;= NB. Note that U**H denotes the conjugate transpose of U. CLAHEF_ROOK is an auxiliary routine called by CHETRF_ROOK. It uses blocked code (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or A22 (if UPLO = 'L').  <br /></td></tr>
<tr class="separator:a987792307500cb275633bfbaba5c3aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23dc5fdc2496b2c2e7c99da7073f4a4" id="r_ad23dc5fdc2496b2c2e7c99da7073f4a4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad23dc5fdc2496b2c2e7c99da7073f4a4">la_lapack_c::la_claic1</a> (job, j, x, sest, w, gamma, sestpr, s, c)</td></tr>
<tr class="memdesc:ad23dc5fdc2496b2c2e7c99da7073f4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAIC1: applies one step of incremental condition estimation in its simplest version: Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j lower triangular matrix L, such that twonorm(L*x) = sest Then CLAIC1 computes sestpr, s, c such that the vector [ s*x ] xhat = [ c ] is an approximate singular vector of [ L 0 ] Lhat = [ w**H gamma ] in the sense that twonorm(Lhat*xhat) = sestpr. Depending on JOB, an estimate for the largest or smallest singular value is computed. Note that [s c]**H and sestpr**2 is an eigenpair of the system diag(sest*sest, 0) + [alpha gamma] * [ conjg(alpha) ] [ conjg(gamma) ] where alpha = x**H*w.  <br /></td></tr>
<tr class="separator:ad23dc5fdc2496b2c2e7c99da7073f4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4449b05b8a132335b3dd6a27219da1b4" id="r_a4449b05b8a132335b3dd6a27219da1b4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4449b05b8a132335b3dd6a27219da1b4">la_lapack_c::la_clapmr</a> (forwrd, m, n, x, ldx, k)</td></tr>
<tr class="memdesc:a4449b05b8a132335b3dd6a27219da1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAPMR: rearranges the rows of the M by N matrix X as specified by the permutation K(1),K(2),...,K(M) of the integers 1,...,M. If FORWRD = .TRUE., forward permutation: X(K(I),*) is moved X(I,*) for I = 1,2,...,M. If FORWRD = .FALSE., backward permutation: X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.  <br /></td></tr>
<tr class="separator:a4449b05b8a132335b3dd6a27219da1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a9aa668b97c77e1b4ae28eed3537eb" id="r_ab5a9aa668b97c77e1b4ae28eed3537eb"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab5a9aa668b97c77e1b4ae28eed3537eb">la_lapack_c::la_clapmt</a> (forwrd, m, n, x, ldx, k)</td></tr>
<tr class="memdesc:ab5a9aa668b97c77e1b4ae28eed3537eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAPMT: rearranges the columns of the M by N matrix X as specified by the permutation K(1),K(2),...,K(N) of the integers 1,...,N. If FORWRD = .TRUE., forward permutation: X(*,K(J)) is moved X(*,J) for J = 1,2,...,N. If FORWRD = .FALSE., backward permutation: X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.  <br /></td></tr>
<tr class="separator:ab5a9aa668b97c77e1b4ae28eed3537eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f770ee60831e7134197ffdd89aa4175" id="r_a5f770ee60831e7134197ffdd89aa4175"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5f770ee60831e7134197ffdd89aa4175">la_lapack_c::la_claqgb</a> (m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, equed)</td></tr>
<tr class="memdesc:a5f770ee60831e7134197ffdd89aa4175"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQGB: equilibrates a general M by N band matrix A with KL subdiagonals and KU superdiagonals using the row and scaling factors in the vectors R and C.  <br /></td></tr>
<tr class="separator:a5f770ee60831e7134197ffdd89aa4175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00518b24b7f7def8ecc89abc2643e709" id="r_a00518b24b7f7def8ecc89abc2643e709"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a00518b24b7f7def8ecc89abc2643e709">la_lapack_c::la_claqge</a> (m, n, a, lda, r, c, rowcnd, colcnd, amax, equed)</td></tr>
<tr class="memdesc:a00518b24b7f7def8ecc89abc2643e709"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQGE: equilibrates a general M by N matrix A using the row and column scaling factors in the vectors R and C.  <br /></td></tr>
<tr class="separator:a00518b24b7f7def8ecc89abc2643e709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada463b371f75a5f74ac20b543f0a5974" id="r_ada463b371f75a5f74ac20b543f0a5974"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ada463b371f75a5f74ac20b543f0a5974">la_lapack_c::la_claqhb</a> (uplo, n, kd, ab, ldab, s, scond, amax, equed)</td></tr>
<tr class="memdesc:ada463b371f75a5f74ac20b543f0a5974"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQHB: equilibrates an Hermitian band matrix A using the scaling factors in the vector S.  <br /></td></tr>
<tr class="separator:ada463b371f75a5f74ac20b543f0a5974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59237002f056afcee7cf86007999aecf" id="r_a59237002f056afcee7cf86007999aecf"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a59237002f056afcee7cf86007999aecf">la_lapack_c::la_claqhe</a> (uplo, n, a, lda, s, scond, amax, equed)</td></tr>
<tr class="memdesc:a59237002f056afcee7cf86007999aecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQHE: equilibrates a Hermitian matrix A using the scaling factors in the vector S.  <br /></td></tr>
<tr class="separator:a59237002f056afcee7cf86007999aecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3573390db0064780c87695a457ae48b1" id="r_a3573390db0064780c87695a457ae48b1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a3573390db0064780c87695a457ae48b1">la_lapack_c::la_claqhp</a> (uplo, n, ap, s, scond, amax, equed)</td></tr>
<tr class="memdesc:a3573390db0064780c87695a457ae48b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQHP: equilibrates a Hermitian matrix A using the scaling factors in the vector S.  <br /></td></tr>
<tr class="separator:a3573390db0064780c87695a457ae48b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3341c0011e0d3fe9f8ff66974990ab39" id="r_a3341c0011e0d3fe9f8ff66974990ab39"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a3341c0011e0d3fe9f8ff66974990ab39">la_lapack_c::la_claqr1</a> (n, h, ldh, s1, s2, v)</td></tr>
<tr class="memdesc:a3341c0011e0d3fe9f8ff66974990ab39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a 2-by-2 or 3-by-3 matrix H, CLAQR1: sets v to a scalar multiple of the first column of the product (*) K = (H - s1*I)*(H - s2*I) scaling to avoid overflows and most underflows. This is useful for starting double implicit shift bulges in the QR algorithm.  <br /></td></tr>
<tr class="separator:a3341c0011e0d3fe9f8ff66974990ab39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71259c6861b271c1effb6e2f6a5e8eec" id="r_a71259c6861b271c1effb6e2f6a5e8eec"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a71259c6861b271c1effb6e2f6a5e8eec">la_lapack_c::la_claqsb</a> (uplo, n, kd, ab, ldab, s, scond, amax, equed)</td></tr>
<tr class="memdesc:a71259c6861b271c1effb6e2f6a5e8eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQSB: equilibrates a symmetric band matrix A using the scaling factors in the vector S.  <br /></td></tr>
<tr class="separator:a71259c6861b271c1effb6e2f6a5e8eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352597ce56f635e493c5fe37271154d6" id="r_a352597ce56f635e493c5fe37271154d6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a352597ce56f635e493c5fe37271154d6">la_lapack_c::la_claqsp</a> (uplo, n, ap, s, scond, amax, equed)</td></tr>
<tr class="memdesc:a352597ce56f635e493c5fe37271154d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQSP: equilibrates a symmetric matrix A using the scaling factors in the vector S.  <br /></td></tr>
<tr class="separator:a352597ce56f635e493c5fe37271154d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9f7fa8b199914594d4b07c08050a89" id="r_adb9f7fa8b199914594d4b07c08050a89"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#adb9f7fa8b199914594d4b07c08050a89">la_lapack_c::la_claqsy</a> (uplo, n, a, lda, s, scond, amax, equed)</td></tr>
<tr class="memdesc:adb9f7fa8b199914594d4b07c08050a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQSY: equilibrates a symmetric matrix A using the scaling factors in the vector S.  <br /></td></tr>
<tr class="separator:adb9f7fa8b199914594d4b07c08050a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6d6b9fcbb8fb601fadd0ad784e4bca" id="r_afc6d6b9fcbb8fb601fadd0ad784e4bca"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#afc6d6b9fcbb8fb601fadd0ad784e4bca">la_lapack_c::la_clar1v</a> (n, b1, bn, lambda, d, l, ld, lld, pivmin, gaptol, z, wantnc, negcnt, ztz, mingma, r, isuppz, nrminv, resid, rqcorr, work)</td></tr>
<tr class="memdesc:afc6d6b9fcbb8fb601fadd0ad784e4bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAR1V: computes the (scaled) r-th column of the inverse of the sumbmatrix in rows B1 through BN of the tridiagonal matrix L D L**T - sigma I. When sigma is close to an eigenvalue, the computed vector is an accurate eigenvector. Usually, r corresponds to the index where the eigenvector is largest in magnitude. The following steps accomplish this computation : (a) Stationary qd transform, L D L**T - sigma I = L(+) D(+) L(+)**T, (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T, (c) Computation of the diagonal elements of the inverse of L D L**T - sigma I by combining the above transforms, and choosing r as the index where the diagonal of the inverse is (one of the) largest in magnitude. (d) Computation of the (scaled) r-th column of the inverse using the twisted factorization obtained by combining the top part of the the stationary and the bottom part of the progressive transform.  <br /></td></tr>
<tr class="separator:afc6d6b9fcbb8fb601fadd0ad784e4bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dc94c5a0d2ea73219048f3f14d68a6" id="r_ae8dc94c5a0d2ea73219048f3f14d68a6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae8dc94c5a0d2ea73219048f3f14d68a6">la_lapack_c::la_clar2v</a> (n, x, y, z, incx, c, s, incc)</td></tr>
<tr class="memdesc:ae8dc94c5a0d2ea73219048f3f14d68a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAR2V: applies a vector of complex plane rotations with real cosines from both sides to a sequence of 2-by-2 complex Hermitian matrices, defined by the elements of the vectors x, y and z. For i = 1,2,...,n ( x(i) z(i) ) := ( conjg(z(i)) y(i) ) ( c(i) conjg(s(i)) ) ( x(i) z(i) ) ( c(i) -conjg(s(i)) ) ( -s(i) c(i) ) ( conjg(z(i)) y(i) ) ( s(i) c(i) )  <br /></td></tr>
<tr class="separator:ae8dc94c5a0d2ea73219048f3f14d68a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ae53f7b777b0683cdb5568225e04d8" id="r_a77ae53f7b777b0683cdb5568225e04d8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a77ae53f7b777b0683cdb5568225e04d8">la_lapack_c::la_clarcm</a> (m, n, a, lda, b, ldb, c, ldc, rwork)</td></tr>
<tr class="memdesc:a77ae53f7b777b0683cdb5568225e04d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARCM: performs a very simple matrix-matrix multiplication: C := A * B, where A is M by M and real; B is M by N and complex; C is M by N and complex.  <br /></td></tr>
<tr class="separator:a77ae53f7b777b0683cdb5568225e04d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b81937dc202033ec70fc927336aabc" id="r_a51b81937dc202033ec70fc927336aabc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a51b81937dc202033ec70fc927336aabc">la_lapack_c::la_clarf</a> (side, m, n, v, incv, tau, c, ldc, work)</td></tr>
<tr class="memdesc:a51b81937dc202033ec70fc927336aabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARF: applies a complex elementary reflector H to a complex M-by-N matrix C, from either the left or the right. H is represented in the form H = I - tau * v * v**H where tau is a complex scalar and v is a complex vector. If tau = 0, then H is taken to be the unit matrix. To apply H**H (the conjugate transpose of H), supply conjg(tau) instead tau.  <br /></td></tr>
<tr class="separator:a51b81937dc202033ec70fc927336aabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10abe089dc232f3eb9b9f490a3462130" id="r_a10abe089dc232f3eb9b9f490a3462130"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a10abe089dc232f3eb9b9f490a3462130">la_lapack_c::la_clarfb</a> (side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork)</td></tr>
<tr class="memdesc:a10abe089dc232f3eb9b9f490a3462130"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARFB: applies a complex block reflector H or its transpose H**H to a complex M-by-N matrix C, from either the left or the right.  <br /></td></tr>
<tr class="separator:a10abe089dc232f3eb9b9f490a3462130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816cb369b66c95b766117388ec748b50" id="r_a816cb369b66c95b766117388ec748b50"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a816cb369b66c95b766117388ec748b50">la_lapack_c::la_clarfb_gett</a> (ident, m, n, k, t, ldt, a, lda, b, ldb, work, ldwork)</td></tr>
<tr class="memdesc:a816cb369b66c95b766117388ec748b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARFB_GETT: applies a complex Householder block reflector H from the left to a complex (K+M)-by-N "triangular-pentagonal" matrix composed of two block matrices: an upper trapezoidal K-by-N matrix A stored in the array A, and a rectangular M-by-(N-K) matrix B, stored in the array B. The block reflector H is stored in a compact WY-representation, where the elementary reflectors are in the arrays A, B and T. See Further Details section.  <br /></td></tr>
<tr class="separator:a816cb369b66c95b766117388ec748b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e172bbfbe3a52b09166d7ba722dac7" id="r_a12e172bbfbe3a52b09166d7ba722dac7"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a12e172bbfbe3a52b09166d7ba722dac7">la_lapack_c::la_clarfg</a> (n, alpha, x, incx, tau)</td></tr>
<tr class="memdesc:a12e172bbfbe3a52b09166d7ba722dac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARFG: generates a complex elementary reflector H of order n, such that H**H * ( alpha ) = ( beta ), H**H * H = I. ( x ) ( 0 ) where alpha and beta are scalars, with beta real, and x is an (n-1)-element complex vector. H is represented in the form H = I - tau * ( 1 ) * ( 1 v**H ) , ( v ) where tau is a complex scalar and v is a complex (n-1)-element vector. Note that H is not hermitian. If the elements of x are all zero and alpha is real, then tau = 0 and H is taken to be the unit matrix. Otherwise 1 &lt;= real(tau) &lt;= 2 and abs(tau-1) &lt;= 1 .  <br /></td></tr>
<tr class="separator:a12e172bbfbe3a52b09166d7ba722dac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2869f7bc80e3500d54332c39b29bfb0a" id="r_a2869f7bc80e3500d54332c39b29bfb0a"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2869f7bc80e3500d54332c39b29bfb0a">la_lapack_c::la_clarfgp</a> (n, alpha, x, incx, tau)</td></tr>
<tr class="memdesc:a2869f7bc80e3500d54332c39b29bfb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARFGP: generates a complex elementary reflector H of order n, such that H**H * ( alpha ) = ( beta ), H**H * H = I. ( x ) ( 0 ) where alpha and beta are scalars, beta is real and non-negative, and x is an (n-1)-element complex vector. H is represented in the form H = I - tau * ( 1 ) * ( 1 v**H ) , ( v ) where tau is a complex scalar and v is a complex (n-1)-element vector. Note that H is not hermitian. If the elements of x are all zero and alpha is real, then tau = 0 and H is taken to be the unit matrix.  <br /></td></tr>
<tr class="separator:a2869f7bc80e3500d54332c39b29bfb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf091d539e6aeeb669711c8df3c9d4e3" id="r_adf091d539e6aeeb669711c8df3c9d4e3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#adf091d539e6aeeb669711c8df3c9d4e3">la_lapack_c::la_clarft</a> (direct, storev, n, k, v, ldv, tau, t, ldt)</td></tr>
<tr class="memdesc:adf091d539e6aeeb669711c8df3c9d4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARFT: forms the triangular factor T of a complex block reflector H of order n, which is defined as a product of k elementary reflectors. If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular; If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular. If STOREV = 'C', the vector which defines the elementary reflector H(i) is stored in the i-th column of the array V, and H = I - V * T * V**H If STOREV = 'R', the vector which defines the elementary reflector H(i) is stored in the i-th row of the array V, and H = I - V**H * T * V.  <br /></td></tr>
<tr class="separator:adf091d539e6aeeb669711c8df3c9d4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb287e76b7ff428e7ac9e0ffa722bc44" id="r_adb287e76b7ff428e7ac9e0ffa722bc44"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#adb287e76b7ff428e7ac9e0ffa722bc44">la_lapack_c::la_clarfx</a> (side, m, n, v, tau, c, ldc, work)</td></tr>
<tr class="memdesc:adb287e76b7ff428e7ac9e0ffa722bc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARFX: applies a complex elementary reflector H to a complex m by n matrix C, from either the left or the right. H is represented in the form H = I - tau * v * v**H where tau is a complex scalar and v is a complex vector. If tau = 0, then H is taken to be the unit matrix This version uses inline code if H has order &lt; 11.  <br /></td></tr>
<tr class="separator:adb287e76b7ff428e7ac9e0ffa722bc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d70a88a9dd889f92b76ce831629738d" id="r_a2d70a88a9dd889f92b76ce831629738d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2d70a88a9dd889f92b76ce831629738d">la_lapack_c::la_clarfy</a> (uplo, n, v, incv, tau, c, ldc, work)</td></tr>
<tr class="memdesc:a2d70a88a9dd889f92b76ce831629738d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARFY: applies an elementary reflector, or Householder matrix, H, to an n x n Hermitian matrix C, from both the left and the right. H is represented in the form H = I - tau * v * v' where tau is a scalar and v is a vector. If tau is zero, then H is taken to be the unit matrix.  <br /></td></tr>
<tr class="separator:a2d70a88a9dd889f92b76ce831629738d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93710b120d8e5f31e7d5dab67dcedc1d" id="r_a93710b120d8e5f31e7d5dab67dcedc1d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a93710b120d8e5f31e7d5dab67dcedc1d">la_lapack_c::la_clarnv</a> (idist, iseed, n, x)</td></tr>
<tr class="memdesc:a93710b120d8e5f31e7d5dab67dcedc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARNV: returns a vector of n random complex numbers from a uniform or normal distribution.  <br /></td></tr>
<tr class="separator:a93710b120d8e5f31e7d5dab67dcedc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abbf350b2d24dd9b3d62a839ee4527d" id="r_a5abbf350b2d24dd9b3d62a839ee4527d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5abbf350b2d24dd9b3d62a839ee4527d">la_lapack_c::la_clartg</a> (f, g, c, s, r)</td></tr>
<tr class="memdesc:a5abbf350b2d24dd9b3d62a839ee4527d"><td class="mdescLeft">&#160;</td><td class="mdescRight">!  <br /></td></tr>
<tr class="separator:a5abbf350b2d24dd9b3d62a839ee4527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3b783fb875e60893a311a61250f838" id="r_a2f3b783fb875e60893a311a61250f838"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2f3b783fb875e60893a311a61250f838">la_lapack_c::la_clartv</a> (n, x, incx, y, incy, c, s, incc)</td></tr>
<tr class="memdesc:a2f3b783fb875e60893a311a61250f838"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARTV: applies a vector of complex plane rotations with real cosines to elements of the complex vectors x and y. For i = 1,2,...,n ( x(i) ) := ( c(i) s(i) ) ( x(i) ) ( y(i) ) ( -conjg(s(i)) c(i) ) ( y(i) )  <br /></td></tr>
<tr class="separator:a2f3b783fb875e60893a311a61250f838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb85e3d34aaf9dab4383acc7e555255" id="r_adbb85e3d34aaf9dab4383acc7e555255"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#adbb85e3d34aaf9dab4383acc7e555255">la_lapack_c::la_clarz</a> (side, m, n, l, v, incv, tau, c, ldc, work)</td></tr>
<tr class="memdesc:adbb85e3d34aaf9dab4383acc7e555255"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARZ: applies a complex elementary reflector H to a complex M-by-N matrix C, from either the left or the right. H is represented in the form H = I - tau * v * v**H where tau is a complex scalar and v is a complex vector. If tau = 0, then H is taken to be the unit matrix. To apply H**H (the conjugate transpose of H), supply conjg(tau) instead tau. H is a product of k elementary reflectors as returned by CTZRZF.  <br /></td></tr>
<tr class="separator:adbb85e3d34aaf9dab4383acc7e555255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cb257132147f246ef039952167cb14" id="r_a42cb257132147f246ef039952167cb14"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a42cb257132147f246ef039952167cb14">la_lapack_c::la_clarzb</a> (side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, c, ldc, work, ldwork)</td></tr>
<tr class="memdesc:a42cb257132147f246ef039952167cb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARZB: applies a complex block reflector H or its transpose H**H to a complex distributed M-by-N C from the left or the right. Currently, only STOREV = 'R' and DIRECT = 'B' are supported.  <br /></td></tr>
<tr class="separator:a42cb257132147f246ef039952167cb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3201266c8c4fcfd802df6bb9e9d4eb76" id="r_a3201266c8c4fcfd802df6bb9e9d4eb76"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a3201266c8c4fcfd802df6bb9e9d4eb76">la_lapack_c::la_clarzt</a> (direct, storev, n, k, v, ldv, tau, t, ldt)</td></tr>
<tr class="memdesc:a3201266c8c4fcfd802df6bb9e9d4eb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARZT: forms the triangular factor T of a complex block reflector H of order &gt; n, which is defined as a product of k elementary reflectors. If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular; If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular. If STOREV = 'C', the vector which defines the elementary reflector H(i) is stored in the i-th column of the array V, and H = I - V * T * V**H If STOREV = 'R', the vector which defines the elementary reflector H(i) is stored in the i-th row of the array V, and H = I - V**H * T * V Currently, only STOREV = 'R' and DIRECT = 'B' are supported.  <br /></td></tr>
<tr class="separator:a3201266c8c4fcfd802df6bb9e9d4eb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde18a1cfef8be6026e973a99326aef5" id="r_abde18a1cfef8be6026e973a99326aef5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abde18a1cfef8be6026e973a99326aef5">la_lapack_c::la_clascl</a> (type, kl, ku, cfrom, cto, m, n, a, lda, info)</td></tr>
<tr class="memdesc:abde18a1cfef8be6026e973a99326aef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLASCL: multiplies the M by N complex matrix A by the real scalar CTO/CFROM. This is done without over/underflow as long as the final result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that A may be full, upper triangular, lower triangular, upper Hessenberg, or banded.  <br /></td></tr>
<tr class="separator:abde18a1cfef8be6026e973a99326aef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f6d9028437b79ec8870cf960266a8d" id="r_aa8f6d9028437b79ec8870cf960266a8d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa8f6d9028437b79ec8870cf960266a8d">la_lapack_c::la_claset</a> (uplo, m, n, alpha, beta, a, lda)</td></tr>
<tr class="memdesc:aa8f6d9028437b79ec8870cf960266a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLASET: initializes a 2-D array A to BETA on the diagonal and ALPHA on the offdiagonals.  <br /></td></tr>
<tr class="separator:aa8f6d9028437b79ec8870cf960266a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6c4162ab8824147e9b90a899aefbe8" id="r_a6d6c4162ab8824147e9b90a899aefbe8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6d6c4162ab8824147e9b90a899aefbe8">la_lapack_c::la_clasr</a> (side, pivot, direct, m, n, c, s, a, lda)</td></tr>
<tr class="memdesc:a6d6c4162ab8824147e9b90a899aefbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLASR: applies a sequence of real plane rotations to a complex matrix A, from either the left or the right. When SIDE = 'L', the transformation takes the form A := P*A and when SIDE = 'R', the transformation takes the form A := A*P**T where P is an orthogonal matrix consisting of a sequence of z plane rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R', and P**T is the transpose of P. When DIRECT = 'F' (Forward sequence), then P = P(z-1) * ... * P(2) * P(1) and when DIRECT = 'B' (Backward sequence), then P = P(1) * P(2) * ... * P(z-1) where P(k) is a plane rotation matrix defined by the 2-by-2 rotation R(k) = ( c(k) s(k) ) = ( -s(k) c(k) ). When PIVOT = 'V' (Variable pivot), the rotation is performed for the plane (k,k+1), i.e., P(k) has the form P(k) = ( 1 ) ( ... ) ( 1 ) ( c(k) s(k) ) ( -s(k) c(k) ) ( 1 ) ( ... ) ( 1 ) where R(k) appears as a rank-2 modification to the identity matrix in rows and columns k and k+1. When PIVOT = 'T' (Top pivot), the rotation is performed for the plane (1,k+1), so P(k) has the form P(k) = ( c(k) s(k) ) ( 1 ) ( ... ) ( 1 ) ( -s(k) c(k) ) ( 1 ) ( ... ) ( 1 ) where R(k) appears in rows and columns 1 and k+1. Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is performed for the plane (k,z), giving P(k) the form P(k) = ( 1 ) ( ... ) ( 1 ) ( c(k) s(k) ) ( 1 ) ( ... ) ( 1 ) ( -s(k) c(k) ) where R(k) appears in rows and columns k and z. The rotations are performed without ever forming P(k) explicitly.  <br /></td></tr>
<tr class="separator:a6d6c4162ab8824147e9b90a899aefbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9238bcdce69d7296d0322567095afa73" id="r_a9238bcdce69d7296d0322567095afa73"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9238bcdce69d7296d0322567095afa73">la_lapack_c::la_classq</a> (n, x, incx, scl, sumsq)</td></tr>
<tr class="memdesc:a9238bcdce69d7296d0322567095afa73"><td class="mdescLeft">&#160;</td><td class="mdescRight">!  <br /></td></tr>
<tr class="separator:a9238bcdce69d7296d0322567095afa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecaebae5feafdcc862f09bee12d6242" id="r_a4ecaebae5feafdcc862f09bee12d6242"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4ecaebae5feafdcc862f09bee12d6242">la_lapack_c::la_claswp</a> (n, a, lda, k1, k2, ipiv, incx)</td></tr>
<tr class="memdesc:a4ecaebae5feafdcc862f09bee12d6242"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLASWP: performs a series of row interchanges on the matrix A. One row interchange is initiated for each of rows K1 through K2 of A.  <br /></td></tr>
<tr class="separator:a4ecaebae5feafdcc862f09bee12d6242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0509d12b4da7596541d0cd77f1c7378" id="r_aa0509d12b4da7596541d0cd77f1c7378"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa0509d12b4da7596541d0cd77f1c7378">la_lapack_c::la_clasyf</a> (uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)</td></tr>
<tr class="memdesc:aa0509d12b4da7596541d0cd77f1c7378"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLASYF: computes a partial factorization of a complex symmetric matrix A using the Bunch-Kaufman diagonal pivoting method. The partial factorization has the form: A = ( I U12 ) ( A11 0 ) ( I 0 ) if UPLO = 'U', or: ( 0 U22 ) ( 0 D ) ( U12**T U22**T ) A = ( L11 0 ) ( D 0 ) ( L11**T L21**T ) if UPLO = 'L' ( L21 I ) ( 0 A22 ) ( 0 I ) where the order of D is at most NB. The actual order is returned in the argument KB, and is either NB or NB-1, or N if N &lt;= NB. Note that U**T denotes the transpose of U. CLASYF is an auxiliary routine called by CSYTRF. It uses blocked code (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or A22 (if UPLO = 'L').  <br /></td></tr>
<tr class="separator:aa0509d12b4da7596541d0cd77f1c7378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4f9a4f301d2be321ea6015fa89e3fa" id="r_a7d4f9a4f301d2be321ea6015fa89e3fa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a7d4f9a4f301d2be321ea6015fa89e3fa">la_lapack_c::la_clasyf_rk</a> (uplo, n, nb, kb, a, lda, e, ipiv, w, ldw, info)</td></tr>
<tr class="memdesc:a7d4f9a4f301d2be321ea6015fa89e3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLASYF_RK: computes a partial factorization of a complex symmetric matrix A using the bounded Bunch-Kaufman (rook) diagonal pivoting method. The partial factorization has the form: A = ( I U12 ) ( A11 0 ) ( I 0 ) if UPLO = 'U', or: ( 0 U22 ) ( 0 D ) ( U12**T U22**T ) A = ( L11 0 ) ( D 0 ) ( L11**T L21**T ) if UPLO = 'L', ( L21 I ) ( 0 A22 ) ( 0 I ) where the order of D is at most NB. The actual order is returned in the argument KB, and is either NB or NB-1, or N if N &lt;= NB. CLASYF_RK is an auxiliary routine called by CSYTRF_RK. It uses blocked code (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or A22 (if UPLO = 'L').  <br /></td></tr>
<tr class="separator:a7d4f9a4f301d2be321ea6015fa89e3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e4a73a5f6ff98bd613d1fce3765859" id="r_ac0e4a73a5f6ff98bd613d1fce3765859"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac0e4a73a5f6ff98bd613d1fce3765859">la_lapack_c::la_clasyf_rook</a> (uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)</td></tr>
<tr class="memdesc:ac0e4a73a5f6ff98bd613d1fce3765859"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLASYF_ROOK: computes a partial factorization of a complex symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method. The partial factorization has the form: A = ( I U12 ) ( A11 0 ) ( I 0 ) if UPLO = 'U', or: ( 0 U22 ) ( 0 D ) ( U12**T U22**T ) A = ( L11 0 ) ( D 0 ) ( L11**T L21**T ) if UPLO = 'L' ( L21 I ) ( 0 A22 ) ( 0 I ) where the order of D is at most NB. The actual order is returned in the argument KB, and is either NB or NB-1, or N if N &lt;= NB. CLASYF_ROOK is an auxiliary routine called by CSYTRF_ROOK. It uses blocked code (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or A22 (if UPLO = 'L').  <br /></td></tr>
<tr class="separator:ac0e4a73a5f6ff98bd613d1fce3765859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c06578c24d3d06b435d441431084e66" id="r_a5c06578c24d3d06b435d441431084e66"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5c06578c24d3d06b435d441431084e66">la_lapack_c::la_clatbs</a> (uplo, trans, diag, normin, n, kd, ab, ldab, x, scale, cnorm, info)</td></tr>
<tr class="memdesc:a5c06578c24d3d06b435d441431084e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLATBS: solves one of the triangular systems A * x = s*b, A**T * x = s*b, or A**H * x = s*b, with scaling to prevent overflow, where A is an upper or lower triangular band matrix. Here A**T denotes the transpose of A, x and b are n-element vectors, and s is a scaling factor, usually less than or equal to 1, chosen so that the components of x will be less than the overflow threshold. If the unscaled problem will not cause overflow, the Level 2 BLAS routine CTBSV is called. If the matrix A is singular (A(j,j) = 0 for some j), then s is set to 0 and a non-trivial solution to A*x = 0 is returned.  <br /></td></tr>
<tr class="separator:a5c06578c24d3d06b435d441431084e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3a19fe8e309ebbe8bbb5169a7facc1" id="r_acc3a19fe8e309ebbe8bbb5169a7facc1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#acc3a19fe8e309ebbe8bbb5169a7facc1">la_lapack_c::la_clatps</a> (uplo, trans, diag, normin, n, ap, x, scale, cnorm, info)</td></tr>
<tr class="memdesc:acc3a19fe8e309ebbe8bbb5169a7facc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLATPS: solves one of the triangular systems A * x = s*b, A**T * x = s*b, or A**H * x = s*b, with scaling to prevent overflow, where A is an upper or lower triangular matrix stored in packed form. Here A**T denotes the transpose of A, A**H denotes the conjugate transpose of A, x and b are n-element vectors, and s is a scaling factor, usually less than or equal to 1, chosen so that the components of x will be less than the overflow threshold. If the unscaled problem will not cause overflow, the Level 2 BLAS routine CTPSV is called. If the matrix A is singular (A(j,j) = 0 for some j), then s is set to 0 and a non-trivial solution to A*x = 0 is returned.  <br /></td></tr>
<tr class="separator:acc3a19fe8e309ebbe8bbb5169a7facc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f44cfbda37fd6f24252e162736fa9e" id="r_a42f44cfbda37fd6f24252e162736fa9e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a42f44cfbda37fd6f24252e162736fa9e">la_lapack_c::la_clatrd</a> (uplo, n, nb, a, lda, e, tau, w, ldw)</td></tr>
<tr class="memdesc:a42f44cfbda37fd6f24252e162736fa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLATRD: reduces NB rows and columns of a complex Hermitian matrix A to Hermitian tridiagonal form by a unitary similarity transformation Q**H * A * Q, and returns the matrices V and W which are needed to apply the transformation to the unreduced part of A. If UPLO = 'U', CLATRD reduces the last NB rows and columns of a matrix, of which the upper triangle is supplied; if UPLO = 'L', CLATRD reduces the first NB rows and columns of a matrix, of which the lower triangle is supplied. This is an auxiliary routine called by CHETRD.  <br /></td></tr>
<tr class="separator:a42f44cfbda37fd6f24252e162736fa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611a9792305bac70ec0d6e3599c73db1" id="r_a611a9792305bac70ec0d6e3599c73db1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a611a9792305bac70ec0d6e3599c73db1">la_lapack_c::la_clatrs</a> (uplo, trans, diag, normin, n, a, lda, x, scale, cnorm, info)</td></tr>
<tr class="memdesc:a611a9792305bac70ec0d6e3599c73db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLATRS: solves one of the triangular systems A * x = s*b, A**T * x = s*b, or A**H * x = s*b, with scaling to prevent overflow. Here A is an upper or lower triangular matrix, A**T denotes the transpose of A, A**H denotes the conjugate transpose of A, x and b are n-element vectors, and s is a scaling factor, usually less than or equal to 1, chosen so that the components of x will be less than the overflow threshold. If the unscaled problem will not cause overflow, the Level 2 BLAS routine CTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j), then s is set to 0 and a non-trivial solution to A*x = 0 is returned.  <br /></td></tr>
<tr class="separator:a611a9792305bac70ec0d6e3599c73db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e179c195efd79465bbb54d23729ad77" id="r_a6e179c195efd79465bbb54d23729ad77"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6e179c195efd79465bbb54d23729ad77">la_lapack_c::la_clatrz</a> (m, n, l, a, lda, tau, work)</td></tr>
<tr class="memdesc:a6e179c195efd79465bbb54d23729ad77"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLATRZ: factors the M-by-(M+L) complex upper trapezoidal matrix [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R 0 ) * Z by means of unitary transformations, where Z is an (M+L)-by-(M+L) unitary matrix and, R and A1 are M-by-M upper triangular matrices.  <br /></td></tr>
<tr class="separator:a6e179c195efd79465bbb54d23729ad77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbc66460ad7dd32b2e61360c9818077" id="r_a9cbc66460ad7dd32b2e61360c9818077"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9cbc66460ad7dd32b2e61360c9818077">la_lapack_c::la_claunhr_col_getrfnp2</a> (m, n, a, lda, d, info)</td></tr>
<tr class="memdesc:a9cbc66460ad7dd32b2e61360c9818077"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAUNHR_COL_GETRFNP2: computes the modified LU factorization without pivoting of a complex general M-by-N matrix A. The factorization has the form: A - S = L * U, where: S is a m-by-n diagonal sign matrix with the diagonal D, so that D(i) = S(i,i), 1 &lt;= i &lt;= min(M,N). The diagonal D is constructed as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing i-1 steps of Gaussian elimination. This means that the diagonal element at each step of "modified" Gaussian elimination is at least one in absolute value (so that division-by-zero not possible during the division by the diagonal element); L is a M-by-N lower triangular matrix with unit diagonal elements (lower trapezoidal if M &gt; N); and U is a M-by-N upper triangular matrix (upper trapezoidal if M &lt; N). This routine is an auxiliary routine used in the Householder reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is applied to an M-by-N matrix A with orthonormal columns, where each element is bounded by one in absolute value. With the choice of the matrix S above, one can show that the diagonal element at each step of Gaussian elimination is the largest (in absolute value) in the column on or below the diagonal, so that no pivoting is required for numerical stability [1]. For more details on the Householder reconstruction algorithm, including the modified LU factorization, see [1]. This is the recursive version of the LU factorization algorithm. Denote A - S by B. The algorithm divides the matrix B into four submatrices: [ B11 | B12 ] where B11 is n1 by n1, B = [ --&mdash;|--&mdash; ] B21 is (m-n1) by n1, [ B21 | B22 ] B12 is n1 by n2, B22 is (m-n1) by n2, with n1 = min(m,n)/2, n2 = n-n1. The subroutine calls itself to factor B11, solves for B21, solves for B12, updates B22, then calls itself to factor B22. For more details on the recursive LU algorithm, see [2]. CLAUNHR_COL_GETRFNP2 is called to factorize a block by the blocked routine CLAUNHR_COL_GETRFNP, which uses blocked code calling Level 3 BLAS to update the submatrix. However, CLAUNHR_COL_GETRFNP2 is self-sufficient and can be used without CLAUNHR_COL_GETRFNP. [1] "Reconstructing Householder vectors from tall-skinny QR", G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen, E. Solomonik, J. Parallel Distrib. Comput., vol. 85, pp. 3-31, 2015. [2] "Recursion leads to automatic variable blocking for dense linear
algebra algorithms", F. Gustavson, IBM J. of Res. and Dev., vol. 41, no. 6, pp. 737-755, 1997.  <br /></td></tr>
<tr class="separator:a9cbc66460ad7dd32b2e61360c9818077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e90ea8058ff7470c018512d2ae4713" id="r_a06e90ea8058ff7470c018512d2ae4713"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a06e90ea8058ff7470c018512d2ae4713">la_lapack_c::la_clauu2</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:a06e90ea8058ff7470c018512d2ae4713"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAUU2: computes the product U * U**H or L**H * L, where the triangular factor U or L is stored in the upper or lower triangular part of the array A. If UPLO = 'U' or 'u' then the upper triangle of the result is stored, overwriting the factor U in A. If UPLO = 'L' or 'l' then the lower triangle of the result is stored, overwriting the factor L in A. This is the unblocked form of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:a06e90ea8058ff7470c018512d2ae4713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6521b6aff9e5d3ec102fcd83d244c1" id="r_add6521b6aff9e5d3ec102fcd83d244c1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#add6521b6aff9e5d3ec102fcd83d244c1">la_lapack_c::la_clauum</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:add6521b6aff9e5d3ec102fcd83d244c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAUUM: computes the product U * U**H or L**H * L, where the triangular factor U or L is stored in the upper or lower triangular part of the array A. If UPLO = 'U' or 'u' then the upper triangle of the result is stored, overwriting the factor U in A. If UPLO = 'L' or 'l' then the lower triangle of the result is stored, overwriting the factor L in A. This is the blocked form of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:add6521b6aff9e5d3ec102fcd83d244c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58af1f4f7d4eb6297579a988c018fdff" id="r_a58af1f4f7d4eb6297579a988c018fdff"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a58af1f4f7d4eb6297579a988c018fdff">la_lapack_c::la_cpbequ</a> (uplo, n, kd, ab, ldab, s, scond, amax, info)</td></tr>
<tr class="memdesc:a58af1f4f7d4eb6297579a988c018fdff"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPBEQU: computes row and column scalings intended to equilibrate a Hermitian positive definite band matrix A and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings.  <br /></td></tr>
<tr class="separator:a58af1f4f7d4eb6297579a988c018fdff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02270dbad9d73ec97c0abc0c986704b6" id="r_a02270dbad9d73ec97c0abc0c986704b6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a02270dbad9d73ec97c0abc0c986704b6">la_lapack_c::la_cpbstf</a> (uplo, n, kd, ab, ldab, info)</td></tr>
<tr class="memdesc:a02270dbad9d73ec97c0abc0c986704b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPBSTF: computes a split Cholesky factorization of a complex Hermitian positive definite band matrix A. This routine is designed to be used in conjunction with CHBGST. The factorization has the form A = S**H*S where S is a band matrix of the same bandwidth as A and the following structure: S = ( U ) ( M L ) where U is upper triangular of order m = (n+kd)/2, and L is lower triangular of order n-m.  <br /></td></tr>
<tr class="separator:a02270dbad9d73ec97c0abc0c986704b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088f4042b11de1808e7e06ec67966d6e" id="r_a088f4042b11de1808e7e06ec67966d6e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a088f4042b11de1808e7e06ec67966d6e">la_lapack_c::la_cpbtf2</a> (uplo, n, kd, ab, ldab, info)</td></tr>
<tr class="memdesc:a088f4042b11de1808e7e06ec67966d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPBTF2: computes the Cholesky factorization of a complex Hermitian positive definite band matrix A. The factorization has the form A = U**H * U , if UPLO = 'U', or A = L * L**H, if UPLO = 'L', where U is an upper triangular matrix, U**H is the conjugate transpose of U, and L is lower triangular. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:a088f4042b11de1808e7e06ec67966d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fb15e00019f1f0687775d00e280332" id="r_a24fb15e00019f1f0687775d00e280332"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a24fb15e00019f1f0687775d00e280332">la_lapack_c::la_cpbtrs</a> (uplo, n, kd, nrhs, ab, ldab, b, ldb, info)</td></tr>
<tr class="memdesc:a24fb15e00019f1f0687775d00e280332"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPBTRS: solves a system of linear equations A*X = B with a Hermitian positive definite band matrix A using the Cholesky factorization A = U**H*U or A = L*L**H computed by CPBTRF.  <br /></td></tr>
<tr class="separator:a24fb15e00019f1f0687775d00e280332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae519c20339e3a585266a6df4077cf0e5" id="r_ae519c20339e3a585266a6df4077cf0e5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae519c20339e3a585266a6df4077cf0e5">la_lapack_c::la_cpoequ</a> (n, a, lda, s, scond, amax, info)</td></tr>
<tr class="memdesc:ae519c20339e3a585266a6df4077cf0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOEQU: computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings.  <br /></td></tr>
<tr class="separator:ae519c20339e3a585266a6df4077cf0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bed34555b13400d1beec624e071bb7" id="r_ae7bed34555b13400d1beec624e071bb7"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae7bed34555b13400d1beec624e071bb7">la_lapack_c::la_cpoequb</a> (n, a, lda, s, scond, amax, info)</td></tr>
<tr class="memdesc:ae7bed34555b13400d1beec624e071bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOEQUB: computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings. This routine differs from CPOEQU by restricting the scaling factors to a power of the radix. Barring over- and underflow, scaling by these factors introduces no additional rounding errors. However, the scaled diagonal entries are no longer approximately 1 but lie between sqrt(radix) and 1/sqrt(radix).  <br /></td></tr>
<tr class="separator:ae7bed34555b13400d1beec624e071bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060052fd843547c7a7f54f2517f1a093" id="r_a060052fd843547c7a7f54f2517f1a093"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a060052fd843547c7a7f54f2517f1a093">la_lapack_c::la_cpotf2</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:a060052fd843547c7a7f54f2517f1a093"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOTF2: computes the Cholesky factorization of a complex Hermitian positive definite matrix A. The factorization has the form A = U**H * U , if UPLO = 'U', or A = L * L**H, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:a060052fd843547c7a7f54f2517f1a093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a99145c7777718f93ad3b3104de1011" id="r_a2a99145c7777718f93ad3b3104de1011"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2a99145c7777718f93ad3b3104de1011">la_lapack_c::la_cpotrf2</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:a2a99145c7777718f93ad3b3104de1011"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOTRF2: computes the Cholesky factorization of a Hermitian positive definite matrix A using the recursive algorithm. The factorization has the form A = U**H * U, if UPLO = 'U', or A = L * L**H, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular. This is the recursive version of the algorithm. It divides the matrix into four submatrices: [ A11 | A12 ] where A11 is n1 by n1 and A22 is n2 by n2 A = [ --&mdash;|--&mdash; ] with n1 = n/2 [ A21 | A22 ] n2 = n-n1 The subroutine calls itself to factor A11. Update and scale A21 or A12, update A22 then calls itself to factor A22.  <br /></td></tr>
<tr class="separator:a2a99145c7777718f93ad3b3104de1011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b4f24628660bbf5ea4e8274688bd06" id="r_a49b4f24628660bbf5ea4e8274688bd06"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a49b4f24628660bbf5ea4e8274688bd06">la_lapack_c::la_cpotrs</a> (uplo, n, nrhs, a, lda, b, ldb, info)</td></tr>
<tr class="memdesc:a49b4f24628660bbf5ea4e8274688bd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOTRS: solves a system of linear equations A*X = B with a Hermitian positive definite matrix A using the Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.  <br /></td></tr>
<tr class="separator:a49b4f24628660bbf5ea4e8274688bd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4f58495f49fa732430174d820fecad" id="r_a9c4f58495f49fa732430174d820fecad"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9c4f58495f49fa732430174d820fecad">la_lapack_c::la_cppequ</a> (uplo, n, ap, s, scond, amax, info)</td></tr>
<tr class="memdesc:a9c4f58495f49fa732430174d820fecad"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPPEQU: computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A in packed storage and reduce its condition number (with respect to the two-norm). S contains the scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal. This choice of S puts the condition number of B within a factor N of the smallest possible condition number over all possible diagonal scalings.  <br /></td></tr>
<tr class="separator:a9c4f58495f49fa732430174d820fecad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949f453608e4f51cc812703ed4eb9538" id="r_a949f453608e4f51cc812703ed4eb9538"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a949f453608e4f51cc812703ed4eb9538">la_lapack_c::la_cpptrf</a> (uplo, n, ap, info)</td></tr>
<tr class="memdesc:a949f453608e4f51cc812703ed4eb9538"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPPTRF: computes the Cholesky factorization of a complex Hermitian positive definite matrix A stored in packed format. The factorization has the form A = U**H * U, if UPLO = 'U', or A = L * L**H, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular.  <br /></td></tr>
<tr class="separator:a949f453608e4f51cc812703ed4eb9538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03c8f96c51bebdb05e9e0c82c3c0071" id="r_aa03c8f96c51bebdb05e9e0c82c3c0071"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa03c8f96c51bebdb05e9e0c82c3c0071">la_lapack_c::la_cpptrs</a> (uplo, n, nrhs, ap, b, ldb, info)</td></tr>
<tr class="memdesc:aa03c8f96c51bebdb05e9e0c82c3c0071"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPPTRS: solves a system of linear equations A*X = B with a Hermitian positive definite matrix A in packed storage using the Cholesky factorization A = U**H*U or A = L*L**H computed by CPPTRF.  <br /></td></tr>
<tr class="separator:aa03c8f96c51bebdb05e9e0c82c3c0071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572f20c388d5bd917e4122a2a02d667a" id="r_a572f20c388d5bd917e4122a2a02d667a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a572f20c388d5bd917e4122a2a02d667a">la_lapack_c::la_cpstf2</a> (uplo, n, a, lda, piv, rank, tol, work, info)</td></tr>
<tr class="memdesc:a572f20c388d5bd917e4122a2a02d667a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPSTF2: computes the Cholesky factorization with complete pivoting of a complex Hermitian positive semidefinite matrix A. The factorization has the form P**T * A * P = U**H * U , if UPLO = 'U', P**T * A * P = L * L**H, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular, and P is stored as vector PIV. This algorithm does not attempt to check that A is positive semidefinite. This version of the algorithm calls level 2 BLAS.  <br /></td></tr>
<tr class="separator:a572f20c388d5bd917e4122a2a02d667a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f40887ca7bd9602c33fc025e2a945fb" id="r_a6f40887ca7bd9602c33fc025e2a945fb"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6f40887ca7bd9602c33fc025e2a945fb">la_lapack_c::la_cpstrf</a> (uplo, n, a, lda, piv, rank, tol, work, info)</td></tr>
<tr class="memdesc:a6f40887ca7bd9602c33fc025e2a945fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPSTRF: computes the Cholesky factorization with complete pivoting of a complex Hermitian positive semidefinite matrix A. The factorization has the form P**T * A * P = U**H * U , if UPLO = 'U', P**T * A * P = L * L**H, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular, and P is stored as vector PIV. This algorithm does not attempt to check that A is positive semidefinite. This version of the algorithm calls level 3 BLAS.  <br /></td></tr>
<tr class="separator:a6f40887ca7bd9602c33fc025e2a945fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060f10729c39584dcd8708921bef89b6" id="r_a060f10729c39584dcd8708921bef89b6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a060f10729c39584dcd8708921bef89b6">la_lapack_c::la_cptcon</a> (n, d, e, anorm, rcond, rwork, info)</td></tr>
<tr class="memdesc:a060f10729c39584dcd8708921bef89b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPTCON: computes the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite tridiagonal matrix using the factorization A = L*D*L**H or A = U**H*D*U computed by CPTTRF. Norm(inv(A)) is computed by a direct method, and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a060f10729c39584dcd8708921bef89b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95de42c809f97e54f2a1f62bfa51d860" id="r_a95de42c809f97e54f2a1f62bfa51d860"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a95de42c809f97e54f2a1f62bfa51d860">la_lapack_c::la_cpttrf</a> (n, d, e, info)</td></tr>
<tr class="memdesc:a95de42c809f97e54f2a1f62bfa51d860"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPTTRF: computes the L*D*L**H factorization of a complex Hermitian positive definite tridiagonal matrix A. The factorization may also be regarded as having the form A = U**H *D*U.  <br /></td></tr>
<tr class="separator:a95de42c809f97e54f2a1f62bfa51d860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91fd6c64ac42b2a0fbe588e7ff45b25" id="r_ae91fd6c64ac42b2a0fbe588e7ff45b25"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae91fd6c64ac42b2a0fbe588e7ff45b25">la_lapack_c::la_cptts2</a> (iuplo, n, nrhs, d, e, b, ldb)</td></tr>
<tr class="memdesc:ae91fd6c64ac42b2a0fbe588e7ff45b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPTTS2: solves a tridiagonal system of the form A * X = B using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF. D is a diagonal matrix specified in the vector D, U (or L) is a unit bidiagonal matrix whose superdiagonal (subdiagonal) is specified in the vector E, and X and B are N by NRHS matrices.  <br /></td></tr>
<tr class="separator:ae91fd6c64ac42b2a0fbe588e7ff45b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1022d6940953e2aeeab21638d4722932" id="r_a1022d6940953e2aeeab21638d4722932"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1022d6940953e2aeeab21638d4722932">la_lapack_c::la_crot</a> (n, cx, incx, cy, incy, c, s)</td></tr>
<tr class="memdesc:a1022d6940953e2aeeab21638d4722932"><td class="mdescLeft">&#160;</td><td class="mdescRight">CROT: applies a plane rotation, where the cos (C) is real and the sin (S) is complex, and the vectors CX and CY are complex.  <br /></td></tr>
<tr class="separator:a1022d6940953e2aeeab21638d4722932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e88322eec5878da21caa6e92cd20b26" id="r_a2e88322eec5878da21caa6e92cd20b26"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2e88322eec5878da21caa6e92cd20b26">la_lapack_c::la_cspmv</a> (uplo, n, alpha, ap, x, incx, beta, y, incy)</td></tr>
<tr class="memdesc:a2e88322eec5878da21caa6e92cd20b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSPMV: performs the matrix-vector operation y := alpha*A*x + beta*y, where alpha and beta are scalars, x and y are n element vectors and A is an n by n symmetric matrix, supplied in packed form.  <br /></td></tr>
<tr class="separator:a2e88322eec5878da21caa6e92cd20b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5afcfe0496d07b6f910ab3efcc807fd" id="r_af5afcfe0496d07b6f910ab3efcc807fd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af5afcfe0496d07b6f910ab3efcc807fd">la_lapack_c::la_cspr</a> (uplo, n, alpha, x, incx, ap)</td></tr>
<tr class="memdesc:af5afcfe0496d07b6f910ab3efcc807fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSPR: performs the symmetric rank 1 operation A := alpha*x*x**H + A, where alpha is a complex scalar, x is an n element vector and A is an n by n symmetric matrix, supplied in packed form.  <br /></td></tr>
<tr class="separator:af5afcfe0496d07b6f910ab3efcc807fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9ac21dd93faec6bc1fde38af621ccd" id="r_aec9ac21dd93faec6bc1fde38af621ccd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aec9ac21dd93faec6bc1fde38af621ccd">la_lapack_c::la_csptrf</a> (uplo, n, ap, ipiv, info)</td></tr>
<tr class="memdesc:aec9ac21dd93faec6bc1fde38af621ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSPTRF: computes the factorization of a complex symmetric matrix A stored in packed format using the Bunch-Kaufman diagonal pivoting method: A = U*D*U**T or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.  <br /></td></tr>
<tr class="separator:aec9ac21dd93faec6bc1fde38af621ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e72c0f58c49fb27a9f0786117b30c5" id="r_ad9e72c0f58c49fb27a9f0786117b30c5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad9e72c0f58c49fb27a9f0786117b30c5">la_lapack_c::la_csptri</a> (uplo, n, ap, ipiv, work, info)</td></tr>
<tr class="memdesc:ad9e72c0f58c49fb27a9f0786117b30c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSPTRI: computes the inverse of a complex symmetric indefinite matrix A in packed storage using the factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.  <br /></td></tr>
<tr class="separator:ad9e72c0f58c49fb27a9f0786117b30c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01c98efa8fbfab1bb805dc9f5b23cd0" id="r_ac01c98efa8fbfab1bb805dc9f5b23cd0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac01c98efa8fbfab1bb805dc9f5b23cd0">la_lapack_c::la_csptrs</a> (uplo, n, nrhs, ap, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:ac01c98efa8fbfab1bb805dc9f5b23cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSPTRS: solves a system of linear equations A*X = B with a complex symmetric matrix A stored in packed format using the factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.  <br /></td></tr>
<tr class="separator:ac01c98efa8fbfab1bb805dc9f5b23cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59c1dd12f847dd5669dddc2369a6f96" id="r_ac59c1dd12f847dd5669dddc2369a6f96"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac59c1dd12f847dd5669dddc2369a6f96">la_lapack_c::la_csrscl</a> (n, sa, sx, incx)</td></tr>
<tr class="memdesc:ac59c1dd12f847dd5669dddc2369a6f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSRSCL: multiplies an n-element complex vector x by the real scalar 1/a. This is done without overflow or underflow as long as the final result x/a does not overflow or underflow.  <br /></td></tr>
<tr class="separator:ac59c1dd12f847dd5669dddc2369a6f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcac06f9a107755849996a307e65111d" id="r_adcac06f9a107755849996a307e65111d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#adcac06f9a107755849996a307e65111d">la_lapack_c::la_cstein</a> (n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifail, info)</td></tr>
<tr class="memdesc:adcac06f9a107755849996a307e65111d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSTEIN: computes the eigenvectors of a real symmetric tridiagonal matrix T corresponding to specified eigenvalues, using inverse iteration. The maximum number of iterations allowed for each eigenvector is specified by an internal parameter MAXITS (currently set to 5). Although the eigenvectors are real, they are stored in a complex array, which may be passed to CUNMTR or CUPMTR for back transformation to the eigenvectors of a complex Hermitian matrix which was reduced to tridiagonal form.  <br /></td></tr>
<tr class="separator:adcac06f9a107755849996a307e65111d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24b1fbdc9feaa555c26447165acf7e5" id="r_af24b1fbdc9feaa555c26447165acf7e5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af24b1fbdc9feaa555c26447165acf7e5">la_lapack_c::la_csteqr</a> (compz, n, d, e, z, ldz, work, info)</td></tr>
<tr class="memdesc:af24b1fbdc9feaa555c26447165acf7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSTEQR: computes all eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the implicit QL or QR method. The eigenvectors of a full or band complex Hermitian matrix can also be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this matrix to tridiagonal form.  <br /></td></tr>
<tr class="separator:af24b1fbdc9feaa555c26447165acf7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542a8e700c913e269d0dd3eb4543a62a" id="r_a542a8e700c913e269d0dd3eb4543a62a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a542a8e700c913e269d0dd3eb4543a62a">la_lapack_c::la_csyconv</a> (uplo, way, n, a, lda, ipiv, e, info)</td></tr>
<tr class="memdesc:a542a8e700c913e269d0dd3eb4543a62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYCONV: convert A given by TRF into L and D and vice-versa. Get Non-diag elements of D (returned in workspace) and apply or reverse permutation done in TRF.  <br /></td></tr>
<tr class="separator:a542a8e700c913e269d0dd3eb4543a62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac056bf1e9ad398dad55d642e7f0d5d3" id="r_aac056bf1e9ad398dad55d642e7f0d5d3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aac056bf1e9ad398dad55d642e7f0d5d3">la_lapack_c::la_csyconvf</a> (uplo, way, n, a, lda, e, ipiv, info)</td></tr>
<tr class="memdesc:aac056bf1e9ad398dad55d642e7f0d5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If parameter WAY = 'C': CSYCONVF: converts the factorization output format used in CSYTRF provided on entry in parameter A into the factorization output format used in CSYTRF_RK (or CSYTRF_BK) that is stored on exit in parameters A and E. It also converts in place details of the intechanges stored in IPIV from the format used in CSYTRF into the format used in CSYTRF_RK (or CSYTRF_BK). If parameter WAY = 'R': CSYCONVF performs the conversion in reverse direction, i.e. converts the factorization output format used in CSYTRF_RK (or CSYTRF_BK) provided on entry in parameters A and E into the factorization output format used in CSYTRF that is stored on exit in parameter A. It also converts in place details of the intechanges stored in IPIV from the format used in CSYTRF_RK (or CSYTRF_BK) into the format used in CSYTRF. CSYCONVF can also convert in Hermitian matrix case, i.e. between formats used in CHETRF and CHETRF_RK (or CHETRF_BK).  <br /></td></tr>
<tr class="separator:aac056bf1e9ad398dad55d642e7f0d5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc066e89f75fe75db96d1895d70a386b" id="r_afc066e89f75fe75db96d1895d70a386b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#afc066e89f75fe75db96d1895d70a386b">la_lapack_c::la_csyconvf_rook</a> (uplo, way, n, a, lda, e, ipiv, info)</td></tr>
<tr class="memdesc:afc066e89f75fe75db96d1895d70a386b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If parameter WAY = 'C': CSYCONVF_ROOK: converts the factorization output format used in CSYTRF_ROOK provided on entry in parameter A into the factorization output format used in CSYTRF_RK (or CSYTRF_BK) that is stored on exit in parameters A and E. IPIV format for CSYTRF_ROOK and CSYTRF_RK (or CSYTRF_BK) is the same and is not converted. If parameter WAY = 'R': CSYCONVF_ROOK performs the conversion in reverse direction, i.e. converts the factorization output format used in CSYTRF_RK (or CSYTRF_BK) provided on entry in parameters A and E into the factorization output format used in CSYTRF_ROOK that is stored on exit in parameter A. IPIV format for CSYTRF_ROOK and CSYTRF_RK (or CSYTRF_BK) is the same and is not converted. CSYCONVF_ROOK can also convert in Hermitian matrix case, i.e. between formats used in CHETRF_ROOK and CHETRF_RK (or CHETRF_BK).  <br /></td></tr>
<tr class="separator:afc066e89f75fe75db96d1895d70a386b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c4bd8f865aaddb5778fbd6296ac1e3" id="r_aa6c4bd8f865aaddb5778fbd6296ac1e3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa6c4bd8f865aaddb5778fbd6296ac1e3">la_lapack_c::la_csyequb</a> (uplo, n, a, lda, s, scond, amax, work, info)</td></tr>
<tr class="memdesc:aa6c4bd8f865aaddb5778fbd6296ac1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYEQUB: computes row and column scalings intended to equilibrate a symmetric matrix A (with respect to the Euclidean norm) and reduce its condition number. The scale factors S are computed by the BIN algorithm (see references) so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of the smallest possible condition number over all possible diagonal scalings.  <br /></td></tr>
<tr class="separator:aa6c4bd8f865aaddb5778fbd6296ac1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab53f4942cb93a97e500839a8ea18ac5" id="r_aab53f4942cb93a97e500839a8ea18ac5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aab53f4942cb93a97e500839a8ea18ac5">la_lapack_c::la_csymv</a> (uplo, n, alpha, a, lda, x, incx, beta, y, incy)</td></tr>
<tr class="memdesc:aab53f4942cb93a97e500839a8ea18ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYMV: performs the matrix-vector operation y := alpha*A*x + beta*y, where alpha and beta are scalars, x and y are n element vectors and A is an n by n symmetric matrix.  <br /></td></tr>
<tr class="separator:aab53f4942cb93a97e500839a8ea18ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45a6dcf9a38d34ba7230edc0a017ec3" id="r_ac45a6dcf9a38d34ba7230edc0a017ec3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac45a6dcf9a38d34ba7230edc0a017ec3">la_lapack_c::la_csyr</a> (uplo, n, alpha, x, incx, a, lda)</td></tr>
<tr class="memdesc:ac45a6dcf9a38d34ba7230edc0a017ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYR: performs the symmetric rank 1 operation A := alpha*x*x**H + A, where alpha is a complex scalar, x is an n element vector and A is an n by n symmetric matrix.  <br /></td></tr>
<tr class="separator:ac45a6dcf9a38d34ba7230edc0a017ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71c76f37604fb158360425836e57993" id="r_ac71c76f37604fb158360425836e57993"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac71c76f37604fb158360425836e57993">la_lapack_c::la_csyswapr</a> (uplo, n, a, lda, i1, i2)</td></tr>
<tr class="memdesc:ac71c76f37604fb158360425836e57993"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYSWAPR: applies an elementary permutation on the rows and the columns of a symmetric matrix.  <br /></td></tr>
<tr class="separator:ac71c76f37604fb158360425836e57993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa168a57603e34fc1156d08ee8a0db05d" id="r_aa168a57603e34fc1156d08ee8a0db05d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa168a57603e34fc1156d08ee8a0db05d">la_lapack_c::la_csytf2</a> (uplo, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:aa168a57603e34fc1156d08ee8a0db05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTF2: computes the factorization of a complex symmetric matrix A using the Bunch-Kaufman diagonal pivoting method: A = U*D*U**T or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, U**T is the transpose of U, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:aa168a57603e34fc1156d08ee8a0db05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d33d717b4fa2c4eec84b8fae3df2e8" id="r_a38d33d717b4fa2c4eec84b8fae3df2e8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a38d33d717b4fa2c4eec84b8fae3df2e8">la_lapack_c::la_csytf2_rk</a> (uplo, n, a, lda, e, ipiv, info)</td></tr>
<tr class="memdesc:a38d33d717b4fa2c4eec84b8fae3df2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTF2_RK: computes the factorization of a complex symmetric matrix A using the bounded Bunch-Kaufman (rook) diagonal pivoting method: A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T), where U (or L) is unit upper (or lower) triangular matrix, U**T (or L**T) is the transpose of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the unblocked version of the algorithm, calling Level 2 BLAS. For more information see Further Details section.  <br /></td></tr>
<tr class="separator:a38d33d717b4fa2c4eec84b8fae3df2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef804bdd6b5aa5b1f4125696367fb1c" id="r_a3ef804bdd6b5aa5b1f4125696367fb1c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a3ef804bdd6b5aa5b1f4125696367fb1c">la_lapack_c::la_csytf2_rook</a> (uplo, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:a3ef804bdd6b5aa5b1f4125696367fb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTF2_ROOK: computes the factorization of a complex symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method: A = U*D*U**T or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, U**T is the transpose of U, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the unblocked version of the algorithm, calling Level 2 BLAS.  <br /></td></tr>
<tr class="separator:a3ef804bdd6b5aa5b1f4125696367fb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5a46aec8d340a2dbd96573d5b8881b" id="r_a1c5a46aec8d340a2dbd96573d5b8881b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1c5a46aec8d340a2dbd96573d5b8881b">la_lapack_c::la_csytrf</a> (uplo, n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:a1c5a46aec8d340a2dbd96573d5b8881b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRF: computes the factorization of a complex symmetric matrix A using the Bunch-Kaufman diagonal pivoting method. The form of the factorization is A = U*D*U**T or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a1c5a46aec8d340a2dbd96573d5b8881b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0a42c1c32d76aa2749be57c7beb98a" id="r_a2e0a42c1c32d76aa2749be57c7beb98a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2e0a42c1c32d76aa2749be57c7beb98a">la_lapack_c::la_csytrf_rk</a> (uplo, n, a, lda, e, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:a2e0a42c1c32d76aa2749be57c7beb98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRF_RK: computes the factorization of a complex symmetric matrix A using the bounded Bunch-Kaufman (rook) diagonal pivoting method: A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T), where U (or L) is unit upper (or lower) triangular matrix, U**T (or L**T) is the transpose of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the blocked version of the algorithm, calling Level 3 BLAS. For more information see Further Details section.  <br /></td></tr>
<tr class="separator:a2e0a42c1c32d76aa2749be57c7beb98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6deb0f0a354fdb9b849dcf4ca5e608c8" id="r_a6deb0f0a354fdb9b849dcf4ca5e608c8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6deb0f0a354fdb9b849dcf4ca5e608c8">la_lapack_c::la_csytrf_rook</a> (uplo, n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:a6deb0f0a354fdb9b849dcf4ca5e608c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRF_ROOK: computes the factorization of a complex symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method. The form of the factorization is A = U*D*U**T or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a6deb0f0a354fdb9b849dcf4ca5e608c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cda215d696f4aa24b53c08495ec4d6b" id="r_a5cda215d696f4aa24b53c08495ec4d6b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5cda215d696f4aa24b53c08495ec4d6b">la_lapack_c::la_csytri</a> (uplo, n, a, lda, ipiv, work, info)</td></tr>
<tr class="memdesc:a5cda215d696f4aa24b53c08495ec4d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRI: computes the inverse of a complex symmetric indefinite matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by CSYTRF.  <br /></td></tr>
<tr class="separator:a5cda215d696f4aa24b53c08495ec4d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf17a343402606fc9e0857ef7d7707d9" id="r_abf17a343402606fc9e0857ef7d7707d9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abf17a343402606fc9e0857ef7d7707d9">la_lapack_c::la_csytri_rook</a> (uplo, n, a, lda, ipiv, work, info)</td></tr>
<tr class="memdesc:abf17a343402606fc9e0857ef7d7707d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRI_ROOK: computes the inverse of a complex symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by CSYTRF_ROOK.  <br /></td></tr>
<tr class="separator:abf17a343402606fc9e0857ef7d7707d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352f4d6d3de5c73b9f9a45a3c1504ae6" id="r_a352f4d6d3de5c73b9f9a45a3c1504ae6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a352f4d6d3de5c73b9f9a45a3c1504ae6">la_lapack_c::la_csytrs</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a352f4d6d3de5c73b9f9a45a3c1504ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRS: solves a system of linear equations A*X = B with a complex symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by CSYTRF.  <br /></td></tr>
<tr class="separator:a352f4d6d3de5c73b9f9a45a3c1504ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7104cafa5a34d767ff013b103973cb5" id="r_ab7104cafa5a34d767ff013b103973cb5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab7104cafa5a34d767ff013b103973cb5">la_lapack_c::la_csytrs2</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, info)</td></tr>
<tr class="memdesc:ab7104cafa5a34d767ff013b103973cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRS2: solves a system of linear equations A*X = B with a complex symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by CSYTRF and converted by CSYCONV.  <br /></td></tr>
<tr class="separator:ab7104cafa5a34d767ff013b103973cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb27236d86166d641d69e0fc2a51dcd5" id="r_abb27236d86166d641d69e0fc2a51dcd5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abb27236d86166d641d69e0fc2a51dcd5">la_lapack_c::la_csytrs_3</a> (uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:abb27236d86166d641d69e0fc2a51dcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRS_3: solves a system of linear equations A * X = B with a complex symmetric matrix A using the factorization computed by CSYTRF_RK or CSYTRF_BK: A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T), where U (or L) is unit upper (or lower) triangular matrix, U**T (or L**T) is the transpose of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This algorithm is using Level 3 BLAS.  <br /></td></tr>
<tr class="separator:abb27236d86166d641d69e0fc2a51dcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278391ef83ed8e8b2cbbde3abf1a304e" id="r_a278391ef83ed8e8b2cbbde3abf1a304e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a278391ef83ed8e8b2cbbde3abf1a304e">la_lapack_c::la_csytrs_aa</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a278391ef83ed8e8b2cbbde3abf1a304e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRS_AA: solves a system of linear equations A*X = B with a complex symmetric matrix A using the factorization A = U**T*T*U or A = L*T*L**T computed by CSYTRF_AA.  <br /></td></tr>
<tr class="separator:a278391ef83ed8e8b2cbbde3abf1a304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500f576d980cd1a022dcb0d3925f087d" id="r_a500f576d980cd1a022dcb0d3925f087d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a500f576d980cd1a022dcb0d3925f087d">la_lapack_c::la_csytrs_rook</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a500f576d980cd1a022dcb0d3925f087d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRS_ROOK: solves a system of linear equations A*X = B with a complex symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by CSYTRF_ROOK.  <br /></td></tr>
<tr class="separator:a500f576d980cd1a022dcb0d3925f087d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819278435b67cb9a43396835173009f8" id="r_a819278435b67cb9a43396835173009f8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a819278435b67cb9a43396835173009f8">la_lapack_c::la_ctbrfs</a> (uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a819278435b67cb9a43396835173009f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTBRFS: provides error bounds and backward error estimates for the solution to a system of linear equations with a triangular band coefficient matrix. The solution matrix X must be computed by CTBTRS or some other means before entering this routine. CTBRFS does not do iterative refinement because doing so cannot improve the backward error.  <br /></td></tr>
<tr class="separator:a819278435b67cb9a43396835173009f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63440a20b758bee64ccea6a0aa350f22" id="r_a63440a20b758bee64ccea6a0aa350f22"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a63440a20b758bee64ccea6a0aa350f22">la_lapack_c::la_ctbtrs</a> (uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, info)</td></tr>
<tr class="memdesc:a63440a20b758bee64ccea6a0aa350f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTBTRS: solves a triangular system of the form A * X = B, A**T * X = B, or A**H * X = B, where A is a triangular band matrix of order N, and B is an N-by-NRHS matrix. A check is made to verify that A is nonsingular.  <br /></td></tr>
<tr class="separator:a63440a20b758bee64ccea6a0aa350f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe803908bc8da92bbb197d0d818d75df" id="r_afe803908bc8da92bbb197d0d818d75df"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#afe803908bc8da92bbb197d0d818d75df">la_lapack_c::la_ctfsm</a> (transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb)</td></tr>
<tr class="memdesc:afe803908bc8da92bbb197d0d818d75df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level 3 BLAS like routine for A in RFP Format. CTFSM: solves the matrix equation op( A )*X = alpha*B or X*op( A ) = alpha*B where alpha is a scalar, X and B are m by n matrices, A is a unit, or non-unit, upper or lower triangular matrix and op( A ) is one of op( A ) = A or op( A ) = A**H. A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.  <br /></td></tr>
<tr class="separator:afe803908bc8da92bbb197d0d818d75df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776c3d1fed3da49880fa78adaa9c674a" id="r_a776c3d1fed3da49880fa78adaa9c674a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a776c3d1fed3da49880fa78adaa9c674a">la_lapack_c::la_ctfttp</a> (transr, uplo, n, arf, ap, info)</td></tr>
<tr class="memdesc:a776c3d1fed3da49880fa78adaa9c674a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTFTTP: copies a triangular matrix A from rectangular full packed format (TF) to standard packed format (TP).  <br /></td></tr>
<tr class="separator:a776c3d1fed3da49880fa78adaa9c674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985f7390487073c094d238f252675e45" id="r_a985f7390487073c094d238f252675e45"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a985f7390487073c094d238f252675e45">la_lapack_c::la_ctfttr</a> (transr, uplo, n, arf, a, lda, info)</td></tr>
<tr class="memdesc:a985f7390487073c094d238f252675e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTFTTR: copies a triangular matrix A from rectangular full packed format (TF) to standard full format (TR).  <br /></td></tr>
<tr class="separator:a985f7390487073c094d238f252675e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5003452af6a48cb6e04c7531645352fc" id="r_a5003452af6a48cb6e04c7531645352fc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5003452af6a48cb6e04c7531645352fc">la_lapack_c::la_ctgevc</a> (side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork, info)</td></tr>
<tr class="memdesc:a5003452af6a48cb6e04c7531645352fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTGEVC: computes some or all of the right and/or left eigenvectors of a pair of complex matrices (S,P), where S and P are upper triangular. Matrix pairs of this type are produced by the generalized Schur factorization of a complex matrix pair (A,B): A = Q*S*Z**H, B = Q*P*Z**H as computed by CGGHRD + CHGEQZ. The right eigenvector x and the left eigenvector y of (S,P) corresponding to an eigenvalue w are defined by: S*x = w*P*x, (y**H)*S = w*(y**H)*P, where y**H denotes the conjugate tranpose of y. The eigenvalues are not input to this routine, but are computed directly from the diagonal elements of S and P. This routine returns the matrices X and/or Y of right and left eigenvectors of (S,P), or the products Z*X and/or Q*Y, where Z and Q are input matrices. If Q and Z are the unitary factors from the generalized Schur factorization of a matrix pair (A,B), then Z*X and Q*Y are the matrices of right and left eigenvectors of (A,B).  <br /></td></tr>
<tr class="separator:a5003452af6a48cb6e04c7531645352fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af641addb211e873a1314f5ac6f18b9b8" id="r_af641addb211e873a1314f5ac6f18b9b8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af641addb211e873a1314f5ac6f18b9b8">la_lapack_c::la_ctgex2</a> (wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, j1, info)</td></tr>
<tr class="memdesc:af641addb211e873a1314f5ac6f18b9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTGEX2: swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22) in an upper triangular matrix pair (A, B) by an unitary equivalence transformation. (A, B) must be in generalized Schur canonical form, that is, A and B are both upper triangular. Optionally, the matrices Q and Z of generalized Schur vectors are updated. Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H.  <br /></td></tr>
<tr class="separator:af641addb211e873a1314f5ac6f18b9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10293dd921cf336a4182fe5eba8f18bb" id="r_a10293dd921cf336a4182fe5eba8f18bb"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a10293dd921cf336a4182fe5eba8f18bb">la_lapack_c::la_ctgexc</a> (wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, info)</td></tr>
<tr class="memdesc:a10293dd921cf336a4182fe5eba8f18bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTGEXC: reorders the generalized Schur decomposition of a complex matrix pair (A,B), using an unitary equivalence transformation (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with row index IFST is moved to row ILST. (A, B) must be in generalized Schur canonical form, that is, A and B are both upper triangular. Optionally, the matrices Q and Z of generalized Schur vectors are updated. Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H.  <br /></td></tr>
<tr class="separator:a10293dd921cf336a4182fe5eba8f18bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab232f24025fee76356438cd4d4a9319d" id="r_ab232f24025fee76356438cd4d4a9319d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab232f24025fee76356438cd4d4a9319d">la_lapack_c::la_ctplqt2</a> (m, n, l, a, lda, b, ldb, t, ldt, info)</td></tr>
<tr class="memdesc:ab232f24025fee76356438cd4d4a9319d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPLQT2: computes a LQ a factorization of a complex "triangular-pentagonal" matrix C, which is composed of a triangular block A and pentagonal block B, using the compact WY representation for Q.  <br /></td></tr>
<tr class="separator:ab232f24025fee76356438cd4d4a9319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606ee7fd5254d2a6e937a8588c2a9904" id="r_a606ee7fd5254d2a6e937a8588c2a9904"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a606ee7fd5254d2a6e937a8588c2a9904">la_lapack_c::la_ctpqrt2</a> (m, n, l, a, lda, b, ldb, t, ldt, info)</td></tr>
<tr class="memdesc:a606ee7fd5254d2a6e937a8588c2a9904"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPQRT2: computes a QR factorization of a complex "triangular-pentagonal" matrix C, which is composed of a triangular block A and pentagonal block B, using the compact WY representation for Q.  <br /></td></tr>
<tr class="separator:a606ee7fd5254d2a6e937a8588c2a9904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc94fb0d819034c2a95628d99fde1c49" id="r_abc94fb0d819034c2a95628d99fde1c49"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abc94fb0d819034c2a95628d99fde1c49">la_lapack_c::la_ctprfb</a> (side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork)</td></tr>
<tr class="memdesc:abc94fb0d819034c2a95628d99fde1c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPRFB: applies a complex "triangular-pentagonal" block reflector H or its conjugate transpose H**H to a complex matrix C, which is composed of two blocks A and B, either from the left or right.  <br /></td></tr>
<tr class="separator:abc94fb0d819034c2a95628d99fde1c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350b6b605992b6e8e6799449c440f739" id="r_a350b6b605992b6e8e6799449c440f739"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a350b6b605992b6e8e6799449c440f739">la_lapack_c::la_ctprfs</a> (uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a350b6b605992b6e8e6799449c440f739"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPRFS: provides error bounds and backward error estimates for the solution to a system of linear equations with a triangular packed coefficient matrix. The solution matrix X must be computed by CTPTRS or some other means before entering this routine. CTPRFS does not do iterative refinement because doing so cannot improve the backward error.  <br /></td></tr>
<tr class="separator:a350b6b605992b6e8e6799449c440f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecb7698bb6cbabc0255469f4601e653" id="r_aeecb7698bb6cbabc0255469f4601e653"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aeecb7698bb6cbabc0255469f4601e653">la_lapack_c::la_ctptri</a> (uplo, diag, n, ap, info)</td></tr>
<tr class="memdesc:aeecb7698bb6cbabc0255469f4601e653"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPTRI: computes the inverse of a complex upper or lower triangular matrix A stored in packed format.  <br /></td></tr>
<tr class="separator:aeecb7698bb6cbabc0255469f4601e653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d34c119c1c3cd9e484ab75fce455a1" id="r_aa5d34c119c1c3cd9e484ab75fce455a1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa5d34c119c1c3cd9e484ab75fce455a1">la_lapack_c::la_ctptrs</a> (uplo, trans, diag, n, nrhs, ap, b, ldb, info)</td></tr>
<tr class="memdesc:aa5d34c119c1c3cd9e484ab75fce455a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPTRS: solves a triangular system of the form A * X = B, A**T * X = B, or A**H * X = B, where A is a triangular matrix of order N stored in packed format, and B is an N-by-NRHS matrix. A check is made to verify that A is nonsingular.  <br /></td></tr>
<tr class="separator:aa5d34c119c1c3cd9e484ab75fce455a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f98f63d8e9b5c58d31daac705b7d68" id="r_ab2f98f63d8e9b5c58d31daac705b7d68"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab2f98f63d8e9b5c58d31daac705b7d68">la_lapack_c::la_ctpttf</a> (transr, uplo, n, ap, arf, info)</td></tr>
<tr class="memdesc:ab2f98f63d8e9b5c58d31daac705b7d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPTTF: copies a triangular matrix A from standard packed format (TP) to rectangular full packed format (TF).  <br /></td></tr>
<tr class="separator:ab2f98f63d8e9b5c58d31daac705b7d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fcbd448dec68995c38b763ce385dd6" id="r_a38fcbd448dec68995c38b763ce385dd6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a38fcbd448dec68995c38b763ce385dd6">la_lapack_c::la_ctpttr</a> (uplo, n, ap, a, lda, info)</td></tr>
<tr class="memdesc:a38fcbd448dec68995c38b763ce385dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPTTR: copies a triangular matrix A from standard packed format (TP) to standard full format (TR).  <br /></td></tr>
<tr class="separator:a38fcbd448dec68995c38b763ce385dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217d645a99b638058a455f1d0ddd3fb4" id="r_a217d645a99b638058a455f1d0ddd3fb4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a217d645a99b638058a455f1d0ddd3fb4">la_lapack_c::la_ctrevc</a> (side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork, info)</td></tr>
<tr class="memdesc:a217d645a99b638058a455f1d0ddd3fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTREVC: computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T. Matrices of this type are produced by the Schur factorization of a complex general matrix: A = Q*T*Q**H, as computed by CHSEQR. The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by: T*x = w*x, (y**H)*T = w*(y**H) where y**H denotes the conjugate transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal of T. This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the unitary factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.  <br /></td></tr>
<tr class="separator:a217d645a99b638058a455f1d0ddd3fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d16ea5c707c61fc2eafcf57833a5a6" id="r_ab8d16ea5c707c61fc2eafcf57833a5a6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab8d16ea5c707c61fc2eafcf57833a5a6">la_lapack_c::la_ctrevc3</a> (side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, lwork, rwork, lrwork, info)</td></tr>
<tr class="memdesc:ab8d16ea5c707c61fc2eafcf57833a5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTREVC3: computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T. Matrices of this type are produced by the Schur factorization of a complex general matrix: A = Q*T*Q**H, as computed by CHSEQR. The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by: T*x = w*x, (y**H)*T = w*(y**H) where y**H denotes the conjugate transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal of T. This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the unitary factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A. This uses a Level 3 BLAS version of the back transformation.  <br /></td></tr>
<tr class="separator:ab8d16ea5c707c61fc2eafcf57833a5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cbb2088abfb65649a9a15da092d113" id="r_aa7cbb2088abfb65649a9a15da092d113"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa7cbb2088abfb65649a9a15da092d113">la_lapack_c::la_ctrexc</a> (compq, n, t, ldt, q, ldq, ifst, ilst, info)</td></tr>
<tr class="memdesc:aa7cbb2088abfb65649a9a15da092d113"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTREXC: reorders the Schur factorization of a complex matrix A = Q*T*Q**H, so that the diagonal element of T with row index IFST is moved to row ILST. The Schur form T is reordered by a unitary similarity transformation Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by postmultplying it with Z.  <br /></td></tr>
<tr class="separator:aa7cbb2088abfb65649a9a15da092d113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a07aae1247d1feccfc1582fa3efa849" id="r_a6a07aae1247d1feccfc1582fa3efa849"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6a07aae1247d1feccfc1582fa3efa849">la_lapack_c::la_ctrrfs</a> (uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a6a07aae1247d1feccfc1582fa3efa849"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTRRFS: provides error bounds and backward error estimates for the solution to a system of linear equations with a triangular coefficient matrix. The solution matrix X must be computed by CTRTRS or some other means before entering this routine. CTRRFS does not do iterative refinement because doing so cannot improve the backward error.  <br /></td></tr>
<tr class="separator:a6a07aae1247d1feccfc1582fa3efa849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690057e0d6a2272c15b27dc49641b61b" id="r_a690057e0d6a2272c15b27dc49641b61b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a690057e0d6a2272c15b27dc49641b61b">la_lapack_c::la_ctrsna</a> (job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork, info)</td></tr>
<tr class="memdesc:a690057e0d6a2272c15b27dc49641b61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTRSNA: estimates reciprocal condition numbers for specified eigenvalues and/or right eigenvectors of a complex upper triangular matrix T (or of any matrix Q*T*Q**H with Q unitary).  <br /></td></tr>
<tr class="separator:a690057e0d6a2272c15b27dc49641b61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a079b9aba4a731568b8484adc725a1c" id="r_a5a079b9aba4a731568b8484adc725a1c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5a079b9aba4a731568b8484adc725a1c">la_lapack_c::la_ctrti2</a> (uplo, diag, n, a, lda, info)</td></tr>
<tr class="memdesc:a5a079b9aba4a731568b8484adc725a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTRTI2: computes the inverse of a complex upper or lower triangular matrix. This is the Level 2 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:a5a079b9aba4a731568b8484adc725a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645078330530db03dbbe60bc7ca17c5c" id="r_a645078330530db03dbbe60bc7ca17c5c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a645078330530db03dbbe60bc7ca17c5c">la_lapack_c::la_ctrtri</a> (uplo, diag, n, a, lda, info)</td></tr>
<tr class="memdesc:a645078330530db03dbbe60bc7ca17c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTRTRI: computes the inverse of a complex upper or lower triangular matrix A. This is the Level 3 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:a645078330530db03dbbe60bc7ca17c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf143b388ad376be9eedf544966e82ad" id="r_aaf143b388ad376be9eedf544966e82ad"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aaf143b388ad376be9eedf544966e82ad">la_lapack_c::la_ctrtrs</a> (uplo, trans, diag, n, nrhs, a, lda, b, ldb, info)</td></tr>
<tr class="memdesc:aaf143b388ad376be9eedf544966e82ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTRTRS: solves a triangular system of the form A * X = B, A**T * X = B, or A**H * X = B, where A is a triangular matrix of order N, and B is an N-by-NRHS matrix. A check is made to verify that A is nonsingular.  <br /></td></tr>
<tr class="separator:aaf143b388ad376be9eedf544966e82ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d4701097544e2537b7fbe37c85f913" id="r_aa4d4701097544e2537b7fbe37c85f913"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa4d4701097544e2537b7fbe37c85f913">la_lapack_c::la_ctrttf</a> (transr, uplo, n, a, lda, arf, info)</td></tr>
<tr class="memdesc:aa4d4701097544e2537b7fbe37c85f913"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTRTTF: copies a triangular matrix A from standard full format (TR) to rectangular full packed format (TF) .  <br /></td></tr>
<tr class="separator:aa4d4701097544e2537b7fbe37c85f913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5248324acbf3b6bd74d31dad7fc73b06" id="r_a5248324acbf3b6bd74d31dad7fc73b06"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5248324acbf3b6bd74d31dad7fc73b06">la_lapack_c::la_ctrttp</a> (uplo, n, a, lda, ap, info)</td></tr>
<tr class="memdesc:a5248324acbf3b6bd74d31dad7fc73b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTRTTP: copies a triangular matrix A from full format (TR) to standard packed format (TP).  <br /></td></tr>
<tr class="separator:a5248324acbf3b6bd74d31dad7fc73b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bcf676e698d5382b9bc82fe8bd71d8" id="r_a72bcf676e698d5382b9bc82fe8bd71d8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a72bcf676e698d5382b9bc82fe8bd71d8">la_lapack_c::la_ctzrzf</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a72bcf676e698d5382b9bc82fe8bd71d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTZRZF: reduces the M-by-N ( M&lt;=N ) complex upper trapezoidal matrix A to upper triangular form by means of unitary transformations. The upper trapezoidal matrix A is factored as A = ( R 0 ) * Z, where Z is an N-by-N unitary matrix and R is an M-by-M upper triangular matrix.  <br /></td></tr>
<tr class="separator:a72bcf676e698d5382b9bc82fe8bd71d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ab6ea1ace34f39201319538cca584b" id="r_af5ab6ea1ace34f39201319538cca584b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af5ab6ea1ace34f39201319538cca584b">la_lapack_c::la_cunbdb</a> (trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork, info)</td></tr>
<tr class="memdesc:af5ab6ea1ace34f39201319538cca584b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNBDB: simultaneously bidiagonalizes the blocks of an M-by-M partitioned unitary matrix X: [ B11 | B12 0 0 ] [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**H X = [--------&mdash;] = [------&mdash;] [-------------&mdash;] [------&mdash;] . [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ] [ 0 | 0 0 I ] X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is not the case, then X must be transposed and/or permuted. This can be done in constant time using the TRANS and SIGNS options. See CUNCSD for details.) The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by- (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are represented implicitly by Householder vectors. B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented implicitly by angles THETA, PHI.  <br /></td></tr>
<tr class="separator:af5ab6ea1ace34f39201319538cca584b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa998088a3dc70b0b21d4fa0bfbf8e433" id="r_aa998088a3dc70b0b21d4fa0bfbf8e433"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa998088a3dc70b0b21d4fa0bfbf8e433">la_lapack_c::la_cunbdb6</a> (m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2, work, lwork, info)</td></tr>
<tr class="memdesc:aa998088a3dc70b0b21d4fa0bfbf8e433"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNBDB6: orthogonalizes the column vector X = [ X1 ] [ X2 ] with respect to the columns of Q = [ Q1 ] . [ Q2 ] The columns of Q must be orthonormal. If the projection is zero according to Kahan's "twice is enough" criterion, then the zero vector is returned.  <br /></td></tr>
<tr class="separator:aa998088a3dc70b0b21d4fa0bfbf8e433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4309947db03e75ef96fd9621ea756d99" id="r_a4309947db03e75ef96fd9621ea756d99"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4309947db03e75ef96fd9621ea756d99">la_lapack_c::la_cung2l</a> (m, n, k, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a4309947db03e75ef96fd9621ea756d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNG2L: generates an m by n complex matrix Q with orthonormal columns, which is defined as the last n columns of a product of k elementary reflectors of order m Q = H(k) . . . H(2) H(1) as returned by CGEQLF.  <br /></td></tr>
<tr class="separator:a4309947db03e75ef96fd9621ea756d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb61e6c2b42ff4d0493a5476103cc36" id="r_afeb61e6c2b42ff4d0493a5476103cc36"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#afeb61e6c2b42ff4d0493a5476103cc36">la_lapack_c::la_cung2r</a> (m, n, k, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:afeb61e6c2b42ff4d0493a5476103cc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNG2R: generates an m by n complex matrix Q with orthonormal columns, which is defined as the first n columns of a product of k elementary reflectors of order m Q = H(1) H(2) . . . H(k) as returned by CGEQRF.  <br /></td></tr>
<tr class="separator:afeb61e6c2b42ff4d0493a5476103cc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7842f1a25df5893b4941ebfd0cd5e38b" id="r_a7842f1a25df5893b4941ebfd0cd5e38b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a7842f1a25df5893b4941ebfd0cd5e38b">la_lapack_c::la_cungl2</a> (m, n, k, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a7842f1a25df5893b4941ebfd0cd5e38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGL2: generates an m-by-n complex matrix Q with orthonormal rows, which is defined as the first m rows of a product of k elementary reflectors of order n Q = H(k)**H . . . H(2)**H H(1)**H as returned by CGELQF.  <br /></td></tr>
<tr class="separator:a7842f1a25df5893b4941ebfd0cd5e38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d46e37e41802cd7707b94d93bd21a5b" id="r_a5d46e37e41802cd7707b94d93bd21a5b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5d46e37e41802cd7707b94d93bd21a5b">la_lapack_c::la_cunglq</a> (m, n, k, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a5d46e37e41802cd7707b94d93bd21a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGLQ: generates an M-by-N complex matrix Q with orthonormal rows, which is defined as the first M rows of a product of K elementary reflectors of order N Q = H(k)**H . . . H(2)**H H(1)**H as returned by CGELQF.  <br /></td></tr>
<tr class="separator:a5d46e37e41802cd7707b94d93bd21a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f6c4f325a491ce733df7f321ee86ff" id="r_a52f6c4f325a491ce733df7f321ee86ff"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a52f6c4f325a491ce733df7f321ee86ff">la_lapack_c::la_cungql</a> (m, n, k, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a52f6c4f325a491ce733df7f321ee86ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGQL: generates an M-by-N complex matrix Q with orthonormal columns, which is defined as the last N columns of a product of K elementary reflectors of order M Q = H(k) . . . H(2) H(1) as returned by CGEQLF.  <br /></td></tr>
<tr class="separator:a52f6c4f325a491ce733df7f321ee86ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe78a75890dab65a85edef0881ee2905" id="r_abe78a75890dab65a85edef0881ee2905"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abe78a75890dab65a85edef0881ee2905">la_lapack_c::la_cungqr</a> (m, n, k, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:abe78a75890dab65a85edef0881ee2905"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGQR: generates an M-by-N complex matrix Q with orthonormal columns, which is defined as the first N columns of a product of K elementary reflectors of order M Q = H(1) H(2) . . . H(k) as returned by CGEQRF.  <br /></td></tr>
<tr class="separator:abe78a75890dab65a85edef0881ee2905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93ffb5580247aaa58614698f5865194" id="r_ab93ffb5580247aaa58614698f5865194"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab93ffb5580247aaa58614698f5865194">la_lapack_c::la_cungr2</a> (m, n, k, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:ab93ffb5580247aaa58614698f5865194"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGR2: generates an m by n complex matrix Q with orthonormal rows, which is defined as the last m rows of a product of k elementary reflectors of order n Q = H(1)**H H(2)**H . . . H(k)**H as returned by CGERQF.  <br /></td></tr>
<tr class="separator:ab93ffb5580247aaa58614698f5865194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a0a10d2180b55055c0c2795c34548f" id="r_a56a0a10d2180b55055c0c2795c34548f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a56a0a10d2180b55055c0c2795c34548f">la_lapack_c::la_cungrq</a> (m, n, k, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a56a0a10d2180b55055c0c2795c34548f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGRQ: generates an M-by-N complex matrix Q with orthonormal rows, which is defined as the last M rows of a product of K elementary reflectors of order N Q = H(1)**H H(2)**H . . . H(k)**H as returned by CGERQF.  <br /></td></tr>
<tr class="separator:a56a0a10d2180b55055c0c2795c34548f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c82b8817da346301c72fa4dfc15958" id="r_af1c82b8817da346301c72fa4dfc15958"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af1c82b8817da346301c72fa4dfc15958">la_lapack_c::la_cungtsqr_row</a> (m, n, mb, nb, a, lda, t, ldt, work, lwork, info)</td></tr>
<tr class="memdesc:af1c82b8817da346301c72fa4dfc15958"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGTSQR_ROW: generates an M-by-N complex matrix Q_out with orthonormal columns from the output of CLATSQR. These N orthonormal columns are the first N columns of a product of complex unitary matrices Q(k)_in of order M, which are returned by CLATSQR in a special format. Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ). The input matrices Q(k)_in are stored in row and column blocks in A. See the documentation of CLATSQR for more details on the format of Q(k)_in, where each Q(k)_in is represented by block Householder transformations. This routine calls an auxiliary routine CLARFB_GETT, where the computation is performed on each individual block. The algorithm first sweeps NB-sized column blocks from the right to left starting in the bottom row block and continues to the top row block (hence _ROW in the routine name). This sweep is in reverse order of the order in which CLATSQR generates the output blocks.  <br /></td></tr>
<tr class="separator:af1c82b8817da346301c72fa4dfc15958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee709ad1ca2b5f2abb2e20054feb5502" id="r_aee709ad1ca2b5f2abb2e20054feb5502"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aee709ad1ca2b5f2abb2e20054feb5502">la_lapack_c::la_cunm22</a> (side, trans, m, n, n1, n2, q, ldq, c, ldc, work, lwork, info)</td></tr>
<tr class="separator:aee709ad1ca2b5f2abb2e20054feb5502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4741ba4c44491c3c3abba8eaa2d4e122" id="r_a4741ba4c44491c3c3abba8eaa2d4e122"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4741ba4c44491c3c3abba8eaa2d4e122">la_lapack_c::la_cunm2l</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:a4741ba4c44491c3c3abba8eaa2d4e122"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNM2L: overwrites the general complex m-by-n matrix C with Q * C if SIDE = 'L' and TRANS = 'N', or Q**H* C if SIDE = 'L' and TRANS = 'C', or C * Q if SIDE = 'R' and TRANS = 'N', or C * Q**H if SIDE = 'R' and TRANS = 'C', where Q is a complex unitary matrix defined as the product of k elementary reflectors Q = H(k) . . . H(2) H(1) as returned by CGEQLF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a4741ba4c44491c3c3abba8eaa2d4e122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81952ea8a98e95d223cf55dbaefa51ce" id="r_a81952ea8a98e95d223cf55dbaefa51ce"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a81952ea8a98e95d223cf55dbaefa51ce">la_lapack_c::la_cunm2r</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:a81952ea8a98e95d223cf55dbaefa51ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNM2R: overwrites the general complex m-by-n matrix C with Q * C if SIDE = 'L' and TRANS = 'N', or Q**H* C if SIDE = 'L' and TRANS = 'C', or C * Q if SIDE = 'R' and TRANS = 'N', or C * Q**H if SIDE = 'R' and TRANS = 'C', where Q is a complex unitary matrix defined as the product of k elementary reflectors Q = H(1) H(2) . . . H(k) as returned by CGEQRF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a81952ea8a98e95d223cf55dbaefa51ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af24fb8200228e31b69f6d450071383" id="r_a1af24fb8200228e31b69f6d450071383"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1af24fb8200228e31b69f6d450071383">la_lapack_c::la_cunml2</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:a1af24fb8200228e31b69f6d450071383"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNML2: overwrites the general complex m-by-n matrix C with Q * C if SIDE = 'L' and TRANS = 'N', or Q**H* C if SIDE = 'L' and TRANS = 'C', or C * Q if SIDE = 'R' and TRANS = 'N', or C * Q**H if SIDE = 'R' and TRANS = 'C', where Q is a complex unitary matrix defined as the product of k elementary reflectors Q = H(k)**H . . . H(2)**H H(1)**H as returned by CGELQF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a1af24fb8200228e31b69f6d450071383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8791260472313c6582cb288031c9f735" id="r_a8791260472313c6582cb288031c9f735"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a8791260472313c6582cb288031c9f735">la_lapack_c::la_cunmlq</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a8791260472313c6582cb288031c9f735"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMLQ: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H where Q is a complex unitary matrix defined as the product of k elementary reflectors Q = H(k)**H . . . H(2)**H H(1)**H as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a8791260472313c6582cb288031c9f735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff2baf7ddb7105a535a1feedb24abcc" id="r_aaff2baf7ddb7105a535a1feedb24abcc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aaff2baf7ddb7105a535a1feedb24abcc">la_lapack_c::la_cunmql</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:aaff2baf7ddb7105a535a1feedb24abcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMQL: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H where Q is a complex unitary matrix defined as the product of k elementary reflectors Q = H(k) . . . H(2) H(1) as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:aaff2baf7ddb7105a535a1feedb24abcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64d6883152338ed7f59eb91e705ed37" id="r_ac64d6883152338ed7f59eb91e705ed37"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac64d6883152338ed7f59eb91e705ed37">la_lapack_c::la_cunmqr</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:ac64d6883152338ed7f59eb91e705ed37"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMQR: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H where Q is a complex unitary matrix defined as the product of k elementary reflectors Q = H(1) H(2) . . . H(k) as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:ac64d6883152338ed7f59eb91e705ed37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2b869d63e9dd9f1c3377d26e62cebf" id="r_a6e2b869d63e9dd9f1c3377d26e62cebf"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6e2b869d63e9dd9f1c3377d26e62cebf">la_lapack_c::la_cunmr2</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:a6e2b869d63e9dd9f1c3377d26e62cebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMR2: overwrites the general complex m-by-n matrix C with Q * C if SIDE = 'L' and TRANS = 'N', or Q**H* C if SIDE = 'L' and TRANS = 'C', or C * Q if SIDE = 'R' and TRANS = 'N', or C * Q**H if SIDE = 'R' and TRANS = 'C', where Q is a complex unitary matrix defined as the product of k elementary reflectors Q = H(1)**H H(2)**H . . . H(k)**H as returned by CGERQF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a6e2b869d63e9dd9f1c3377d26e62cebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8364e144ef1508e88e466ad58cb4285" id="r_ac8364e144ef1508e88e466ad58cb4285"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac8364e144ef1508e88e466ad58cb4285">la_lapack_c::la_cunmr3</a> (side, trans, m, n, k, l, a, lda, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:ac8364e144ef1508e88e466ad58cb4285"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMR3: overwrites the general complex m by n matrix C with Q * C if SIDE = 'L' and TRANS = 'N', or Q**H* C if SIDE = 'L' and TRANS = 'C', or C * Q if SIDE = 'R' and TRANS = 'N', or C * Q**H if SIDE = 'R' and TRANS = 'C', where Q is a complex unitary matrix defined as the product of k elementary reflectors Q = H(1) H(2) . . . H(k) as returned by CTZRZF. Q is of order m if SIDE = 'L' and of order n if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:ac8364e144ef1508e88e466ad58cb4285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0599c126166274ae8702a42d2a0a81d7" id="r_a0599c126166274ae8702a42d2a0a81d7"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0599c126166274ae8702a42d2a0a81d7">la_lapack_c::la_cunmrq</a> (side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a0599c126166274ae8702a42d2a0a81d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMRQ: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H where Q is a complex unitary matrix defined as the product of k elementary reflectors Q = H(1)**H H(2)**H . . . H(k)**H as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a0599c126166274ae8702a42d2a0a81d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ac1f6e042b52f085cb2891a22deb69" id="r_a62ac1f6e042b52f085cb2891a22deb69"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a62ac1f6e042b52f085cb2891a22deb69">la_lapack_c::la_cunmrz</a> (side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a62ac1f6e042b52f085cb2891a22deb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMRZ: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H where Q is a complex unitary matrix defined as the product of k elementary reflectors Q = H(1) H(2) . . . H(k) as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a62ac1f6e042b52f085cb2891a22deb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af919ce7c1baa9cd4ea2d24edd71f1d3b" id="r_af919ce7c1baa9cd4ea2d24edd71f1d3b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af919ce7c1baa9cd4ea2d24edd71f1d3b">la_lapack_c::la_cbbcsd</a> (jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork, info)</td></tr>
<tr class="memdesc:af919ce7c1baa9cd4ea2d24edd71f1d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBBCSD: computes the CS decomposition of a unitary matrix in bidiagonal-block form, [ B11 | B12 0 0 ] [ 0 | 0 -I 0 ] X = [-------------&mdash;] [ B21 | B22 0 0 ] [ 0 | 0 0 I ] [ C | -S 0 0 ] [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**H = [------&mdash;] [------------&mdash;] [------&mdash;] . [ | U2 ] [ S | C 0 0 ] [ | V2 ] [ 0 | 0 0 I ] X is M-by-M, its top-left block is P-by-Q, and Q must be no larger than P, M-P, or M-Q. (If Q is not the smallest index, then X must be transposed and/or permuted. This can be done in constant time using the TRANS and SIGNS options. See CUNCSD for details.) The bidiagonal matrices B11, B12, B21, and B22 are represented implicitly by angles THETA(1:Q) and PHI(1:Q-1). The unitary matrices U1, U2, V1T, and V2T are input/output. The input matrices are pre- or post-multiplied by the appropriate singular vector matrices.  <br /></td></tr>
<tr class="separator:af919ce7c1baa9cd4ea2d24edd71f1d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93eebde10e6b76c4f9ed4ba4ca885a59" id="r_a93eebde10e6b76c4f9ed4ba4ca885a59"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a93eebde10e6b76c4f9ed4ba4ca885a59">la_lapack_c::la_cbdsqr</a> (uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, rwork, info)</td></tr>
<tr class="memdesc:a93eebde10e6b76c4f9ed4ba4ca885a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBDSQR: computes the singular values and, optionally, the right and/or left singular vectors from the singular value decomposition (SVD) of a real N-by-N (upper or lower) bidiagonal matrix B using the implicit zero-shift QR algorithm. The SVD of B has the form B = Q * S * P**H where S is the diagonal matrix of singular values, Q is an orthogonal matrix of left singular vectors, and P is an orthogonal matrix of right singular vectors. If left singular vectors are requested, this subroutine actually returns U*Q instead of Q, and, if right singular vectors are requested, this subroutine returns P**H*VT instead of P**H, for given complex input matrices U and VT. When U and VT are the unitary matrices that reduce a general matrix A to bidiagonal form: A = U*B*VT, as computed by CGEBRD, then A = (U*Q) * S * (P**H*VT) is the SVD of A. Optionally, the subroutine may also compute Q**H*C for a given complex input matrix C. See "Computing  Small Singular Values of Bidiagonal Matrices With
Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan, LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11, no. 5, pp. 873-912, Sept 1990) and "Accurate singular values and differential qd algorithms," by B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics Department, University of California at Berkeley, July 1992 for a detailed description of the algorithm.  <br /></td></tr>
<tr class="separator:a93eebde10e6b76c4f9ed4ba4ca885a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad881c479c53f259b6159dc6b9f60d4ac" id="r_ad881c479c53f259b6159dc6b9f60d4ac"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad881c479c53f259b6159dc6b9f60d4ac">la_lapack_c::la_cgbcon</a> (norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork, info)</td></tr>
<tr class="memdesc:ad881c479c53f259b6159dc6b9f60d4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBCON: estimates the reciprocal of the condition number of a complex general band matrix A, in either the 1-norm or the infinity-norm, using the LU factorization computed by CGBTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).  <br /></td></tr>
<tr class="separator:ad881c479c53f259b6159dc6b9f60d4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2711b09340e5ae27755c4fc149b00eb9" id="r_a2711b09340e5ae27755c4fc149b00eb9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2711b09340e5ae27755c4fc149b00eb9">la_lapack_c::la_cgbtrf</a> (m, n, kl, ku, ab, ldab, ipiv, info)</td></tr>
<tr class="memdesc:a2711b09340e5ae27755c4fc149b00eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBTRF: computes an LU factorization of a complex m-by-n band matrix A using partial pivoting with row interchanges. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a2711b09340e5ae27755c4fc149b00eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2667c260721a9614eecb5b11642bb4" id="r_a0d2667c260721a9614eecb5b11642bb4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0d2667c260721a9614eecb5b11642bb4">la_lapack_c::la_cgbtrs</a> (trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a0d2667c260721a9614eecb5b11642bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBTRS: solves a system of linear equations A * X = B, A**T * X = B, or A**H * X = B with a general band matrix A using the LU factorization computed by CGBTRF.  <br /></td></tr>
<tr class="separator:a0d2667c260721a9614eecb5b11642bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab3877d3e8ee5c4a986693b61cb9eea" id="r_aeab3877d3e8ee5c4a986693b61cb9eea"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aeab3877d3e8ee5c4a986693b61cb9eea">la_lapack_c::la_cgebd2</a> (m, n, a, lda, d, e, tauq, taup, work, info)</td></tr>
<tr class="memdesc:aeab3877d3e8ee5c4a986693b61cb9eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEBD2: reduces a complex general m by n matrix A to upper or lower real bidiagonal form B by a unitary transformation: Q**H * A * P = B. If m &gt;= n, B is upper bidiagonal; if m &lt; n, B is lower bidiagonal.  <br /></td></tr>
<tr class="separator:aeab3877d3e8ee5c4a986693b61cb9eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f907eeec39052ce50d85eeef41fe3" id="r_ab80f907eeec39052ce50d85eeef41fe3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab80f907eeec39052ce50d85eeef41fe3">la_lapack_c::la_cgecon</a> (norm, n, a, lda, anorm, rcond, work, rwork, info)</td></tr>
<tr class="memdesc:ab80f907eeec39052ce50d85eeef41fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGECON: estimates the reciprocal of the condition number of a general complex matrix A, in either the 1-norm or the infinity-norm, using the LU factorization computed by CGETRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).  <br /></td></tr>
<tr class="separator:ab80f907eeec39052ce50d85eeef41fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd847f8b4547ddf76ecf448b7dbda8a" id="r_aadd847f8b4547ddf76ecf448b7dbda8a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aadd847f8b4547ddf76ecf448b7dbda8a">la_lapack_c::la_cgehd2</a> (n, ilo, ihi, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:aadd847f8b4547ddf76ecf448b7dbda8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEHD2: reduces a complex general matrix A to upper Hessenberg form H by a unitary similarity transformation: Q**H * A * Q = H .  <br /></td></tr>
<tr class="separator:aadd847f8b4547ddf76ecf448b7dbda8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cbd72e182ed59a64ff37818fa150f1" id="r_a31cbd72e182ed59a64ff37818fa150f1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a31cbd72e182ed59a64ff37818fa150f1">la_lapack_c::la_cgelq2</a> (m, n, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a31cbd72e182ed59a64ff37818fa150f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGELQ2: computes an LQ factorization of a complex m-by-n matrix A: A = ( L 0 ) * Q where: Q is a n-by-n orthogonal matrix; L is a lower-triangular m-by-m matrix; 0 is a m-by-(n-m) zero matrix, if m &lt; n.  <br /></td></tr>
<tr class="separator:a31cbd72e182ed59a64ff37818fa150f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472cb4d159d0248cce4945485d371f29" id="r_a472cb4d159d0248cce4945485d371f29"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a472cb4d159d0248cce4945485d371f29">la_lapack_c::la_cgelqf</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a472cb4d159d0248cce4945485d371f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGELQF: computes an LQ factorization of a complex M-by-N matrix A: A = ( L 0 ) * Q where: Q is a N-by-N orthogonal matrix; L is a lower-triangular M-by-M matrix; 0 is a M-by-(N-M) zero matrix, if M &lt; N.  <br /></td></tr>
<tr class="separator:a472cb4d159d0248cce4945485d371f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72a76e99120ce0ccce5f00b7ff234a0" id="r_ad72a76e99120ce0ccce5f00b7ff234a0"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad72a76e99120ce0ccce5f00b7ff234a0">la_lapack_c::la_cgelqt3</a> (m, n, a, lda, t, ldt, info)</td></tr>
<tr class="memdesc:ad72a76e99120ce0ccce5f00b7ff234a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGELQT3: recursively computes a LQ factorization of a complex M-by-N matrix A, using the compact WY representation of Q. Based on the algorithm of Elmroth and Gustavson, IBM J. Res. Develop. Vol 44 No. 4 July 2000.  <br /></td></tr>
<tr class="separator:ad72a76e99120ce0ccce5f00b7ff234a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b7c1700080844b0c2ad2b8b83c2529" id="r_a15b7c1700080844b0c2ad2b8b83c2529"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a15b7c1700080844b0c2ad2b8b83c2529">la_lapack_c::la_cgemlqt</a> (side, trans, m, n, k, mb, v, ldv, t, ldt, c, ldc, work, info)</td></tr>
<tr class="memdesc:a15b7c1700080844b0c2ad2b8b83c2529"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEMLQT: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q C C Q TRANS = 'C': Q**H C C Q**H where Q is a complex unitary matrix defined as the product of K elementary reflectors: Q = H(1) H(2) . . . H(K) = I - V T V**H generated using the compact WY representation as returned by CGELQT. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:a15b7c1700080844b0c2ad2b8b83c2529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99e1c6fefe0379006986f34b431bcd9" id="r_ae99e1c6fefe0379006986f34b431bcd9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae99e1c6fefe0379006986f34b431bcd9">la_lapack_c::la_cgemqrt</a> (side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work, info)</td></tr>
<tr class="memdesc:ae99e1c6fefe0379006986f34b431bcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEMQRT: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q C C Q TRANS = 'C': Q**H C C Q**H where Q is a complex orthogonal matrix defined as the product of K elementary reflectors: Q = H(1) H(2) . . . H(K) = I - V T V**H generated using the compact WY representation as returned by CGEQRT. Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.  <br /></td></tr>
<tr class="separator:ae99e1c6fefe0379006986f34b431bcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467695c7089f0e5cd3e9a7b88b815e2a" id="r_a467695c7089f0e5cd3e9a7b88b815e2a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a467695c7089f0e5cd3e9a7b88b815e2a">la_lapack_c::la_cgeql2</a> (m, n, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a467695c7089f0e5cd3e9a7b88b815e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQL2: computes a QL factorization of a complex m by n matrix A: A = Q * L.  <br /></td></tr>
<tr class="separator:a467695c7089f0e5cd3e9a7b88b815e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fe7bfadef6924c88de36978b1dbea7" id="r_a52fe7bfadef6924c88de36978b1dbea7"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a52fe7bfadef6924c88de36978b1dbea7">la_lapack_c::la_cgeqlf</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a52fe7bfadef6924c88de36978b1dbea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQLF: computes a QL factorization of a complex M-by-N matrix A: A = Q * L.  <br /></td></tr>
<tr class="separator:a52fe7bfadef6924c88de36978b1dbea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2e42f853f95a631303cbf93732a012" id="r_acf2e42f853f95a631303cbf93732a012"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#acf2e42f853f95a631303cbf93732a012">la_lapack_c::la_cgeqr2</a> (m, n, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:acf2e42f853f95a631303cbf93732a012"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQR2: computes a QR factorization of a complex m-by-n matrix A: A = Q * ( R ), ( 0 ) where: Q is a m-by-m orthogonal matrix; R is an upper-triangular n-by-n matrix; 0 is a (m-n)-by-n zero matrix, if m &gt; n.  <br /></td></tr>
<tr class="separator:acf2e42f853f95a631303cbf93732a012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe783bd63b77fdda46f5f1c44ab8623" id="r_a3fe783bd63b77fdda46f5f1c44ab8623"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a3fe783bd63b77fdda46f5f1c44ab8623">la_lapack_c::la_cgeqr2p</a> (m, n, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a3fe783bd63b77fdda46f5f1c44ab8623"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQR2P: computes a QR factorization of a complex m-by-n matrix A: A = Q * ( R ), ( 0 ) where: Q is a m-by-m orthogonal matrix; R is an upper-triangular n-by-n matrix with nonnegative diagonal entries; 0 is a (m-n)-by-n zero matrix, if m &gt; n.  <br /></td></tr>
<tr class="separator:a3fe783bd63b77fdda46f5f1c44ab8623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e8089e813cfbd07a3b01c1baf00696" id="r_a34e8089e813cfbd07a3b01c1baf00696"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a34e8089e813cfbd07a3b01c1baf00696">la_lapack_c::la_cgeqrf</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a34e8089e813cfbd07a3b01c1baf00696"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQRF: computes a QR factorization of a complex M-by-N matrix A: A = Q * ( R ), ( 0 ) where: Q is a M-by-M orthogonal matrix; R is an upper-triangular N-by-N matrix; 0 is a (M-N)-by-N zero matrix, if M &gt; N.  <br /></td></tr>
<tr class="separator:a34e8089e813cfbd07a3b01c1baf00696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62930357a71265e65c6a55b47c575e81" id="r_a62930357a71265e65c6a55b47c575e81"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a62930357a71265e65c6a55b47c575e81">la_lapack_c::la_cgeqrfp</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a62930357a71265e65c6a55b47c575e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQR2P computes a QR factorization of a complex M-by-N matrix A: A = Q * ( R ), ( 0 ) where: Q is a M-by-M orthogonal matrix; R is an upper-triangular N-by-N matrix with nonnegative diagonal entries; 0 is a (M-N)-by-N zero matrix, if M &gt; N.  <br /></td></tr>
<tr class="separator:a62930357a71265e65c6a55b47c575e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac330a97d77a921e62714b3a09ae09161" id="r_ac330a97d77a921e62714b3a09ae09161"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac330a97d77a921e62714b3a09ae09161">la_lapack_c::la_cgeqrt2</a> (m, n, a, lda, t, ldt, info)</td></tr>
<tr class="memdesc:ac330a97d77a921e62714b3a09ae09161"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQRT2: computes a QR factorization of a complex M-by-N matrix A, using the compact WY representation of Q.  <br /></td></tr>
<tr class="separator:ac330a97d77a921e62714b3a09ae09161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ffd82d7d87d6ed0e286a54992c71ca" id="r_ab3ffd82d7d87d6ed0e286a54992c71ca"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab3ffd82d7d87d6ed0e286a54992c71ca">la_lapack_c::la_cgeqrt3</a> (m, n, a, lda, t, ldt, info)</td></tr>
<tr class="memdesc:ab3ffd82d7d87d6ed0e286a54992c71ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQRT3: recursively computes a QR factorization of a complex M-by-N matrix A, using the compact WY representation of Q. Based on the algorithm of Elmroth and Gustavson, IBM J. Res. Develop. Vol 44 No. 4 July 2000.  <br /></td></tr>
<tr class="separator:ab3ffd82d7d87d6ed0e286a54992c71ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b582b82d6c86b98bafe2fbba8c41bfa" id="r_a9b582b82d6c86b98bafe2fbba8c41bfa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9b582b82d6c86b98bafe2fbba8c41bfa">la_lapack_c::la_cgerq2</a> (m, n, a, lda, tau, work, info)</td></tr>
<tr class="memdesc:a9b582b82d6c86b98bafe2fbba8c41bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGERQ2: computes an RQ factorization of a complex m by n matrix A: A = R * Q.  <br /></td></tr>
<tr class="separator:a9b582b82d6c86b98bafe2fbba8c41bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b0c068fad17dc5d625c20ca613a1b8" id="r_a22b0c068fad17dc5d625c20ca613a1b8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a22b0c068fad17dc5d625c20ca613a1b8">la_lapack_c::la_cgerqf</a> (m, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a22b0c068fad17dc5d625c20ca613a1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGERQF: computes an RQ factorization of a complex M-by-N matrix A: A = R * Q.  <br /></td></tr>
<tr class="separator:a22b0c068fad17dc5d625c20ca613a1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fb3e75e901afea8ddd6f1b9a43ff37" id="r_a17fb3e75e901afea8ddd6f1b9a43ff37"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a17fb3e75e901afea8ddd6f1b9a43ff37">la_lapack_c::la_cgesc2</a> (n, a, lda, rhs, ipiv, jpiv, scale)</td></tr>
<tr class="memdesc:a17fb3e75e901afea8ddd6f1b9a43ff37"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGESC2: solves a system of linear equations A * X = scale* RHS with a general N-by-N matrix A using the LU factorization with complete pivoting computed by CGETC2.  <br /></td></tr>
<tr class="separator:a17fb3e75e901afea8ddd6f1b9a43ff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f203e3c342fda2984dc2c691e135f1" id="r_a61f203e3c342fda2984dc2c691e135f1"><td class="memItemLeft" align="right" valign="top">pure recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a61f203e3c342fda2984dc2c691e135f1">la_lapack_c::la_cgetrf2</a> (m, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:a61f203e3c342fda2984dc2c691e135f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETRF2: computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n). This is the recursive version of the algorithm. It divides the matrix into four submatrices: [ A11 | A12 ] where A11 is n1 by n1 and A22 is n2 by n2 A = [ --&mdash;|--&mdash; ] with n1 = min(m,n)/2 [ A21 | A22 ] n2 = n-n1 [ A11 ] The subroutine calls itself to factor [ &mdash; ], [ A12 ] [ A12 ] do the swaps on [ &mdash; ], solve A12, update A22, [ A22 ] then calls itself to factor A22 and do the swaps on A21.  <br /></td></tr>
<tr class="separator:a61f203e3c342fda2984dc2c691e135f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2612bd6fb1df36f7d72d688327b4d69" id="r_ae2612bd6fb1df36f7d72d688327b4d69"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae2612bd6fb1df36f7d72d688327b4d69">la_lapack_c::la_cgetri</a> (n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:ae2612bd6fb1df36f7d72d688327b4d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETRI: computes the inverse of a matrix using the LU factorization computed by CGETRF. This method inverts U and then computes inv(A) by solving the system inv(A)*L = inv(U) for inv(A).  <br /></td></tr>
<tr class="separator:ae2612bd6fb1df36f7d72d688327b4d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bb959e94a4e9fa33455a0e3682775b" id="r_ab1bb959e94a4e9fa33455a0e3682775b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab1bb959e94a4e9fa33455a0e3682775b">la_lapack_c::la_cgetrs</a> (trans, n, nrhs, a, lda, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:ab1bb959e94a4e9fa33455a0e3682775b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETRS: solves a system of linear equations A * X = B, A**T * X = B, or A**H * X = B with a general N-by-N matrix A using the LU factorization computed by CGETRF.  <br /></td></tr>
<tr class="separator:ab1bb959e94a4e9fa33455a0e3682775b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1737f01392a5b5daa89512db4039d666" id="r_a1737f01392a5b5daa89512db4039d666"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1737f01392a5b5daa89512db4039d666">la_lapack_c::la_cgghrd</a> (compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, info)</td></tr>
<tr class="memdesc:a1737f01392a5b5daa89512db4039d666"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGHRD: reduces a pair of complex matrices (A,B) to generalized upper Hessenberg form using unitary transformations, where A is a general matrix and B is upper triangular. The form of the generalized eigenvalue problem is A*x = lambda*B*x, and B is typically made upper triangular by computing its QR factorization and moving the unitary matrix Q to the left side of the equation. This subroutine simultaneously reduces A to a Hessenberg matrix H: Q**H*A*Z = H and transforms B to another upper triangular matrix T: Q**H*B*Z = T in order to reduce the problem to its standard form H*y = lambda*T*y where y = Z**H*x. The unitary matrices Q and Z are determined as products of Givens rotations. They may either be formed explicitly, or they may be postmultiplied into input matrices Q1 and Z1, so that Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H If Q1 is the unitary matrix from the QR factorization of B in the original equation A*x = lambda*B*x, then CGGHRD reduces the original problem to generalized Hessenberg form.  <br /></td></tr>
<tr class="separator:a1737f01392a5b5daa89512db4039d666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820d5bad45535edc35d396a4bb50b234" id="r_a820d5bad45535edc35d396a4bb50b234"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a820d5bad45535edc35d396a4bb50b234">la_lapack_c::la_cggqrf</a> (n, m, p, a, lda, taua, b, ldb, taub, work, lwork, info)</td></tr>
<tr class="memdesc:a820d5bad45535edc35d396a4bb50b234"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGQRF: computes a generalized QR factorization of an N-by-M matrix A and an N-by-P matrix B: A = Q*R, B = Q*T*Z, where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix, and R and T assume one of the forms: if N &gt;= M, R = ( R11 ) M , or if N &lt; M, R = ( R11 R12 ) N, ( 0 ) N-M N M-N M where R11 is upper triangular, and if N &lt;= P, T = ( 0 T12 ) N, or if N &gt; P, T = ( T11 ) N-P, P-N N ( T21 ) P P where T12 or T21 is upper triangular. In particular, if B is square and nonsingular, the GQR factorization of A and B implicitly gives the QR factorization of inv(B)*A: inv(B)*A = Z**H * (inv(T)*R) where inv(B) denotes the inverse of the matrix B, and Z' denotes the conjugate transpose of matrix Z.  <br /></td></tr>
<tr class="separator:a820d5bad45535edc35d396a4bb50b234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbd383743d74cde67cfe18afe8b166b" id="r_a2bbd383743d74cde67cfe18afe8b166b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2bbd383743d74cde67cfe18afe8b166b">la_lapack_c::la_cggrqf</a> (m, p, n, a, lda, taua, b, ldb, taub, work, lwork, info)</td></tr>
<tr class="memdesc:a2bbd383743d74cde67cfe18afe8b166b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGRQF: computes a generalized RQ factorization of an M-by-N matrix A and a P-by-N matrix B: A = R*Q, B = Z*T*Q, where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix, and R and T assume one of the forms: if M &lt;= N, R = ( 0 R12 ) M, or if M &gt; N, R = ( R11 ) M-N, N-M M ( R21 ) N N where R12 or R21 is upper triangular, and if P &gt;= N, T = ( T11 ) N , or if P &lt; N, T = ( T11 T12 ) P, ( 0 ) P-N P N-P N where T11 is upper triangular. In particular, if B is square and nonsingular, the GRQ factorization of A and B implicitly gives the RQ factorization of A*inv(B): A*inv(B) = (R*inv(T))*Z**H where inv(B) denotes the inverse of the matrix B, and Z**H denotes the conjugate transpose of the matrix Z.  <br /></td></tr>
<tr class="separator:a2bbd383743d74cde67cfe18afe8b166b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a20377574b6f6e774072f2236a28e41" id="r_a9a20377574b6f6e774072f2236a28e41"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9a20377574b6f6e774072f2236a28e41">la_lapack_c::la_cgttrs</a> (trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a9a20377574b6f6e774072f2236a28e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGTTRS: solves one of the systems of equations A * X = B, A**T * X = B, or A**H * X = B, with a tridiagonal matrix A using the LU factorization computed by CGTTRF.  <br /></td></tr>
<tr class="separator:a9a20377574b6f6e774072f2236a28e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d7429d9af7ce422ae8861b590273c6" id="r_ac3d7429d9af7ce422ae8861b590273c6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac3d7429d9af7ce422ae8861b590273c6">la_lapack_c::la_chb2st_kernels</a> (uplo, wantz, ttype, st, ed, sweep, n, nb, ib, a, lda, v, tau, ldvt, work)</td></tr>
<tr class="memdesc:ac3d7429d9af7ce422ae8861b590273c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHB2ST_KERNELS: is an internal routine used by the CHETRD_HB2ST subroutine.  <br /></td></tr>
<tr class="separator:ac3d7429d9af7ce422ae8861b590273c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0bd415668ce4f6afe55c4c0eee8d7f" id="r_a4b0bd415668ce4f6afe55c4c0eee8d7f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4b0bd415668ce4f6afe55c4c0eee8d7f">la_lapack_c::la_cheequb</a> (uplo, n, a, lda, s, scond, amax, work, info)</td></tr>
<tr class="memdesc:a4b0bd415668ce4f6afe55c4c0eee8d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEEQUB: computes row and column scalings intended to equilibrate a Hermitian matrix A (with respect to the Euclidean norm) and reduce its condition number. The scale factors S are computed by the BIN algorithm (see references) so that the scaled matrix B with elements B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of the smallest possible condition number over all possible diagonal scalings.  <br /></td></tr>
<tr class="separator:a4b0bd415668ce4f6afe55c4c0eee8d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18d7aa56cbbeb53daa47070dd960362" id="r_ac18d7aa56cbbeb53daa47070dd960362"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac18d7aa56cbbeb53daa47070dd960362">la_lapack_c::la_chegs2</a> (itype, uplo, n, a, lda, b, ldb, info)</td></tr>
<tr class="memdesc:ac18d7aa56cbbeb53daa47070dd960362"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEGS2: reduces a complex Hermitian-definite generalized eigenproblem to standard form. If ITYPE = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H) If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H *A*L. B must have been previously factorized as U**H *U or L*L**H by ZPOTRF.  <br /></td></tr>
<tr class="separator:ac18d7aa56cbbeb53daa47070dd960362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae0beec2c03169fd2600688a6738451" id="r_adae0beec2c03169fd2600688a6738451"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#adae0beec2c03169fd2600688a6738451">la_lapack_c::la_chegst</a> (itype, uplo, n, a, lda, b, ldb, info)</td></tr>
<tr class="memdesc:adae0beec2c03169fd2600688a6738451"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEGST: reduces a complex Hermitian-definite generalized eigenproblem to standard form. If ITYPE = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H) If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L. B must have been previously factorized as U**H*U or L*L**H by CPOTRF.  <br /></td></tr>
<tr class="separator:adae0beec2c03169fd2600688a6738451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab559f084c2ee55e4f6dc2e4e27c0715f" id="r_ab559f084c2ee55e4f6dc2e4e27c0715f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab559f084c2ee55e4f6dc2e4e27c0715f">la_lapack_c::la_chetd2</a> (uplo, n, a, lda, d, e, tau, info)</td></tr>
<tr class="memdesc:ab559f084c2ee55e4f6dc2e4e27c0715f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETD2: reduces a complex Hermitian matrix A to real symmetric tridiagonal form T by a unitary similarity transformation: Q**H * A * Q = T.  <br /></td></tr>
<tr class="separator:ab559f084c2ee55e4f6dc2e4e27c0715f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8d64a35e51b6db8be259fd6c5e2ce2" id="r_a9a8d64a35e51b6db8be259fd6c5e2ce2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9a8d64a35e51b6db8be259fd6c5e2ce2">la_lapack_c::la_chetrd</a> (uplo, n, a, lda, d, e, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a9a8d64a35e51b6db8be259fd6c5e2ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRD: reduces a complex Hermitian matrix A to real symmetric tridiagonal form T by a unitary similarity transformation: Q**H * A * Q = T.  <br /></td></tr>
<tr class="separator:a9a8d64a35e51b6db8be259fd6c5e2ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6792d953313a357ae3c8765a4e1c0be" id="r_af6792d953313a357ae3c8765a4e1c0be"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af6792d953313a357ae3c8765a4e1c0be">la_lapack_c::la_chetrd_hb2st</a> (stage1, vect, uplo, n, kd, ab, ldab, d, e, hous, lhous, work, lwork, info)</td></tr>
<tr class="memdesc:af6792d953313a357ae3c8765a4e1c0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRD_HB2ST: reduces a complex Hermitian band matrix A to real symmetric tridiagonal form T by a unitary similarity transformation: Q**H * A * Q = T.  <br /></td></tr>
<tr class="separator:af6792d953313a357ae3c8765a4e1c0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd34fc432dd4fc6e235587e23145dc8a" id="r_abd34fc432dd4fc6e235587e23145dc8a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abd34fc432dd4fc6e235587e23145dc8a">la_lapack_c::la_chetrd_he2hb</a> (uplo, n, kd, a, lda, ab, ldab, tau, work, lwork, info)</td></tr>
<tr class="memdesc:abd34fc432dd4fc6e235587e23145dc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRD_HE2HB: reduces a complex Hermitian matrix A to complex Hermitian band-diagonal form AB by a unitary similarity transformation: Q**H * A * Q = AB.  <br /></td></tr>
<tr class="separator:abd34fc432dd4fc6e235587e23145dc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeff35b37c5c9a58cc03e6c625134397" id="r_adeff35b37c5c9a58cc03e6c625134397"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#adeff35b37c5c9a58cc03e6c625134397">la_lapack_c::la_chetrf</a> (uplo, n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:adeff35b37c5c9a58cc03e6c625134397"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRF: computes the factorization of a complex Hermitian matrix A using the Bunch-Kaufman diagonal pivoting method. The form of the factorization is A = U*D*U**H or A = L*D*L**H where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:adeff35b37c5c9a58cc03e6c625134397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbc1d30fd2d8d987392be8ea228d417" id="r_a9cbc1d30fd2d8d987392be8ea228d417"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9cbc1d30fd2d8d987392be8ea228d417">la_lapack_c::la_chetrf_rk</a> (uplo, n, a, lda, e, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:a9cbc1d30fd2d8d987392be8ea228d417"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRF_RK: computes the factorization of a complex Hermitian matrix A using the bounded Bunch-Kaufman (rook) diagonal pivoting method: A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T), where U (or L) is unit upper (or lower) triangular matrix, U**H (or L**H) is the conjugate of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the blocked version of the algorithm, calling Level 3 BLAS. For more information see Further Details section.  <br /></td></tr>
<tr class="separator:a9cbc1d30fd2d8d987392be8ea228d417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1502415a417dbe1c4a8f34d6a107ac90" id="r_a1502415a417dbe1c4a8f34d6a107ac90"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1502415a417dbe1c4a8f34d6a107ac90">la_lapack_c::la_chetrf_rook</a> (uplo, n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:a1502415a417dbe1c4a8f34d6a107ac90"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRF_ROOK: computes the factorization of a complex Hermitian matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method. The form of the factorization is A = U*D*U**T or A = L*D*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a1502415a417dbe1c4a8f34d6a107ac90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f534fdae83f457f86f2c8db87986fb9" id="r_a8f534fdae83f457f86f2c8db87986fb9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a8f534fdae83f457f86f2c8db87986fb9">la_lapack_c::la_chetrs</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a8f534fdae83f457f86f2c8db87986fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRS: solves a system of linear equations A*X = B with a complex Hermitian matrix A using the factorization A = U*D*U**H or A = L*D*L**H computed by CHETRF.  <br /></td></tr>
<tr class="separator:a8f534fdae83f457f86f2c8db87986fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe24d223977b5faedfe6b3277ff420f2" id="r_abe24d223977b5faedfe6b3277ff420f2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abe24d223977b5faedfe6b3277ff420f2">la_lapack_c::la_chetrs2</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, info)</td></tr>
<tr class="memdesc:abe24d223977b5faedfe6b3277ff420f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRS2: solves a system of linear equations A*X = B with a complex Hermitian matrix A using the factorization A = U*D*U**H or A = L*D*L**H computed by CHETRF and converted by CSYCONV.  <br /></td></tr>
<tr class="separator:abe24d223977b5faedfe6b3277ff420f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67377761776e575add9ee840637c3469" id="r_a67377761776e575add9ee840637c3469"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a67377761776e575add9ee840637c3469">la_lapack_c::la_chetrs_aa</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a67377761776e575add9ee840637c3469"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRS_AA: solves a system of linear equations A*X = B with a complex hermitian matrix A using the factorization A = U**H*T*U or A = L*T*L**H computed by CHETRF_AA.  <br /></td></tr>
<tr class="separator:a67377761776e575add9ee840637c3469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4b31e876fc730b896387a5e0155ed2" id="r_aed4b31e876fc730b896387a5e0155ed2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aed4b31e876fc730b896387a5e0155ed2">la_lapack_c::la_chetrs_rook</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:aed4b31e876fc730b896387a5e0155ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRS_ROOK: solves a system of linear equations A*X = B with a complex Hermitian matrix A using the factorization A = U*D*U**H or A = L*D*L**H computed by CHETRF_ROOK.  <br /></td></tr>
<tr class="separator:aed4b31e876fc730b896387a5e0155ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b0d28a3d24f3a02927604161b2f404" id="r_a98b0d28a3d24f3a02927604161b2f404"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a98b0d28a3d24f3a02927604161b2f404">la_lapack_c::la_chptrd</a> (uplo, n, ap, d, e, tau, info)</td></tr>
<tr class="memdesc:a98b0d28a3d24f3a02927604161b2f404"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPTRD: reduces a complex Hermitian matrix A stored in packed form to real symmetric tridiagonal form T by a unitary similarity transformation: Q**H * A * Q = T.  <br /></td></tr>
<tr class="separator:a98b0d28a3d24f3a02927604161b2f404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4e2558e0787b7ff2ca44ed71437ba1" id="r_a4c4e2558e0787b7ff2ca44ed71437ba1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4c4e2558e0787b7ff2ca44ed71437ba1">la_lapack_c::la_chptrs</a> (uplo, n, nrhs, ap, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a4c4e2558e0787b7ff2ca44ed71437ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPTRS: solves a system of linear equations A*X = B with a complex Hermitian matrix A stored in packed format using the factorization A = U*D*U**H or A = L*D*L**H computed by CHPTRF.  <br /></td></tr>
<tr class="separator:a4c4e2558e0787b7ff2ca44ed71437ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2180587b48f62a74c7e7c78de6191c" id="r_a9a2180587b48f62a74c7e7c78de6191c"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9a2180587b48f62a74c7e7c78de6191c">la_lapack_c::la_cla_gbrcond_c</a> (trans, n, kl, ku, ab, ldab, afb, ldafb, ipiv, c, capply, info, work, rwork)</td></tr>
<tr class="memdesc:a9a2180587b48f62a74c7e7c78de6191c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_GBRCOND_C: Computes the infinity norm condition number of op(A) * inv(diag(C)) where C is a REAL vector.  <br /></td></tr>
<tr class="separator:a9a2180587b48f62a74c7e7c78de6191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70862adc9c7f0e73e2cd654559d36df7" id="r_a70862adc9c7f0e73e2cd654559d36df7"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a70862adc9c7f0e73e2cd654559d36df7">la_lapack_c::la_cla_gercond_c</a> (trans, n, a, lda, af, ldaf, ipiv, c, capply, info, work, rwork)</td></tr>
<tr class="memdesc:a70862adc9c7f0e73e2cd654559d36df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_GERCOND_C: computes the infinity norm condition number of op(A) * inv(diag(C)) where C is a REAL vector.  <br /></td></tr>
<tr class="separator:a70862adc9c7f0e73e2cd654559d36df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df93ced08a26566de491e12633c9645" id="r_a3df93ced08a26566de491e12633c9645"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a3df93ced08a26566de491e12633c9645">la_lapack_c::la_cla_hercond_c</a> (uplo, n, a, lda, af, ldaf, ipiv, c, capply, info, work, rwork)</td></tr>
<tr class="memdesc:a3df93ced08a26566de491e12633c9645"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_HERCOND_C: computes the infinity norm condition number of op(A) * inv(diag(C)) where C is a REAL vector.  <br /></td></tr>
<tr class="separator:a3df93ced08a26566de491e12633c9645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04544098d624dda962393a489812ca0f" id="r_a04544098d624dda962393a489812ca0f"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a04544098d624dda962393a489812ca0f">la_lapack_c::la_cla_herpvgrw</a> (uplo, n, info, a, lda, af, ldaf, ipiv, work)</td></tr>
<tr class="memdesc:a04544098d624dda962393a489812ca0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_HERPVGRW: computes the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If this is much less than 1, the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, estimated condition numbers, and error bounds could be unreliable.  <br /></td></tr>
<tr class="separator:a04544098d624dda962393a489812ca0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cbb2c2a66691c573f62f9f8ea76f18" id="r_a67cbb2c2a66691c573f62f9f8ea76f18"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a67cbb2c2a66691c573f62f9f8ea76f18">la_lapack_c::la_cla_porcond_c</a> (uplo, n, a, lda, af, ldaf, c, capply, info, work, rwork)</td></tr>
<tr class="memdesc:a67cbb2c2a66691c573f62f9f8ea76f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_PORCOND_C: Computes the infinity norm condition number of op(A) * inv(diag(C)) where C is a REAL vector.  <br /></td></tr>
<tr class="separator:a67cbb2c2a66691c573f62f9f8ea76f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b0dbb3d1e8e43af6a5d72c7e35c357" id="r_a46b0dbb3d1e8e43af6a5d72c7e35c357"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a46b0dbb3d1e8e43af6a5d72c7e35c357">la_lapack_c::la_cla_syrcond_c</a> (uplo, n, a, lda, af, ldaf, ipiv, c, capply, info, work, rwork)</td></tr>
<tr class="memdesc:a46b0dbb3d1e8e43af6a5d72c7e35c357"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_SYRCOND_C: Computes the infinity norm condition number of op(A) * inv(diag(C)) where C is a REAL vector.  <br /></td></tr>
<tr class="separator:a46b0dbb3d1e8e43af6a5d72c7e35c357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d7669bb0f6dd97898a416111c5de97" id="r_af3d7669bb0f6dd97898a416111c5de97"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af3d7669bb0f6dd97898a416111c5de97">la_lapack_c::la_cla_syrpvgrw</a> (uplo, n, info, a, lda, af, ldaf, ipiv, work)</td></tr>
<tr class="memdesc:af3d7669bb0f6dd97898a416111c5de97"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLA_SYRPVGRW: computes the reciprocal pivot growth factor norm(A)/norm(U). The "max absolute element" norm is used. If this is much less than 1, the stability of the LU factorization of the (equilibrated) matrix A could be poor. This also means that the solution X, estimated condition numbers, and error bounds could be unreliable.  <br /></td></tr>
<tr class="separator:af3d7669bb0f6dd97898a416111c5de97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328f925f1e8af8830cac97ed35687bbf" id="r_a328f925f1e8af8830cac97ed35687bbf"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a328f925f1e8af8830cac97ed35687bbf">la_lapack_c::la_clabrd</a> (m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y, ldy)</td></tr>
<tr class="memdesc:a328f925f1e8af8830cac97ed35687bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLABRD: reduces the first NB rows and columns of a complex general m by n matrix A to upper or lower real bidiagonal form by a unitary transformation Q**H * A * P, and returns the matrices X and Y which are needed to apply the transformation to the unreduced part of A. If m &gt;= n, A is reduced to upper bidiagonal form; if m &lt; n, to lower bidiagonal form. This is an auxiliary routine called by CGEBRD.  <br /></td></tr>
<tr class="separator:a328f925f1e8af8830cac97ed35687bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d726bdb4d964771021bb92a264ebde" id="r_a53d726bdb4d964771021bb92a264ebde"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a53d726bdb4d964771021bb92a264ebde">la_lapack_c::la_claed7</a> (n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q, ldq, rho, indxq, qstore, qptr, prmptr, perm, givptr, givcol, givnum, work, rwork, iwork, info)</td></tr>
<tr class="memdesc:a53d726bdb4d964771021bb92a264ebde"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAED7: computes the updated eigensystem of a diagonal matrix after modification by a rank-one symmetric matrix. This routine is used only for the eigenproblem which requires all eigenvalues and optionally eigenvectors of a dense or banded Hermitian matrix that has been reduced to tridiagonal form. T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out) where Z = Q**Hu, u is a vector of length N with ones in the CUTPNT and CUTPNT + 1 th elements and zeros elsewhere. The eigenvectors of the original matrix are stored in Q, and the eigenvalues are in D. The algorithm consists of three stages: The first stage consists of deflating the size of the problem when there are multiple eigenvalues or if there is a zero in the Z vector. For each such occurrence the dimension of the secular equation problem is reduced by one. This stage is performed by the routine SLAED2. The second stage consists of calculating the updated eigenvalues. This is done by finding the roots of the secular equation via the routine SLAED4 (as called by SLAED3). This routine also calculates the eigenvectors of the current problem. The final stage consists of computing the updated eigenvectors directly using the updated eigenvalues. The eigenvectors for the current problem are multiplied with the eigenvectors from the overall problem.  <br /></td></tr>
<tr class="separator:a53d726bdb4d964771021bb92a264ebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af972a09d6b8a6ce9ac429c86aa4b0c55" id="r_af972a09d6b8a6ce9ac429c86aa4b0c55"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af972a09d6b8a6ce9ac429c86aa4b0c55">la_lapack_c::la_claein</a> (rightv, noinit, n, h, ldh, w, v, b, ldb, rwork, eps3, smlnum, info)</td></tr>
<tr class="memdesc:af972a09d6b8a6ce9ac429c86aa4b0c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAEIN: uses inverse iteration to find a right or left eigenvector corresponding to the eigenvalue W of a complex upper Hessenberg matrix H.  <br /></td></tr>
<tr class="separator:af972a09d6b8a6ce9ac429c86aa4b0c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810b9f487ce7de9b14045cfb7c0bd11c" id="r_a810b9f487ce7de9b14045cfb7c0bd11c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a810b9f487ce7de9b14045cfb7c0bd11c">la_lapack_c::la_clags2</a> (upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, snv, csq, snq)</td></tr>
<tr class="memdesc:a810b9f487ce7de9b14045cfb7c0bd11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAGS2: computes 2-by-2 unitary matrices U, V and Q, such that if ( UPPER ) then U**H *A*Q = U**H *( A1 A2 )*Q = ( x 0 ) ( 0 A3 ) ( x x ) and V**H*B*Q = V**H *( B1 B2 )*Q = ( x 0 ) ( 0 B3 ) ( x x ) or if ( .NOT.UPPER ) then U**H *A*Q = U**H *( A1 0 )*Q = ( x x ) ( A2 A3 ) ( 0 x ) and V**H *B*Q = V**H *( B1 0 )*Q = ( x x ) ( B2 B3 ) ( 0 x ) where U = ( CSU SNU ), V = ( CSV SNV ), ( -SNU**H CSU ) ( -SNV**H CSV ) Q = ( CSQ SNQ ) ( -SNQ**H CSQ ) The rows of the transformed A and B are parallel. Moreover, if the input 2-by-2 matrix A is not zero, then the transformed (1,1) entry of A is not zero. If the input matrices A and B are both not zero, then the transformed (2,2) element of B is not zero, except when the first rows of input A and B are parallel and the second rows are zero.  <br /></td></tr>
<tr class="separator:a810b9f487ce7de9b14045cfb7c0bd11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736541171318c3ae1d4a02426917e966" id="r_a736541171318c3ae1d4a02426917e966"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a736541171318c3ae1d4a02426917e966">la_lapack_c::la_clahqr</a> (wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z, ldz, info)</td></tr>
<tr class="memdesc:a736541171318c3ae1d4a02426917e966"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAHQR: is an auxiliary routine called by CHSEQR to update the eigenvalues and Schur decomposition already computed by CHSEQR, by dealing with the Hessenberg submatrix in rows and columns ILO to IHI.  <br /></td></tr>
<tr class="separator:a736541171318c3ae1d4a02426917e966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b93797af1a0baa295fe667b34b2fdd1" id="r_a3b93797af1a0baa295fe667b34b2fdd1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a3b93797af1a0baa295fe667b34b2fdd1">la_lapack_c::la_clahr2</a> (n, k, nb, a, lda, tau, t, ldt, y, ldy)</td></tr>
<tr class="memdesc:a3b93797af1a0baa295fe667b34b2fdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAHR2: reduces the first NB columns of A complex general n-BY-(n-k+1) matrix A so that elements below the k-th subdiagonal are zero. The reduction is performed by an unitary similarity transformation Q**H * A * Q. The routine returns the matrices V and T which determine Q as a block reflector I - V*T*v**H, and also the matrix Y = A * V * T. This is an auxiliary routine called by CGEHRD.  <br /></td></tr>
<tr class="separator:a3b93797af1a0baa295fe667b34b2fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e84834b3a95f188b52a5077e873a0aa" id="r_a4e84834b3a95f188b52a5077e873a0aa"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4e84834b3a95f188b52a5077e873a0aa">la_lapack_c::la_clals0</a> (icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx, perm, givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z, k, c, s, rwork, info)</td></tr>
<tr class="memdesc:a4e84834b3a95f188b52a5077e873a0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLALS0: applies back the multiplying factors of either the left or the right singular vector matrix of a diagonal matrix appended by a row to the right hand side matrix B in solving the least squares problem using the divide-and-conquer SVD approach. For the left singular vector matrix, three types of orthogonal matrices are involved: (1L) Givens rotations: the number of such rotations is GIVPTR; the pairs of columns/rows they were applied to are stored in GIVCOL; and the C- and S-values of these rotations are stored in GIVNUM. (2L) Permutation. The (NL+1)-st row of B is to be moved to the first row, and for J=2:N, PERM(J)-th row of B is to be moved to the J-th row. (3L) The left singular vector matrix of the remaining matrix. For the right singular vector matrix, four types of orthogonal matrices are involved: (1R) The right singular vector matrix of the remaining matrix. (2R) If SQRE = 1, one extra Givens rotation to generate the right null space. (3R) The inverse transformation of (2L). (4R) The inverse transformation of (1L).  <br /></td></tr>
<tr class="separator:a4e84834b3a95f188b52a5077e873a0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae0794ff1f32f5519b2022cf4ed6207" id="r_a3ae0794ff1f32f5519b2022cf4ed6207"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a3ae0794ff1f32f5519b2022cf4ed6207">la_lapack_c::la_clalsa</a> (icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, vt, k, difl, difr, z, poles, givptr, givcol, ldgcol, perm, givnum, c, s, rwork, iwork, info)</td></tr>
<tr class="memdesc:a3ae0794ff1f32f5519b2022cf4ed6207"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLALSA: is an itermediate step in solving the least squares problem by computing the SVD of the coefficient matrix in compact form (The singular vectors are computed as products of simple orthorgonal matrices.). If ICOMPQ = 0, CLALSA applies the inverse of the left singular vector matrix of an upper bidiagonal matrix to the right hand side; and if ICOMPQ = 1, CLALSA applies the right singular vector matrix to the right hand side. The singular vector matrices were generated in compact form by CLALSA.  <br /></td></tr>
<tr class="separator:a3ae0794ff1f32f5519b2022cf4ed6207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeabaa32ba295bb6a6db3993476c6df1" id="r_adeabaa32ba295bb6a6db3993476c6df1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#adeabaa32ba295bb6a6db3993476c6df1">la_lapack_c::la_clalsd</a> (uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond, rank, work, rwork, iwork, info)</td></tr>
<tr class="memdesc:adeabaa32ba295bb6a6db3993476c6df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLALSD: uses the singular value decomposition of A to solve the least squares problem of finding X to minimize the Euclidean norm of each column of A*X-B, where A is N-by-N upper bidiagonal, and X and B are N-by-NRHS. The solution X overwrites B. The singular values of A smaller than RCOND times the largest singular value are treated as zero in solving the least squares problem; in this case a minimum norm solution is returned. The actual singular values are returned in D in ascending order. This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:adeabaa32ba295bb6a6db3993476c6df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a3f8befdd29efebff93e0b9b823311" id="r_a93a3f8befdd29efebff93e0b9b823311"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a93a3f8befdd29efebff93e0b9b823311">la_lapack_c::la_clangb</a> (norm, n, kl, ku, ab, ldab, work)</td></tr>
<tr class="memdesc:a93a3f8befdd29efebff93e0b9b823311"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANGB: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of an n by n band matrix A, with kl sub-diagonals and ku super-diagonals.  <br /></td></tr>
<tr class="separator:a93a3f8befdd29efebff93e0b9b823311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c4bea66ffb256ca466bbeddff88037" id="r_a88c4bea66ffb256ca466bbeddff88037"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a88c4bea66ffb256ca466bbeddff88037">la_lapack_c::la_clange</a> (norm, m, n, a, lda, work)</td></tr>
<tr class="memdesc:a88c4bea66ffb256ca466bbeddff88037"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANGE: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a complex matrix A.  <br /></td></tr>
<tr class="separator:a88c4bea66ffb256ca466bbeddff88037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81c5f7a77f792eb3bf1d5c439578471" id="r_aa81c5f7a77f792eb3bf1d5c439578471"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa81c5f7a77f792eb3bf1d5c439578471">la_lapack_c::la_clangt</a> (norm, n, dl, d, du)</td></tr>
<tr class="memdesc:aa81c5f7a77f792eb3bf1d5c439578471"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANGT: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a complex tridiagonal matrix A.  <br /></td></tr>
<tr class="separator:aa81c5f7a77f792eb3bf1d5c439578471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694723bd05d378fb1bffcdebbffcbd6d" id="r_a694723bd05d378fb1bffcdebbffcbd6d"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a694723bd05d378fb1bffcdebbffcbd6d">la_lapack_c::la_clanhb</a> (norm, uplo, n, k, ab, ldab, work)</td></tr>
<tr class="memdesc:a694723bd05d378fb1bffcdebbffcbd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANHB: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of an n by n hermitian band matrix A, with k super-diagonals.  <br /></td></tr>
<tr class="separator:a694723bd05d378fb1bffcdebbffcbd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137917e79c4dd8421a6049706443b119" id="r_a137917e79c4dd8421a6049706443b119"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a137917e79c4dd8421a6049706443b119">la_lapack_c::la_clanhe</a> (norm, uplo, n, a, lda, work)</td></tr>
<tr class="memdesc:a137917e79c4dd8421a6049706443b119"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANHE: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a complex hermitian matrix A.  <br /></td></tr>
<tr class="separator:a137917e79c4dd8421a6049706443b119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7983ab3a6c579c05a34e6fe36c486b" id="r_a0b7983ab3a6c579c05a34e6fe36c486b"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0b7983ab3a6c579c05a34e6fe36c486b">la_lapack_c::la_clanhf</a> (norm, transr, uplo, n, a, work)</td></tr>
<tr class="memdesc:a0b7983ab3a6c579c05a34e6fe36c486b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANHF: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a complex Hermitian matrix A in RFP format.  <br /></td></tr>
<tr class="separator:a0b7983ab3a6c579c05a34e6fe36c486b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bea5e97b5ceae673a255b09fb99269" id="r_a47bea5e97b5ceae673a255b09fb99269"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a47bea5e97b5ceae673a255b09fb99269">la_lapack_c::la_clanhp</a> (norm, uplo, n, ap, work)</td></tr>
<tr class="memdesc:a47bea5e97b5ceae673a255b09fb99269"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANHP: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a complex hermitian matrix A, supplied in packed form.  <br /></td></tr>
<tr class="separator:a47bea5e97b5ceae673a255b09fb99269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645627e12a136c82550f1ab60ed84f16" id="r_a645627e12a136c82550f1ab60ed84f16"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a645627e12a136c82550f1ab60ed84f16">la_lapack_c::la_clanhs</a> (norm, n, a, lda, work)</td></tr>
<tr class="memdesc:a645627e12a136c82550f1ab60ed84f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANHS: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a Hessenberg matrix A.  <br /></td></tr>
<tr class="separator:a645627e12a136c82550f1ab60ed84f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108dec6ad0611b20e3ad344de0fb4eb5" id="r_a108dec6ad0611b20e3ad344de0fb4eb5"><td class="memItemLeft" align="right" valign="top">pure real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a108dec6ad0611b20e3ad344de0fb4eb5">la_lapack_c::la_clanht</a> (norm, n, d, e)</td></tr>
<tr class="memdesc:a108dec6ad0611b20e3ad344de0fb4eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANHT: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a complex Hermitian tridiagonal matrix A.  <br /></td></tr>
<tr class="separator:a108dec6ad0611b20e3ad344de0fb4eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeeaaae2736f5abeaac4c95ef2ee16ef" id="r_aeeeaaae2736f5abeaac4c95ef2ee16ef"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aeeeaaae2736f5abeaac4c95ef2ee16ef">la_lapack_c::la_clansb</a> (norm, uplo, n, k, ab, ldab, work)</td></tr>
<tr class="memdesc:aeeeaaae2736f5abeaac4c95ef2ee16ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANSB: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of an n by n symmetric band matrix A, with k super-diagonals.  <br /></td></tr>
<tr class="separator:aeeeaaae2736f5abeaac4c95ef2ee16ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d17dd91b2975e2056ad9ecdc255c10" id="r_a60d17dd91b2975e2056ad9ecdc255c10"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a60d17dd91b2975e2056ad9ecdc255c10">la_lapack_c::la_clansp</a> (norm, uplo, n, ap, work)</td></tr>
<tr class="memdesc:a60d17dd91b2975e2056ad9ecdc255c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANSP: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a complex symmetric matrix A, supplied in packed form.  <br /></td></tr>
<tr class="separator:a60d17dd91b2975e2056ad9ecdc255c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44fa7f0fcc08c507891b17b0d7b6e78" id="r_ae44fa7f0fcc08c507891b17b0d7b6e78"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae44fa7f0fcc08c507891b17b0d7b6e78">la_lapack_c::la_clansy</a> (norm, uplo, n, a, lda, work)</td></tr>
<tr class="memdesc:ae44fa7f0fcc08c507891b17b0d7b6e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANSY: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a complex symmetric matrix A.  <br /></td></tr>
<tr class="separator:ae44fa7f0fcc08c507891b17b0d7b6e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e51a2bf6b912dd06795670236a4f34" id="r_ad2e51a2bf6b912dd06795670236a4f34"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad2e51a2bf6b912dd06795670236a4f34">la_lapack_c::la_clantb</a> (norm, uplo, diag, n, k, ab, ldab, work)</td></tr>
<tr class="memdesc:ad2e51a2bf6b912dd06795670236a4f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANTB: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of an n by n triangular band matrix A, with ( k + 1 ) diagonals.  <br /></td></tr>
<tr class="separator:ad2e51a2bf6b912dd06795670236a4f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba396ae132952b4643d7a5f10c67ca5" id="r_a5ba396ae132952b4643d7a5f10c67ca5"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5ba396ae132952b4643d7a5f10c67ca5">la_lapack_c::la_clantp</a> (norm, uplo, diag, n, ap, work)</td></tr>
<tr class="memdesc:a5ba396ae132952b4643d7a5f10c67ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANTP: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a triangular matrix A, supplied in packed form.  <br /></td></tr>
<tr class="separator:a5ba396ae132952b4643d7a5f10c67ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a7c8173a27eac048b6cb1def008ba4" id="r_ab6a7c8173a27eac048b6cb1def008ba4"><td class="memItemLeft" align="right" valign="top">real(<a class="el" href="namespacela__constants.html#aaa5fae659a9baf5889d27d0af583cd0d">sp</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab6a7c8173a27eac048b6cb1def008ba4">la_lapack_c::la_clantr</a> (norm, uplo, diag, m, n, a, lda, work)</td></tr>
<tr class="memdesc:ab6a7c8173a27eac048b6cb1def008ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLANTR: returns the value of the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a trapezoidal or triangular matrix A.  <br /></td></tr>
<tr class="separator:ab6a7c8173a27eac048b6cb1def008ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3ed4a18b4026b967471fe6f3ac2b56" id="r_a6a3ed4a18b4026b967471fe6f3ac2b56"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6a3ed4a18b4026b967471fe6f3ac2b56">la_lapack_c::la_clapll</a> (n, x, incx, y, incy, ssmin)</td></tr>
<tr class="memdesc:a6a3ed4a18b4026b967471fe6f3ac2b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two column vectors X and Y, let A = ( X Y ). The subroutine first computes the QR factorization of A = Q*R, and then computes the SVD of the 2-by-2 upper triangular matrix R. The smaller singular value of R is returned in SSMIN, which is used as the measurement of the linear dependency of the vectors X and Y.  <br /></td></tr>
<tr class="separator:a6a3ed4a18b4026b967471fe6f3ac2b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af664179d42306f3eb508fb3bca10f76e" id="r_af664179d42306f3eb508fb3bca10f76e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af664179d42306f3eb508fb3bca10f76e">la_lapack_c::la_claqp2</a> (m, n, offset, a, lda, jpvt, tau, vn1, vn2, work)</td></tr>
<tr class="memdesc:af664179d42306f3eb508fb3bca10f76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQP2: computes a QR factorization with column pivoting of the block A(OFFSET+1:M,1:N). The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.  <br /></td></tr>
<tr class="separator:af664179d42306f3eb508fb3bca10f76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580ab492a3b558c13aa97b8929e45211" id="r_a580ab492a3b558c13aa97b8929e45211"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a580ab492a3b558c13aa97b8929e45211">la_lapack_c::la_claqps</a> (m, n, offset, nb, kb, a, lda, jpvt, tau, vn1, vn2, auxv, f, ldf)</td></tr>
<tr class="memdesc:a580ab492a3b558c13aa97b8929e45211"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQPS: computes a step of QR factorization with column pivoting of a complex M-by-N matrix A by using Blas-3. It tries to factorize NB columns from A starting from the row OFFSET+1, and updates all of the matrix with Blas-3 xGEMM. In some cases, due to catastrophic cancellations, it cannot factorize NB columns. Hence, the actual number of factorized columns is returned in KB. Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.  <br /></td></tr>
<tr class="separator:a580ab492a3b558c13aa97b8929e45211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5328479f7c3f6b15dc14f8a3e729971" id="r_af5328479f7c3f6b15dc14f8a3e729971"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af5328479f7c3f6b15dc14f8a3e729971">la_lapack_c::la_claqr5</a> (wantt, wantz, kacc22, n, ktop, kbot, nshfts, s, h, ldh, iloz, ihiz, z, ldz, v, ldv, u, ldu, nv, wv, ldwv, nh, wh, ldwh)</td></tr>
<tr class="memdesc:af5328479f7c3f6b15dc14f8a3e729971"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQR5: called by CLAQR0 performs a single small-bulge multi-shift QR sweep.  <br /></td></tr>
<tr class="separator:af5328479f7c3f6b15dc14f8a3e729971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a04b98ca4f568823283dd8758e6fc8b" id="r_a3a04b98ca4f568823283dd8758e6fc8b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a3a04b98ca4f568823283dd8758e6fc8b">la_lapack_c::la_claqz1</a> (ilq, ilz, k, istartm, istopm, ihi, a, lda, b, ldb, nq, qstart, q, ldq, nz, zstart, z, ldz)</td></tr>
<tr class="memdesc:a3a04b98ca4f568823283dd8758e6fc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQZ1: chases a 1x1 shift bulge in a matrix pencil down a single position.  <br /></td></tr>
<tr class="separator:a3a04b98ca4f568823283dd8758e6fc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eb4fd302963544ba3f4fa5f4b6c9f2" id="r_ad1eb4fd302963544ba3f4fa5f4b6c9f2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad1eb4fd302963544ba3f4fa5f4b6c9f2">la_lapack_c::la_claqz3</a> (ilschur, ilq, ilz, n, ilo, ihi, nshifts, nblock_desired, alpha, beta, a, lda, b, ldb, q, ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork, info)</td></tr>
<tr class="memdesc:ad1eb4fd302963544ba3f4fa5f4b6c9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQZ3: Executes a single multishift QZ sweep.  <br /></td></tr>
<tr class="separator:ad1eb4fd302963544ba3f4fa5f4b6c9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c353619eea0f27dddb12da9623f87e" id="r_a75c353619eea0f27dddb12da9623f87e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a75c353619eea0f27dddb12da9623f87e">la_lapack_c::la_clargv</a> (n, x, incx, y, incy, c, incc)</td></tr>
<tr class="memdesc:a75c353619eea0f27dddb12da9623f87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARGV: generates a vector of complex plane rotations with real cosines, determined by elements of the complex vectors x and y. For i = 1,2,...,n ( c(i) s(i) ) ( x(i) ) = ( r(i) ) ( -conjg(s(i)) c(i) ) ( y(i) ) = ( 0 ) where c(i)**2 + ABS(s(i))**2 = 1 The following conventions are used (these are the same as in CLARTG, but differ from the BLAS1 routine CROTG): If y(i)=0, then c(i)=1 and s(i)=0. If x(i)=0, then c(i)=0 and s(i) is chosen so that r(i) is real.  <br /></td></tr>
<tr class="separator:a75c353619eea0f27dddb12da9623f87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7c53abd241214b86dbf6fcbed422db" id="r_acd7c53abd241214b86dbf6fcbed422db"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#acd7c53abd241214b86dbf6fcbed422db">la_lapack_c::la_clarrv</a> (n, vl, vu, d, l, pivmin, isplit, m, dol, dou, minrgp, rtol1, rtol2, w, werr, wgap, iblock, indexw, gers, z, ldz, isuppz, work, iwork, info)</td></tr>
<tr class="memdesc:acd7c53abd241214b86dbf6fcbed422db"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLARRV: computes the eigenvectors of the tridiagonal matrix T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T. The input eigenvalues should have been computed by SLARRE.  <br /></td></tr>
<tr class="separator:acd7c53abd241214b86dbf6fcbed422db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201d97fdbb1b89b1861d364d006d0207" id="r_a201d97fdbb1b89b1861d364d006d0207"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a201d97fdbb1b89b1861d364d006d0207">la_lapack_c::la_clatdf</a> (ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv, jpiv)</td></tr>
<tr class="memdesc:a201d97fdbb1b89b1861d364d006d0207"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLATDF: computes the contribution to the reciprocal Dif-estimate by solving for x in Z * x = b, where b is chosen such that the norm of x is as large as possible. It is assumed that LU decomposition of Z has been computed by CGETC2. On entry RHS = f holds the contribution from earlier solved sub-systems, and on return RHS = x. The factorization of Z returned by CGETC2 has the form Z = P * L * U * Q, where P and Q are permutation matrices. L is lower triangular with unit diagonal elements and U is upper triangular.  <br /></td></tr>
<tr class="separator:a201d97fdbb1b89b1861d364d006d0207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130760c67a5e7362e130d40f71450ba9" id="r_a130760c67a5e7362e130d40f71450ba9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a130760c67a5e7362e130d40f71450ba9">la_lapack_c::la_claunhr_col_getrfnp</a> (m, n, a, lda, d, info)</td></tr>
<tr class="memdesc:a130760c67a5e7362e130d40f71450ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAUNHR_COL_GETRFNP: computes the modified LU factorization without pivoting of a complex general M-by-N matrix A. The factorization has the form: A - S = L * U, where: S is a m-by-n diagonal sign matrix with the diagonal D, so that D(i) = S(i,i), 1 &lt;= i &lt;= min(M,N). The diagonal D is constructed as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing i-1 steps of Gaussian elimination. This means that the diagonal element at each step of "modified" Gaussian elimination is at least one in absolute value (so that division-by-zero not not possible during the division by the diagonal element); L is a M-by-N lower triangular matrix with unit diagonal elements (lower trapezoidal if M &gt; N); and U is a M-by-N upper triangular matrix (upper trapezoidal if M &lt; N). This routine is an auxiliary routine used in the Householder reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is applied to an M-by-N matrix A with orthonormal columns, where each element is bounded by one in absolute value. With the choice of the matrix S above, one can show that the diagonal element at each step of Gaussian elimination is the largest (in absolute value) in the column on or below the diagonal, so that no pivoting is required for numerical stability [1]. For more details on the Householder reconstruction algorithm, including the modified LU factorization, see [1]. This is the blocked right-looking version of the algorithm, calling Level 3 BLAS to update the submatrix. To factorize a block, this routine calls the recursive routine CLAUNHR_COL_GETRFNP2. [1] "Reconstructing Householder vectors from tall-skinny QR", G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen, E. Solomonik, J. Parallel Distrib. Comput., vol. 85, pp. 3-31, 2015.  <br /></td></tr>
<tr class="separator:a130760c67a5e7362e130d40f71450ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568485bdbe2e013cee30949383e7f804" id="r_a568485bdbe2e013cee30949383e7f804"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a568485bdbe2e013cee30949383e7f804">la_lapack_c::la_cpbcon</a> (uplo, n, kd, ab, ldab, anorm, rcond, work, rwork, info)</td></tr>
<tr class="memdesc:a568485bdbe2e013cee30949383e7f804"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPBCON: estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite band matrix using the Cholesky factorization A = U**H*U or A = L*L**H computed by CPBTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a568485bdbe2e013cee30949383e7f804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2250348ce75e4d07700caed73225ad32" id="r_a2250348ce75e4d07700caed73225ad32"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2250348ce75e4d07700caed73225ad32">la_lapack_c::la_cpbrfs</a> (uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a2250348ce75e4d07700caed73225ad32"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPBRFS: improves the computed solution to a system of linear equations when the coefficient matrix is Hermitian positive definite and banded, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:a2250348ce75e4d07700caed73225ad32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040e321a9f3c18784d08cb6ce1d214c3" id="r_a040e321a9f3c18784d08cb6ce1d214c3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a040e321a9f3c18784d08cb6ce1d214c3">la_lapack_c::la_cpbtrf</a> (uplo, n, kd, ab, ldab, info)</td></tr>
<tr class="memdesc:a040e321a9f3c18784d08cb6ce1d214c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPBTRF: computes the Cholesky factorization of a complex Hermitian positive definite band matrix A. The factorization has the form A = U**H * U, if UPLO = 'U', or A = L * L**H, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular.  <br /></td></tr>
<tr class="separator:a040e321a9f3c18784d08cb6ce1d214c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd2c22f51d8562f261905503447f00d" id="r_aebd2c22f51d8562f261905503447f00d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aebd2c22f51d8562f261905503447f00d">la_lapack_c::la_cpftrs</a> (transr, uplo, n, nrhs, a, b, ldb, info)</td></tr>
<tr class="memdesc:aebd2c22f51d8562f261905503447f00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPFTRS: solves a system of linear equations A*X = B with a Hermitian positive definite matrix A using the Cholesky factorization A = U**H*U or A = L*L**H computed by CPFTRF.  <br /></td></tr>
<tr class="separator:aebd2c22f51d8562f261905503447f00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b86868650b87750579be1568744003" id="r_ac5b86868650b87750579be1568744003"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac5b86868650b87750579be1568744003">la_lapack_c::la_cpocon</a> (uplo, n, a, lda, anorm, rcond, work, rwork, info)</td></tr>
<tr class="memdesc:ac5b86868650b87750579be1568744003"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOCON: estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite matrix using the Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:ac5b86868650b87750579be1568744003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20093bce9642d795fa87b378e3e94e8" id="r_aa20093bce9642d795fa87b378e3e94e8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa20093bce9642d795fa87b378e3e94e8">la_lapack_c::la_cporfs</a> (uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:aa20093bce9642d795fa87b378e3e94e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPORFS: improves the computed solution to a system of linear equations when the coefficient matrix is Hermitian positive definite, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:aa20093bce9642d795fa87b378e3e94e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec9d1998ec39bb58c8eda3bb3ce3b45" id="r_aeec9d1998ec39bb58c8eda3bb3ce3b45"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aeec9d1998ec39bb58c8eda3bb3ce3b45">la_lapack_c::la_cpotrf</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:aeec9d1998ec39bb58c8eda3bb3ce3b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOTRF: computes the Cholesky factorization of a complex Hermitian positive definite matrix A. The factorization has the form A = U**H * U, if UPLO = 'U', or A = L * L**H, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular. This is the block version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:aeec9d1998ec39bb58c8eda3bb3ce3b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a4d67d7bd87c26fbf8169e668f72e0" id="r_a65a4d67d7bd87c26fbf8169e668f72e0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a65a4d67d7bd87c26fbf8169e668f72e0">la_lapack_c::la_cpotri</a> (uplo, n, a, lda, info)</td></tr>
<tr class="memdesc:a65a4d67d7bd87c26fbf8169e668f72e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOTRI: computes the inverse of a complex Hermitian positive definite matrix A using the Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.  <br /></td></tr>
<tr class="separator:a65a4d67d7bd87c26fbf8169e668f72e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcfd36bcc6f6c851a532306f7a615fc" id="r_afdcfd36bcc6f6c851a532306f7a615fc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#afdcfd36bcc6f6c851a532306f7a615fc">la_lapack_c::la_cppcon</a> (uplo, n, ap, anorm, rcond, work, rwork, info)</td></tr>
<tr class="memdesc:afdcfd36bcc6f6c851a532306f7a615fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPPCON: estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite packed matrix using the Cholesky factorization A = U**H*U or A = L*L**H computed by CPPTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:afdcfd36bcc6f6c851a532306f7a615fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af172d246f56a490a34c160e59706eef1" id="r_af172d246f56a490a34c160e59706eef1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af172d246f56a490a34c160e59706eef1">la_lapack_c::la_cpprfs</a> (uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:af172d246f56a490a34c160e59706eef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPPRFS: improves the computed solution to a system of linear equations when the coefficient matrix is Hermitian positive definite and packed, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:af172d246f56a490a34c160e59706eef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b929a8873dafe4fba516c4d01e19d5f" id="r_a1b929a8873dafe4fba516c4d01e19d5f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1b929a8873dafe4fba516c4d01e19d5f">la_lapack_c::la_cppsv</a> (uplo, n, nrhs, ap, b, ldb, info)</td></tr>
<tr class="memdesc:a1b929a8873dafe4fba516c4d01e19d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPPSV: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian positive definite matrix stored in packed format and X and B are N-by-NRHS matrices. The Cholesky decomposition is used to factor A as A = U**H * U, if UPLO = 'U', or A = L * L**H, if UPLO = 'L', where U is an upper triangular matrix and L is a lower triangular matrix. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a1b929a8873dafe4fba516c4d01e19d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8f9423d6081f60fe734b015942d08a" id="r_a5a8f9423d6081f60fe734b015942d08a"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5a8f9423d6081f60fe734b015942d08a">la_lapack_c::la_cppsvx</a> (fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a5a8f9423d6081f60fe734b015942d08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPPSVX: uses the Cholesky factorization A = U**H*U or A = L*L**H to compute the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian positive definite matrix stored in packed format and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a5a8f9423d6081f60fe734b015942d08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3615ad40890d7a07d509a01fd161c13" id="r_ab3615ad40890d7a07d509a01fd161c13"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab3615ad40890d7a07d509a01fd161c13">la_lapack_c::la_cpptri</a> (uplo, n, ap, info)</td></tr>
<tr class="memdesc:ab3615ad40890d7a07d509a01fd161c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPPTRI: computes the inverse of a complex Hermitian positive definite matrix A using the Cholesky factorization A = U**H*U or A = L*L**H computed by CPPTRF.  <br /></td></tr>
<tr class="separator:ab3615ad40890d7a07d509a01fd161c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2629dca141705a4ad141bf3ce234bd92" id="r_a2629dca141705a4ad141bf3ce234bd92"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2629dca141705a4ad141bf3ce234bd92">la_lapack_c::la_cpteqr</a> (compz, n, d, e, z, ldz, work, info)</td></tr>
<tr class="memdesc:a2629dca141705a4ad141bf3ce234bd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPTEQR: computes all eigenvalues and, optionally, eigenvectors of a symmetric positive definite tridiagonal matrix by first factoring the matrix using SPTTRF and then calling CBDSQR to compute the singular values of the bidiagonal factor. This routine computes the eigenvalues of the positive definite tridiagonal matrix to high relative accuracy. This means that if the eigenvalues range over many orders of magnitude in size, then the small eigenvalues and corresponding eigenvectors will be computed more accurately than, for example, with the standard QR method. The eigenvectors of a full or band positive definite Hermitian matrix can also be found if CHETRD, CHPTRD, or CHBTRD has been used to reduce this matrix to tridiagonal form. (The reduction to tridiagonal form, however, may preclude the possibility of obtaining high relative accuracy in the small eigenvalues of the original matrix, if these eigenvalues range over many orders of magnitude.)  <br /></td></tr>
<tr class="separator:a2629dca141705a4ad141bf3ce234bd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c98c1548eecd7fb6204687b065acd02" id="r_a1c98c1548eecd7fb6204687b065acd02"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1c98c1548eecd7fb6204687b065acd02">la_lapack_c::la_cpttrs</a> (uplo, n, nrhs, d, e, b, ldb, info)</td></tr>
<tr class="memdesc:a1c98c1548eecd7fb6204687b065acd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPTTRS: solves a tridiagonal system of the form A * X = B using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF. D is a diagonal matrix specified in the vector D, U (or L) is a unit bidiagonal matrix whose superdiagonal (subdiagonal) is specified in the vector E, and X and B are N by NRHS matrices.  <br /></td></tr>
<tr class="separator:a1c98c1548eecd7fb6204687b065acd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2582ac86e550515bde1f371529cf0b" id="r_a5c2582ac86e550515bde1f371529cf0b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5c2582ac86e550515bde1f371529cf0b">la_lapack_c::la_cspcon</a> (uplo, n, ap, ipiv, anorm, rcond, work, info)</td></tr>
<tr class="memdesc:a5c2582ac86e550515bde1f371529cf0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSPCON: estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric packed matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a5c2582ac86e550515bde1f371529cf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd5ccf04a403d4379cdc9c961534a43" id="r_a5fd5ccf04a403d4379cdc9c961534a43"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5fd5ccf04a403d4379cdc9c961534a43">la_lapack_c::la_csprfs</a> (uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a5fd5ccf04a403d4379cdc9c961534a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSPRFS: improves the computed solution to a system of linear equations when the coefficient matrix is symmetric indefinite and packed, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:a5fd5ccf04a403d4379cdc9c961534a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1cbe9b5d16b6b092494d1f6c066157" id="r_a6f1cbe9b5d16b6b092494d1f6c066157"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6f1cbe9b5d16b6b092494d1f6c066157">la_lapack_c::la_cspsv</a> (uplo, n, nrhs, ap, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a6f1cbe9b5d16b6b092494d1f6c066157"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSPSV: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N symmetric matrix stored in packed format and X and B are N-by-NRHS matrices. The diagonal pivoting method is used to factor A as A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a6f1cbe9b5d16b6b092494d1f6c066157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8f9d39372c4311a185177be414e277" id="r_a7d8f9d39372c4311a185177be414e277"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a7d8f9d39372c4311a185177be414e277">la_lapack_c::la_cspsvx</a> (fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a7d8f9d39372c4311a185177be414e277"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSPSVX: uses the diagonal pivoting factorization A = U*D*U**T or A = L*D*L**T to compute the solution to a complex system of linear equations A * X = B, where A is an N-by-N symmetric matrix stored in packed format and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a7d8f9d39372c4311a185177be414e277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800d6157510bfc179486fc21a892c405" id="r_a800d6157510bfc179486fc21a892c405"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a800d6157510bfc179486fc21a892c405">la_lapack_c::la_cstemr</a> (jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a800d6157510bfc179486fc21a892c405"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSTEMR: computes selected eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix T. Any such unreduced matrix has a well defined set of pairwise different real eigenvalues, the corresponding real eigenvectors are pairwise orthogonal. The spectrum may be computed either completely or partially by specifying either an interval (VL,VU] or a range of indices IL:IU for the desired eigenvalues. Depending on the number of desired eigenvalues, these are computed either by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are computed by the use of various suitable L D L^T factorizations near clusters of close eigenvalues (referred to as RRRs, Relatively Robust Representations). An informal sketch of the algorithm follows. For each unreduced block (submatrix) of T, (a) Compute T - sigma I = L D L^T, so that L and D define all the wanted eigenvalues to high relative accuracy. This means that small relative changes in the entries of D and L cause only small relative changes in the eigenvalues and eigenvectors. The standard (unfactored) representation of the tridiagonal matrix T does not have this property in general. (b) Compute the eigenvalues to suitable accuracy. If the eigenvectors are desired, the algorithm attains full accuracy of the computed eigenvalues only right before the corresponding vectors have to be computed, see steps c) and d). (c) For each cluster of close eigenvalues, select a new shift close to the cluster, find a new factorization, and refine the shifted eigenvalues to suitable accuracy. (d) For each eigenvalue with a large enough relative separation compute the corresponding eigenvector by forming a rank revealing twisted factorization. Go back to (c) for any clusters that remain. For more details, see:  <br /></td></tr>
<tr class="separator:a800d6157510bfc179486fc21a892c405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a1bf6c1dd53d154ac699469512a846" id="r_a11a1bf6c1dd53d154ac699469512a846"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a11a1bf6c1dd53d154ac699469512a846">la_lapack_c::la_csycon</a> (uplo, n, a, lda, ipiv, anorm, rcond, work, info)</td></tr>
<tr class="memdesc:a11a1bf6c1dd53d154ac699469512a846"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYCON: estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by CSYTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a11a1bf6c1dd53d154ac699469512a846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf277fb0cc894948a44da8886ed52791" id="r_abf277fb0cc894948a44da8886ed52791"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abf277fb0cc894948a44da8886ed52791">la_lapack_c::la_csycon_rook</a> (uplo, n, a, lda, ipiv, anorm, rcond, work, info)</td></tr>
<tr class="memdesc:abf277fb0cc894948a44da8886ed52791"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYCON_ROOK: estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric matrix A using the factorization A = U*D*U**T or A = L*D*L**T computed by CSYTRF_ROOK. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:abf277fb0cc894948a44da8886ed52791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1b919fa892e73dc8dacb077ecf98b9" id="r_acd1b919fa892e73dc8dacb077ecf98b9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#acd1b919fa892e73dc8dacb077ecf98b9">la_lapack_c::la_csyrfs</a> (uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:acd1b919fa892e73dc8dacb077ecf98b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYRFS: improves the computed solution to a system of linear equations when the coefficient matrix is symmetric indefinite, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:acd1b919fa892e73dc8dacb077ecf98b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda316a5bc6cf43f0808240243e7b6fc" id="r_aeda316a5bc6cf43f0808240243e7b6fc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aeda316a5bc6cf43f0808240243e7b6fc">la_lapack_c::la_csysv</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:aeda316a5bc6cf43f0808240243e7b6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYSV: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices. The diagonal pivoting method is used to factor A as A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:aeda316a5bc6cf43f0808240243e7b6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd33db0d68d985a8b329ea3a12dc4f9" id="r_aecd33db0d68d985a8b329ea3a12dc4f9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aecd33db0d68d985a8b329ea3a12dc4f9">la_lapack_c::la_csysv_rk</a> (uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:aecd33db0d68d985a8b329ea3a12dc4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYSV_RK: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices. The bounded Bunch-Kaufman (rook) diagonal pivoting method is used to factor A as A = P*U*D*(U**T)*(P**T), if UPLO = 'U', or A = P*L*D*(L**T)*(P**T), if UPLO = 'L', where U (or L) is unit upper (or lower) triangular matrix, U**T (or L**T) is the transpose of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. CSYTRF_RK is called to compute the factorization of a complex symmetric matrix. The factored form of A is then used to solve the system of equations A * X = B by calling BLAS3 routine CSYTRS_3.  <br /></td></tr>
<tr class="separator:aecd33db0d68d985a8b329ea3a12dc4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e6e88374c0c4eb09e8896b7fa3e1d8" id="r_a16e6e88374c0c4eb09e8896b7fa3e1d8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a16e6e88374c0c4eb09e8896b7fa3e1d8">la_lapack_c::la_csysv_rook</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a16e6e88374c0c4eb09e8896b7fa3e1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYSV_ROOK: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices. The diagonal pivoting method is used to factor A as A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. CSYTRF_ROOK is called to compute the factorization of a complex symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method. The factored form of A is then used to solve the system of equations A * X = B by calling CSYTRS_ROOK.  <br /></td></tr>
<tr class="separator:a16e6e88374c0c4eb09e8896b7fa3e1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301091ed581ba1e2ce6954e0249f51ce" id="r_a301091ed581ba1e2ce6954e0249f51ce"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a301091ed581ba1e2ce6954e0249f51ce">la_lapack_c::la_csysvx</a> (fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:a301091ed581ba1e2ce6954e0249f51ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYSVX: uses the diagonal pivoting factorization to compute the solution to a complex system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a301091ed581ba1e2ce6954e0249f51ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe04d67ca64d210656a3c1fe2aa5ec92" id="r_afe04d67ca64d210656a3c1fe2aa5ec92"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#afe04d67ca64d210656a3c1fe2aa5ec92">la_lapack_c::la_ctbcon</a> (norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwork, info)</td></tr>
<tr class="memdesc:afe04d67ca64d210656a3c1fe2aa5ec92"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTBCON: estimates the reciprocal of the condition number of a triangular band matrix A, in either the 1-norm or the infinity-norm. The norm of A is computed and an estimate is obtained for norm(inv(A)), then the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).  <br /></td></tr>
<tr class="separator:afe04d67ca64d210656a3c1fe2aa5ec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106105fb06d2e4405e9a130321451159" id="r_a106105fb06d2e4405e9a130321451159"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a106105fb06d2e4405e9a130321451159">la_lapack_c::la_ctftri</a> (transr, uplo, diag, n, a, info)</td></tr>
<tr class="memdesc:a106105fb06d2e4405e9a130321451159"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTFTRI: computes the inverse of a triangular matrix A stored in RFP format. This is a Level 3 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:a106105fb06d2e4405e9a130321451159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eff6e44438af08bcc3e9a46bf2f8dd" id="r_aa1eff6e44438af08bcc3e9a46bf2f8dd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa1eff6e44438af08bcc3e9a46bf2f8dd">la_lapack_c::la_ctgsja</a> (jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle, info)</td></tr>
<tr class="memdesc:aa1eff6e44438af08bcc3e9a46bf2f8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTGSJA: computes the generalized singular value decomposition (GSVD) of two complex upper triangular (or trapezoidal) matrices A and B. On entry, it is assumed that matrices A and B have the following forms, which may be obtained by the preprocessing subroutine CGGSVP from a general M-by-N matrix A and P-by-N matrix B: N-K-L K L A = K ( 0 A12 A13 ) if M-K-L &gt;= 0; L ( 0 0 A23 ) M-K-L ( 0 0 0 ) N-K-L K L A = K ( 0 A12 A13 ) if M-K-L &lt; 0; M-K ( 0 0 A23 ) N-K-L K L B = L ( 0 0 B13 ) P-L ( 0 0 0 ) where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular upper triangular; A23 is L-by-L upper triangular if M-K-L &gt;= 0, otherwise A23 is (M-K)-by-L upper trapezoidal. On exit, U**H <em>A*Q = D1</em>( 0 R ), V**H <em>B*Q = D2</em>( 0 R ), where U, V and Q are unitary matrices. R is a nonsingular upper triangular matrix, and D1 and D2 are `&lsquo;diagonal&rsquo;' matrices, which are of the following structures: If M-K-L &gt;= 0, K L D1 = K ( I 0 ) L ( 0 C ) M-K-L ( 0 0 ) K L D2 = L ( 0 S ) P-L ( 0 0 ) N-K-L K L ( 0 R ) = K ( 0 R11 R12 ) K L ( 0 0 R22 ) L where C = diag( ALPHA(K+1), ... , ALPHA(K+L) ), S = diag( BETA(K+1), ... , BETA(K+L) ), C**2 + S**2 = I. R is stored in A(1:K+L,N-K-L+1:N) on exit. If M-K-L &lt; 0, K M-K K+L-M D1 = K ( I 0 0 ) M-K ( 0 C 0 ) K M-K K+L-M D2 = M-K ( 0 S 0 ) K+L-M ( 0 0 I ) P-L ( 0 0 0 ) N-K-L K M-K K+L-M ( 0 R ) = K ( 0 R11 R12 R13 ) M-K ( 0 0 R22 R23 ) K+L-M ( 0 0 0 R33 ) where C = diag( ALPHA(K+1), ... , ALPHA(M) ), S = diag( BETA(K+1), ... , BETA(M) ), C**2 + S**2 = I. R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored ( 0 R22 R23 ) in B(M-K+1:L,N+M-K-L+1:N) on exit. The computation of the unitary transformation matrices U, V or Q is optional. These matrices may either be formed explicitly, or they may be postmultiplied into input matrices U1, V1, or Q1.  <br /></td></tr>
<tr class="separator:aa1eff6e44438af08bcc3e9a46bf2f8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faab8545c4b477c2330f68dcf05e9a3" id="r_a2faab8545c4b477c2330f68dcf05e9a3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2faab8545c4b477c2330f68dcf05e9a3">la_lapack_c::la_ctgsy2</a> (trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, rdsum, rdscal, info)</td></tr>
<tr class="memdesc:a2faab8545c4b477c2330f68dcf05e9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTGSY2: solves the generalized Sylvester equation A * R - L * B = scale * C (1) D * R - L * E = scale * F using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices, (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M, N-by-N and M-by-N, respectively. A, B, D and E are upper triangular (i.e., (A,D) and (B,E) in generalized Schur form). The solution (R, L) overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output scaling factor chosen to avoid overflow. In matrix notation solving equation (1) corresponds to solve Zx = scale * b, where Z is defined as Z = [ kron(In, A) -kron(B**H, Im) ] (2) [ kron(In, D) -kron(E**H, Im) ], Ik is the identity matrix of size k and X**H is the transpose of X. kron(X, Y) is the Kronecker product between the matrices X and Y. If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b is solved for, which is equivalent to solve for R and L in A**H * R + D**H * L = scale * C (3) R * B**H + L * E**H = scale * -F This case is used to compute an estimate of Dif[(A, D), (B, E)] = = sigma_min(Z) using reverse communication with CLACON. CTGSY2 also (IJOB &gt;= 1) contributes to the computation in CTGSYL of an upper bound on the separation between to matrix pairs. Then the input (A, D), (B, E) are sub-pencils of two matrix pairs in CTGSYL.  <br /></td></tr>
<tr class="separator:a2faab8545c4b477c2330f68dcf05e9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecd2feb5a7a9d3d2f21515e277344f4" id="r_a0ecd2feb5a7a9d3d2f21515e277344f4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0ecd2feb5a7a9d3d2f21515e277344f4">la_lapack_c::la_ctgsyl</a> (trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:a0ecd2feb5a7a9d3d2f21515e277344f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTGSYL: solves the generalized Sylvester equation: A * R - L * B = scale * C (1) D * R - L * E = scale * F where R and L are unknown m-by-n matrices, (A, D), (B, E) and (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n, respectively, with complex entries. A, B, D and E are upper triangular (i.e., (A,D) and (B,E) in generalized Schur form). The solution (R, L) overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output scaling factor chosen to avoid overflow. In matrix notation (1) is equivalent to solve Zx = scale*b, where Z is defined as Z = [ kron(In, A) -kron(B**H, Im) ] (2) [ kron(In, D) -kron(E**H, Im) ], Here Ix is the identity matrix of size x and X**H is the conjugate transpose of X. Kron(X, Y) is the Kronecker product between the matrices X and Y. If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b is solved for, which is equivalent to solve for R and L in A**H * R + D**H * L = scale * C (3) R * B**H + L * E**H = scale * -F This case (TRANS = 'C') is used to compute an one-norm-based estimate of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D) and (B,E), using CLACON. If IJOB &gt;= 1, CTGSYL computes a Frobenius norm-based estimate of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the reciprocal of the smallest singular value of Z. This is a level-3 BLAS algorithm.  <br /></td></tr>
<tr class="separator:a0ecd2feb5a7a9d3d2f21515e277344f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac458df46454070d60a6f7a08077443e9" id="r_ac458df46454070d60a6f7a08077443e9"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac458df46454070d60a6f7a08077443e9">la_lapack_c::la_ctpcon</a> (norm, uplo, diag, n, ap, rcond, work, rwork, info)</td></tr>
<tr class="memdesc:ac458df46454070d60a6f7a08077443e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPCON: estimates the reciprocal of the condition number of a packed triangular matrix A, in either the 1-norm or the infinity-norm. The norm of A is computed and an estimate is obtained for norm(inv(A)), then the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).  <br /></td></tr>
<tr class="separator:ac458df46454070d60a6f7a08077443e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49419bd33ec73c76215e9c50584edbb7" id="r_a49419bd33ec73c76215e9c50584edbb7"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a49419bd33ec73c76215e9c50584edbb7">la_lapack_c::la_ctplqt</a> (m, n, l, mb, a, lda, b, ldb, t, ldt, work, info)</td></tr>
<tr class="memdesc:a49419bd33ec73c76215e9c50584edbb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPLQT: computes a blocked LQ factorization of a complex "triangular-pentagonal" matrix C, which is composed of a triangular block A and pentagonal block B, using the compact WY representation for Q.  <br /></td></tr>
<tr class="separator:a49419bd33ec73c76215e9c50584edbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edc813189c86cbf24731ebad761d39f" id="r_a8edc813189c86cbf24731ebad761d39f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a8edc813189c86cbf24731ebad761d39f">la_lapack_c::la_ctpmlqt</a> (side, trans, m, n, k, l, mb, v, ldv, t, ldt, a, lda, b, ldb, work, info)</td></tr>
<tr class="memdesc:a8edc813189c86cbf24731ebad761d39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPMLQT: applies a complex unitary matrix Q obtained from a "triangular-pentagonal" complex block reflector H to a general complex matrix C, which consists of two blocks A and B.  <br /></td></tr>
<tr class="separator:a8edc813189c86cbf24731ebad761d39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd71c68f54f15580054474250d46204" id="r_a0bd71c68f54f15580054474250d46204"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0bd71c68f54f15580054474250d46204">la_lapack_c::la_ctpmqrt</a> (side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work, info)</td></tr>
<tr class="memdesc:a0bd71c68f54f15580054474250d46204"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPMQRT: applies a complex orthogonal matrix Q obtained from a "triangular-pentagonal" complex block reflector H to a general complex matrix C, which consists of two blocks A and B.  <br /></td></tr>
<tr class="separator:a0bd71c68f54f15580054474250d46204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab434f7d420912ab8205479b9a0d2089d" id="r_ab434f7d420912ab8205479b9a0d2089d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab434f7d420912ab8205479b9a0d2089d">la_lapack_c::la_ctpqrt</a> (m, n, l, nb, a, lda, b, ldb, t, ldt, work, info)</td></tr>
<tr class="memdesc:ab434f7d420912ab8205479b9a0d2089d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTPQRT: computes a blocked QR factorization of a complex "triangular-pentagonal" matrix C, which is composed of a triangular block A and pentagonal block B, using the compact WY representation for Q.  <br /></td></tr>
<tr class="separator:ab434f7d420912ab8205479b9a0d2089d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad490fc95f624cf91af1ca169502f9d94" id="r_ad490fc95f624cf91af1ca169502f9d94"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad490fc95f624cf91af1ca169502f9d94">la_lapack_c::la_ctrcon</a> (norm, uplo, diag, n, a, lda, rcond, work, rwork, info)</td></tr>
<tr class="memdesc:ad490fc95f624cf91af1ca169502f9d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTRCON: estimates the reciprocal of the condition number of a triangular matrix A, in either the 1-norm or the infinity-norm. The norm of A is computed and an estimate is obtained for norm(inv(A)), then the reciprocal of the condition number is computed as RCOND = 1 / ( norm(A) * norm(inv(A)) ).  <br /></td></tr>
<tr class="separator:ad490fc95f624cf91af1ca169502f9d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b56ead1eb554743b1308c053fe464d" id="r_a66b56ead1eb554743b1308c053fe464d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a66b56ead1eb554743b1308c053fe464d">la_lapack_c::la_ctrsyl</a> (trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)</td></tr>
<tr class="memdesc:a66b56ead1eb554743b1308c053fe464d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTRSYL: solves the complex Sylvester matrix equation: op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C, where op(A) = A or A**H, and A and B are both upper triangular. A is M-by-M and B is N-by-N; the right hand side C and the solution X are M-by-N; and scale is an output scale factor, set &lt;= 1 to avoid overflow in X.  <br /></td></tr>
<tr class="separator:a66b56ead1eb554743b1308c053fe464d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1543cf882f996deafaae6d8e004721e6" id="r_a1543cf882f996deafaae6d8e004721e6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1543cf882f996deafaae6d8e004721e6">la_lapack_c::la_cunbdb5</a> (m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2, work, lwork, info)</td></tr>
<tr class="memdesc:a1543cf882f996deafaae6d8e004721e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNBDB5: orthogonalizes the column vector X = [ X1 ] [ X2 ] with respect to the columns of Q = [ Q1 ] . [ Q2 ] The columns of Q must be orthonormal. If the projection is zero according to Kahan's "twice is enough" criterion, then some other vector from the orthogonal complement is returned. This vector is chosen in an arbitrary but deterministic way.  <br /></td></tr>
<tr class="separator:a1543cf882f996deafaae6d8e004721e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae96035460da28f3e83e990b352b6ef0" id="r_aae96035460da28f3e83e990b352b6ef0"><td class="memItemLeft" align="right" valign="top">recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aae96035460da28f3e83e990b352b6ef0">la_lapack_c::la_cuncsd</a> (jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork, info)</td></tr>
<tr class="memdesc:aae96035460da28f3e83e990b352b6ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNCSD: computes the CS decomposition of an M-by-M partitioned unitary matrix X: [ I 0 0 | 0 0 0 ] [ 0 C 0 | 0 -S 0 ] [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**H X = [--------&mdash;] = [------&mdash;] [------------------&mdash;] [------&mdash;] . [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ] [ 0 S 0 | 0 C 0 ] [ 0 0 I | 0 0 0 ] X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P, (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which R = MIN(P,M-P,Q,M-Q).  <br /></td></tr>
<tr class="separator:aae96035460da28f3e83e990b352b6ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763e649bcad25325b48a39feb006dc98" id="r_a763e649bcad25325b48a39feb006dc98"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a763e649bcad25325b48a39feb006dc98">la_lapack_c::la_cunghr</a> (n, ilo, ihi, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a763e649bcad25325b48a39feb006dc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGHR: generates a complex unitary matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by CGEHRD: Q = H(ilo) H(ilo+1) . . . H(ihi-1).  <br /></td></tr>
<tr class="separator:a763e649bcad25325b48a39feb006dc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa562b3850a767bff0c1a6a008ba202cc" id="r_aa562b3850a767bff0c1a6a008ba202cc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa562b3850a767bff0c1a6a008ba202cc">la_lapack_c::la_cungtr</a> (uplo, n, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:aa562b3850a767bff0c1a6a008ba202cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGTR: generates a complex unitary matrix Q which is defined as the product of n-1 elementary reflectors of order N, as returned by CHETRD: if UPLO = 'U', Q = H(n-1) . . . H(2) H(1), if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).  <br /></td></tr>
<tr class="separator:aa562b3850a767bff0c1a6a008ba202cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988e18faeeb982d1af495e0ad3733305" id="r_a988e18faeeb982d1af495e0ad3733305"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a988e18faeeb982d1af495e0ad3733305">la_lapack_c::la_cunhr_col</a> (m, n, nb, a, lda, t, ldt, d, info)</td></tr>
<tr class="memdesc:a988e18faeeb982d1af495e0ad3733305"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNHR_COL: takes an M-by-N complex matrix Q_in with orthonormal columns as input, stored in A, and performs Householder Reconstruction (HR), i.e. reconstructs Householder vectors V(i) implicitly representing another M-by-N matrix Q_out, with the property that Q_in = Q_out*S, where S is an N-by-N diagonal matrix with diagonal entries equal to +1 or -1. The Householder vectors (columns V(i) of V) are stored in A on output, and the diagonal entries of S are stored in D. Block reflectors are also returned in T (same output format as CGEQRT).  <br /></td></tr>
<tr class="separator:a988e18faeeb982d1af495e0ad3733305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada23ac2a4d9ed3b16bee9f3162ec029e" id="r_ada23ac2a4d9ed3b16bee9f3162ec029e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ada23ac2a4d9ed3b16bee9f3162ec029e">la_lapack_c::la_cunmhr</a> (side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:ada23ac2a4d9ed3b16bee9f3162ec029e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMHR: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H where Q is a complex unitary matrix of order nq, with nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of IHI-ILO elementary reflectors, as returned by CGEHRD: Q = H(ilo) H(ilo+1) . . . H(ihi-1).  <br /></td></tr>
<tr class="separator:ada23ac2a4d9ed3b16bee9f3162ec029e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783ddbc59751216f3b7c6012af2d568e" id="r_a783ddbc59751216f3b7c6012af2d568e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a783ddbc59751216f3b7c6012af2d568e">la_lapack_c::la_cunmtr</a> (side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a783ddbc59751216f3b7c6012af2d568e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMTR: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H where Q is a complex unitary matrix of order nq, with nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of nq-1 elementary reflectors, as returned by CHETRD: if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1); if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).  <br /></td></tr>
<tr class="separator:a783ddbc59751216f3b7c6012af2d568e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d3e74e202a2832b96dcf133d250462" id="r_a68d3e74e202a2832b96dcf133d250462"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a68d3e74e202a2832b96dcf133d250462">la_lapack_c::la_cupgtr</a> (uplo, n, ap, tau, q, ldq, work, info)</td></tr>
<tr class="memdesc:a68d3e74e202a2832b96dcf133d250462"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUPGTR: generates a complex unitary matrix Q which is defined as the product of n-1 elementary reflectors H(i) of order n, as returned by CHPTRD using packed storage: if UPLO = 'U', Q = H(n-1) . . . H(2) H(1), if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).  <br /></td></tr>
<tr class="separator:a68d3e74e202a2832b96dcf133d250462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656ae6ba2215535bf9649f9f59060804" id="r_a656ae6ba2215535bf9649f9f59060804"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a656ae6ba2215535bf9649f9f59060804">la_lapack_c::la_cupmtr</a> (side, uplo, trans, m, n, ap, tau, c, ldc, work, info)</td></tr>
<tr class="memdesc:a656ae6ba2215535bf9649f9f59060804"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUPMTR: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H where Q is a complex unitary matrix of order nq, with nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of nq-1 elementary reflectors, as returned by CHPTRD using packed storage: if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1); if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).  <br /></td></tr>
<tr class="separator:a656ae6ba2215535bf9649f9f59060804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9a25848b91dfa4c60c7434a62a045d" id="r_a8a9a25848b91dfa4c60c7434a62a045d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a8a9a25848b91dfa4c60c7434a62a045d">la_lapack_c::la_cgbbrd</a> (vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork, info)</td></tr>
<tr class="memdesc:a8a9a25848b91dfa4c60c7434a62a045d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBBRD: reduces a complex general m-by-n band matrix A to real upper bidiagonal form B by a unitary transformation: Q**H * A * P = B. The routine computes B, and optionally forms Q or P**H, or computes Q**H*C for a given matrix C.  <br /></td></tr>
<tr class="separator:a8a9a25848b91dfa4c60c7434a62a045d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fc4e5e8d7f71f8e64c419fb5b7979e" id="r_ad8fc4e5e8d7f71f8e64c419fb5b7979e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad8fc4e5e8d7f71f8e64c419fb5b7979e">la_lapack_c::la_cgbrfs</a> (trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:ad8fc4e5e8d7f71f8e64c419fb5b7979e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBRFS: improves the computed solution to a system of linear equations when the coefficient matrix is banded, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:ad8fc4e5e8d7f71f8e64c419fb5b7979e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c36297435a63273a164d37faaa7d6a1" id="r_a0c36297435a63273a164d37faaa7d6a1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0c36297435a63273a164d37faaa7d6a1">la_lapack_c::la_cgbsv</a> (n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:a0c36297435a63273a164d37faaa7d6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBSV: computes the solution to a complex system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a0c36297435a63273a164d37faaa7d6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9333eaefc5d63c3cffa41878e6f84614" id="r_a9333eaefc5d63c3cffa41878e6f84614"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9333eaefc5d63c3cffa41878e6f84614">la_lapack_c::la_cgbsvx</a> (fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a9333eaefc5d63c3cffa41878e6f84614"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBSVX: uses the LU factorization to compute the solution to a complex system of linear equations A * X = B, A**T * X = B, or A**H * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a9333eaefc5d63c3cffa41878e6f84614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1703a4afdd140849897c71ddb7d8250c" id="r_a1703a4afdd140849897c71ddb7d8250c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1703a4afdd140849897c71ddb7d8250c">la_lapack_c::la_cgebrd</a> (m, n, a, lda, d, e, tauq, taup, work, lwork, info)</td></tr>
<tr class="memdesc:a1703a4afdd140849897c71ddb7d8250c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEBRD: reduces a general complex M-by-N matrix A to upper or lower bidiagonal form B by a unitary transformation: Q**H * A * P = B. If m &gt;= n, B is upper bidiagonal; if m &lt; n, B is lower bidiagonal.  <br /></td></tr>
<tr class="separator:a1703a4afdd140849897c71ddb7d8250c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f91075fc3e1c38039b9e5466280e5f" id="r_a82f91075fc3e1c38039b9e5466280e5f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a82f91075fc3e1c38039b9e5466280e5f">la_lapack_c::la_cgehrd</a> (n, ilo, ihi, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a82f91075fc3e1c38039b9e5466280e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEHRD: reduces a complex general matrix A to upper Hessenberg form H by an unitary similarity transformation: Q**H * A * Q = H .  <br /></td></tr>
<tr class="separator:a82f91075fc3e1c38039b9e5466280e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40976d6222f4b8a8ca3bb97a0599c254" id="r_a40976d6222f4b8a8ca3bb97a0599c254"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a40976d6222f4b8a8ca3bb97a0599c254">la_lapack_c::la_cgelqt</a> (m, n, mb, a, lda, t, ldt, work, info)</td></tr>
<tr class="memdesc:a40976d6222f4b8a8ca3bb97a0599c254"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGELQT: computes a blocked LQ factorization of a complex M-by-N matrix A using the compact WY representation of Q.  <br /></td></tr>
<tr class="separator:a40976d6222f4b8a8ca3bb97a0599c254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad817d682cf79e19f9dd665705ed88d84" id="r_ad817d682cf79e19f9dd665705ed88d84"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad817d682cf79e19f9dd665705ed88d84">la_lapack_c::la_cgels</a> (trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:ad817d682cf79e19f9dd665705ed88d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGELS: solves overdetermined or underdetermined complex linear systems involving an M-by-N matrix A, or its conjugate-transpose, using a QR or LQ factorization of A. It is assumed that A has full rank. The following options are provided:  <br /></td></tr>
<tr class="separator:ad817d682cf79e19f9dd665705ed88d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66a27a724096e54a2886f9911ccd913" id="r_af66a27a724096e54a2886f9911ccd913"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af66a27a724096e54a2886f9911ccd913">la_lapack_c::la_cgeqp3</a> (m, n, a, lda, jpvt, tau, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:af66a27a724096e54a2886f9911ccd913"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQP3: computes a QR factorization with column pivoting of a matrix A: A*P = Q*R using Level 3 BLAS.  <br /></td></tr>
<tr class="separator:af66a27a724096e54a2886f9911ccd913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda87e730d08f589617b2357f2b0a63e" id="r_adda87e730d08f589617b2357f2b0a63e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#adda87e730d08f589617b2357f2b0a63e">la_lapack_c::la_cgeqrt</a> (m, n, nb, a, lda, t, ldt, work, info)</td></tr>
<tr class="memdesc:adda87e730d08f589617b2357f2b0a63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQRT: computes a blocked QR factorization of a complex M-by-N matrix A using the compact WY representation of Q.  <br /></td></tr>
<tr class="separator:adda87e730d08f589617b2357f2b0a63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aef023646c85dc693384469f46a9260" id="r_a5aef023646c85dc693384469f46a9260"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5aef023646c85dc693384469f46a9260">la_lapack_c::la_cgerfs</a> (trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a5aef023646c85dc693384469f46a9260"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGERFS: improves the computed solution to a system of linear equations and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:a5aef023646c85dc693384469f46a9260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80cd4ff059dbb47c92f96c303b3d69e" id="r_aa80cd4ff059dbb47c92f96c303b3d69e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa80cd4ff059dbb47c92f96c303b3d69e">la_lapack_c::la_cgetrf</a> (m, n, a, lda, ipiv, info)</td></tr>
<tr class="memdesc:aa80cd4ff059dbb47c92f96c303b3d69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETRF: computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n). This is the right-looking Level 3 BLAS version of the algorithm.  <br /></td></tr>
<tr class="separator:aa80cd4ff059dbb47c92f96c303b3d69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bb644094dfc4ca384556f9b47592a6" id="r_aa1bb644094dfc4ca384556f9b47592a6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa1bb644094dfc4ca384556f9b47592a6">la_lapack_c::la_cggglm</a> (n, m, p, a, lda, b, ldb, d, x, y, work, lwork, info)</td></tr>
<tr class="memdesc:aa1bb644094dfc4ca384556f9b47592a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGGLM: solves a general Gauss-Markov linear model (GLM) problem: minimize || y ||_2 subject to d = A*x + B*y x where A is an N-by-M matrix, B is an N-by-P matrix, and d is a given N-vector. It is assumed that M &lt;= N &lt;= M+P, and rank(A) = M and rank( A B ) = N. Under these assumptions, the constrained equation is always consistent, and there is a unique solution x and a minimal 2-norm solution y, which is obtained using a generalized QR factorization of the matrices (A, B) given by A = Q*(R), B = Q*T*Z. (0) In particular, if matrix B is square nonsingular, then the problem GLM is equivalent to the following weighted linear least squares problem minimize || inv(B)*(d-A*x) ||_2 x where inv(B) denotes the inverse of B.  <br /></td></tr>
<tr class="separator:aa1bb644094dfc4ca384556f9b47592a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6cb1d00b3e0469bb8414989aa99d87" id="r_a6e6cb1d00b3e0469bb8414989aa99d87"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6e6cb1d00b3e0469bb8414989aa99d87">la_lapack_c::la_cgghd3</a> (compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork, info)</td></tr>
<tr class="memdesc:a6e6cb1d00b3e0469bb8414989aa99d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGHD3: reduces a pair of complex matrices (A,B) to generalized upper Hessenberg form using unitary transformations, where A is a general matrix and B is upper triangular. The form of the generalized eigenvalue problem is A*x = lambda*B*x, and B is typically made upper triangular by computing its QR factorization and moving the unitary matrix Q to the left side of the equation. This subroutine simultaneously reduces A to a Hessenberg matrix H: Q**H*A*Z = H and transforms B to another upper triangular matrix T: Q**H*B*Z = T in order to reduce the problem to its standard form H*y = lambda*T*y where y = Z**H*x. The unitary matrices Q and Z are determined as products of Givens rotations. They may either be formed explicitly, or they may be postmultiplied into input matrices Q1 and Z1, so that Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H If Q1 is the unitary matrix from the QR factorization of B in the original equation A*x = lambda*B*x, then CGGHD3 reduces the original problem to generalized Hessenberg form. This is a blocked variant of CGGHRD, using matrix-matrix multiplications for parts of the computation to enhance performance.  <br /></td></tr>
<tr class="separator:a6e6cb1d00b3e0469bb8414989aa99d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24364d871feb5c3c3ba6430a4d699e0f" id="r_a24364d871feb5c3c3ba6430a4d699e0f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a24364d871feb5c3c3ba6430a4d699e0f">la_lapack_c::la_cgglse</a> (m, n, p, a, lda, b, ldb, c, d, x, work, lwork, info)</td></tr>
<tr class="memdesc:a24364d871feb5c3c3ba6430a4d699e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGLSE: solves the linear equality-constrained least squares (LSE) problem: minimize || c - A*x ||_2 subject to B*x = d where A is an M-by-N matrix, B is a P-by-N matrix, c is a given M-vector, and d is a given P-vector. It is assumed that P &lt;= N &lt;= M+P, and rank(B) = P and rank( (A) ) = N. ( (B) ) These conditions ensure that the LSE problem has a unique solution, which is obtained using a generalized RQ factorization of the matrices (B, A) given by B = (0 R)*Q, A = Z*T*Q.  <br /></td></tr>
<tr class="separator:a24364d871feb5c3c3ba6430a4d699e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8052a4a58237fb0cbd659eb9fd8e1f" id="r_a2e8052a4a58237fb0cbd659eb9fd8e1f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2e8052a4a58237fb0cbd659eb9fd8e1f">la_lapack_c::la_cgtcon</a> (norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, info)</td></tr>
<tr class="memdesc:a2e8052a4a58237fb0cbd659eb9fd8e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGTCON: estimates the reciprocal of the condition number of a complex tridiagonal matrix A using the LU factorization as computed by CGTTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a2e8052a4a58237fb0cbd659eb9fd8e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4458295a969884700a2ac5972255630" id="r_ab4458295a969884700a2ac5972255630"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab4458295a969884700a2ac5972255630">la_lapack_c::la_cgtrfs</a> (trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:ab4458295a969884700a2ac5972255630"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGTRFS: improves the computed solution to a system of linear equations when the coefficient matrix is tridiagonal, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:ab4458295a969884700a2ac5972255630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40b4d279da73061dace955cc3dceaae" id="r_ad40b4d279da73061dace955cc3dceaae"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad40b4d279da73061dace955cc3dceaae">la_lapack_c::la_cgtsvx</a> (fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:ad40b4d279da73061dace955cc3dceaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGTSVX: uses the LU factorization to compute the solution to a complex system of linear equations A * X = B, A**T * X = B, or A**H * X = B, where A is a tridiagonal matrix of order N and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:ad40b4d279da73061dace955cc3dceaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bd5d4431a52957b5e226fb26789fbc" id="r_a26bd5d4431a52957b5e226fb26789fbc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a26bd5d4431a52957b5e226fb26789fbc">la_lapack_c::la_chbgst</a> (vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork, info)</td></tr>
<tr class="memdesc:a26bd5d4431a52957b5e226fb26789fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHBGST: reduces a complex Hermitian-definite banded generalized eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y, such that C has the same bandwidth as A. B must have been previously factorized as S**H*S by CPBSTF, using a split Cholesky factorization. A is overwritten by C = X**H*A*X, where X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the bandwidth of A.  <br /></td></tr>
<tr class="separator:a26bd5d4431a52957b5e226fb26789fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4288395185918a46b8f27ef21c838516" id="r_a4288395185918a46b8f27ef21c838516"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4288395185918a46b8f27ef21c838516">la_lapack_c::la_chbtrd</a> (vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work, info)</td></tr>
<tr class="memdesc:a4288395185918a46b8f27ef21c838516"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHBTRD: reduces a complex Hermitian band matrix A to real symmetric tridiagonal form T by a unitary similarity transformation: Q**H * A * Q = T.  <br /></td></tr>
<tr class="separator:a4288395185918a46b8f27ef21c838516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec737bead552d92664a4a2e1f62bb1" id="r_abfec737bead552d92664a4a2e1f62bb1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abfec737bead552d92664a4a2e1f62bb1">la_lapack_c::la_checon</a> (uplo, n, a, lda, ipiv, anorm, rcond, work, info)</td></tr>
<tr class="memdesc:abfec737bead552d92664a4a2e1f62bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECON: estimates the reciprocal of the condition number of a complex Hermitian matrix A using the factorization A = U*D*U**H or A = L*D*L**H computed by CHETRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:abfec737bead552d92664a4a2e1f62bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3854b0eb7e3edd4385c2ffee85232cbd" id="r_a3854b0eb7e3edd4385c2ffee85232cbd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a3854b0eb7e3edd4385c2ffee85232cbd">la_lapack_c::la_checon_rook</a> (uplo, n, a, lda, ipiv, anorm, rcond, work, info)</td></tr>
<tr class="memdesc:a3854b0eb7e3edd4385c2ffee85232cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECON_ROOK: estimates the reciprocal of the condition number of a complex Hermitian matrix A using the factorization A = U*D*U**H or A = L*D*L**H computed by CHETRF_ROOK. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a3854b0eb7e3edd4385c2ffee85232cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc2ccb363ea7046570eb4c24c01b6fe" id="r_a1cc2ccb363ea7046570eb4c24c01b6fe"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1cc2ccb363ea7046570eb4c24c01b6fe">la_lapack_c::la_cheev</a> (jobz, uplo, n, a, lda, w, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:a1cc2ccb363ea7046570eb4c24c01b6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEEV: computes all eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A.  <br /></td></tr>
<tr class="separator:a1cc2ccb363ea7046570eb4c24c01b6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed4079b9bc2d429d063a5860ef596e2" id="r_a2ed4079b9bc2d429d063a5860ef596e2"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2ed4079b9bc2d429d063a5860ef596e2">la_lapack_c::la_cheevr</a> (jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a2ed4079b9bc2d429d063a5860ef596e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEEVR: computes selected eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues. CHEEVR first reduces the matrix A to tridiagonal form T with a call to CHETRD. Then, whenever possible, CHEEVR calls CSTEMR to compute the eigenspectrum using Relatively Robust Representations. CSTEMR computes eigenvalues by the dqds algorithm, while orthogonal eigenvectors are computed from various "good" L D L^T representations (also known as Relatively Robust Representations). Gram-Schmidt orthogonalization is avoided as far as possible. More specifically, the various steps of the algorithm are as follows. For each unreduced block (submatrix) of T, (a) Compute T - sigma I = L D L^T, so that L and D define all the wanted eigenvalues to high relative accuracy. This means that small relative changes in the entries of D and L cause only small relative changes in the eigenvalues and eigenvectors. The standard (unfactored) representation of the tridiagonal matrix T does not have this property in general. (b) Compute the eigenvalues to suitable accuracy. If the eigenvectors are desired, the algorithm attains full accuracy of the computed eigenvalues only right before the corresponding vectors have to be computed, see steps c) and d). (c) For each cluster of close eigenvalues, select a new shift close to the cluster, find a new factorization, and refine the shifted eigenvalues to suitable accuracy. (d) For each eigenvalue with a large enough relative separation compute the corresponding eigenvector by forming a rank revealing twisted factorization. Go back to (c) for any clusters that remain. The desired accuracy of the output can be specified by the input parameter ABSTOL. For more details, see CSTEMR's documentation and:  <br /></td></tr>
<tr class="separator:a2ed4079b9bc2d429d063a5860ef596e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13d62715c54adadf65ace1fabc5f043" id="r_ab13d62715c54adadf65ace1fabc5f043"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab13d62715c54adadf65ace1fabc5f043">la_lapack_c::la_cheevx</a> (jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail, info)</td></tr>
<tr class="memdesc:ab13d62715c54adadf65ace1fabc5f043"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEEVX: computes selected eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:ab13d62715c54adadf65ace1fabc5f043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43a4b508be56e756e95285bb1006441" id="r_ad43a4b508be56e756e95285bb1006441"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad43a4b508be56e756e95285bb1006441">la_lapack_c::la_chegv</a> (itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:ad43a4b508be56e756e95285bb1006441"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEGV: computes all the eigenvalues, and optionally, the eigenvectors of a complex generalized Hermitian-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be Hermitian and B is also positive definite.  <br /></td></tr>
<tr class="separator:ad43a4b508be56e756e95285bb1006441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae02bf539af4d8856a7155beb11ca3b" id="r_a1ae02bf539af4d8856a7155beb11ca3b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1ae02bf539af4d8856a7155beb11ca3b">la_lapack_c::la_chegvx</a> (itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail, info)</td></tr>
<tr class="memdesc:a1ae02bf539af4d8856a7155beb11ca3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEGVX: computes selected eigenvalues, and optionally, eigenvectors of a complex generalized Hermitian-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be Hermitian and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:a1ae02bf539af4d8856a7155beb11ca3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50503b061ba9770e565289d9c192c86e" id="r_a50503b061ba9770e565289d9c192c86e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a50503b061ba9770e565289d9c192c86e">la_lapack_c::la_cherfs</a> (uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a50503b061ba9770e565289d9c192c86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHERFS: improves the computed solution to a system of linear equations when the coefficient matrix is Hermitian indefinite, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:a50503b061ba9770e565289d9c192c86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42305897dcd51c3d54c0c2958c1c845" id="r_ae42305897dcd51c3d54c0c2958c1c845"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae42305897dcd51c3d54c0c2958c1c845">la_lapack_c::la_chesv</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:ae42305897dcd51c3d54c0c2958c1c845"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHESV: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS matrices. The diagonal pivoting method is used to factor A as A = U * D * U**H, if UPLO = 'U', or A = L * D * L**H, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:ae42305897dcd51c3d54c0c2958c1c845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8599fd84e4b8d56b57b0f55738bd571f" id="r_a8599fd84e4b8d56b57b0f55738bd571f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a8599fd84e4b8d56b57b0f55738bd571f">la_lapack_c::la_chesv_rk</a> (uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a8599fd84e4b8d56b57b0f55738bd571f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHESV_RK: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS matrices. The bounded Bunch-Kaufman (rook) diagonal pivoting method is used to factor A as A = P*U*D*(U**H)*(P**T), if UPLO = 'U', or A = P*L*D*(L**H)*(P**T), if UPLO = 'L', where U (or L) is unit upper (or lower) triangular matrix, U**H (or L**H) is the conjugate of U (or L), P is a permutation matrix, P**T is the transpose of P, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. CHETRF_RK is called to compute the factorization of a complex Hermitian matrix. The factored form of A is then used to solve the system of equations A * X = B by calling BLAS3 routine CHETRS_3.  <br /></td></tr>
<tr class="separator:a8599fd84e4b8d56b57b0f55738bd571f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01abdd3c157ef1e602e905fc1b754bf6" id="r_a01abdd3c157ef1e602e905fc1b754bf6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a01abdd3c157ef1e602e905fc1b754bf6">la_lapack_c::la_chesv_rook</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a01abdd3c157ef1e602e905fc1b754bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHESV_ROOK: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS matrices. The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used to factor A as A = U * D * U**T, if UPLO = 'U', or A = L * D * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. CHETRF_ROOK is called to compute the factorization of a complex Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting method. The factored form of A is then used to solve the system of equations A * X = B by calling CHETRS_ROOK (uses BLAS 2).  <br /></td></tr>
<tr class="separator:a01abdd3c157ef1e602e905fc1b754bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3b484d01fe715d024a8e6339e57553" id="r_aee3b484d01fe715d024a8e6339e57553"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aee3b484d01fe715d024a8e6339e57553">la_lapack_c::la_chesvx</a> (fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:aee3b484d01fe715d024a8e6339e57553"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHESVX: uses the diagonal pivoting factorization to compute the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:aee3b484d01fe715d024a8e6339e57553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc87397c2fbccecf4934eba0fdb5ba8" id="r_adcc87397c2fbccecf4934eba0fdb5ba8"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#adcc87397c2fbccecf4934eba0fdb5ba8">la_lapack_c::la_chgeqz</a> (job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:adcc87397c2fbccecf4934eba0fdb5ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHGEQZ: computes the eigenvalues of a complex matrix pair (H,T), where H is an upper Hessenberg matrix and T is upper triangular, using the single-shift QZ method. Matrix pairs of this type are produced by the reduction to generalized upper Hessenberg form of a complex matrix pair (A,B): A = Q1*H*Z1**H, B = Q1*T*Z1**H, as computed by CGGHRD. If JOB='S', then the Hessenberg-triangular pair (H,T) is also reduced to generalized Schur form, H = Q*S*Z**H, T = Q*P*Z**H, where Q and Z are unitary matrices and S and P are upper triangular. Optionally, the unitary matrix Q from the generalized Schur factorization may be postmultiplied into an input matrix Q1, and the unitary matrix Z may be postmultiplied into an input matrix Z1. If Q1 and Z1 are the unitary matrices from CGGHRD that reduced the matrix pair (A,B) to generalized Hessenberg form, then the output matrices Q1*Q and Z1*Z are the unitary factors from the generalized Schur factorization of (A,B): A = (Q1*Q)*S*(Z1*Z)**H, B = (Q1*Q)*P*(Z1*Z)**H. To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently, of (A,B)) are computed as a pair of complex values (alpha,beta). If beta is nonzero, lambda = alpha / beta is an eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP) A*x = lambda*B*x and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the alternate form of the GNEP mu*A*y = B*y. The values of alpha and beta for the i-th eigenvalue can be read directly from the generalized Schur form: alpha = S(i,i), beta = P(i,i). Ref: C.B. Moler Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973), pp. 241&ndash;256.  <br /></td></tr>
<tr class="separator:adcc87397c2fbccecf4934eba0fdb5ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881f9d46a60a0d8f077de89d4dcce79f" id="r_a881f9d46a60a0d8f077de89d4dcce79f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a881f9d46a60a0d8f077de89d4dcce79f">la_lapack_c::la_chpcon</a> (uplo, n, ap, ipiv, anorm, rcond, work, info)</td></tr>
<tr class="memdesc:a881f9d46a60a0d8f077de89d4dcce79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPCON: estimates the reciprocal of the condition number of a complex Hermitian packed matrix A using the factorization A = U*D*U**H or A = L*D*L**H computed by CHPTRF. An estimate is obtained for norm(inv(A)), and the reciprocal of the condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).  <br /></td></tr>
<tr class="separator:a881f9d46a60a0d8f077de89d4dcce79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fc99ec544bc235ae45930509b15270" id="r_a97fc99ec544bc235ae45930509b15270"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a97fc99ec544bc235ae45930509b15270">la_lapack_c::la_chpev</a> (jobz, uplo, n, ap, w, z, ldz, work, rwork, info)</td></tr>
<tr class="memdesc:a97fc99ec544bc235ae45930509b15270"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPEV: computes all the eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix in packed storage.  <br /></td></tr>
<tr class="separator:a97fc99ec544bc235ae45930509b15270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efd5e5a37591101d076fc2590a3a3fa" id="r_a5efd5e5a37591101d076fc2590a3a3fa"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5efd5e5a37591101d076fc2590a3a3fa">la_lapack_c::la_chpevx</a> (jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail, info)</td></tr>
<tr class="memdesc:a5efd5e5a37591101d076fc2590a3a3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPEVX: computes selected eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A in packed storage. Eigenvalues/vectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:a5efd5e5a37591101d076fc2590a3a3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8ce56f9a318aebe43d759f5fdfd8a9" id="r_abd8ce56f9a318aebe43d759f5fdfd8a9"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abd8ce56f9a318aebe43d759f5fdfd8a9">la_lapack_c::la_chpgv</a> (itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork, info)</td></tr>
<tr class="memdesc:abd8ce56f9a318aebe43d759f5fdfd8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPGV: computes all the eigenvalues and, optionally, the eigenvectors of a complex generalized Hermitian-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be Hermitian, stored in packed format, and B is also positive definite.  <br /></td></tr>
<tr class="separator:abd8ce56f9a318aebe43d759f5fdfd8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cc3980fb6b3efcc29c5fcb79553e58" id="r_a91cc3980fb6b3efcc29c5fcb79553e58"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a91cc3980fb6b3efcc29c5fcb79553e58">la_lapack_c::la_chpgvx</a> (itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail, info)</td></tr>
<tr class="memdesc:a91cc3980fb6b3efcc29c5fcb79553e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPGVX: computes selected eigenvalues and, optionally, eigenvectors of a complex generalized Hermitian-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be Hermitian, stored in packed format, and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:a91cc3980fb6b3efcc29c5fcb79553e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4359d77e0c6f6acba1449ff21da1eb3d" id="r_a4359d77e0c6f6acba1449ff21da1eb3d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4359d77e0c6f6acba1449ff21da1eb3d">la_lapack_c::la_chprfs</a> (uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a4359d77e0c6f6acba1449ff21da1eb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPRFS: improves the computed solution to a system of linear equations when the coefficient matrix is Hermitian indefinite and packed, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:a4359d77e0c6f6acba1449ff21da1eb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcbf53bda33508b647f89708ac5af5c" id="r_abfcbf53bda33508b647f89708ac5af5c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abfcbf53bda33508b647f89708ac5af5c">la_lapack_c::la_chpsv</a> (uplo, n, nrhs, ap, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:abfcbf53bda33508b647f89708ac5af5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPSV: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian matrix stored in packed format and X and B are N-by-NRHS matrices. The diagonal pivoting method is used to factor A as A = U * D * U**H, if UPLO = 'U', or A = L * D * L**H, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, D is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:abfcbf53bda33508b647f89708ac5af5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9eff521e7f6eef058455f2f27086e30" id="r_ac9eff521e7f6eef058455f2f27086e30"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac9eff521e7f6eef058455f2f27086e30">la_lapack_c::la_chpsvx</a> (fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:ac9eff521e7f6eef058455f2f27086e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPSVX: uses the diagonal pivoting factorization A = U*D*U**H or A = L*D*L**H to compute the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian matrix stored in packed format and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:ac9eff521e7f6eef058455f2f27086e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29f2a34e5b0db318b26f627d540231e" id="r_ab29f2a34e5b0db318b26f627d540231e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab29f2a34e5b0db318b26f627d540231e">la_lapack_c::la_chsein</a> (side, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr, info)</td></tr>
<tr class="memdesc:ab29f2a34e5b0db318b26f627d540231e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHSEIN: uses inverse iteration to find specified right and/or left eigenvectors of a complex upper Hessenberg matrix H. The right eigenvector x and the left eigenvector y of the matrix H corresponding to an eigenvalue w are defined by: H * x = w * x, y**h * H = w * y**h where y**h denotes the conjugate transpose of the vector y.  <br /></td></tr>
<tr class="separator:ab29f2a34e5b0db318b26f627d540231e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98a1d4772cb29d2889cecebacd5e0a5" id="r_aa98a1d4772cb29d2889cecebacd5e0a5"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa98a1d4772cb29d2889cecebacd5e0a5">la_lapack_c::la_claed0</a> (qsiz, n, d, e, q, ldq, qstore, ldqs, rwork, iwork, info)</td></tr>
<tr class="memdesc:aa98a1d4772cb29d2889cecebacd5e0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the divide and conquer method, CLAED0: computes all eigenvalues of a symmetric tridiagonal matrix which is one diagonal block of those from reducing a dense or band Hermitian matrix and corresponding eigenvectors of the dense or band matrix.  <br /></td></tr>
<tr class="separator:aa98a1d4772cb29d2889cecebacd5e0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adc5e3e50a52d8a0f552baca4213ab0" id="r_a6adc5e3e50a52d8a0f552baca4213ab0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6adc5e3e50a52d8a0f552baca4213ab0">la_lapack_c::la_clamswlq</a> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a6adc5e3e50a52d8a0f552baca4213ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAMSWLQ: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**H * C C * Q**H where Q is a complex unitary matrix defined as the product of blocked elementary reflectors computed by short wide LQ factorization (CLASWLQ)  <br /></td></tr>
<tr class="separator:a6adc5e3e50a52d8a0f552baca4213ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e107e1160048592f5b57f0706dd8400" id="r_a2e107e1160048592f5b57f0706dd8400"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2e107e1160048592f5b57f0706dd8400">la_lapack_c::la_clamtsqr</a> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a2e107e1160048592f5b57f0706dd8400"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAMTSQR: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H where Q is a complex unitary matrix defined as the product of blocked elementary reflectors computed by tall skinny QR factorization (CLATSQR)  <br /></td></tr>
<tr class="separator:a2e107e1160048592f5b57f0706dd8400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f317aef2255d912c3eef15d0eafab4" id="r_a98f317aef2255d912c3eef15d0eafab4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a98f317aef2255d912c3eef15d0eafab4">la_lapack_c::la_claqr2</a> (wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz, z, ldz, ns, nd, sh, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork)</td></tr>
<tr class="memdesc:a98f317aef2255d912c3eef15d0eafab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQR2: is identical to CLAQR3 except that it avoids recursion by calling CLAHQR instead of CLAQR4. Aggressive early deflation: This subroutine accepts as input an upper Hessenberg matrix H and performs an unitary similarity transformation designed to detect and deflate fully converged eigenvalues from a trailing principal submatrix. On output H has been over- written by a new Hessenberg matrix that is a perturbation of an unitary similarity transformation of H. It is to be hoped that the final version of H has many zero subdiagonal entries.  <br /></td></tr>
<tr class="separator:a98f317aef2255d912c3eef15d0eafab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f7cb4515ddf5565511306b2b62910b" id="r_a43f7cb4515ddf5565511306b2b62910b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a43f7cb4515ddf5565511306b2b62910b">la_lapack_c::la_claswlq</a> (m, n, mb, nb, a, lda, t, ldt, work, lwork, info)</td></tr>
<tr class="memdesc:a43f7cb4515ddf5565511306b2b62910b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLASWLQ: computes a blocked Tall-Skinny LQ factorization of a complex M-by-N matrix A for M &lt;= N: A = ( L 0 ) * Q, where: Q is a n-by-N orthogonal matrix, stored on exit in an implicit form in the elements above the diagonal of the array A and in the elements of the array T; L is a lower-triangular M-by-M matrix stored on exit in the elements on and below the diagonal of the array A. 0 is a M-by-(N-M) zero matrix, if M &lt; N, and is not stored.  <br /></td></tr>
<tr class="separator:a43f7cb4515ddf5565511306b2b62910b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb38af48ed330e4804e517cd706e48f" id="r_abcb38af48ed330e4804e517cd706e48f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abcb38af48ed330e4804e517cd706e48f">la_lapack_c::la_clatsqr</a> (m, n, mb, nb, a, lda, t, ldt, work, lwork, info)</td></tr>
<tr class="memdesc:abcb38af48ed330e4804e517cd706e48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLATSQR: computes a blocked Tall-Skinny QR factorization of a complex M-by-N matrix A for M &gt;= N: A = Q * ( R ), ( 0 ) where: Q is a M-by-M orthogonal matrix, stored on exit in an implicit form in the elements below the diagonal of the array A and in the elements of the array T; R is an upper-triangular N-by-N matrix, stored on exit in the elements on and above the diagonal of the array A. 0 is a (M-N)-by-N zero matrix, and is not stored.  <br /></td></tr>
<tr class="separator:abcb38af48ed330e4804e517cd706e48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae879b1ab9a62d7f6401a178abd1d2a9f" id="r_ae879b1ab9a62d7f6401a178abd1d2a9f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae879b1ab9a62d7f6401a178abd1d2a9f">la_lapack_c::la_cpbsv</a> (uplo, n, kd, nrhs, ab, ldab, b, ldb, info)</td></tr>
<tr class="memdesc:ae879b1ab9a62d7f6401a178abd1d2a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPBSV: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian positive definite band matrix and X and B are N-by-NRHS matrices. The Cholesky decomposition is used to factor A as A = U**H * U, if UPLO = 'U', or A = L * L**H, if UPLO = 'L', where U is an upper triangular band matrix, and L is a lower triangular band matrix, with the same number of superdiagonals or subdiagonals as A. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:ae879b1ab9a62d7f6401a178abd1d2a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ca6dc0260d35829e96551d93235ee0" id="r_a93ca6dc0260d35829e96551d93235ee0"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a93ca6dc0260d35829e96551d93235ee0">la_lapack_c::la_cpbsvx</a> (fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a93ca6dc0260d35829e96551d93235ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPBSVX: uses the Cholesky factorization A = U**H*U or A = L*L**H to compute the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian positive definite band matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a93ca6dc0260d35829e96551d93235ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cb32a7ccf16d73ca0759e0024d6025" id="r_a14cb32a7ccf16d73ca0759e0024d6025"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a14cb32a7ccf16d73ca0759e0024d6025">la_lapack_c::la_cpftrf</a> (transr, uplo, n, a, info)</td></tr>
<tr class="memdesc:a14cb32a7ccf16d73ca0759e0024d6025"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPFTRF: computes the Cholesky factorization of a complex Hermitian positive definite matrix A. The factorization has the form A = U**H * U, if UPLO = 'U', or A = L * L**H, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular. This is the block version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a14cb32a7ccf16d73ca0759e0024d6025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76eb8ee32e6e0df87436d9b12754bcef" id="r_a76eb8ee32e6e0df87436d9b12754bcef"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a76eb8ee32e6e0df87436d9b12754bcef">la_lapack_c::la_cpftri</a> (transr, uplo, n, a, info)</td></tr>
<tr class="memdesc:a76eb8ee32e6e0df87436d9b12754bcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPFTRI: computes the inverse of a complex Hermitian positive definite matrix A using the Cholesky factorization A = U**H*U or A = L*L**H computed by CPFTRF.  <br /></td></tr>
<tr class="separator:a76eb8ee32e6e0df87436d9b12754bcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344c1771f6c8e4d77213d3b58e17523d" id="r_a344c1771f6c8e4d77213d3b58e17523d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a344c1771f6c8e4d77213d3b58e17523d">la_lapack_c::la_cposv</a> (uplo, n, nrhs, a, lda, b, ldb, info)</td></tr>
<tr class="memdesc:a344c1771f6c8e4d77213d3b58e17523d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOSV: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian positive definite matrix and X and B are N-by-NRHS matrices. The Cholesky decomposition is used to factor A as A = U**H* U, if UPLO = 'U', or A = L * L**H, if UPLO = 'L', where U is an upper triangular matrix and L is a lower triangular matrix. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a344c1771f6c8e4d77213d3b58e17523d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab143174967ba8c9ac2c40c2cb6681149" id="r_ab143174967ba8c9ac2c40c2cb6681149"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab143174967ba8c9ac2c40c2cb6681149">la_lapack_c::la_cposvx</a> (fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:ab143174967ba8c9ac2c40c2cb6681149"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOSVX: uses the Cholesky factorization A = U**H*U or A = L*L**H to compute the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian positive definite matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:ab143174967ba8c9ac2c40c2cb6681149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bb9d1704be1674d3e1c2f2ad194212" id="r_a32bb9d1704be1674d3e1c2f2ad194212"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a32bb9d1704be1674d3e1c2f2ad194212">la_lapack_c::la_cptrfs</a> (uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a32bb9d1704be1674d3e1c2f2ad194212"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPTRFS: improves the computed solution to a system of linear equations when the coefficient matrix is Hermitian positive definite and tridiagonal, and provides error bounds and backward error estimates for the solution.  <br /></td></tr>
<tr class="separator:a32bb9d1704be1674d3e1c2f2ad194212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a43d9aa8488e793cd715fe2efba0be4" id="r_a2a43d9aa8488e793cd715fe2efba0be4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2a43d9aa8488e793cd715fe2efba0be4">la_lapack_c::la_cptsv</a> (n, nrhs, d, e, b, ldb, info)</td></tr>
<tr class="memdesc:a2a43d9aa8488e793cd715fe2efba0be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPTSV: computes the solution to a complex system of linear equations A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal matrix, and X and B are N-by-NRHS matrices. A is factored as A = L*D*L**H, and the factored form of A is then used to solve the system of equations.  <br /></td></tr>
<tr class="separator:a2a43d9aa8488e793cd715fe2efba0be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46630a4a6f97f2d75067a5e2812a2689" id="r_a46630a4a6f97f2d75067a5e2812a2689"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a46630a4a6f97f2d75067a5e2812a2689">la_lapack_c::la_cptsvx</a> (fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:a46630a4a6f97f2d75067a5e2812a2689"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPTSVX: uses the factorization A = L*D*L**H to compute the solution to a complex system of linear equations A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:a46630a4a6f97f2d75067a5e2812a2689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482918edd67c5fd4ea9f34e59c71f902" id="r_a482918edd67c5fd4ea9f34e59c71f902"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a482918edd67c5fd4ea9f34e59c71f902">la_lapack_c::la_cstedc</a> (compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a482918edd67c5fd4ea9f34e59c71f902"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSTEDC: computes all eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. The eigenvectors of a full or band complex Hermitian matrix can also be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this matrix to tridiagonal form. This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See SLAED3 for details.  <br /></td></tr>
<tr class="separator:a482918edd67c5fd4ea9f34e59c71f902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17d9ecbbb477269e72325130ec0943b" id="r_ad17d9ecbbb477269e72325130ec0943b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad17d9ecbbb477269e72325130ec0943b">la_lapack_c::la_cstegr</a> (jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:ad17d9ecbbb477269e72325130ec0943b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSTEGR: computes selected eigenvalues and, optionally, eigenvectors of a real symmetric tridiagonal matrix T. Any such unreduced matrix has a well defined set of pairwise different real eigenvalues, the corresponding real eigenvectors are pairwise orthogonal. The spectrum may be computed either completely or partially by specifying either an interval (VL,VU] or a range of indices IL:IU for the desired eigenvalues. CSTEGR is a compatibility wrapper around the improved CSTEMR routine. See SSTEMR for further details. One important change is that the ABSTOL parameter no longer provides any benefit and hence is no longer used. Note : CSTEGR and CSTEMR work only on machines which follow IEEE-754 floating-point standard in their handling of infinities and NaNs. Normal execution may create these exceptiona values and hence may abort due to a floating point exception in environments which do not conform to the IEEE-754 standard.  <br /></td></tr>
<tr class="separator:ad17d9ecbbb477269e72325130ec0943b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bbd95b8eb48f4f05849c061976122d" id="r_a01bbd95b8eb48f4f05849c061976122d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a01bbd95b8eb48f4f05849c061976122d">la_lapack_c::la_ctgsen</a> (ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a01bbd95b8eb48f4f05849c061976122d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTGSEN: reorders the generalized Schur decomposition of a complex matrix pair (A, B) (in terms of an unitary equivalence trans- formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the pair (A,B). The leading columns of Q and Z form unitary bases of the corresponding left and right eigenspaces (deflating subspaces). (A, B) must be in generalized Schur canonical form, that is, A and B are both upper triangular. CTGSEN also computes the generalized eigenvalues w(j)= ALPHA(j) / BETA(j) of the reordered matrix pair (A, B). Optionally, the routine computes estimates of reciprocal condition numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11), (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s) between the matrix pairs (A11, B11) and (A22,B22) that correspond to the selected cluster and the eigenvalues outside the cluster, resp., and norms of "projections" onto left and right eigenspaces w.r.t. the selected cluster in the (1,1)-block.  <br /></td></tr>
<tr class="separator:a01bbd95b8eb48f4f05849c061976122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34f17bf9a42f6fe38b080745615cc19" id="r_ac34f17bf9a42f6fe38b080745615cc19"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac34f17bf9a42f6fe38b080745615cc19">la_lapack_c::la_ctgsna</a> (job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork, info)</td></tr>
<tr class="memdesc:ac34f17bf9a42f6fe38b080745615cc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTGSNA: estimates reciprocal condition numbers for specified eigenvalues and/or eigenvectors of a matrix pair (A, B). (A, B) must be in generalized Schur canonical form, that is, A and B are both upper triangular.  <br /></td></tr>
<tr class="separator:ac34f17bf9a42f6fe38b080745615cc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6505f76fcce1e08da25490139e0e80b" id="r_ad6505f76fcce1e08da25490139e0e80b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad6505f76fcce1e08da25490139e0e80b">la_lapack_c::la_ctrsen</a> (job, compq, select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork, info)</td></tr>
<tr class="memdesc:ad6505f76fcce1e08da25490139e0e80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTRSEN: reorders the Schur factorization of a complex matrix A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in the leading positions on the diagonal of the upper triangular matrix T, and the leading columns of Q form an orthonormal basis of the corresponding right invariant subspace. Optionally the routine computes the reciprocal condition numbers of the cluster of eigenvalues and/or the invariant subspace.  <br /></td></tr>
<tr class="separator:ad6505f76fcce1e08da25490139e0e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e6037273bf4d4e2fdfffeffb84e54c" id="r_a03e6037273bf4d4e2fdfffeffb84e54c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a03e6037273bf4d4e2fdfffeffb84e54c">la_lapack_c::la_cunbdb1</a> (m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info)</td></tr>
<tr class="memdesc:a03e6037273bf4d4e2fdfffeffb84e54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNBDB1: simultaneously bidiagonalizes the blocks of a tall and skinny matrix X with orthonomal columns: [ B11 ] [ X11 ] [ P1 | ] [ 0 ] [--&mdash;] = [------&mdash;] [--&mdash;] Q1**T . [ X21 ] [ | P2 ] [ B21 ] [ 0 ] X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P, M-P, or M-Q. Routines CUNBDB2, CUNBDB3, and CUNBDB4 handle cases in which Q is not the minimum dimension. The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P), and (M-Q)-by-(M-Q), respectively. They are represented implicitly by Householder vectors. B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by angles THETA, PHI.  <br /></td></tr>
<tr class="separator:a03e6037273bf4d4e2fdfffeffb84e54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a32457c753942312da7f2ef26d01504" id="r_a4a32457c753942312da7f2ef26d01504"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a4a32457c753942312da7f2ef26d01504">la_lapack_c::la_cunbdb2</a> (m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info)</td></tr>
<tr class="memdesc:a4a32457c753942312da7f2ef26d01504"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNBDB2: simultaneously bidiagonalizes the blocks of a tall and skinny matrix X with orthonomal columns: [ B11 ] [ X11 ] [ P1 | ] [ 0 ] [--&mdash;] = [------&mdash;] [--&mdash;] Q1**T . [ X21 ] [ | P2 ] [ B21 ] [ 0 ] X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P, Q, or M-Q. Routines CUNBDB1, CUNBDB3, and CUNBDB4 handle cases in which P is not the minimum dimension. The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P), and (M-Q)-by-(M-Q), respectively. They are represented implicitly by Householder vectors. B11 and B12 are P-by-P bidiagonal matrices represented implicitly by angles THETA, PHI.  <br /></td></tr>
<tr class="separator:a4a32457c753942312da7f2ef26d01504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76817f254e9c4263ad3ff09f7c8191d" id="r_ac76817f254e9c4263ad3ff09f7c8191d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac76817f254e9c4263ad3ff09f7c8191d">la_lapack_c::la_cunbdb3</a> (m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, work, lwork, info)</td></tr>
<tr class="memdesc:ac76817f254e9c4263ad3ff09f7c8191d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNBDB3: simultaneously bidiagonalizes the blocks of a tall and skinny matrix X with orthonomal columns: [ B11 ] [ X11 ] [ P1 | ] [ 0 ] [--&mdash;] = [------&mdash;] [--&mdash;] Q1**T . [ X21 ] [ | P2 ] [ B21 ] [ 0 ] X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P, Q, or M-Q. Routines CUNBDB1, CUNBDB2, and CUNBDB4 handle cases in which M-P is not the minimum dimension. The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P), and (M-Q)-by-(M-Q), respectively. They are represented implicitly by Householder vectors. B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented implicitly by angles THETA, PHI.  <br /></td></tr>
<tr class="separator:ac76817f254e9c4263ad3ff09f7c8191d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08ebc964287787c80fe14394f4c70dd" id="r_af08ebc964287787c80fe14394f4c70dd"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af08ebc964287787c80fe14394f4c70dd">la_lapack_c::la_cunbdb4</a> (m, p, q, x11, ldx11, x21, ldx21, theta, phi, taup1, taup2, tauq1, phantom, work, lwork, info)</td></tr>
<tr class="memdesc:af08ebc964287787c80fe14394f4c70dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNBDB4: simultaneously bidiagonalizes the blocks of a tall and skinny matrix X with orthonomal columns: [ B11 ] [ X11 ] [ P1 | ] [ 0 ] [--&mdash;] = [------&mdash;] [--&mdash;] Q1**T . [ X21 ] [ | P2 ] [ B21 ] [ 0 ] X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P, M-P, or Q. Routines CUNBDB1, CUNBDB2, and CUNBDB3 handle cases in which M-Q is not the minimum dimension. The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P), and (M-Q)-by-(M-Q), respectively. They are represented implicitly by Householder vectors. B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented implicitly by angles THETA, PHI.  <br /></td></tr>
<tr class="separator:af08ebc964287787c80fe14394f4c70dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6155548fe38d46508ae94300d01ad0d2" id="r_a6155548fe38d46508ae94300d01ad0d2"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6155548fe38d46508ae94300d01ad0d2">la_lapack_c::la_cuncsd2by1</a> (jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, rwork, lrwork, iwork, info)</td></tr>
<tr class="memdesc:a6155548fe38d46508ae94300d01ad0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNCSD2BY1: computes the CS decomposition of an M-by-Q matrix X with orthonormal columns that has been partitioned into a 2-by-1 block structure: [ I1 0 0 ] [ 0 C 0 ] [ X11 ] [ U1 | ] [ 0 0 0 ] X = [--&mdash;] = [------&mdash;] [-------&mdash;] V1**T . [ X21 ] [ | U2 ] [ 0 0 0 ] [ 0 S 0 ] [ 0 0 I2] X11 is P-by-Q. The unitary matrices U1, U2, and V1 are P-by-P, (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).  <br /></td></tr>
<tr class="separator:a6155548fe38d46508ae94300d01ad0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cac20a1962c2aacd0114a8bd8ea9c6" id="r_a32cac20a1962c2aacd0114a8bd8ea9c6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a32cac20a1962c2aacd0114a8bd8ea9c6">la_lapack_c::la_cungbr</a> (vect, m, n, k, a, lda, tau, work, lwork, info)</td></tr>
<tr class="memdesc:a32cac20a1962c2aacd0114a8bd8ea9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGBR: generates one of the complex unitary matrices Q or P**H determined by CGEBRD when reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q and P**H are defined as products of elementary reflectors H(i) or G(i) respectively. If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q is of order M: if m &gt;= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n columns of Q, where m &gt;= n &gt;= k; if m &lt; k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an M-by-M matrix. If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H is of order N: if k &lt; n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m rows of P**H, where n &gt;= m &gt;= k; if k &gt;= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as an N-by-N matrix.  <br /></td></tr>
<tr class="separator:a32cac20a1962c2aacd0114a8bd8ea9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0715bb6540df354cfe0bc3a1f5817191" id="r_a0715bb6540df354cfe0bc3a1f5817191"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0715bb6540df354cfe0bc3a1f5817191">la_lapack_c::la_cungtsqr</a> (m, n, mb, nb, a, lda, t, ldt, work, lwork, info)</td></tr>
<tr class="memdesc:a0715bb6540df354cfe0bc3a1f5817191"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGTSQR: generates an M-by-N complex matrix Q_out with orthonormal columns, which are the first N columns of a product of comlpex unitary matrices of order M which are returned by CLATSQR Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ). See the documentation for CLATSQR.  <br /></td></tr>
<tr class="separator:a0715bb6540df354cfe0bc3a1f5817191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a7e2f625b025e79adb503d359c5c6e" id="r_ae3a7e2f625b025e79adb503d359c5c6e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae3a7e2f625b025e79adb503d359c5c6e">la_lapack_c::la_cunmbr</a> (vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:ae3a7e2f625b025e79adb503d359c5c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If VECT = 'Q', CUNMBR: overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': P * C C * P TRANS = 'C': P**H * C C * P**H Here Q and P**H are the unitary matrices determined by CGEBRD when reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q and P**H are defined as products of elementary reflectors H(i) and G(i) respectively. Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the order of the unitary matrix Q or P**H that is applied. If VECT = 'Q', A is assumed to have been an NQ-by-K matrix: if nq &gt;= k, Q = H(1) H(2) . . . H(k); if nq &lt; k, Q = H(1) H(2) . . . H(nq-1). If VECT = 'P', A is assumed to have been a K-by-NQ matrix: if k &lt; nq, P = G(1) G(2) . . . G(k); if k &gt;= nq, P = G(1) G(2) . . . G(nq-1).  <br /></td></tr>
<tr class="separator:ae3a7e2f625b025e79adb503d359c5c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c566b654f7ccd4b9a951ebaa1e3f12d" id="r_a9c566b654f7ccd4b9a951ebaa1e3f12d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a9c566b654f7ccd4b9a951ebaa1e3f12d">la_lapack_c::la_cgelq</a> (m, n, a, lda, t, tsize, work, lwork, info)</td></tr>
<tr class="memdesc:a9c566b654f7ccd4b9a951ebaa1e3f12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGELQ: computes an LQ factorization of a complex M-by-N matrix A: A = ( L 0 ) * Q where: Q is a N-by-N orthogonal matrix; L is a lower-triangular M-by-M matrix; 0 is a M-by-(N-M) zero matrix, if M &lt; N.  <br /></td></tr>
<tr class="separator:a9c566b654f7ccd4b9a951ebaa1e3f12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0693807b1f52200b1ac69813fe601e4d" id="r_a0693807b1f52200b1ac69813fe601e4d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0693807b1f52200b1ac69813fe601e4d">la_lapack_c::la_cgelsd</a> (m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, iwork, info)</td></tr>
<tr class="memdesc:a0693807b1f52200b1ac69813fe601e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGELSD: computes the minimum-norm solution to a real linear least squares problem: minimize 2-norm(| b - A*x |) using the singular value decomposition (SVD) of A. A is an M-by-N matrix which may be rank-deficient. Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X. The problem is solved in three steps: (1) Reduce the coefficient matrix A to bidiagonal form with Householder transformations, reducing the original problem into a "bidiagonal least squares problem" (BLS) (2) Solve the BLS using a divide and conquer approach. (3) Apply back all the Householder transformations to solve the original least squares problem. The effective rank of A is determined by treating as zero those singular values which are less than RCOND times the largest singular value. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a0693807b1f52200b1ac69813fe601e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dbd20dc42099f4af4573a9e6212b87" id="r_ad7dbd20dc42099f4af4573a9e6212b87"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad7dbd20dc42099f4af4573a9e6212b87">la_lapack_c::la_cgelss</a> (m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:ad7dbd20dc42099f4af4573a9e6212b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGELSS: computes the minimum norm solution to a complex linear least squares problem: Minimize 2-norm(| b - A*x |). using the singular value decomposition (SVD) of A. A is an M-by-N matrix which may be rank-deficient. Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X. The effective rank of A is determined by treating as zero those singular values which are less than RCOND times the largest singular value.  <br /></td></tr>
<tr class="separator:ad7dbd20dc42099f4af4573a9e6212b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af406f24485dd11d1403d4335b85423d4" id="r_af406f24485dd11d1403d4335b85423d4"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af406f24485dd11d1403d4335b85423d4">la_lapack_c::la_cgelsy</a> (m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:af406f24485dd11d1403d4335b85423d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGELSY: computes the minimum-norm solution to a complex linear least squares problem: minimize || A * X - B || using a complete orthogonal factorization of A. A is an M-by-N matrix which may be rank-deficient. Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X. The routine first computes a QR factorization with column pivoting: A * P = Q * [ R11 R12 ] [ 0 R22 ] with R11 defined as the largest leading submatrix whose estimated condition number is less than 1/RCOND. The order of R11, RANK, is the effective rank of A. Then, R22 is considered to be negligible, and R12 is annihilated by unitary transformations from the right, arriving at the complete orthogonal factorization: A * P = Q * [ T11 0 ] * Z [ 0 0 ] The minimum-norm solution is then X = P * Z**H [ inv(T11)*Q1**H*B ] [ 0 ] where Q1 consists of the first RANK columns of Q. This routine is basically identical to the original xGELSX except three differences: o The permutation of matrix B (the right hand side) is faster and more simple. o The call to the subroutine xGEQPF has been substituted by the the call to the subroutine xGEQP3. This subroutine is a Blas-3 version of the QR factorization with column pivoting. o Matrix B (the right hand side) is updated with Blas-3.  <br /></td></tr>
<tr class="separator:af406f24485dd11d1403d4335b85423d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93ba1ee55038b09e8448929875747a6" id="r_ad93ba1ee55038b09e8448929875747a6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad93ba1ee55038b09e8448929875747a6">la_lapack_c::la_cgemlq</a> (side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:ad93ba1ee55038b09e8448929875747a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEMLQ: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'C': Q**H * C C * Q**H where Q is a complex unitary matrix defined as the product of blocked elementary reflectors computed by short wide LQ factorization (CGELQ)  <br /></td></tr>
<tr class="separator:ad93ba1ee55038b09e8448929875747a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048da8793a25fce213b25a9339294362" id="r_a048da8793a25fce213b25a9339294362"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a048da8793a25fce213b25a9339294362">la_lapack_c::la_cgemqr</a> (side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork, info)</td></tr>
<tr class="memdesc:a048da8793a25fce213b25a9339294362"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEMQR: overwrites the general real M-by-N matrix C with SIDE = 'L' SIDE = 'R' TRANS = 'N': Q * C C * Q TRANS = 'T': Q**H * C C * Q**H where Q is a complex unitary matrix defined as the product of blocked elementary reflectors computed by tall skinny QR factorization (CGEQR)  <br /></td></tr>
<tr class="separator:a048da8793a25fce213b25a9339294362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade15487041339808a5834ce8d4f873e9" id="r_ade15487041339808a5834ce8d4f873e9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ade15487041339808a5834ce8d4f873e9">la_lapack_c::la_cgeqr</a> (m, n, a, lda, t, tsize, work, lwork, info)</td></tr>
<tr class="memdesc:ade15487041339808a5834ce8d4f873e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEQR: computes a QR factorization of a complex M-by-N matrix A: A = Q * ( R ), ( 0 ) where: Q is a M-by-M orthogonal matrix; R is an upper-triangular N-by-N matrix; 0 is a (M-N)-by-N zero matrix, if M &gt; N.  <br /></td></tr>
<tr class="separator:ade15487041339808a5834ce8d4f873e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783e7cbfb705a5d2c45bf568981322bd" id="r_a783e7cbfb705a5d2c45bf568981322bd"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a783e7cbfb705a5d2c45bf568981322bd">la_lapack_c::la_cgesdd</a> (jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork, info)</td></tr>
<tr class="memdesc:a783e7cbfb705a5d2c45bf568981322bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGESDD: computes the singular value decomposition (SVD) of a complex M-by-N matrix A, optionally computing the left and/or right singular vectors, by using divide-and-conquer method. The SVD is written A = U * SIGMA * conjugate-transpose(V) where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M unitary matrix, and V is an N-by-N unitary matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A. Note that the routine returns VT = V**H, not V. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a783e7cbfb705a5d2c45bf568981322bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade76f4aa6526dd5b5dd4e92060c41e18" id="r_ade76f4aa6526dd5b5dd4e92060c41e18"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ade76f4aa6526dd5b5dd4e92060c41e18">la_lapack_c::la_cgesv</a> (n, nrhs, a, lda, ipiv, b, ldb, info)</td></tr>
<tr class="memdesc:ade76f4aa6526dd5b5dd4e92060c41e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGESV: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N matrix and X and B are N-by-NRHS matrices. The LU decomposition with partial pivoting and row interchanges is used to factor A as A = P * L * U, where P is a permutation matrix, L is unit lower triangular, and U is upper triangular. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:ade76f4aa6526dd5b5dd4e92060c41e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12415cec84d76d088cef7dd3fa04cf46" id="r_a12415cec84d76d088cef7dd3fa04cf46"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a12415cec84d76d088cef7dd3fa04cf46">la_lapack_c::la_cgesvd</a> (jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:a12415cec84d76d088cef7dd3fa04cf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGESVD: computes the singular value decomposition (SVD) of a complex M-by-N matrix A, optionally computing the left and/or right singular vectors. The SVD is written A = U * SIGMA * conjugate-transpose(V) where SIGMA is an M-by-N matrix which is zero except for its min(m,n) diagonal elements, U is an M-by-M unitary matrix, and V is an N-by-N unitary matrix. The diagonal elements of SIGMA are the singular values of A; they are real and non-negative, and are returned in descending order. The first min(m,n) columns of U and V are the left and right singular vectors of A. Note that the routine returns V**H, not V.  <br /></td></tr>
<tr class="separator:a12415cec84d76d088cef7dd3fa04cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84453558d156c0b102017b6bc1e946ca" id="r_a84453558d156c0b102017b6bc1e946ca"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a84453558d156c0b102017b6bc1e946ca">la_lapack_c::la_cgesvdq</a> (joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork, info)</td></tr>
<tr class="memdesc:a84453558d156c0b102017b6bc1e946ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGESVDQ: computes the singular value decomposition (SVD) of a complex M-by-N matrix A, where M &gt;= N. The SVD of A is written as [++] [xx] [x0] [xx] A = U * SIGMA * V^*, [++] = [xx] * [ox] * [xx] [++] [xx] where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal matrix, and V is an N-by-N unitary matrix. The diagonal elements of SIGMA are the singular values of A. The columns of U and V are the left and the right singular vectors of A, respectively.  <br /></td></tr>
<tr class="separator:a84453558d156c0b102017b6bc1e946ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa241c738e18b44ae92d3fd37bf76911a" id="r_aa241c738e18b44ae92d3fd37bf76911a"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa241c738e18b44ae92d3fd37bf76911a">la_lapack_c::la_cgesvx</a> (fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)</td></tr>
<tr class="memdesc:aa241c738e18b44ae92d3fd37bf76911a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGESVX: uses the LU factorization to compute the solution to a complex system of linear equations A * X = B, where A is an N-by-N matrix and X and B are N-by-NRHS matrices. Error bounds on the solution and a condition estimate are also provided.  <br /></td></tr>
<tr class="separator:aa241c738e18b44ae92d3fd37bf76911a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ef0e1049be7044a9e6670fc984710b" id="r_ab6ef0e1049be7044a9e6670fc984710b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ab6ef0e1049be7044a9e6670fc984710b">la_lapack_c::la_cgetsls</a> (trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:ab6ef0e1049be7044a9e6670fc984710b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETSLS: solves overdetermined or underdetermined complex linear systems involving an M-by-N matrix A, using a tall skinny QR or short wide LQ factorization of A. It is assumed that A has full rank. The following options are provided:  <br /></td></tr>
<tr class="separator:ab6ef0e1049be7044a9e6670fc984710b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1982498cba31cca570594790a8bb4d0" id="r_ae1982498cba31cca570594790a8bb4d0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae1982498cba31cca570594790a8bb4d0">la_lapack_c::la_cgetsqrhrt</a> (m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork, info)</td></tr>
<tr class="memdesc:ae1982498cba31cca570594790a8bb4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETSQRHRT: computes a NB2-sized column blocked QR-factorization of a complex M-by-N matrix A with M &gt;= N, A = Q * R. The routine uses internally a NB1-sized column blocked and MB1-sized row blocked TSQR-factorization and perfors the reconstruction of the Householder vectors from the TSQR output. The routine also converts the R_tsqr factor from the TSQR-factorization output into the R factor that corresponds to the Householder QR-factorization, A = Q_tsqr * R_tsqr = Q * R. The output Q and R factors are stored in the same format as in CGEQRT (Q is in blocked compact WY-representation). See the documentation of CGEQRT for more details on the format.  <br /></td></tr>
<tr class="separator:ae1982498cba31cca570594790a8bb4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec977de0594994cceb5540b1c2df859" id="r_abec977de0594994cceb5540b1c2df859"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#abec977de0594994cceb5540b1c2df859">la_lapack_c::la_cgges</a> (jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork, info)</td></tr>
<tr class="memdesc:abec977de0594994cceb5540b1c2df859"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGES: computes for a pair of N-by-N complex nonsymmetric matrices (A,B), the generalized eigenvalues, the generalized complex Schur form (S, T), and optionally left and/or right Schur vectors (VSL and VSR). This gives the generalized Schur factorization (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H ) where (VSR)**H is the conjugate-transpose of VSR. Optionally, it also orders the eigenvalues so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper triangular matrix S and the upper triangular matrix T. The leading columns of VSL and VSR then form an unitary basis for the corresponding left and right eigenspaces (deflating subspaces). (If only the generalized eigenvalues are needed, use the driver CGGEV instead, which is faster.) A generalized eigenvalue for a pair of matrices (A,B) is a scalar w or a ratio alpha/beta = w, such that A - w*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0, and even for both being zero. A pair of matrices (S,T) is in generalized complex Schur form if S and T are upper triangular and, in addition, the diagonal elements of T are non-negative real numbers.  <br /></td></tr>
<tr class="separator:abec977de0594994cceb5540b1c2df859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf11c79ee1a4b930c7e485b8e79672d6" id="r_acf11c79ee1a4b930c7e485b8e79672d6"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#acf11c79ee1a4b930c7e485b8e79672d6">la_lapack_c::la_cggesx</a> (jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork, info)</td></tr>
<tr class="memdesc:acf11c79ee1a4b930c7e485b8e79672d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGESX: computes for a pair of N-by-N complex nonsymmetric matrices (A,B), the generalized eigenvalues, the complex Schur form (S,T), and, optionally, the left and/or right matrices of Schur vectors (VSL and VSR). This gives the generalized Schur factorization (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H ) where (VSR)**H is the conjugate-transpose of VSR. Optionally, it also orders the eigenvalues so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper triangular matrix S and the upper triangular matrix T; computes a reciprocal condition number for the average of the selected eigenvalues (RCONDE); and computes a reciprocal condition number for the right and left deflating subspaces corresponding to the selected eigenvalues (RCONDV). The leading columns of VSL and VSR then form an orthonormal basis for the corresponding left and right eigenspaces (deflating subspaces). A generalized eigenvalue for a pair of matrices (A,B) is a scalar w or a ratio alpha/beta = w, such that A - w*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0 or for both being zero. A pair of matrices (S,T) is in generalized complex Schur form if T is upper triangular with non-negative diagonal and S is upper triangular.  <br /></td></tr>
<tr class="separator:acf11c79ee1a4b930c7e485b8e79672d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e0de50e6f6ca732bd8304ac64275c0" id="r_a05e0de50e6f6ca732bd8304ac64275c0"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a05e0de50e6f6ca732bd8304ac64275c0">la_lapack_c::la_cggev</a> (jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:a05e0de50e6f6ca732bd8304ac64275c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGEV: computes for a pair of N-by-N complex nonsymmetric matrices (A,B), the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors. A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta = lambda, such that A - lambda*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0, and even for both being zero. The right generalized eigenvector v(j) corresponding to the generalized eigenvalue lambda(j) of (A,B) satisfies A * v(j) = lambda(j) * B * v(j). The left generalized eigenvector u(j) corresponding to the generalized eigenvalues lambda(j) of (A,B) satisfies u(j)**H * A = lambda(j) * u(j)**H * B where u(j)**H is the conjugate-transpose of u(j).  <br /></td></tr>
<tr class="separator:a05e0de50e6f6ca732bd8304ac64275c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefbe27d10ee3712263a34c9cc78bc64" id="r_acefbe27d10ee3712263a34c9cc78bc64"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#acefbe27d10ee3712263a34c9cc78bc64">la_lapack_c::la_cggevx</a> (balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork, info)</td></tr>
<tr class="memdesc:acefbe27d10ee3712263a34c9cc78bc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGEVX: computes for a pair of N-by-N complex nonsymmetric matrices (A,B) the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors. Optionally, it also computes a balancing transformation to improve the conditioning of the eigenvalues and eigenvectors (ILO, IHI, LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for the eigenvalues (RCONDE), and reciprocal condition numbers for the right eigenvectors (RCONDV). A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta = lambda, such that A - lambda*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0, and even for both being zero. The right eigenvector v(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies A * v(j) = lambda(j) * B * v(j) . The left eigenvector u(j) corresponding to the eigenvalue lambda(j) of (A,B) satisfies u(j)**H * A = lambda(j) * u(j)**H * B. where u(j)**H is the conjugate-transpose of u(j).  <br /></td></tr>
<tr class="separator:acefbe27d10ee3712263a34c9cc78bc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1467b3f2a97d92038484174568573b05" id="r_a1467b3f2a97d92038484174568573b05"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a1467b3f2a97d92038484174568573b05">la_lapack_c::la_chbev</a> (jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork, info)</td></tr>
<tr class="memdesc:a1467b3f2a97d92038484174568573b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHBEV: computes all the eigenvalues and, optionally, eigenvectors of a complex Hermitian band matrix A.  <br /></td></tr>
<tr class="separator:a1467b3f2a97d92038484174568573b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2dffe823a20173c573705c6eaab0d5" id="r_aaf2dffe823a20173c573705c6eaab0d5"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aaf2dffe823a20173c573705c6eaab0d5">la_lapack_c::la_chbevd</a> (jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:aaf2dffe823a20173c573705c6eaab0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHBEVD: computes all the eigenvalues and, optionally, eigenvectors of a complex Hermitian band matrix A. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:aaf2dffe823a20173c573705c6eaab0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dfb5e0b86cee513792e759e854c2a2" id="r_a79dfb5e0b86cee513792e759e854c2a2"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a79dfb5e0b86cee513792e759e854c2a2">la_lapack_c::la_chbevx</a> (jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail, info)</td></tr>
<tr class="memdesc:a79dfb5e0b86cee513792e759e854c2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHBEVX: computes selected eigenvalues and, optionally, eigenvectors of a complex Hermitian band matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:a79dfb5e0b86cee513792e759e854c2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bee78d539c94a23ee569bdb992abf0f" id="r_a8bee78d539c94a23ee569bdb992abf0f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a8bee78d539c94a23ee569bdb992abf0f">la_lapack_c::la_chbgv</a> (jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork, info)</td></tr>
<tr class="memdesc:a8bee78d539c94a23ee569bdb992abf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHBGV: computes all the eigenvalues, and optionally, the eigenvectors of a complex generalized Hermitian-definite banded eigenproblem, of the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian and banded, and B is also positive definite.  <br /></td></tr>
<tr class="separator:a8bee78d539c94a23ee569bdb992abf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f097117c957e0800a716d4a508fd11c" id="r_a7f097117c957e0800a716d4a508fd11c"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a7f097117c957e0800a716d4a508fd11c">la_lapack_c::la_chbgvd</a> (jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a7f097117c957e0800a716d4a508fd11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHBGVD: computes all the eigenvalues, and optionally, the eigenvectors of a complex generalized Hermitian-definite banded eigenproblem, of the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian and banded, and B is also positive definite. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a7f097117c957e0800a716d4a508fd11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7282554d93cfa2a35b976112cbfc66" id="r_aaf7282554d93cfa2a35b976112cbfc66"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aaf7282554d93cfa2a35b976112cbfc66">la_lapack_c::la_chbgvx</a> (jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail, info)</td></tr>
<tr class="memdesc:aaf7282554d93cfa2a35b976112cbfc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHBGVX: computes all the eigenvalues, and optionally, the eigenvectors of a complex generalized Hermitian-definite banded eigenproblem, of the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian and banded, and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either all eigenvalues, a range of values or a range of indices for the desired eigenvalues.  <br /></td></tr>
<tr class="separator:aaf7282554d93cfa2a35b976112cbfc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfd03ab06c32d6ca5c8bbd8a6d8428d" id="r_a0cfd03ab06c32d6ca5c8bbd8a6d8428d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0cfd03ab06c32d6ca5c8bbd8a6d8428d">la_lapack_c::la_cheevd</a> (jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a0cfd03ab06c32d6ca5c8bbd8a6d8428d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEEVD: computes all eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a0cfd03ab06c32d6ca5c8bbd8a6d8428d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d694cadaff9474ff6c2398a4aec26e" id="r_a06d694cadaff9474ff6c2398a4aec26e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a06d694cadaff9474ff6c2398a4aec26e">la_lapack_c::la_chegvd</a> (itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a06d694cadaff9474ff6c2398a4aec26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEGVD: computes all the eigenvalues, and optionally, the eigenvectors of a complex generalized Hermitian-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be Hermitian and B is also positive definite. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a06d694cadaff9474ff6c2398a4aec26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446c81628a21d0d33c30b3a2e06e14cb" id="r_a446c81628a21d0d33c30b3a2e06e14cb"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a446c81628a21d0d33c30b3a2e06e14cb">la_lapack_c::la_chpevd</a> (jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a446c81628a21d0d33c30b3a2e06e14cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPEVD: computes all the eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A in packed storage. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a446c81628a21d0d33c30b3a2e06e14cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80214bf8c6a8668d1e3c4082bbae4453" id="r_a80214bf8c6a8668d1e3c4082bbae4453"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a80214bf8c6a8668d1e3c4082bbae4453">la_lapack_c::la_chpgvd</a> (itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info)</td></tr>
<tr class="memdesc:a80214bf8c6a8668d1e3c4082bbae4453"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHPGVD: computes all the eigenvalues and, optionally, the eigenvectors of a complex generalized Hermitian-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and B are assumed to be Hermitian, stored in packed format, and B is also positive definite. If eigenvectors are desired, it uses a divide and conquer algorithm. The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.  <br /></td></tr>
<tr class="separator:a80214bf8c6a8668d1e3c4082bbae4453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5360523252e609a14be3bc4c738df631" id="r_a5360523252e609a14be3bc4c738df631"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5360523252e609a14be3bc4c738df631">la_lapack_c::la_cgees</a> (jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork, info)</td></tr>
<tr class="memdesc:a5360523252e609a14be3bc4c738df631"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEES: computes for an N-by-N complex nonsymmetric matrix A, the eigenvalues, the Schur form T, and, optionally, the matrix of Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**H). Optionally, it also orders the eigenvalues on the diagonal of the Schur form so that selected eigenvalues are at the top left. The leading columns of Z then form an orthonormal basis for the invariant subspace corresponding to the selected eigenvalues. A complex matrix is in Schur form if it is upper triangular.  <br /></td></tr>
<tr class="separator:a5360523252e609a14be3bc4c738df631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dad4ddb61a26ef23bd90121057463c" id="r_ad3dad4ddb61a26ef23bd90121057463c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ad3dad4ddb61a26ef23bd90121057463c">la_lapack_c::la_cgeesx</a> (jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork, info)</td></tr>
<tr class="memdesc:ad3dad4ddb61a26ef23bd90121057463c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEESX: computes for an N-by-N complex nonsymmetric matrix A, the eigenvalues, the Schur form T, and, optionally, the matrix of Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**H). Optionally, it also orders the eigenvalues on the diagonal of the Schur form so that selected eigenvalues are at the top left; computes a reciprocal condition number for the average of the selected eigenvalues (RCONDE); and computes a reciprocal condition number for the right invariant subspace corresponding to the selected eigenvalues (RCONDV). The leading columns of Z form an orthonormal basis for this invariant subspace. For further explanation of the reciprocal condition numbers RCONDE and RCONDV, see Section 4.10_sp of the LAPACK Users' Guide (where these quantities are called s and sep respectively). A complex matrix is in Schur form if it is upper triangular.  <br /></td></tr>
<tr class="separator:ad3dad4ddb61a26ef23bd90121057463c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ed9df1f39e617f013a32e5b13b7fca" id="r_a18ed9df1f39e617f013a32e5b13b7fca"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a18ed9df1f39e617f013a32e5b13b7fca">la_lapack_c::la_cgeev</a> (jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:a18ed9df1f39e617f013a32e5b13b7fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEEV: computes for an N-by-N complex nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors. The right eigenvector v(j) of A satisfies A * v(j) = lambda(j) * v(j) where lambda(j) is its eigenvalue. The left eigenvector u(j) of A satisfies u(j)**H * A = lambda(j) * u(j)**H where u(j)**H denotes the conjugate transpose of u(j). The computed eigenvectors are normalized to have Euclidean norm equal to 1 and largest component real.  <br /></td></tr>
<tr class="separator:a18ed9df1f39e617f013a32e5b13b7fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac128f3fda3b9d2b52ab641e85e0eb3cd" id="r_ac128f3fda3b9d2b52ab641e85e0eb3cd"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ac128f3fda3b9d2b52ab641e85e0eb3cd">la_lapack_c::la_cgeevx</a> (balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:ac128f3fda3b9d2b52ab641e85e0eb3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEEVX: computes for an N-by-N complex nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors. Optionally also, it computes a balancing transformation to improve the conditioning of the eigenvalues and eigenvectors (ILO, IHI, SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues (RCONDE), and reciprocal condition numbers for the right eigenvectors (RCONDV). The right eigenvector v(j) of A satisfies A * v(j) = lambda(j) * v(j) where lambda(j) is its eigenvalue. The left eigenvector u(j) of A satisfies u(j)**H * A = lambda(j) * u(j)**H where u(j)**H denotes the conjugate transpose of u(j). The computed eigenvectors are normalized to have Euclidean norm equal to 1 and largest component real. Balancing a matrix means permuting the rows and columns to make it more nearly upper triangular, and applying a diagonal similarity transformation D * A * D**(-1), where D is a diagonal matrix, to make its rows and columns closer in norm and the condition numbers of its eigenvalues and eigenvectors smaller. The computed reciprocal condition numbers correspond to the balanced matrix. Permuting rows and columns will not change the condition numbers (in exact arithmetic) but diagonal scaling will. For further explanation of balancing, see section 4.10.2_sp of the LAPACK Users' Guide.  <br /></td></tr>
<tr class="separator:ac128f3fda3b9d2b52ab641e85e0eb3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f67413f69ab263b73b5b483b59d08fd" id="r_a0f67413f69ab263b73b5b483b59d08fd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0f67413f69ab263b73b5b483b59d08fd">la_lapack_c::la_cgejsv</a> (joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork, rwork, lrwork, iwork, info)</td></tr>
<tr class="memdesc:a0f67413f69ab263b73b5b483b59d08fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGEJSV: computes the singular value decomposition (SVD) of a complex M-by-N matrix [A], where M &gt;= N. The SVD of [A] is written as [A] = [U] * [SIGMA] * [V]^*, where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are the singular values of [A]. The columns of [U] and [V] are the left and the right singular vectors of [A], respectively. The matrices [U] and [V] are computed and stored in the arrays U and V, respectively. The diagonal of [SIGMA] is computed and stored in the array SVA.  <br /></td></tr>
<tr class="separator:a0f67413f69ab263b73b5b483b59d08fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dad67bfb440da1783dc6d36f7a961ab" id="r_a0dad67bfb440da1783dc6d36f7a961ab"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a0dad67bfb440da1783dc6d36f7a961ab">la_lapack_c::la_cgesvj</a> (joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, cwork, lwork, rwork, lrwork, info)</td></tr>
<tr class="memdesc:a0dad67bfb440da1783dc6d36f7a961ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGESVJ: computes the singular value decomposition (SVD) of a complex M-by-N matrix A, where M &gt;= N. The SVD of A is written as [++] [xx] [x0] [xx] A = U * SIGMA * V^*, [++] = [xx] * [ox] * [xx] [++] [xx] where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal matrix, and V is an N-by-N unitary matrix. The diagonal elements of SIGMA are the singular values of A. The columns of U and V are the left and the right singular vectors of A, respectively.  <br /></td></tr>
<tr class="separator:a0dad67bfb440da1783dc6d36f7a961ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795944986f336f437e616eea220df481" id="r_a795944986f336f437e616eea220df481"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a795944986f336f437e616eea220df481">la_lapack_c::la_cgges3</a> (jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork, info)</td></tr>
<tr class="memdesc:a795944986f336f437e616eea220df481"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGES3: computes for a pair of N-by-N complex nonsymmetric matrices (A,B), the generalized eigenvalues, the generalized complex Schur form (S, T), and optionally left and/or right Schur vectors (VSL and VSR). This gives the generalized Schur factorization (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H ) where (VSR)**H is the conjugate-transpose of VSR. Optionally, it also orders the eigenvalues so that a selected cluster of eigenvalues appears in the leading diagonal blocks of the upper triangular matrix S and the upper triangular matrix T. The leading columns of VSL and VSR then form an unitary basis for the corresponding left and right eigenspaces (deflating subspaces). (If only the generalized eigenvalues are needed, use the driver CGGEV instead, which is faster.) A generalized eigenvalue for a pair of matrices (A,B) is a scalar w or a ratio alpha/beta = w, such that A - w*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0, and even for both being zero. A pair of matrices (S,T) is in generalized complex Schur form if S and T are upper triangular and, in addition, the diagonal elements of T are non-negative real numbers.  <br /></td></tr>
<tr class="separator:a795944986f336f437e616eea220df481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0f9b232c3dc55b8c0aca8c6d4026dc" id="r_a5e0f9b232c3dc55b8c0aca8c6d4026dc"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a5e0f9b232c3dc55b8c0aca8c6d4026dc">la_lapack_c::la_cggev3</a> (jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork, info)</td></tr>
<tr class="memdesc:a5e0f9b232c3dc55b8c0aca8c6d4026dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGEV3: computes for a pair of N-by-N complex nonsymmetric matrices (A,B), the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors. A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta = lambda, such that A - lambda*B is singular. It is usually represented as the pair (alpha,beta), as there is a reasonable interpretation for beta=0, and even for both being zero. The right generalized eigenvector v(j) corresponding to the generalized eigenvalue lambda(j) of (A,B) satisfies A * v(j) = lambda(j) * B * v(j). The left generalized eigenvector u(j) corresponding to the generalized eigenvalues lambda(j) of (A,B) satisfies u(j)**H * A = lambda(j) * u(j)**H * B where u(j)**H is the conjugate-transpose of u(j).  <br /></td></tr>
<tr class="separator:a5e0f9b232c3dc55b8c0aca8c6d4026dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dddbaa04d27b577881126699f40bf0" id="r_ae1dddbaa04d27b577881126699f40bf0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae1dddbaa04d27b577881126699f40bf0">la_lapack_c::la_cgsvj0</a> (jobv, m, n, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork, info)</td></tr>
<tr class="memdesc:ae1dddbaa04d27b577881126699f40bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGSVJ0: is called from CGESVJ as a pre-processor and that is its main purpose. It applies Jacobi rotations in the same way as CGESVJ does, but it does not check convergence (stopping criterion). Few tuning parameters (marked by [TP]) are available for the implementer.  <br /></td></tr>
<tr class="separator:ae1dddbaa04d27b577881126699f40bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a514917d13d2fd1b3a0b575a9179e9" id="r_a85a514917d13d2fd1b3a0b575a9179e9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a85a514917d13d2fd1b3a0b575a9179e9">la_lapack_c::la_cgsvj1</a> (jobv, m, n, n1, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork, info)</td></tr>
<tr class="memdesc:a85a514917d13d2fd1b3a0b575a9179e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGSVJ1: is called from CGESVJ as a pre-processor and that is its main purpose. It applies Jacobi rotations in the same way as CGESVJ does, but it targets only particular pivots and it does not check convergence (stopping criterion). Few tuning parameters (marked by [TP]) are available for the implementer. Further Details.  <br /></td></tr>
<tr class="separator:a85a514917d13d2fd1b3a0b575a9179e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a8988d7a44a2590ac1d6ed6e0fe64b" id="r_a01a8988d7a44a2590ac1d6ed6e0fe64b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a01a8988d7a44a2590ac1d6ed6e0fe64b">la_lapack_c::la_chesv_aa</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a01a8988d7a44a2590ac1d6ed6e0fe64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHESV_AA: computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS matrices. Aasen's algorithm is used to factor A as A = U**H * T * U, if UPLO = 'U', or A = L * T * L**H, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and T is Hermitian and tridiagonal. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a01a8988d7a44a2590ac1d6ed6e0fe64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9d2954fbe6ea8f4738278542969d5f" id="r_aec9d2954fbe6ea8f4738278542969d5f"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aec9d2954fbe6ea8f4738278542969d5f">la_lapack_c::la_chetrf_aa</a> (uplo, n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:aec9d2954fbe6ea8f4738278542969d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHETRF_AA: computes the factorization of a complex hermitian matrix A using the Aasen's algorithm. The form of the factorization is A = U**H*T*U or A = L*T*L**H where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and T is a hermitian tridiagonal matrix. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:aec9d2954fbe6ea8f4738278542969d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b66fb388442e3e7b16665db1914d80" id="r_a26b66fb388442e3e7b16665db1914d80"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a26b66fb388442e3e7b16665db1914d80">la_lapack_c::la_chseqr</a> (job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork, info)</td></tr>
<tr class="memdesc:a26b66fb388442e3e7b16665db1914d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHSEQR: computes the eigenvalues of a Hessenberg matrix H and, optionally, the matrices T and Z from the Schur decomposition H = Z T Z**H, where T is an upper triangular matrix (the Schur form), and Z is the unitary matrix of Schur vectors. Optionally Z may be postmultiplied into an input unitary matrix Q so that this routine can give the Schur factorization of a matrix A which has been reduced to the Hessenberg form H by the unitary matrix Q: A = Q*H*Q**H = (QZ)*T*(QZ)**H.  <br /></td></tr>
<tr class="separator:a26b66fb388442e3e7b16665db1914d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cbfefea5c520c4c4a208c4547513f8" id="r_af3cbfefea5c520c4c4a208c4547513f8"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#af3cbfefea5c520c4c4a208c4547513f8">la_lapack_c::la_clahef_aa</a> (uplo, j1, m, nb, a, lda, ipiv, h, ldh, work)</td></tr>
<tr class="memdesc:af3cbfefea5c520c4c4a208c4547513f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAHEF_AA: factorizes a panel of a complex hermitian matrix A using the Aasen's algorithm. The panel consists of a set of NB rows of A when UPLO is U, or a set of NB columns when UPLO is L. In order to factorize the panel, the Aasen's algorithm requires the last row, or column, of the previous panel. The first row, or column, of A is set to be the first row, or column, of an identity matrix, which is used to factorize the first panel. The resulting J-th row of U, or J-th column of L, is stored in the (J-1)-th row, or column, of A (without the unit diagonals), while the diagonal and subdiagonal of A are overwritten by those of T.  <br /></td></tr>
<tr class="separator:af3cbfefea5c520c4c4a208c4547513f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38154631bca6dfa97066bfecea804bc" id="r_aa38154631bca6dfa97066bfecea804bc"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#aa38154631bca6dfa97066bfecea804bc">la_lapack_c::la_claqr0</a> (wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z, ldz, work, lwork, info)</td></tr>
<tr class="memdesc:aa38154631bca6dfa97066bfecea804bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQR0: computes the eigenvalues of a Hessenberg matrix H and, optionally, the matrices T and Z from the Schur decomposition H = Z T Z**H, where T is an upper triangular matrix (the Schur form), and Z is the unitary matrix of Schur vectors. Optionally Z may be postmultiplied into an input unitary matrix Q so that this routine can give the Schur factorization of a matrix A which has been reduced to the Hessenberg form H by the unitary matrix Q: A = Q*H*Q**H = (QZ)*H*(QZ)**H.  <br /></td></tr>
<tr class="separator:aa38154631bca6dfa97066bfecea804bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae404f7fd16af17f1f358d77c874270da" id="r_ae404f7fd16af17f1f358d77c874270da"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#ae404f7fd16af17f1f358d77c874270da">la_lapack_c::la_claqr3</a> (wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz, z, ldz, ns, nd, sh, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork)</td></tr>
<tr class="memdesc:ae404f7fd16af17f1f358d77c874270da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggressive early deflation: CLAQR3: accepts as input an upper Hessenberg matrix H and performs an unitary similarity transformation designed to detect and deflate fully converged eigenvalues from a trailing principal submatrix. On output H has been over- written by a new Hessenberg matrix that is a perturbation of an unitary similarity transformation of H. It is to be hoped that the final version of H has many zero subdiagonal entries.  <br /></td></tr>
<tr class="separator:ae404f7fd16af17f1f358d77c874270da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2548361a25450b531236c026d85be716" id="r_a2548361a25450b531236c026d85be716"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a2548361a25450b531236c026d85be716">la_lapack_c::la_claqr4</a> (wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z, ldz, work, lwork, info)</td></tr>
<tr class="memdesc:a2548361a25450b531236c026d85be716"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQR4: implements one level of recursion for CLAQR0. It is a complete implementation of the small bulge multi-shift QR algorithm. It may be called by CLAQR0 and, for large enough deflation window size, it may be called by CLAQR3. This subroutine is identical to CLAQR0 except that it calls CLAQR2 instead of CLAQR3. CLAQR4 computes the eigenvalues of a Hessenberg matrix H and, optionally, the matrices T and Z from the Schur decomposition H = Z T Z**H, where T is an upper triangular matrix (the Schur form), and Z is the unitary matrix of Schur vectors. Optionally Z may be postmultiplied into an input unitary matrix Q so that this routine can give the Schur factorization of a matrix A which has been reduced to the Hessenberg form H by the unitary matrix Q: A = Q*H*Q**H = (QZ)*H*(QZ)**H.  <br /></td></tr>
<tr class="separator:a2548361a25450b531236c026d85be716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90da9dafeadae16e2f8df5146af92332" id="r_a90da9dafeadae16e2f8df5146af92332"><td class="memItemLeft" align="right" valign="top">recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a90da9dafeadae16e2f8df5146af92332">la_lapack_c::la_claqz0</a> (wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, work, lwork, rwork, rec, info)</td></tr>
<tr class="memdesc:a90da9dafeadae16e2f8df5146af92332"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQZ0: computes the eigenvalues of a matrix pair (H,T), where H is an upper Hessenberg matrix and T is upper triangular, using the double-shift QZ method. Matrix pairs of this type are produced by the reduction to generalized upper Hessenberg form of a matrix pair (A,B): A = Q1*H*Z1**H, B = Q1*T*Z1**H, as computed by CGGHRD. If JOB='S', then the Hessenberg-triangular pair (H,T) is also reduced to generalized Schur form, H = Q*S*Z**H, T = Q*P*Z**H, where Q and Z are unitary matrices, P and S are an upper triangular matrices. Optionally, the unitary matrix Q from the generalized Schur factorization may be postmultiplied into an input matrix Q1, and the unitary matrix Z may be postmultiplied into an input matrix Z1. If Q1 and Z1 are the unitary matrices from CGGHRD that reduced the matrix pair (A,B) to generalized upper Hessenberg form, then the output matrices Q1*Q and Z1*Z are the unitary factors from the generalized Schur factorization of (A,B): A = (Q1*Q)*S*(Z1*Z)**H, B = (Q1*Q)*P*(Z1*Z)**H. To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently, of (A,B)) are computed as a pair of values (alpha,beta), where alpha is complex and beta real. If beta is nonzero, lambda = alpha / beta is an eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP) A*x = lambda*B*x and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the alternate form of the GNEP mu*A*y = B*y. Eigenvalues can be read directly from the generalized Schur form: alpha = S(i,i), beta = P(i,i). Ref: C.B. Moler Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
pp. 241&amp;ndash;256.
Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ Algorithm with Aggressive Early Deflation", SIAM J. Numer.
Anal., 29(2006), pp. 199&amp;ndash;227.
Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift, multipole rational QZ method with agressive early deflation".  <br /></td></tr>
<tr class="separator:a90da9dafeadae16e2f8df5146af92332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6630fcc98c89c41da993d21af1c20273" id="r_a6630fcc98c89c41da993d21af1c20273"><td class="memItemLeft" align="right" valign="top">recursive subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a6630fcc98c89c41da993d21af1c20273">la_lapack_c::la_claqz2</a> (ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb, q, ldq, z, ldz, ns, nd, alpha, beta, qc, ldqc, zc, ldzc, work, lwork, rwork, rec, info)</td></tr>
<tr class="memdesc:a6630fcc98c89c41da993d21af1c20273"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLAQZ2: performs AED.  <br /></td></tr>
<tr class="separator:a6630fcc98c89c41da993d21af1c20273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785dc41ef350b7d6e60f6eab9e36b8a3" id="r_a785dc41ef350b7d6e60f6eab9e36b8a3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a785dc41ef350b7d6e60f6eab9e36b8a3">la_lapack_c::la_clasyf_aa</a> (uplo, j1, m, nb, a, lda, ipiv, h, ldh, work)</td></tr>
<tr class="memdesc:a785dc41ef350b7d6e60f6eab9e36b8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">DLATRF_AA factorizes a panel of a complex symmetric matrix A using the Aasen's algorithm. The panel consists of a set of NB rows of A when UPLO is U, or a set of NB columns when UPLO is L. In order to factorize the panel, the Aasen's algorithm requires the last row, or column, of the previous panel. The first row, or column, of A is set to be the first row, or column, of an identity matrix, which is used to factorize the first panel. The resulting J-th row of U, or J-th column of L, is stored in the (J-1)-th row, or column, of A (without the unit diagonals), while the diagonal and subdiagonal of A are overwritten by those of T.  <br /></td></tr>
<tr class="separator:a785dc41ef350b7d6e60f6eab9e36b8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408add26d2f4cf49bb0d4bfdf6b74bcd" id="r_a408add26d2f4cf49bb0d4bfdf6b74bcd"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a408add26d2f4cf49bb0d4bfdf6b74bcd">la_lapack_c::la_csysv_aa</a> (uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, info)</td></tr>
<tr class="memdesc:a408add26d2f4cf49bb0d4bfdf6b74bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYSV computes the solution to a complex system of linear equations A * X = B, where A is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices. Aasen's algorithm is used to factor A as A = U**T * T * U, if UPLO = 'U', or A = L * T * L**T, if UPLO = 'L', where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and T is symmetric tridiagonal. The factored form of A is then used to solve the system of equations A * X = B.  <br /></td></tr>
<tr class="separator:a408add26d2f4cf49bb0d4bfdf6b74bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237096fa3d72359ae1ef283494202e57" id="r_a237096fa3d72359ae1ef283494202e57"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacela__lapack__c.html#a237096fa3d72359ae1ef283494202e57">la_lapack_c::la_csytrf_aa</a> (uplo, n, a, lda, ipiv, work, lwork, info)</td></tr>
<tr class="memdesc:a237096fa3d72359ae1ef283494202e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSYTRF_AA: computes the factorization of a complex symmetric matrix A using the Aasen's algorithm. The form of the factorization is A = U**T*T*U or A = L*T*L**T where U (or L) is a product of permutation and unit upper (lower) triangular matrices, and T is a complex symmetric tridiagonal matrix. This is the blocked version of the algorithm, calling Level 3 BLAS.  <br /></td></tr>
<tr class="separator:a237096fa3d72359ae1ef283494202e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="la__lapack__c_8f90.html">la_lapack_c.f90</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
